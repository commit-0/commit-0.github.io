
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference pydantic - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-pydantic" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference pydantic
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_computed_fieldspytest_multiple_references_to_schemamake_typed_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_computed_fields.py::test_multiple_references_to_schema[make_typed_dict]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_discriminated_unionpytest_presence_of_discriminator_when_generating_type_adaptor_json_schema_definitions" class="md-nav__link">
    <span class="md-ellipsis">
      test_discriminated_union.py::test_presence_of_discriminator_when_generating_type_adaptor_json_schema_definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_discriminated_unionpytest_discriminated_union_model_dump_with_nested_class" class="md-nav__link">
    <span class="md-ellipsis">
      test_discriminated_union.py::test_discriminated_union_model_dump_with_nested_class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_genericspytest_generic_model_as_parameter_to_generic_type_alias" class="md-nav__link">
    <span class="md-ellipsis">
      test_generics.py::test_generic_model_as_parameter_to_generic_type_alias
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_genericspytest_variadic_generic_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_generics.py::test_variadic_generic_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_genericspytest_variadic_generic_with_variadic_fields" class="md-nav__link">
    <span class="md-ellipsis">
      test_generics.py::test_variadic_generic_with_variadic_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_json_schemapytest_get_pydantic_core_schema_calls" class="md-nav__link">
    <span class="md-ellipsis">
      test_json_schema.py::test_get_pydantic_core_schema_calls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mainpytest_model_validate_list_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_main.py::test_model_validate_list_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#app" class="md-nav__link">
    <span class="md-ellipsis">
      app]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_adapterpytest_validate_json_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_adapter.py::test_validate_json_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_alias_typepytest_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_alias_type.py::test_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_typespytest_invalid_schema_constraintskwargs0-int" class="md-nav__link">
    <span class="md-ellipsis">
      test_types.py::test_invalid_schema_constraints[kwargs0-int]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-pydantic"><strong>Reference (Gold)</strong>: pydantic</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">5091</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">38</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">12</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">5141</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">5141</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_computed_fieldspytest_multiple_references_to_schemamake_typed_dict">test_computed_fields.py::test_multiple_references_to_schema[make_typed_dict]</h3>
<details><summary> <pre>test_computed_fields.py::test_multiple_references_to_schema[make_typed_dict]</pre></summary><pre>
model_factory = <function make_typed_dict at 0x7f87f07cc7c0>

    @pytest.mark.parametrize(
        'model_factory',
        [
            make_base_model,
            pytest.param(
                make_typed_dict,
                marks=pytest.mark.xfail(
                    reason='computed fields do not work with TypedDict yet. See https://github.com/pydantic/pydantic-core/issues/657'
                ),
            ),
            make_dataclass,
        ],
    )
    def test_multiple_references_to_schema(model_factory: Callable[[], Any]) -> None:
        """
        https://github.com/pydantic/pydantic/issues/5980
        """

        model = model_factory()

        ta = TypeAdapter(model)

>       assert ta.dump_python(model()) == {'comp_1': {}, 'comp_2': {}}

tests/test_computed_fields.py:726: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pydantic/type_adapter.py:142: in wrapped
    return func(self, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pydantic.type_adapter.TypeAdapter object at 0x7f87ebd56d80>
instance = {}

    @_frame_depth(1)
    def dump_python(
        self,
        instance: T,
        /,
        *,
        mode: Literal['json', 'python'] = 'python',
        include: IncEx | None = None,
        exclude: IncEx | None = None,
        by_alias: bool = False,
        exclude_unset: bool = False,
        exclude_defaults: bool = False,
        exclude_none: bool = False,
        round_trip: bool = False,
        warnings: bool | Literal['none', 'warn', 'error'] = True,
        serialize_as_any: bool = False,
        context: dict[str, Any] | None = None,
    ) -> Any:
        """Dump an instance of the adapted type to a Python object.

        Args:
            instance: The Python object to serialize.
            mode: The output format.
            include: Fields to include in the output.
            exclude: Fields to exclude from the output.
            by_alias: Whether to use alias names for field names.
            exclude_unset: Whether to exclude unset fields.
            exclude_defaults: Whether to exclude fields with default values.
            exclude_none: Whether to exclude fields with None values.
            round_trip: Whether to output the serialized data in a way that is compatible with deserialization.
            warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
                "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
            context: Additional context to pass to the serializer.

        Returns:
            The serialized object.
        """
>       return self.serializer.to_python(
            instance,
            mode=mode,
            by_alias=by_alias,
            include=include,
            exclude=exclude,
            exclude_unset=exclude_unset,
            exclude_defaults=exclude_defaults,
            exclude_none=exclude_none,
            round_trip=round_trip,
            warnings=warnings,
            serialize_as_any=serialize_as_any,
            context=context,
        )
E       AttributeError: 'dict' object has no attribute 'comp_1'

pydantic/type_adapter.py:458: AttributeError
</pre>
</details>
<h3 id="test_discriminated_unionpytest_presence_of_discriminator_when_generating_type_adaptor_json_schema_definitions">test_discriminated_union.py::test_presence_of_discriminator_when_generating_type_adaptor_json_schema_definitions</h3>
<details><summary> <pre>test_discriminated_union.py::test_presence_of_discriminator_when_generating_type_adaptor_json_schema_definitions</pre></summary><pre>
@pytest.mark.xfail(reason='Issue not yet fixed, see: https://github.com/pydantic/pydantic/issues/8271.')
    def test_presence_of_discriminator_when_generating_type_adaptor_json_schema_definitions() -> None:
        class ItemType(str, Enum):
            ITEM1 = 'item1'
            ITEM2 = 'item2'

        class CreateItem1(BaseModel):
            item_type: Annotated[Literal[ItemType.ITEM1], Field(alias='type')]
            id: int

        class CreateItem2(BaseModel):
            item_type: Annotated[Literal[ItemType.ITEM2], Field(alias='type')]
            id: int

        class CreateObjectDto(BaseModel):
            id: int
            items: List[
                Annotated[
                    Union[
                        CreateItem1,
                        CreateItem2,
                    ],
                    Field(discriminator='item_type'),
                ]
            ]

        adaptor = TypeAdapter(
            Annotated[CreateObjectDto, FieldInfo(examples=[{'id': 1, 'items': [{'id': 3, 'type': 'ITEM1'}]}])]
        )

        schema_map, definitions = GenerateJsonSchema().generate_definitions([(adaptor, 'validation', adaptor.core_schema)])
>       assert definitions == {
            'CreateItem1': {
                'properties': {'id': {'title': 'Id', 'type': 'integer'}, 'type': {'const': 'item1', 'title': 'Type'}},
                'required': ['type', 'id'],
                'title': 'CreateItem1',
                'type': 'object',
            },
            'CreateItem2': {
                'properties': {'id': {'title': 'Id', 'type': 'integer'}, 'type': {'const': 'item2', 'title': 'Type'}},
                'required': ['type', 'id'],
                'title': 'CreateItem2',
                'type': 'object',
            },
            'CreateObjectDto': {
                'properties': {
                    'id': {'title': 'Id', 'type': 'integer'},
                    'items': {
                        'items': {
                            'discriminator': {
                                'mapping': {'item1': '#/$defs/CreateItem1', 'item2': '#/$defs/CreateItem2'},
                                'propertyName': 'type',
                            },
                            'oneOf': [{'$ref': '#/$defs/CreateItem1'}, {'$ref': '#/$defs/CreateItem2'}],
                        },
                        'title': 'Items',
                        'type': 'array',
                    },
                },
                'required': ['id', 'items'],
                'title': 'CreateObjectDto',
                'type': 'object',
            },
        }
E       AssertionError: assert {'CreateItem1...e': 'object'}} == {'CreateItem1...e': 'object'}}
E         
E         Differing items:
E         {'CreateItem2': {'properties': {'id': {'title': 'Id', 'type': 'integer'}, 'type': {'const': 'item2', 'enum': ['item2'], 'title': 'Type', 'type': 'string'}}, 'required': ['type', 'id'], 'title': 'CreateItem2', 'type': 'object'}} != {'CreateItem2': {'properties': {'id': {'title': 'Id', 'type': 'integer'}, 'type': {'const': 'item2', 'title': 'Type'}}, 'required': ['type', 'id'], 'title': 'CreateItem2', 'type': 'object'}}
E         {'CreateItem1': {'properties': {'id': {'title': 'Id', 'type': 'integer'}, 'type': {'const': 'item1', 'enum': ['item1'], 'title': 'Type', 't...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

tests/test_discriminated_union.py:1742: AssertionError
</pre>
</details>
<h3 id="test_discriminated_unionpytest_discriminated_union_model_dump_with_nested_class">test_discriminated_union.py::test_discriminated_union_model_dump_with_nested_class</h3>
<details><summary> <pre>test_discriminated_union.py::test_discriminated_union_model_dump_with_nested_class</pre></summary><pre>
@pytest.mark.xfail(
        reason='model_dump does not properly serialize the discriminator field to string if it is using an Enum. Issue: https://github.com/pydantic/pydantic/issues/9235'
    )
    def test_discriminated_union_model_dump_with_nested_class():
        class SomeEnum(str, Enum):
            CAT = 'cat'
            DOG = 'dog'

        class Dog(BaseModel):
            type: Literal[SomeEnum.DOG] = SomeEnum.DOG
            name: str

        class Cat(BaseModel):
            type: Literal[SomeEnum.CAT] = SomeEnum.CAT
            name: str

        class Yard(BaseModel):
            pet: Union[Dog, Cat] = Field(discriminator='type')

        yard = Yard(pet=Dog(name='Rex'))
        yard_dict = yard.model_dump(mode='json')
        assert isinstance(yard_dict['pet']['type'], str)
>       assert not isinstance(yard_dict['pet']['type'], SomeEnum)
E       AssertionError: assert not True
E        +  where True = isinstance(<SomeEnum.DOG: 'dog'>, <enum 'SomeEnum'>)

tests/test_discriminated_union.py:2058: AssertionError
</pre>
</details>
<h3 id="test_genericspytest_generic_model_as_parameter_to_generic_type_alias">test_generics.py::test_generic_model_as_parameter_to_generic_type_alias</h3>
<details><summary> <pre>test_generics.py::test_generic_model_as_parameter_to_generic_type_alias</pre></summary><pre>
@pytest.mark.xfail(reason='Generic models are not type aliases', raises=TypeError)
    def test_generic_model_as_parameter_to_generic_type_alias() -> None:
        T = TypeVar('T')

        class GenericPydanticModel(BaseModel, Generic[T]):
            x: T

        GenericPydanticModelList = List[GenericPydanticModel[T]]
>       GenericPydanticModelList[int]

tests/test_generics.py:2236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/typing.py:398: in inner
    return func(*args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = typing.List[tests.test_generics.test_generic_model_as_parameter_to_generic_type_alias.<locals>.GenericPydanticModel]
args = <class 'int'>

    @_tp_cache
    def __getitem__(self, args):
        # Parameterizes an already-parameterized object.
        #
        # For example, we arrive here doing something like:
        #   T1 = TypeVar('T1')
        #   T2 = TypeVar('T2')
        #   T3 = TypeVar('T3')
        #   class A(Generic[T1]): pass
        #   B = A[T2]  # B is a _GenericAlias
        #   C = B[T3]  # Invokes _GenericAlias.__getitem__
        #
        # We also arrive here when parameterizing a generic `Callable` alias:
        #   T = TypeVar('T')
        #   C = Callable[[T], None]
        #   C[int]  # Invokes _GenericAlias.__getitem__

        if self.__origin__ in (Generic, Protocol):
            # Can't subscript Generic[...] or Protocol[...].
            raise TypeError(f"Cannot subscript already-subscripted {self}")
        if not self.__parameters__:
>           raise TypeError(f"{self} is not a generic class")
E           TypeError: typing.List[tests.test_generics.test_generic_model_as_parameter_to_generic_type_alias.<locals>.GenericPydanticModel] is not a generic class

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/typing.py:1315: TypeError
</pre>
</details>
<h3 id="test_genericspytest_variadic_generic_init">test_generics.py::test_variadic_generic_init</h3>
<details><summary> <pre>test_generics.py::test_variadic_generic_init</pre></summary><pre>
@pytest.mark.skipif(sys.version_info < (3, 11), reason='requires python 3.11 or higher')
    @pytest.mark.xfail(
        reason='TODO: Variadic generic parametrization is not supported yet;'
        ' Issue: https://github.com/pydantic/pydantic/issues/5804'
    )
    def test_variadic_generic_init():
        class ComponentModel(BaseModel):
            pass

        class Wrench(ComponentModel):
            pass

        class Screwdriver(ComponentModel):
            pass

        ComponentVar = TypeVar('ComponentVar', bound=ComponentModel)
        NumberOfComponents = TypeVarTuple('NumberOfComponents')

>       class VariadicToolbox(BaseModel, Generic[ComponentVar, Unpack[NumberOfComponents]]):

tests/test_generics.py:2497: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pydantic/_internal/_model_construction.py:205: in __new__
    complete_model_class(
pydantic/_internal/_model_construction.py:534: in complete_model_class
    schema = cls.__get_pydantic_core_schema__(cls, handler)
pydantic/main.py:643: in __get_pydantic_core_schema__
    return handler(source)
pydantic/_internal/_schema_generation_shared.py:83: in __call__
    schema = self._handler(source_type)
pydantic/_internal/_generate_schema.py:512: in generate_schema
    schema = self._generate_schema_inner(obj)
pydantic/_internal/_generate_schema.py:784: in _generate_schema_inner
    return self._model_schema(obj)
pydantic/_internal/_generate_schema.py:593: in _model_schema
    self._computed_field_schema(d, decorators.field_serializers)
pydantic/_internal/_generate_schema.py:1768: in _computed_field_schema
    return_type_schema = self.generate_schema(return_type)
pydantic/_internal/_generate_schema.py:512: in generate_schema
    schema = self._generate_schema_inner(obj)
pydantic/_internal/_generate_schema.py:789: in _generate_schema_inner
    return self.match_type(obj)
pydantic/_internal/_generate_schema.py:871: in match_type
    return self._match_generic_type(obj, origin)
pydantic/_internal/_generate_schema.py:897: in _match_generic_type
    return self._tuple_schema(obj)
pydantic/_internal/_generate_schema.py:1460: in _tuple_schema
    return core_schema.tuple_schema([self.generate_schema(param) for param in params])
pydantic/_internal/_generate_schema.py:512: in generate_schema
    schema = self._generate_schema_inner(obj)
pydantic/_internal/_generate_schema.py:789: in _generate_schema_inner
    return self.match_type(obj)
pydantic/_internal/_generate_schema.py:871: in match_type
    return self._match_generic_type(obj, origin)
pydantic/_internal/_generate_schema.py:919: in _match_generic_type
    return self._unknown_type_schema(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pydantic._internal._generate_schema.GenerateSchema object at 0x7f87ec907650>
obj = typing.Unpack[NumberOfComponents]

    def _unknown_type_schema(self, obj: Any) -> CoreSchema:
>       raise PydanticSchemaGenerationError(
            f'Unable to generate pydantic-core schema for {obj!r}. '
            'Set `arbitrary_types_allowed=True` in the model_config to ignore this error'
            ' or implement `__get_pydantic_core_schema__` on your type to fully support it.'
            '\n\nIf you got this error by calling handler(<some type>) within'
            ' `__get_pydantic_core_schema__` then you likely need to call'
            ' `handler.generate_schema(<some type>)` since we do not call'
            ' `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.'
        )
E       pydantic.errors.PydanticSchemaGenerationError: Unable to generate pydantic-core schema for typing.Unpack[NumberOfComponents]. Set `arbitrary_types_allowed=True` in the model_config to ignore this error or implement `__get_pydantic_core_schema__` on your type to fully support it.
E       
E       If you got this error by calling handler(<some type>) within `__get_pydantic_core_schema__` then you likely need to call `handler.generate_schema(<some type>)` since we do not call `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.
E       
E       For further information visit https://errors.pydantic.dev/2.8/u/schema-for-unknown-type

pydantic/_internal/_generate_schema.py:415: PydanticSchemaGenerationError
</pre>
</details>
<h3 id="test_genericspytest_variadic_generic_with_variadic_fields">test_generics.py::test_variadic_generic_with_variadic_fields</h3>
<details><summary> <pre>test_generics.py::test_variadic_generic_with_variadic_fields</pre></summary><pre>
@pytest.mark.skipif(sys.version_info < (3, 11), reason='requires python 3.11 or higher')
    @pytest.mark.xfail(
        reason='TODO: Variadic fields are not supported yet; Issue: https://github.com/pydantic/pydantic/issues/5804'
    )
    def test_variadic_generic_with_variadic_fields():
        class ComponentModel(BaseModel):
            pass

        class Wrench(ComponentModel):
            pass

        class Screwdriver(ComponentModel):
            pass

        ComponentVar = TypeVar('ComponentVar', bound=ComponentModel)
        NumberOfComponents = TypeVarTuple('NumberOfComponents')

>       class VariadicToolbox(BaseModel, Generic[ComponentVar, Unpack[NumberOfComponents]]):

tests/test_generics.py:2532: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pydantic/_internal/_model_construction.py:205: in __new__
    complete_model_class(
pydantic/_internal/_model_construction.py:534: in complete_model_class
    schema = cls.__get_pydantic_core_schema__(cls, handler)
pydantic/main.py:643: in __get_pydantic_core_schema__
    return handler(source)
pydantic/_internal/_schema_generation_shared.py:83: in __call__
    schema = self._handler(source_type)
pydantic/_internal/_generate_schema.py:512: in generate_schema
    schema = self._generate_schema_inner(obj)
pydantic/_internal/_generate_schema.py:784: in _generate_schema_inner
    return self._model_schema(obj)
pydantic/_internal/_generate_schema.py:591: in _model_schema
    {k: self._generate_md_field_schema(k, v, decorators) for k, v in fields.items()},
pydantic/_internal/_generate_schema.py:947: in _generate_md_field_schema
    common_field = self._common_field_schema(name, field_info, decorators)
pydantic/_internal/_generate_schema.py:1134: in _common_field_schema
    schema = self._apply_annotations(
pydantic/_internal/_generate_schema.py:1890: in _apply_annotations
    schema = get_inner_schema(source_type)
pydantic/_internal/_schema_generation_shared.py:83: in __call__
    schema = self._handler(source_type)
pydantic/_internal/_generate_schema.py:1871: in inner_handler
    schema = self._generate_schema_inner(obj)
pydantic/_internal/_generate_schema.py:789: in _generate_schema_inner
    return self.match_type(obj)
pydantic/_internal/_generate_schema.py:871: in match_type
    return self._match_generic_type(obj, origin)
pydantic/_internal/_generate_schema.py:895: in _match_generic_type
    return self._union_schema(obj)
pydantic/_internal/_generate_schema.py:1207: in _union_schema
    choices.append(self.generate_schema(arg))
pydantic/_internal/_generate_schema.py:512: in generate_schema
    schema = self._generate_schema_inner(obj)
pydantic/_internal/_generate_schema.py:789: in _generate_schema_inner
    return self.match_type(obj)
pydantic/_internal/_generate_schema.py:871: in match_type
    return self._match_generic_type(obj, origin)
pydantic/_internal/_generate_schema.py:897: in _match_generic_type
    return self._tuple_schema(obj)
pydantic/_internal/_generate_schema.py:1460: in _tuple_schema
    return core_schema.tuple_schema([self.generate_schema(param) for param in params])
pydantic/_internal/_generate_schema.py:512: in generate_schema
    schema = self._generate_schema_inner(obj)
pydantic/_internal/_generate_schema.py:789: in _generate_schema_inner
    return self.match_type(obj)
pydantic/_internal/_generate_schema.py:871: in match_type
    return self._match_generic_type(obj, origin)
pydantic/_internal/_generate_schema.py:919: in _match_generic_type
    return self._unknown_type_schema(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pydantic._internal._generate_schema.GenerateSchema object at 0x7f87e99aa480>
obj = typing.Unpack[NumberOfComponents]

    def _unknown_type_schema(self, obj: Any) -> CoreSchema:
>       raise PydanticSchemaGenerationError(
            f'Unable to generate pydantic-core schema for {obj!r}. '
            'Set `arbitrary_types_allowed=True` in the model_config to ignore this error'
            ' or implement `__get_pydantic_core_schema__` on your type to fully support it.'
            '\n\nIf you got this error by calling handler(<some type>) within'
            ' `__get_pydantic_core_schema__` then you likely need to call'
            ' `handler.generate_schema(<some type>)` since we do not call'
            ' `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.'
        )
E       pydantic.errors.PydanticSchemaGenerationError: Unable to generate pydantic-core schema for typing.Unpack[NumberOfComponents]. Set `arbitrary_types_allowed=True` in the model_config to ignore this error or implement `__get_pydantic_core_schema__` on your type to fully support it.
E       
E       If you got this error by calling handler(<some type>) within `__get_pydantic_core_schema__` then you likely need to call `handler.generate_schema(<some type>)` since we do not call `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.
E       
E       For further information visit https://errors.pydantic.dev/2.8/u/schema-for-unknown-type

pydantic/_internal/_generate_schema.py:415: PydanticSchemaGenerationError
</pre>
</details>
<h3 id="test_json_schemapytest_get_pydantic_core_schema_calls">test_json_schema.py::test_get_pydantic_core_schema_calls</h3>
<details><summary> <pre>test_json_schema.py::test_get_pydantic_core_schema_calls</pre></summary><pre>
@pytest.mark.xfail(
        reason=(
            'We are calling __get_pydantic_json_schema__ too many times.'
            ' The second time we analyze a model we get the CoreSchema from __pydantic_core_schema__.'
            ' But then we proceed to append to the metadata json schema functions.'
        )
    )
    def test_get_pydantic_core_schema_calls() -> None:
        """Verify when/how many times `__get_pydantic_core_schema__` gets called"""

        calls: List[str] = []

        class Model(BaseModel):
            @classmethod
            def __get_pydantic_json_schema__(cls, schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:
                calls.append('Model::before')
                json_schema = handler(schema)
                calls.append('Model::after')
                return json_schema

        schema = Model.model_json_schema()
        expected: JsonSchemaValue = {'type': 'object', 'properties': {}, 'title': 'Model'}

        assert schema == expected
        assert calls == ['Model::before', 'Model::after']

        calls.clear()

        class CustomAnnotation(NamedTuple):
            name: str

            def __get_pydantic_json_schema__(self, schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:
                calls.append(f'CustomAnnotation({self.name})::before')
                json_schema = handler(schema)
                calls.append(f'CustomAnnotation({self.name})::after')
                return json_schema

        AnnotatedType = Annotated[str, CustomAnnotation('foo'), CustomAnnotation('bar')]

        schema = TypeAdapter(AnnotatedType).json_schema()
        expected: JsonSchemaValue = {'type': 'string'}

        assert schema == expected
        assert calls == [
            'CustomAnnotation(bar)::before',
            'CustomAnnotation(foo)::before',
            'CustomAnnotation(foo)::after',
            'CustomAnnotation(bar)::after',
        ]

        calls.clear()

        class OuterModel(BaseModel):
            x: Model

            @classmethod
            def __get_pydantic_json_schema__(cls, schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:
                calls.append('OuterModel::before')
                json_schema = handler(schema)
                calls.append('OuterModel::after')
                return json_schema

        schema = OuterModel.model_json_schema()
        expected: JsonSchemaValue = {
            'type': 'object',
            'properties': {'x': {'$ref': '#/$defs/Model'}},
            'required': ['x'],
            'title': 'OuterModel',
            '$defs': {'Model': {'type': 'object', 'properties': {}, 'title': 'Model'}},
        }

        assert schema == expected
        assert calls == [
            'OuterModel::before',
            'Model::before',
            'Model::after',
            'OuterModel::after',
        ]

        calls.clear()

        AnnotatedModel = Annotated[Model, CustomAnnotation('foo')]

        schema = TypeAdapter(AnnotatedModel).json_schema()
        expected: JsonSchemaValue = {}

>       assert schema == expected
E       AssertionError: assert {'properties'...pe': 'object'} == {}
E         
E         Left contains 3 more items:
E         {'properties': {}, 'title': 'Model', 'type': 'object'}
E         Use -v to get more diff

tests/test_json_schema.py:4585: AssertionError
</pre>
</details>
<h3 id="test_mainpytest_model_validate_list_strict">test_main.py::test_model_validate_list_strict</h3>
<details><summary> <pre>test_main.py::test_model_validate_list_strict</pre></summary><pre>
@pytest.mark.xfail(
        reason='strict=True in model_validate_json does not overwrite strict=False given in ConfigDict'
        'See issue: https://github.com/pydantic/pydantic/issues/8930'
    )
    def test_model_validate_list_strict() -> None:
        # FIXME: This change must be implemented in pydantic-core. The argument strict=True
        # in model_validate_json method is not overwriting the one set with ConfigDict(strict=False)
        # for sequence like types. See: https://github.com/pydantic/pydantic/issues/8930

        class LaxModel(BaseModel):
            x: List[str]
            model_config = ConfigDict(strict=False)

        assert LaxModel.model_validate_json(json.dumps({'x': ('a', 'b', 'c')}), strict=None) == LaxModel(x=('a', 'b', 'c'))
        assert LaxModel.model_validate_json(json.dumps({'x': ('a', 'b', 'c')}), strict=False) == LaxModel(x=('a', 'b', 'c'))
>       with pytest.raises(ValidationError) as exc_info:
E       Failed: DID NOT RAISE <class 'pydantic_core._pydantic_core.ValidationError'>

tests/test_main.py:2415: Failed
</pre>
</details>
<h3 id="app">app]</h3>
<details><summary> <pre>app]</pre></summary><pre>
dsn = 'mongodb+srv://user:pass@localhost/app'
expected = 'mongodb+srv://user:pass@localhost/app'

    @pytest.mark.parametrize(
        ('dsn', 'expected'),
        [
            ('mongodb://user:pass@localhost/app', 'mongodb://user:pass@localhost:27017/app'),
            pytest.param(
                'mongodb+srv://user:pass@localhost/app',
                'mongodb+srv://user:pass@localhost/app',
                marks=pytest.mark.xfail(
                    reason=(
                        'This case is not supported. '
                        'Check https://github.com/pydantic/pydantic/pull/7116 for more details.'
                    )
                ),
            ),
        ],
    )
    def test_mongodsn_default_ports(dsn: str, expected: str):
        class Model(BaseModel):
            dsn: MongoDsn

        m = Model(dsn=dsn)
>       assert str(m.dsn) == expected
E       AssertionError: assert 'mongodb+srv:...ost:27017/app' == 'mongodb+srv:...localhost/app'
E         
E         - mongodb+srv://user:pass@localhost/app
E         + mongodb+srv://user:pass@localhost:27017/app
E         ?                                  ++++++

tests/test_networks.py:756: AssertionError
</pre>
</details>
<h3 id="test_type_adapterpytest_validate_json_strict">test_type_adapter.py::test_validate_json_strict</h3>
<details><summary> <pre>test_type_adapter.py::test_validate_json_strict</pre></summary><pre>
@pytest.mark.xfail(reason='Need to fix this in https://github.com/pydantic/pydantic/pull/5944')
    def test_validate_json_strict() -> None:
        class Model(TypedDict):
            x: int

        class ModelStrict(Model):
            __pydantic_config__ = ConfigDict(strict=True)  # type: ignore

>       lax_validator = TypeAdapter(Model, config=ConfigDict(strict=False))

tests/test_type_adapter.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pydantic.type_adapter.TypeAdapter object at 0x7f87e92a9c40>
type = <class 'tests.test_type_adapter.test_validate_json_strict.<locals>.Model'>

    def __init__(
        self,
        type: Any,
        *,
        config: ConfigDict | None = None,
        _parent_depth: int = 2,
        module: str | None = None,
    ) -> None:
        """Initializes the TypeAdapter object.

        Args:
            type: The type associated with the `TypeAdapter`.
            config: Configuration for the `TypeAdapter`, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].
            _parent_depth: depth at which to search the parent namespace to construct the local namespace.
            module: The module that passes to plugin if provided.

        !!! note
            You cannot use the `config` argument when instantiating a `TypeAdapter` if the type you're using has its own
            config that cannot be overridden (ex: `BaseModel`, `TypedDict`, and `dataclass`). A
            [`type-adapter-config-unused`](../errors/usage_errors.md#type-adapter-config-unused) error will be raised in this case.

        !!! note
            The `_parent_depth` argument is named with an underscore to suggest its private nature and discourage use.
            It may be deprecated in a minor version, so we only recommend using it if you're
            comfortable with potential change in behavior / support.

        ??? tip "Compatibility with `mypy`"
            Depending on the type used, `mypy` might raise an error when instantiating a `TypeAdapter`. As a workaround, you can explicitly
            annotate your variable:

            <div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">TypeAdapter</span>

<span class="n">ta</span><span class="p">:</span> <span class="n">TypeAdapter</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">TypeAdapter</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>  <span class="c1"># type: ignore[arg-type]</span>
</code></pre></div>

        Returns:
            A type adapter configured for the specified `type`.
        """
        if _type_has_config(type) and config is not None:
>           raise PydanticUserError(
                'Cannot use `config` when the type is a BaseModel, dataclass or TypedDict.'
                ' These types can have their own config and setting the config via the `config`'
                ' parameter to TypeAdapter will not override it, thus the `config` you passed to'
                ' TypeAdapter becomes meaningless, which is probably not what you want.',
                code='type-adapter-config-unused',
            )
E           pydantic.errors.PydanticUserError: Cannot use `config` when the type is a BaseModel, dataclass or TypedDict. These types can have their own config and setting the config via the `config` parameter to TypeAdapter will not override it, thus the `config` you passed to TypeAdapter becomes meaningless, which is probably not what you want.
E           
E           For further information visit https://errors.pydantic.dev/2.8/u/type-adapter-config-unused

pydantic/type_adapter.py:238: PydanticUserError
</pre>
</details>
<h3 id="test_type_alias_typepytest_field">test_type_alias_type.py::test_field</h3>
<details><summary> <pre>test_type_alias_type.py::test_field</pre></summary><pre>
@pytest.mark.xfail(reason='description is currently dropped')
    def test_field() -> None:
        SomeAlias = TypeAliasType('SomeAlias', Annotated[int, Field(description='number')])

        ta = TypeAdapter(Annotated[SomeAlias, Field(title='abc')])

        # insert_assert(ta.json_schema())
>       assert ta.json_schema() == {
            '$defs': {'SomeAlias': {'type': 'integer', 'description': 'number'}},
            'allOf': [{'$ref': '#/$defs/SomeAlias'}],
            'title': 'abc',
        }
E       AssertionError: assert {'$defs': {'S...title': 'abc'} == {'$defs': {'S...title': 'abc'}
E         
E         Omitting 2 identical items, use -vv to show
E         Differing items:
E         {'$defs': {'SomeAlias': {'type': 'integer'}}} != {'$defs': {'SomeAlias': {'description': 'number', 'type': 'integer'}}}
E         Use -v to get more diff

tests/test_type_alias_type.py:325: AssertionError
</pre>
</details>
<h3 id="test_typespytest_invalid_schema_constraintskwargs0-int">test_types.py::test_invalid_schema_constraints[kwargs0-int]</h3>
<details><summary> <pre>test_types.py::test_invalid_schema_constraints[kwargs0-int]</pre></summary><pre>
kwargs = {'pattern': '^foo$'}, type_ = <class 'int'>

    @pytest.mark.parametrize(
        'kwargs,type_',
        [
            pytest.param(
                {'pattern': '^foo$'},
                int,
                marks=pytest.mark.xfail(
                    reason='int cannot be used with pattern but we do not currently validate that at schema build time'
                ),
            ),
            ({'gt': 0}, conlist(int, min_length=4)),
            ({'gt': 0}, conset(int, min_length=4)),
            ({'gt': 0}, confrozenset(int, min_length=4)),
        ],
    )
    def test_invalid_schema_constraints(kwargs, type_):
        match = (
            r'(:?Invalid Schema:\n.*\n  Extra inputs are not permitted)|(:?The following constraints cannot be applied to)'
        )
>       with pytest.raises((SchemaError, TypeError), match=match):
E       Failed: DID NOT RAISE (<class 'pydantic_core._pydantic_core.SchemaError'>, <class 'TypeError'>)

tests/test_types.py:1803: Failed
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/pydantic/_internal/_config.py b/pydantic/_internal/_config.py</span>
<span class="gh">index 9809c1f3e..d27e3bba8 100644</span>
<span class="gd">--- a/pydantic/_internal/_config.py</span>
<span class="gi">+++ b/pydantic/_internal/_config.py</span>
<span class="gu">@@ -1,26 +1,46 @@</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from contextlib import contextmanager
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, cast</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    cast,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import core_schema
<span class="gd">-from typing_extensions import Literal, Self</span>
<span class="gi">+from typing_extensions import (</span>
<span class="gi">+    Literal,</span>
<span class="gi">+    Self,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from ..aliases import AliasGenerator
<span class="w"> </span>from ..config import ConfigDict, ExtraValues, JsonDict, JsonEncoder, JsonSchemaExtraCallable
<span class="w"> </span>from ..errors import PydanticUserError
<span class="w"> </span>from ..warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>if not TYPE_CHECKING:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .._internal._schema_generation_shared import GenerateSchema
<span class="w"> </span>    from ..fields import ComputedFieldInfo, FieldInfo
<span class="gd">-DEPRECATION_MESSAGE = (</span>
<span class="gd">-    &#39;Support for class-based `config` is deprecated, use ConfigDict instead.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+DEPRECATION_MESSAGE = &#39;Support for class-based `config` is deprecated, use ConfigDict instead.&#39;</span>


<span class="w"> </span>class ConfigWrapper:
<span class="w"> </span>    &quot;&quot;&quot;Internal wrapper for Config which exposes ConfigDict items as attributes.&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;config_dict&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&#39;config_dict&#39;,)</span>
<span class="gi">+</span>
<span class="w"> </span>    config_dict: ConfigDict
<span class="gi">+</span>
<span class="gi">+    # all annotations are copied directly from ConfigDict, and should be kept up to date, a test will fail if they</span>
<span class="gi">+    # stop matching</span>
<span class="w"> </span>    title: str | None
<span class="w"> </span>    str_to_lower: bool
<span class="w"> </span>    str_to_upper: bool
<span class="gu">@@ -34,20 +54,25 @@ class ConfigWrapper:</span>
<span class="w"> </span>    validate_assignment: bool
<span class="w"> </span>    arbitrary_types_allowed: bool
<span class="w"> </span>    from_attributes: bool
<span class="gi">+    # whether to use the actual key provided in the data (e.g. alias or first alias for &quot;field required&quot; errors) instead of field_names</span>
<span class="gi">+    # to construct error `loc`s, default `True`</span>
<span class="w"> </span>    loc_by_alias: bool
<span class="w"> </span>    alias_generator: Callable[[str], str] | AliasGenerator | None
<span class="w"> </span>    model_title_generator: Callable[[type], str] | None
<span class="gd">-    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str</span>
<span class="gd">-        ] | None</span>
<span class="gi">+    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None</span>
<span class="w"> </span>    ignored_types: tuple[type, ...]
<span class="w"> </span>    allow_inf_nan: bool
<span class="w"> </span>    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None
<span class="w"> </span>    json_encoders: dict[type[object], JsonEncoder] | None
<span class="gi">+</span>
<span class="gi">+    # new in V2</span>
<span class="w"> </span>    strict: bool
<span class="gi">+    # whether instances of models and dataclasses (including subclass instances) should re-validate, default &#39;never&#39;</span>
<span class="w"> </span>    revalidate_instances: Literal[&#39;always&#39;, &#39;never&#39;, &#39;subclass-instances&#39;]
<span class="w"> </span>    ser_json_timedelta: Literal[&#39;iso8601&#39;, &#39;float&#39;]
<span class="w"> </span>    ser_json_bytes: Literal[&#39;utf8&#39;, &#39;base64&#39;]
<span class="w"> </span>    ser_json_inf_nan: Literal[&#39;null&#39;, &#39;constants&#39;, &#39;strings&#39;]
<span class="gi">+    # whether to validate default values during validation, default False</span>
<span class="w"> </span>    validate_default: bool
<span class="w"> </span>    validate_return: bool
<span class="w"> </span>    protected_namespaces: tuple[str, ...]
<span class="gu">@@ -64,16 +89,14 @@ class ConfigWrapper:</span>
<span class="w"> </span>    use_attribute_docstrings: bool
<span class="w"> </span>    cache_strings: bool | Literal[&#39;all&#39;, &#39;keys&#39;, &#39;none&#39;]

<span class="gd">-    def __init__(self, config: (ConfigDict | dict[str, Any] | type[Any] |</span>
<span class="gd">-        None), *, check: bool=True):</span>
<span class="gi">+    def __init__(self, config: ConfigDict | dict[str, Any] | type[Any] | None, *, check: bool = True):</span>
<span class="w"> </span>        if check:
<span class="w"> </span>            self.config_dict = prepare_config(config)
<span class="w"> </span>        else:
<span class="w"> </span>            self.config_dict = cast(ConfigDict, config)

<span class="w"> </span>    @classmethod
<span class="gd">-    def for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str,</span>
<span class="gd">-        Any], kwargs: dict[str, Any]) -&gt;Self:</span>
<span class="gi">+    def for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str, Any], kwargs: dict[str, Any]) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build a new `ConfigWrapper` instance for a `BaseModel`.

<span class="w"> </span>        The config wrapper built based on (in descending order of priority):
<span class="gu">@@ -89,20 +112,48 @@ class ConfigWrapper:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A `ConfigWrapper` instance for `BaseModel`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    if not TYPE_CHECKING:</span>
<span class="gi">+        config_new = ConfigDict()</span>
<span class="gi">+        for base in bases:</span>
<span class="gi">+            config = getattr(base, &#39;model_config&#39;, None)</span>
<span class="gi">+            if config:</span>
<span class="gi">+                config_new.update(config.copy())</span>
<span class="gi">+</span>
<span class="gi">+        config_class_from_namespace = namespace.get(&#39;Config&#39;)</span>
<span class="gi">+        config_dict_from_namespace = namespace.get(&#39;model_config&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        raw_annotations = namespace.get(&#39;__annotations__&#39;, {})</span>
<span class="gi">+        if raw_annotations.get(&#39;model_config&#39;) and not config_dict_from_namespace:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;`model_config` cannot be used as a model field name. Use `model_config` for model configuration.&#39;,</span>
<span class="gi">+                code=&#39;model-config-invalid-field-name&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if config_class_from_namespace and config_dict_from_namespace:</span>
<span class="gi">+            raise PydanticUserError(&#39;&quot;Config&quot; and &quot;model_config&quot; cannot be used together&#39;, code=&#39;config-both&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        config_from_namespace = config_dict_from_namespace or prepare_config(config_class_from_namespace)</span>
<span class="gi">+</span>
<span class="gi">+        config_new.update(config_from_namespace)</span>
<span class="gi">+</span>
<span class="gi">+        for k in list(kwargs.keys()):</span>
<span class="gi">+            if k in config_keys:</span>
<span class="gi">+                config_new[k] = kwargs.pop(k)</span>

<span class="gd">-        def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+        return cls(config_new)</span>
<span class="gi">+</span>
<span class="gi">+    # we don&#39;t show `__getattr__` to type checkers so missing attributes cause errors</span>
<span class="gi">+    if not TYPE_CHECKING:  # pragma: no branch</span>
<span class="gi">+</span>
<span class="gi">+        def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>            try:
<span class="w"> </span>                return self.config_dict[name]
<span class="w"> </span>            except KeyError:
<span class="w"> </span>                try:
<span class="w"> </span>                    return config_defaults[name]
<span class="w"> </span>                except KeyError:
<span class="gd">-                    raise AttributeError(f&#39;Config has no attribute {name!r}&#39;</span>
<span class="gd">-                        ) from None</span>
<span class="gi">+                    raise AttributeError(f&#39;Config has no attribute {name!r}&#39;) from None</span>

<span class="gd">-    def core_config(self, obj: Any) -&gt;core_schema.CoreConfig:</span>
<span class="gi">+    def core_config(self, obj: Any) -&gt; core_schema.CoreConfig:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a pydantic-core config, `obj` is just used to populate `title` if not set in config.

<span class="w"> </span>        Pass `obj=None` if you do not want to attempt to infer the `title`.
<span class="gu">@@ -115,7 +166,37 @@ class ConfigWrapper:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A `CoreConfig` object created from config.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def dict_not_none(**kwargs: Any) -&gt; Any:</span>
<span class="gi">+            return {k: v for k, v in kwargs.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+        core_config = core_schema.CoreConfig(</span>
<span class="gi">+            **dict_not_none(</span>
<span class="gi">+                title=self.config_dict.get(&#39;title&#39;) or (obj and obj.__name__),</span>
<span class="gi">+                extra_fields_behavior=self.config_dict.get(&#39;extra&#39;),</span>
<span class="gi">+                allow_inf_nan=self.config_dict.get(&#39;allow_inf_nan&#39;),</span>
<span class="gi">+                populate_by_name=self.config_dict.get(&#39;populate_by_name&#39;),</span>
<span class="gi">+                str_strip_whitespace=self.config_dict.get(&#39;str_strip_whitespace&#39;),</span>
<span class="gi">+                str_to_lower=self.config_dict.get(&#39;str_to_lower&#39;),</span>
<span class="gi">+                str_to_upper=self.config_dict.get(&#39;str_to_upper&#39;),</span>
<span class="gi">+                strict=self.config_dict.get(&#39;strict&#39;),</span>
<span class="gi">+                ser_json_timedelta=self.config_dict.get(&#39;ser_json_timedelta&#39;),</span>
<span class="gi">+                ser_json_bytes=self.config_dict.get(&#39;ser_json_bytes&#39;),</span>
<span class="gi">+                ser_json_inf_nan=self.config_dict.get(&#39;ser_json_inf_nan&#39;),</span>
<span class="gi">+                from_attributes=self.config_dict.get(&#39;from_attributes&#39;),</span>
<span class="gi">+                loc_by_alias=self.config_dict.get(&#39;loc_by_alias&#39;),</span>
<span class="gi">+                revalidate_instances=self.config_dict.get(&#39;revalidate_instances&#39;),</span>
<span class="gi">+                validate_default=self.config_dict.get(&#39;validate_default&#39;),</span>
<span class="gi">+                str_max_length=self.config_dict.get(&#39;str_max_length&#39;),</span>
<span class="gi">+                str_min_length=self.config_dict.get(&#39;str_min_length&#39;),</span>
<span class="gi">+                hide_input_in_errors=self.config_dict.get(&#39;hide_input_in_errors&#39;),</span>
<span class="gi">+                coerce_numbers_to_str=self.config_dict.get(&#39;coerce_numbers_to_str&#39;),</span>
<span class="gi">+                regex_engine=self.config_dict.get(&#39;regex_engine&#39;),</span>
<span class="gi">+                validation_error_cause=self.config_dict.get(&#39;validation_error_cause&#39;),</span>
<span class="gi">+                cache_strings=self.config_dict.get(&#39;cache_strings&#39;),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        return core_config</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        c = &#39;, &#39;.join(f&#39;{k}={v!r}&#39; for k, v in self.config_dict.items())
<span class="gu">@@ -128,27 +209,73 @@ class ConfigWrapperStack:</span>
<span class="w"> </span>    def __init__(self, config_wrapper: ConfigWrapper):
<span class="w"> </span>        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]

<span class="gi">+    @property</span>
<span class="gi">+    def tail(self) -&gt; ConfigWrapper:</span>
<span class="gi">+        return self._config_wrapper_stack[-1]</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):</span>
<span class="gi">+        if config_wrapper is None:</span>
<span class="gi">+            yield</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(config_wrapper, ConfigWrapper):</span>
<span class="gi">+            config_wrapper = ConfigWrapper(config_wrapper, check=False)</span>
<span class="gi">+</span>
<span class="gi">+        self._config_wrapper_stack.append(config_wrapper)</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._config_wrapper_stack.pop()</span>
<span class="gi">+</span>

<span class="gd">-config_defaults = ConfigDict(title=None, str_to_lower=False, str_to_upper=</span>
<span class="gd">-    False, str_strip_whitespace=False, str_min_length=0, str_max_length=</span>
<span class="gd">-    None, extra=None, frozen=False, populate_by_name=False, use_enum_values</span>
<span class="gd">-    =False, validate_assignment=False, arbitrary_types_allowed=False,</span>
<span class="gd">-    from_attributes=False, loc_by_alias=True, alias_generator=None,</span>
<span class="gd">-    model_title_generator=None, field_title_generator=None, ignored_types=(</span>
<span class="gd">-    ), allow_inf_nan=True, json_schema_extra=None, strict=False,</span>
<span class="gd">-    revalidate_instances=&#39;never&#39;, ser_json_timedelta=&#39;iso8601&#39;,</span>
<span class="gd">-    ser_json_bytes=&#39;utf8&#39;, ser_json_inf_nan=&#39;null&#39;, validate_default=False,</span>
<span class="gd">-    validate_return=False, protected_namespaces=(&#39;model_&#39;,),</span>
<span class="gd">-    hide_input_in_errors=False, json_encoders=None, defer_build=False,</span>
<span class="gd">-    experimental_defer_build_mode=(&#39;model&#39;,), plugin_settings=None,</span>
<span class="gd">-    schema_generator=None, json_schema_serialization_defaults_required=</span>
<span class="gd">-    False, json_schema_mode_override=None, coerce_numbers_to_str=False,</span>
<span class="gd">-    regex_engine=&#39;rust-regex&#39;, validation_error_cause=False,</span>
<span class="gd">-    use_attribute_docstrings=False, cache_strings=True)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def prepare_config(config: (ConfigDict | dict[str, Any] | type[Any] | None)</span>
<span class="gd">-    ) -&gt;ConfigDict:</span>
<span class="gi">+config_defaults = ConfigDict(</span>
<span class="gi">+    title=None,</span>
<span class="gi">+    str_to_lower=False,</span>
<span class="gi">+    str_to_upper=False,</span>
<span class="gi">+    str_strip_whitespace=False,</span>
<span class="gi">+    str_min_length=0,</span>
<span class="gi">+    str_max_length=None,</span>
<span class="gi">+    # let the model / dataclass decide how to handle it</span>
<span class="gi">+    extra=None,</span>
<span class="gi">+    frozen=False,</span>
<span class="gi">+    populate_by_name=False,</span>
<span class="gi">+    use_enum_values=False,</span>
<span class="gi">+    validate_assignment=False,</span>
<span class="gi">+    arbitrary_types_allowed=False,</span>
<span class="gi">+    from_attributes=False,</span>
<span class="gi">+    loc_by_alias=True,</span>
<span class="gi">+    alias_generator=None,</span>
<span class="gi">+    model_title_generator=None,</span>
<span class="gi">+    field_title_generator=None,</span>
<span class="gi">+    ignored_types=(),</span>
<span class="gi">+    allow_inf_nan=True,</span>
<span class="gi">+    json_schema_extra=None,</span>
<span class="gi">+    strict=False,</span>
<span class="gi">+    revalidate_instances=&#39;never&#39;,</span>
<span class="gi">+    ser_json_timedelta=&#39;iso8601&#39;,</span>
<span class="gi">+    ser_json_bytes=&#39;utf8&#39;,</span>
<span class="gi">+    ser_json_inf_nan=&#39;null&#39;,</span>
<span class="gi">+    validate_default=False,</span>
<span class="gi">+    validate_return=False,</span>
<span class="gi">+    protected_namespaces=(&#39;model_&#39;,),</span>
<span class="gi">+    hide_input_in_errors=False,</span>
<span class="gi">+    json_encoders=None,</span>
<span class="gi">+    defer_build=False,</span>
<span class="gi">+    experimental_defer_build_mode=(&#39;model&#39;,),</span>
<span class="gi">+    plugin_settings=None,</span>
<span class="gi">+    schema_generator=None,</span>
<span class="gi">+    json_schema_serialization_defaults_required=False,</span>
<span class="gi">+    json_schema_mode_override=None,</span>
<span class="gi">+    coerce_numbers_to_str=False,</span>
<span class="gi">+    regex_engine=&#39;rust-regex&#39;,</span>
<span class="gi">+    validation_error_cause=False,</span>
<span class="gi">+    use_attribute_docstrings=False,</span>
<span class="gi">+    cache_strings=True,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def prepare_config(config: ConfigDict | dict[str, Any] | type[Any] | None) -&gt; ConfigDict:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a `ConfigDict` instance from an existing dict, a class (e.g. old class-based config) or None.

<span class="w"> </span>    Args:
<span class="gu">@@ -157,26 +284,58 @@ def prepare_config(config: (ConfigDict | dict[str, Any] | type[Any] | None)</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A ConfigDict object created from config.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if config is None:</span>
<span class="gi">+        return ConfigDict()</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(config, dict):</span>
<span class="gi">+        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)</span>
<span class="gi">+        config = {k: getattr(config, k) for k in dir(config) if not k.startswith(&#39;__&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+    config_dict = cast(ConfigDict, config)</span>
<span class="gi">+    check_deprecated(config_dict)</span>
<span class="gi">+    return config_dict</span>


<span class="w"> </span>config_keys = set(ConfigDict.__annotations__.keys())
<span class="gd">-V2_REMOVED_KEYS = {&#39;allow_mutation&#39;, &#39;error_msg_templates&#39;, &#39;fields&#39;,</span>
<span class="gd">-    &#39;getter_dict&#39;, &#39;smart_union&#39;, &#39;underscore_attrs_are_private&#39;,</span>
<span class="gd">-    &#39;json_loads&#39;, &#39;json_dumps&#39;, &#39;copy_on_model_validation&#39;, &#39;post_init_call&#39;}</span>
<span class="gd">-V2_RENAMED_KEYS = {&#39;allow_population_by_field_name&#39;: &#39;populate_by_name&#39;,</span>
<span class="gd">-    &#39;anystr_lower&#39;: &#39;str_to_lower&#39;, &#39;anystr_strip_whitespace&#39;:</span>
<span class="gd">-    &#39;str_strip_whitespace&#39;, &#39;anystr_upper&#39;: &#39;str_to_upper&#39;,</span>
<span class="gd">-    &#39;keep_untouched&#39;: &#39;ignored_types&#39;, &#39;max_anystr_length&#39;:</span>
<span class="gd">-    &#39;str_max_length&#39;, &#39;min_anystr_length&#39;: &#39;str_min_length&#39;, &#39;orm_mode&#39;:</span>
<span class="gd">-    &#39;from_attributes&#39;, &#39;schema_extra&#39;: &#39;json_schema_extra&#39;, &#39;validate_all&#39;:</span>
<span class="gd">-    &#39;validate_default&#39;}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def check_deprecated(config_dict: ConfigDict) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+V2_REMOVED_KEYS = {</span>
<span class="gi">+    &#39;allow_mutation&#39;,</span>
<span class="gi">+    &#39;error_msg_templates&#39;,</span>
<span class="gi">+    &#39;fields&#39;,</span>
<span class="gi">+    &#39;getter_dict&#39;,</span>
<span class="gi">+    &#39;smart_union&#39;,</span>
<span class="gi">+    &#39;underscore_attrs_are_private&#39;,</span>
<span class="gi">+    &#39;json_loads&#39;,</span>
<span class="gi">+    &#39;json_dumps&#39;,</span>
<span class="gi">+    &#39;copy_on_model_validation&#39;,</span>
<span class="gi">+    &#39;post_init_call&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+V2_RENAMED_KEYS = {</span>
<span class="gi">+    &#39;allow_population_by_field_name&#39;: &#39;populate_by_name&#39;,</span>
<span class="gi">+    &#39;anystr_lower&#39;: &#39;str_to_lower&#39;,</span>
<span class="gi">+    &#39;anystr_strip_whitespace&#39;: &#39;str_strip_whitespace&#39;,</span>
<span class="gi">+    &#39;anystr_upper&#39;: &#39;str_to_upper&#39;,</span>
<span class="gi">+    &#39;keep_untouched&#39;: &#39;ignored_types&#39;,</span>
<span class="gi">+    &#39;max_anystr_length&#39;: &#39;str_max_length&#39;,</span>
<span class="gi">+    &#39;min_anystr_length&#39;: &#39;str_min_length&#39;,</span>
<span class="gi">+    &#39;orm_mode&#39;: &#39;from_attributes&#39;,</span>
<span class="gi">+    &#39;schema_extra&#39;: &#39;json_schema_extra&#39;,</span>
<span class="gi">+    &#39;validate_all&#39;: &#39;validate_default&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def check_deprecated(config_dict: ConfigDict) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check for deprecated config keys and warn the user.

<span class="w"> </span>    Args:
<span class="w"> </span>        config_dict: The input config.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    deprecated_removed_keys = V2_REMOVED_KEYS &amp; config_dict.keys()</span>
<span class="gi">+    deprecated_renamed_keys = V2_RENAMED_KEYS.keys() &amp; config_dict.keys()</span>
<span class="gi">+    if deprecated_removed_keys or deprecated_renamed_keys:</span>
<span class="gi">+        renamings = {k: V2_RENAMED_KEYS[k] for k in sorted(deprecated_renamed_keys)}</span>
<span class="gi">+        renamed_bullets = [f&#39;* {k!r} has been renamed to {v!r}&#39; for k, v in renamings.items()]</span>
<span class="gi">+        removed_bullets = [f&#39;* {k!r} has been removed&#39; for k in sorted(deprecated_removed_keys)]</span>
<span class="gi">+        message = &#39;\n&#39;.join([&#39;Valid config keys have changed in V2:&#39;] + renamed_bullets + removed_bullets)</span>
<span class="gi">+        warnings.warn(message, UserWarning)</span>
<span class="gh">diff --git a/pydantic/_internal/_core_metadata.py b/pydantic/_internal/_core_metadata.py</span>
<span class="gh">index e9361dbe5..296d49f59 100644</span>
<span class="gd">--- a/pydantic/_internal/_core_metadata.py</span>
<span class="gi">+++ b/pydantic/_internal/_core_metadata.py</span>
<span class="gu">@@ -1,13 +1,20 @@</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>import typing_extensions
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    from ._schema_generation_shared import CoreSchemaOrField as CoreSchemaOrField</span>
<span class="gd">-    from ._schema_generation_shared import GetJsonSchemaFunction</span>
<span class="gi">+    from ._schema_generation_shared import (</span>
<span class="gi">+        CoreSchemaOrField as CoreSchemaOrField,</span>
<span class="gi">+    )</span>
<span class="gi">+    from ._schema_generation_shared import (</span>
<span class="gi">+        GetJsonSchemaFunction,</span>
<span class="gi">+    )</span>


<span class="gd">-class CoreMetadata(typing_extensions.TypedDict, total=(False)):</span>
<span class="gi">+class CoreMetadata(typing_extensions.TypedDict, total=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;A `TypedDict` for holding the metadata dict of the schema.

<span class="w"> </span>    Attributes:
<span class="gu">@@ -15,10 +22,15 @@ class CoreMetadata(typing_extensions.TypedDict, total=(False)):</span>
<span class="w"> </span>        pydantic_js_prefer_positional_arguments: Whether JSON schema generator will
<span class="w"> </span>            prefer positional over keyword arguments for an &#39;arguments&#39; schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pydantic_js_functions: list[GetJsonSchemaFunction]
<span class="w"> </span>    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]
<span class="gi">+</span>
<span class="gi">+    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will</span>
<span class="gi">+    # prefer positional over keyword arguments for an &#39;arguments&#39; schema.</span>
<span class="w"> </span>    pydantic_js_prefer_positional_arguments: bool | None
<span class="gd">-    pydantic_typed_dict_cls: type[Any] | None</span>
<span class="gi">+</span>
<span class="gi">+    pydantic_typed_dict_cls: type[Any] | None  # TODO: Consider moving this into the pydantic-core TypedDictSchema</span>


<span class="w"> </span>class CoreMetadataHandler:
<span class="gu">@@ -27,31 +39,54 @@ class CoreMetadataHandler:</span>
<span class="w"> </span>    This class is used to interact with the metadata field on a CoreSchema object in a consistent
<span class="w"> </span>    way throughout pydantic.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_schema&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&#39;_schema&#39;,)</span>

<span class="w"> </span>    def __init__(self, schema: CoreSchemaOrField):
<span class="w"> </span>        self._schema = schema
<span class="gi">+</span>
<span class="w"> </span>        metadata = schema.get(&#39;metadata&#39;)
<span class="w"> </span>        if metadata is None:
<span class="w"> </span>            schema[&#39;metadata&#39;] = CoreMetadata()
<span class="w"> </span>        elif not isinstance(metadata, dict):
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                f&#39;CoreSchema metadata should be a dict; got {metadata!r}.&#39;)</span>
<span class="gi">+            raise TypeError(f&#39;CoreSchema metadata should be a dict; got {metadata!r}.&#39;)</span>

<span class="w"> </span>    @property
<span class="gd">-    def metadata(self) -&gt;CoreMetadata:</span>
<span class="gi">+    def metadata(self) -&gt; CoreMetadata:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieves the metadata dict from the schema, initializing it to a dict if it is None
<span class="w"> </span>        and raises an error if it is not a dict.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        metadata = self._schema.get(&#39;metadata&#39;)</span>
<span class="gi">+        if metadata is None:</span>
<span class="gi">+            self._schema[&#39;metadata&#39;] = metadata = CoreMetadata()</span>
<span class="gi">+        if not isinstance(metadata, dict):</span>
<span class="gi">+            raise TypeError(f&#39;CoreSchema metadata should be a dict; got {metadata!r}.&#39;)</span>
<span class="gi">+        return metadata</span>


<span class="gd">-def build_metadata_dict(*, js_functions: (list[GetJsonSchemaFunction] |</span>
<span class="gd">-    None)=None, js_annotation_functions: (list[GetJsonSchemaFunction] |</span>
<span class="gd">-    None)=None, js_prefer_positional_arguments: (bool | None)=None,</span>
<span class="gd">-    typed_dict_cls: (type[Any] | None)=None, initial_metadata: (Any | None)</span>
<span class="gd">-    =None) -&gt;Any:</span>
<span class="gi">+def build_metadata_dict(</span>
<span class="gi">+    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way</span>
<span class="gi">+    js_functions: list[GetJsonSchemaFunction] | None = None,</span>
<span class="gi">+    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,</span>
<span class="gi">+    js_prefer_positional_arguments: bool | None = None,</span>
<span class="gi">+    typed_dict_cls: type[Any] | None = None,</span>
<span class="gi">+    initial_metadata: Any | None = None,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent
<span class="w"> </span>    with the CoreMetadataHandler class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if initial_metadata is not None and not isinstance(initial_metadata, dict):</span>
<span class="gi">+        raise TypeError(f&#39;CoreSchema metadata should be a dict; got {initial_metadata!r}.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    metadata = CoreMetadata(</span>
<span class="gi">+        pydantic_js_functions=js_functions or [],</span>
<span class="gi">+        pydantic_js_annotation_functions=js_annotation_functions or [],</span>
<span class="gi">+        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,</span>
<span class="gi">+        pydantic_typed_dict_cls=typed_dict_cls,</span>
<span class="gi">+    )</span>
<span class="gi">+    metadata = {k: v for k, v in metadata.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+    if initial_metadata is not None:</span>
<span class="gi">+        metadata = {**initial_metadata, **metadata}</span>
<span class="gi">+</span>
<span class="gi">+    return metadata</span>
<span class="gh">diff --git a/pydantic/_internal/_core_utils.py b/pydantic/_internal/_core_utils.py</span>
<span class="gh">index 5f858e638..baec70625 100644</span>
<span class="gd">--- a/pydantic/_internal/_core_utils.py</span>
<span class="gi">+++ b/pydantic/_internal/_core_utils.py</span>
<span class="gu">@@ -1,26 +1,45 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from collections import defaultdict
<span class="gd">-from typing import Any, Callable, Hashable, TypeVar, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Hashable,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import CoreSchema, core_schema
<span class="w"> </span>from pydantic_core import validate_core_schema as _validate_core_schema
<span class="w"> </span>from typing_extensions import TypeAliasType, TypeGuard, get_args, get_origin
<span class="gi">+</span>
<span class="w"> </span>from . import _repr
<span class="w"> </span>from ._typing_extra import is_generic_alias
<span class="gd">-AnyFunctionSchema = Union[core_schema.AfterValidatorFunctionSchema,</span>
<span class="gd">-    core_schema.BeforeValidatorFunctionSchema, core_schema.</span>
<span class="gd">-    WrapValidatorFunctionSchema, core_schema.PlainValidatorFunctionSchema]</span>
<span class="gd">-FunctionSchemaWithInnerSchema = Union[core_schema.</span>
<span class="gd">-    AfterValidatorFunctionSchema, core_schema.BeforeValidatorFunctionSchema,</span>
<span class="gd">-    core_schema.WrapValidatorFunctionSchema]</span>
<span class="gd">-CoreSchemaField = Union[core_schema.ModelField, core_schema.DataclassField,</span>
<span class="gd">-    core_schema.TypedDictField, core_schema.ComputedField]</span>
<span class="gi">+</span>
<span class="gi">+AnyFunctionSchema = Union[</span>
<span class="gi">+    core_schema.AfterValidatorFunctionSchema,</span>
<span class="gi">+    core_schema.BeforeValidatorFunctionSchema,</span>
<span class="gi">+    core_schema.WrapValidatorFunctionSchema,</span>
<span class="gi">+    core_schema.PlainValidatorFunctionSchema,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+FunctionSchemaWithInnerSchema = Union[</span>
<span class="gi">+    core_schema.AfterValidatorFunctionSchema,</span>
<span class="gi">+    core_schema.BeforeValidatorFunctionSchema,</span>
<span class="gi">+    core_schema.WrapValidatorFunctionSchema,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+CoreSchemaField = Union[</span>
<span class="gi">+    core_schema.ModelField, core_schema.DataclassField, core_schema.TypedDictField, core_schema.ComputedField</span>
<span class="gi">+]</span>
<span class="w"> </span>CoreSchemaOrField = Union[core_schema.CoreSchema, CoreSchemaField]
<span class="gd">-_CORE_SCHEMA_FIELD_TYPES = {&#39;typed-dict-field&#39;, &#39;dataclass-field&#39;,</span>
<span class="gd">-    &#39;model-field&#39;, &#39;computed-field&#39;}</span>
<span class="gd">-_FUNCTION_WITH_INNER_SCHEMA_TYPES = {&#39;function-before&#39;, &#39;function-after&#39;,</span>
<span class="gd">-    &#39;function-wrap&#39;}</span>
<span class="gi">+</span>
<span class="gi">+_CORE_SCHEMA_FIELD_TYPES = {&#39;typed-dict-field&#39;, &#39;dataclass-field&#39;, &#39;model-field&#39;, &#39;computed-field&#39;}</span>
<span class="gi">+_FUNCTION_WITH_INNER_SCHEMA_TYPES = {&#39;function-before&#39;, &#39;function-after&#39;, &#39;function-wrap&#39;}</span>
<span class="w"> </span>_LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES = {&#39;list&#39;, &#39;set&#39;, &#39;frozenset&#39;}
<span class="gi">+</span>
<span class="w"> </span>TAGGED_UNION_TAG_KEY = &#39;pydantic.internal.tagged_union_tag&#39;
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Used in a `Tag` schema to specify the tag used for a discriminated union.
<span class="gu">@@ -31,39 +50,354 @@ schema was first encountered.</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gd">-def get_type_ref(type_: type[Any], args_override: (tuple[type[Any], ...] |</span>
<span class="gd">-    None)=None) -&gt;str:</span>
<span class="gi">+def is_core_schema(</span>
<span class="gi">+    schema: CoreSchemaOrField,</span>
<span class="gi">+) -&gt; TypeGuard[CoreSchema]:</span>
<span class="gi">+    return schema[&#39;type&#39;] not in _CORE_SCHEMA_FIELD_TYPES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_core_schema_field(</span>
<span class="gi">+    schema: CoreSchemaOrField,</span>
<span class="gi">+) -&gt; TypeGuard[CoreSchemaField]:</span>
<span class="gi">+    return schema[&#39;type&#39;] in _CORE_SCHEMA_FIELD_TYPES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_function_with_inner_schema(</span>
<span class="gi">+    schema: CoreSchemaOrField,</span>
<span class="gi">+) -&gt; TypeGuard[FunctionSchemaWithInnerSchema]:</span>
<span class="gi">+    return schema[&#39;type&#39;] in _FUNCTION_WITH_INNER_SCHEMA_TYPES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_list_like_schema_with_items_schema(</span>
<span class="gi">+    schema: CoreSchema,</span>
<span class="gi">+) -&gt; TypeGuard[core_schema.ListSchema | core_schema.SetSchema | core_schema.FrozenSetSchema]:</span>
<span class="gi">+    return schema[&#39;type&#39;] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_type_ref(type_: type[Any], args_override: tuple[type[Any], ...] | None = None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Produces the ref to be used for this type by pydantic_core&#39;s core schemas.

<span class="w"> </span>    This `args_override` argument was added for the purpose of creating valid recursive references
<span class="w"> </span>    when creating generic models without needing to create a concrete class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    origin = get_origin(type_) or type_</span>

<span class="gi">+    args = get_args(type_) if is_generic_alias(type_) else (args_override or ())</span>
<span class="gi">+    generic_metadata = getattr(type_, &#39;__pydantic_generic_metadata__&#39;, None)</span>
<span class="gi">+    if generic_metadata:</span>
<span class="gi">+        origin = generic_metadata[&#39;origin&#39;] or origin</span>
<span class="gi">+        args = generic_metadata[&#39;args&#39;] or args</span>

<span class="gd">-def get_ref(s: core_schema.CoreSchema) -&gt;(None | str):</span>
<span class="gi">+    module_name = getattr(origin, &#39;__module__&#39;, &#39;&lt;No __module__&gt;&#39;)</span>
<span class="gi">+    if isinstance(origin, TypeAliasType):</span>
<span class="gi">+        type_ref = f&#39;{module_name}.{origin.__name__}:{id(origin)}&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            qualname = getattr(origin, &#39;__qualname__&#39;, f&#39;&lt;No __qualname__: {origin}&gt;&#39;)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            qualname = getattr(origin, &#39;__qualname__&#39;, &#39;&lt;No __qualname__&gt;&#39;)</span>
<span class="gi">+        type_ref = f&#39;{module_name}.{qualname}:{id(origin)}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    arg_refs: list[str] = []</span>
<span class="gi">+    for arg in args:</span>
<span class="gi">+        if isinstance(arg, str):</span>
<span class="gi">+            # Handle string literals as a special case; we may be able to remove this special handling if we</span>
<span class="gi">+            # wrap them in a ForwardRef at some point.</span>
<span class="gi">+            arg_ref = f&#39;{arg}:str-{id(arg)}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            arg_ref = f&#39;{_repr.display_as_type(arg)}:{id(arg)}&#39;</span>
<span class="gi">+        arg_refs.append(arg_ref)</span>
<span class="gi">+    if arg_refs:</span>
<span class="gi">+        type_ref = f&#39;{type_ref}[{&quot;,&quot;.join(arg_refs)}]&#39;</span>
<span class="gi">+    return type_ref</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_ref(s: core_schema.CoreSchema) -&gt; None | str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the ref from the schema if it has one.
<span class="w"> </span>    This exists just for type checking to work correctly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return s.get(&#39;ref&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def collect_definitions(schema: core_schema.CoreSchema) -&gt; dict[str, core_schema.CoreSchema]:</span>
<span class="gi">+    defs: dict[str, CoreSchema] = {}</span>
<span class="gi">+</span>
<span class="gi">+    def _record_valid_refs(s: core_schema.CoreSchema, recurse: Recurse) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        ref = get_ref(s)</span>
<span class="gi">+        if ref:</span>
<span class="gi">+            defs[ref] = s</span>
<span class="gi">+        return recurse(s, _record_valid_refs)</span>
<span class="gi">+</span>
<span class="gi">+    walk_core_schema(schema, _record_valid_refs)</span>
<span class="gi">+</span>
<span class="gi">+    return defs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def define_expected_missing_refs(</span>
<span class="gi">+    schema: core_schema.CoreSchema, allowed_missing_refs: set[str]</span>
<span class="gi">+) -&gt; core_schema.CoreSchema | None:</span>
<span class="gi">+    if not allowed_missing_refs:</span>
<span class="gi">+        # in this case, there are no missing refs to potentially substitute, so there&#39;s no need to walk the schema</span>
<span class="gi">+        # this is a common case (will be hit for all non-generic models), so it&#39;s worth optimizing for</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    refs = collect_definitions(schema).keys()</span>
<span class="gi">+</span>
<span class="gi">+    expected_missing_refs = allowed_missing_refs.difference(refs)</span>
<span class="gi">+    if expected_missing_refs:</span>
<span class="gi">+        definitions: list[core_schema.CoreSchema] = [</span>
<span class="gi">+            # TODO: Replace this with a (new) CoreSchema that, if present at any level, makes validation fail</span>
<span class="gi">+            #   Issue: https://github.com/pydantic/pydantic-core/issues/619</span>
<span class="gi">+            core_schema.none_schema(ref=ref, metadata={HAS_INVALID_SCHEMAS_METADATA_KEY: True})</span>
<span class="gi">+            for ref in expected_missing_refs</span>
<span class="gi">+        ]</span>
<span class="gi">+        return core_schema.definitions_schema(schema, definitions)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def collect_invalid_schemas(schema: core_schema.CoreSchema) -&gt; bool:</span>
<span class="gi">+    invalid = False</span>
<span class="gi">+</span>
<span class="gi">+    def _is_schema_valid(s: core_schema.CoreSchema, recurse: Recurse) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        nonlocal invalid</span>
<span class="gi">+        if &#39;metadata&#39; in s:</span>
<span class="gi">+            metadata = s[&#39;metadata&#39;]</span>
<span class="gi">+            if HAS_INVALID_SCHEMAS_METADATA_KEY in metadata:</span>
<span class="gi">+                invalid = metadata[HAS_INVALID_SCHEMAS_METADATA_KEY]</span>
<span class="gi">+                return s</span>
<span class="gi">+        return recurse(s, _is_schema_valid)</span>
<span class="gi">+</span>
<span class="gi">+    walk_core_schema(schema, _is_schema_valid)</span>
<span class="gi">+    return invalid</span>


<span class="w"> </span>T = TypeVar(&#39;T&#39;)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>Recurse = Callable[[core_schema.CoreSchema, &#39;Walk&#39;], core_schema.CoreSchema]
<span class="w"> </span>Walk = Callable[[core_schema.CoreSchema, Recurse], core_schema.CoreSchema]

<span class="gi">+# TODO: Should we move _WalkCoreSchema into pydantic_core proper?</span>
<span class="gi">+#   Issue: https://github.com/pydantic/pydantic-core/issues/615</span>

<span class="gd">-class _WalkCoreSchema:</span>

<span class="gi">+class _WalkCoreSchema:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._schema_type_to_method = self._build_schema_type_to_method()

<span class="gi">+    def _build_schema_type_to_method(self) -&gt; dict[core_schema.CoreSchemaType, Recurse]:</span>
<span class="gi">+        mapping: dict[core_schema.CoreSchemaType, Recurse] = {}</span>
<span class="gi">+        key: core_schema.CoreSchemaType</span>
<span class="gi">+        for key in get_args(core_schema.CoreSchemaType):</span>
<span class="gi">+            method_name = f&quot;handle_{key.replace(&#39;-&#39;, &#39;_&#39;)}_schema&quot;</span>
<span class="gi">+            mapping[key] = getattr(self, method_name, self._handle_other_schemas)</span>
<span class="gi">+        return mapping</span>
<span class="gi">+</span>
<span class="gi">+    def walk(self, schema: core_schema.CoreSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return f(schema, self._walk)</span>
<span class="gi">+</span>
<span class="gi">+    def _walk(self, schema: core_schema.CoreSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        schema = self._schema_type_to_method[schema[&#39;type&#39;]](schema.copy(), f)</span>
<span class="gi">+        ser_schema: core_schema.SerSchema | None = schema.get(&#39;serialization&#39;)  # type: ignore</span>
<span class="gi">+        if ser_schema:</span>
<span class="gi">+            schema[&#39;serialization&#39;] = self._handle_ser_schemas(ser_schema, f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_other_schemas(self, schema: core_schema.CoreSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        sub_schema = schema.get(&#39;schema&#39;, None)</span>
<span class="gi">+        if sub_schema is not None:</span>
<span class="gi">+            schema[&#39;schema&#39;] = self.walk(sub_schema, f)  # type: ignore</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_ser_schemas(self, ser_schema: core_schema.SerSchema, f: Walk) -&gt; core_schema.SerSchema:</span>
<span class="gi">+        schema: core_schema.CoreSchema | None = ser_schema.get(&#39;schema&#39;, None)</span>
<span class="gi">+        if schema is not None:</span>
<span class="gi">+            ser_schema[&#39;schema&#39;] = self.walk(schema, f)  # type: ignore</span>
<span class="gi">+        return_schema: core_schema.CoreSchema | None = ser_schema.get(&#39;return_schema&#39;, None)</span>
<span class="gi">+        if return_schema is not None:</span>
<span class="gi">+            ser_schema[&#39;return_schema&#39;] = self.walk(return_schema, f)  # type: ignore</span>
<span class="gi">+        return ser_schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_definitions_schema(self, schema: core_schema.DefinitionsSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        new_definitions: list[core_schema.CoreSchema] = []</span>
<span class="gi">+        for definition in schema[&#39;definitions&#39;]:</span>
<span class="gi">+            if &#39;schema_ref&#39; in definition and &#39;ref&#39; in definition:</span>
<span class="gi">+                # This indicates a purposely indirect reference</span>
<span class="gi">+                # We want to keep such references around for implications related to JSON schema, etc.:</span>
<span class="gi">+                new_definitions.append(definition)</span>
<span class="gi">+                # However, we still need to walk the referenced definition:</span>
<span class="gi">+                self.walk(definition, f)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            updated_definition = self.walk(definition, f)</span>
<span class="gi">+            if &#39;ref&#39; in updated_definition:</span>
<span class="gi">+                # If the updated definition schema doesn&#39;t have a &#39;ref&#39;, it shouldn&#39;t go in the definitions</span>
<span class="gi">+                # This is most likely to happen due to replacing something with a definition reference, in</span>
<span class="gi">+                # which case it should certainly not go in the definitions list</span>
<span class="gi">+                new_definitions.append(updated_definition)</span>
<span class="gi">+        new_inner_schema = self.walk(schema[&#39;schema&#39;], f)</span>
<span class="gi">+</span>
<span class="gi">+        if not new_definitions and len(schema) == 3:</span>
<span class="gi">+            # This means we&#39;d be returning a &quot;trivial&quot; definitions schema that just wrapped the inner schema</span>
<span class="gi">+            return new_inner_schema</span>
<span class="gi">+</span>
<span class="gi">+        new_schema = schema.copy()</span>
<span class="gi">+        new_schema[&#39;schema&#39;] = new_inner_schema</span>
<span class="gi">+        new_schema[&#39;definitions&#39;] = new_definitions</span>
<span class="gi">+        return new_schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_list_schema(self, schema: core_schema.ListSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        items_schema = schema.get(&#39;items_schema&#39;)</span>
<span class="gi">+        if items_schema is not None:</span>
<span class="gi">+            schema[&#39;items_schema&#39;] = self.walk(items_schema, f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_set_schema(self, schema: core_schema.SetSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        items_schema = schema.get(&#39;items_schema&#39;)</span>
<span class="gi">+        if items_schema is not None:</span>
<span class="gi">+            schema[&#39;items_schema&#39;] = self.walk(items_schema, f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_frozenset_schema(self, schema: core_schema.FrozenSetSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        items_schema = schema.get(&#39;items_schema&#39;)</span>
<span class="gi">+        if items_schema is not None:</span>
<span class="gi">+            schema[&#39;items_schema&#39;] = self.walk(items_schema, f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_generator_schema(self, schema: core_schema.GeneratorSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        items_schema = schema.get(&#39;items_schema&#39;)</span>
<span class="gi">+        if items_schema is not None:</span>
<span class="gi">+            schema[&#39;items_schema&#39;] = self.walk(items_schema, f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_tuple_schema(self, schema: core_schema.TupleSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        schema[&#39;items_schema&#39;] = [self.walk(v, f) for v in schema[&#39;items_schema&#39;]]</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_dict_schema(self, schema: core_schema.DictSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        keys_schema = schema.get(&#39;keys_schema&#39;)</span>
<span class="gi">+        if keys_schema is not None:</span>
<span class="gi">+            schema[&#39;keys_schema&#39;] = self.walk(keys_schema, f)</span>
<span class="gi">+        values_schema = schema.get(&#39;values_schema&#39;)</span>
<span class="gi">+        if values_schema:</span>
<span class="gi">+            schema[&#39;values_schema&#39;] = self.walk(values_schema, f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_function_schema(self, schema: AnyFunctionSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        if not is_function_with_inner_schema(schema):</span>
<span class="gi">+            return schema</span>
<span class="gi">+        schema[&#39;schema&#39;] = self.walk(schema[&#39;schema&#39;], f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_union_schema(self, schema: core_schema.UnionSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        new_choices: list[CoreSchema | tuple[CoreSchema, str]] = []</span>
<span class="gi">+        for v in schema[&#39;choices&#39;]:</span>
<span class="gi">+            if isinstance(v, tuple):</span>
<span class="gi">+                new_choices.append((self.walk(v[0], f), v[1]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_choices.append(self.walk(v, f))</span>
<span class="gi">+        schema[&#39;choices&#39;] = new_choices</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_tagged_union_schema(self, schema: core_schema.TaggedUnionSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        new_choices: dict[Hashable, core_schema.CoreSchema] = {}</span>
<span class="gi">+        for k, v in schema[&#39;choices&#39;].items():</span>
<span class="gi">+            new_choices[k] = v if isinstance(v, (str, int)) else self.walk(v, f)</span>
<span class="gi">+        schema[&#39;choices&#39;] = new_choices</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_chain_schema(self, schema: core_schema.ChainSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        schema[&#39;steps&#39;] = [self.walk(v, f) for v in schema[&#39;steps&#39;]]</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        schema[&#39;lax_schema&#39;] = self.walk(schema[&#39;lax_schema&#39;], f)</span>
<span class="gi">+        schema[&#39;strict_schema&#39;] = self.walk(schema[&#39;strict_schema&#39;], f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        schema[&#39;json_schema&#39;] = self.walk(schema[&#39;json_schema&#39;], f)</span>
<span class="gi">+        schema[&#39;python_schema&#39;] = self.walk(schema[&#39;python_schema&#39;], f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_model_fields_schema(self, schema: core_schema.ModelFieldsSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        extras_schema = schema.get(&#39;extras_schema&#39;)</span>
<span class="gi">+        if extras_schema is not None:</span>
<span class="gi">+            schema[&#39;extras_schema&#39;] = self.walk(extras_schema, f)</span>
<span class="gi">+        replaced_fields: dict[str, core_schema.ModelField] = {}</span>
<span class="gi">+        replaced_computed_fields: list[core_schema.ComputedField] = []</span>
<span class="gi">+        for computed_field in schema.get(&#39;computed_fields&#39;, ()):</span>
<span class="gi">+            replaced_field = computed_field.copy()</span>
<span class="gi">+            replaced_field[&#39;return_schema&#39;] = self.walk(computed_field[&#39;return_schema&#39;], f)</span>
<span class="gi">+            replaced_computed_fields.append(replaced_field)</span>
<span class="gi">+        if replaced_computed_fields:</span>
<span class="gi">+            schema[&#39;computed_fields&#39;] = replaced_computed_fields</span>
<span class="gi">+        for k, v in schema[&#39;fields&#39;].items():</span>
<span class="gi">+            replaced_field = v.copy()</span>
<span class="gi">+            replaced_field[&#39;schema&#39;] = self.walk(v[&#39;schema&#39;], f)</span>
<span class="gi">+            replaced_fields[k] = replaced_field</span>
<span class="gi">+        schema[&#39;fields&#39;] = replaced_fields</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_typed_dict_schema(self, schema: core_schema.TypedDictSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        extras_schema = schema.get(&#39;extras_schema&#39;)</span>
<span class="gi">+        if extras_schema is not None:</span>
<span class="gi">+            schema[&#39;extras_schema&#39;] = self.walk(extras_schema, f)</span>
<span class="gi">+        replaced_computed_fields: list[core_schema.ComputedField] = []</span>
<span class="gi">+        for computed_field in schema.get(&#39;computed_fields&#39;, ()):</span>
<span class="gi">+            replaced_field = computed_field.copy()</span>
<span class="gi">+            replaced_field[&#39;return_schema&#39;] = self.walk(computed_field[&#39;return_schema&#39;], f)</span>
<span class="gi">+            replaced_computed_fields.append(replaced_field)</span>
<span class="gi">+        if replaced_computed_fields:</span>
<span class="gi">+            schema[&#39;computed_fields&#39;] = replaced_computed_fields</span>
<span class="gi">+        replaced_fields: dict[str, core_schema.TypedDictField] = {}</span>
<span class="gi">+        for k, v in schema[&#39;fields&#39;].items():</span>
<span class="gi">+            replaced_field = v.copy()</span>
<span class="gi">+            replaced_field[&#39;schema&#39;] = self.walk(v[&#39;schema&#39;], f)</span>
<span class="gi">+            replaced_fields[k] = replaced_field</span>
<span class="gi">+        schema[&#39;fields&#39;] = replaced_fields</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        replaced_fields: list[core_schema.DataclassField] = []</span>
<span class="gi">+        replaced_computed_fields: list[core_schema.ComputedField] = []</span>
<span class="gi">+        for computed_field in schema.get(&#39;computed_fields&#39;, ()):</span>
<span class="gi">+            replaced_field = computed_field.copy()</span>
<span class="gi">+            replaced_field[&#39;return_schema&#39;] = self.walk(computed_field[&#39;return_schema&#39;], f)</span>
<span class="gi">+            replaced_computed_fields.append(replaced_field)</span>
<span class="gi">+        if replaced_computed_fields:</span>
<span class="gi">+            schema[&#39;computed_fields&#39;] = replaced_computed_fields</span>
<span class="gi">+        for field in schema[&#39;fields&#39;]:</span>
<span class="gi">+            replaced_field = field.copy()</span>
<span class="gi">+            replaced_field[&#39;schema&#39;] = self.walk(field[&#39;schema&#39;], f)</span>
<span class="gi">+            replaced_fields.append(replaced_field)</span>
<span class="gi">+        schema[&#39;fields&#39;] = replaced_fields</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_arguments_schema(self, schema: core_schema.ArgumentsSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        replaced_arguments_schema: list[core_schema.ArgumentsParameter] = []</span>
<span class="gi">+        for param in schema[&#39;arguments_schema&#39;]:</span>
<span class="gi">+            replaced_param = param.copy()</span>
<span class="gi">+            replaced_param[&#39;schema&#39;] = self.walk(param[&#39;schema&#39;], f)</span>
<span class="gi">+            replaced_arguments_schema.append(replaced_param)</span>
<span class="gi">+        schema[&#39;arguments_schema&#39;] = replaced_arguments_schema</span>
<span class="gi">+        if &#39;var_args_schema&#39; in schema:</span>
<span class="gi">+            schema[&#39;var_args_schema&#39;] = self.walk(schema[&#39;var_args_schema&#39;], f)</span>
<span class="gi">+        if &#39;var_kwargs_schema&#39; in schema:</span>
<span class="gi">+            schema[&#39;var_kwargs_schema&#39;] = self.walk(schema[&#39;var_kwargs_schema&#39;], f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_call_schema(self, schema: core_schema.CallSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        schema[&#39;arguments_schema&#39;] = self.walk(schema[&#39;arguments_schema&#39;], f)</span>
<span class="gi">+        if &#39;return_schema&#39; in schema:</span>
<span class="gi">+            schema[&#39;return_schema&#39;] = self.walk(schema[&#39;return_schema&#39;], f)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>

<span class="w"> </span>_dispatch = _WalkCoreSchema().walk


<span class="gd">-def walk_core_schema(schema: core_schema.CoreSchema, f: Walk</span>
<span class="gd">-    ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+def walk_core_schema(schema: core_schema.CoreSchema, f: Walk) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursively traverse a CoreSchema.

<span class="w"> </span>    Args:
<span class="gu">@@ -77,11 +411,142 @@ def walk_core_schema(schema: core_schema.CoreSchema, f: Walk</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        core_schema.CoreSchema: A processed CoreSchema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return f(schema.copy(), _dispatch)</span>
<span class="gi">+</span>

<span class="gi">+def simplify_schema_references(schema: core_schema.CoreSchema) -&gt; core_schema.CoreSchema:  # noqa: C901</span>
<span class="gi">+    definitions: dict[str, core_schema.CoreSchema] = {}</span>
<span class="gi">+    ref_counts: dict[str, int] = defaultdict(int)</span>
<span class="gi">+    involved_in_recursion: dict[str, bool] = {}</span>
<span class="gi">+    current_recursion_ref_count: dict[str, int] = defaultdict(int)</span>

<span class="gd">-def pretty_print_core_schema(schema: CoreSchema, include_metadata: bool=False</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+    def collect_refs(s: core_schema.CoreSchema, recurse: Recurse) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        if s[&#39;type&#39;] == &#39;definitions&#39;:</span>
<span class="gi">+            for definition in s[&#39;definitions&#39;]:</span>
<span class="gi">+                ref = get_ref(definition)</span>
<span class="gi">+                assert ref is not None</span>
<span class="gi">+                if ref not in definitions:</span>
<span class="gi">+                    definitions[ref] = definition</span>
<span class="gi">+                recurse(definition, collect_refs)</span>
<span class="gi">+            return recurse(s[&#39;schema&#39;], collect_refs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ref = get_ref(s)</span>
<span class="gi">+            if ref is not None:</span>
<span class="gi">+                new = recurse(s, collect_refs)</span>
<span class="gi">+                new_ref = get_ref(new)</span>
<span class="gi">+                if new_ref:</span>
<span class="gi">+                    definitions[new_ref] = new</span>
<span class="gi">+                return core_schema.definition_reference_schema(schema_ref=ref)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return recurse(s, collect_refs)</span>
<span class="gi">+</span>
<span class="gi">+    schema = walk_core_schema(schema, collect_refs)</span>
<span class="gi">+</span>
<span class="gi">+    def count_refs(s: core_schema.CoreSchema, recurse: Recurse) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        if s[&#39;type&#39;] != &#39;definition-ref&#39;:</span>
<span class="gi">+            return recurse(s, count_refs)</span>
<span class="gi">+        ref = s[&#39;schema_ref&#39;]</span>
<span class="gi">+        ref_counts[ref] += 1</span>
<span class="gi">+</span>
<span class="gi">+        if ref_counts[ref] &gt;= 2:</span>
<span class="gi">+            # If this model is involved in a recursion this should be detected</span>
<span class="gi">+            # on its second encounter, we can safely stop the walk here.</span>
<span class="gi">+            if current_recursion_ref_count[ref] != 0:</span>
<span class="gi">+                involved_in_recursion[ref] = True</span>
<span class="gi">+            return s</span>
<span class="gi">+</span>
<span class="gi">+        current_recursion_ref_count[ref] += 1</span>
<span class="gi">+        recurse(definitions[ref], count_refs)</span>
<span class="gi">+        current_recursion_ref_count[ref] -= 1</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    schema = walk_core_schema(schema, count_refs)</span>
<span class="gi">+</span>
<span class="gi">+    assert all(c == 0 for c in current_recursion_ref_count.values()), &#39;this is a bug! please report it&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def can_be_inlined(s: core_schema.DefinitionReferenceSchema, ref: str) -&gt; bool:</span>
<span class="gi">+        if ref_counts[ref] &gt; 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if involved_in_recursion.get(ref, False):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if &#39;serialization&#39; in s:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if &#39;metadata&#39; in s:</span>
<span class="gi">+            metadata = s[&#39;metadata&#39;]</span>
<span class="gi">+            for k in (</span>
<span class="gi">+                &#39;pydantic_js_functions&#39;,</span>
<span class="gi">+                &#39;pydantic_js_annotation_functions&#39;,</span>
<span class="gi">+                &#39;pydantic.internal.union_discriminator&#39;,</span>
<span class="gi">+            ):</span>
<span class="gi">+                if k in metadata:</span>
<span class="gi">+                    # we need to keep this as a ref</span>
<span class="gi">+                    return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def inline_refs(s: core_schema.CoreSchema, recurse: Recurse) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        if s[&#39;type&#39;] == &#39;definition-ref&#39;:</span>
<span class="gi">+            ref = s[&#39;schema_ref&#39;]</span>
<span class="gi">+            # Check if the reference is only used once, not involved in recursion and does not have</span>
<span class="gi">+            # any extra keys (like &#39;serialization&#39;)</span>
<span class="gi">+            if can_be_inlined(s, ref):</span>
<span class="gi">+                # Inline the reference by replacing the reference with the actual schema</span>
<span class="gi">+                new = definitions.pop(ref)</span>
<span class="gi">+                ref_counts[ref] -= 1  # because we just replaced it!</span>
<span class="gi">+                # put all other keys that were on the def-ref schema into the inlined version</span>
<span class="gi">+                # in particular this is needed for `serialization`</span>
<span class="gi">+                if &#39;serialization&#39; in s:</span>
<span class="gi">+                    new[&#39;serialization&#39;] = s[&#39;serialization&#39;]</span>
<span class="gi">+                s = recurse(new, inline_refs)</span>
<span class="gi">+                return s</span>
<span class="gi">+            else:</span>
<span class="gi">+                return recurse(s, inline_refs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return recurse(s, inline_refs)</span>
<span class="gi">+</span>
<span class="gi">+    schema = walk_core_schema(schema, inline_refs)</span>
<span class="gi">+</span>
<span class="gi">+    def_values = [v for v in definitions.values() if ref_counts[v[&#39;ref&#39;]] &gt; 0]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    if def_values:</span>
<span class="gi">+        schema = core_schema.definitions_schema(schema=schema, definitions=def_values)</span>
<span class="gi">+    return schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _strip_metadata(schema: CoreSchema) -&gt; CoreSchema:</span>
<span class="gi">+    def strip_metadata(s: CoreSchema, recurse: Recurse) -&gt; CoreSchema:</span>
<span class="gi">+        s = s.copy()</span>
<span class="gi">+        s.pop(&#39;metadata&#39;, None)</span>
<span class="gi">+        if s[&#39;type&#39;] == &#39;model-fields&#39;:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            s[&#39;fields&#39;] = {k: v.copy() for k, v in s[&#39;fields&#39;].items()}</span>
<span class="gi">+            for field_name, field_schema in s[&#39;fields&#39;].items():</span>
<span class="gi">+                field_schema.pop(&#39;metadata&#39;, None)</span>
<span class="gi">+                s[&#39;fields&#39;][field_name] = field_schema</span>
<span class="gi">+            computed_fields = s.get(&#39;computed_fields&#39;, None)</span>
<span class="gi">+            if computed_fields:</span>
<span class="gi">+                s[&#39;computed_fields&#39;] = [cf.copy() for cf in computed_fields]</span>
<span class="gi">+                for cf in computed_fields:</span>
<span class="gi">+                    cf.pop(&#39;metadata&#39;, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                s.pop(&#39;computed_fields&#39;, None)</span>
<span class="gi">+        elif s[&#39;type&#39;] == &#39;model&#39;:</span>
<span class="gi">+            # remove some defaults</span>
<span class="gi">+            if s.get(&#39;custom_init&#39;, True) is False:</span>
<span class="gi">+                s.pop(&#39;custom_init&#39;)</span>
<span class="gi">+            if s.get(&#39;root_model&#39;, True) is False:</span>
<span class="gi">+                s.pop(&#39;root_model&#39;)</span>
<span class="gi">+            if {&#39;title&#39;}.issuperset(s.get(&#39;config&#39;, {}).keys()):</span>
<span class="gi">+                s.pop(&#39;config&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+        return recurse(s, strip_metadata)</span>
<span class="gi">+</span>
<span class="gi">+    return walk_core_schema(schema, strip_metadata)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pretty_print_core_schema(</span>
<span class="gi">+    schema: CoreSchema,</span>
<span class="gi">+    include_metadata: bool = False,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pretty print a CoreSchema using rich.
<span class="w"> </span>    This is intended for debugging purposes.

<span class="gu">@@ -89,4 +554,15 @@ def pretty_print_core_schema(schema: CoreSchema, include_metadata: bool=False</span>
<span class="w"> </span>        schema: The CoreSchema to print.
<span class="w"> </span>        include_metadata: Whether to include metadata in the output. Defaults to `False`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from rich import print  # type: ignore  # install it manually in your dev env</span>
<span class="gi">+</span>
<span class="gi">+    if not include_metadata:</span>
<span class="gi">+        schema = _strip_metadata(schema)</span>
<span class="gi">+</span>
<span class="gi">+    return print(schema)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_core_schema(schema: CoreSchema) -&gt; CoreSchema:</span>
<span class="gi">+    if &#39;PYDANTIC_SKIP_VALIDATING_CORE_SCHEMAS&#39; in os.environ:</span>
<span class="gi">+        return schema</span>
<span class="gi">+    return _validate_core_schema(schema)</span>
<span class="gh">diff --git a/pydantic/_internal/_dataclasses.py b/pydantic/_internal/_dataclasses.py</span>
<span class="gh">index 35f40c504..73272922a 100644</span>
<span class="gd">--- a/pydantic/_internal/_dataclasses.py</span>
<span class="gi">+++ b/pydantic/_internal/_dataclasses.py</span>
<span class="gu">@@ -1,12 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Private logic for creating pydantic dataclasses.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import typing
<span class="w"> </span>import warnings
<span class="w"> </span>from functools import partial, wraps
<span class="w"> </span>from typing import Any, Callable, ClassVar
<span class="gd">-from pydantic_core import ArgsKwargs, SchemaSerializer, SchemaValidator, core_schema</span>
<span class="gi">+</span>
<span class="gi">+from pydantic_core import (</span>
<span class="gi">+    ArgsKwargs,</span>
<span class="gi">+    SchemaSerializer,</span>
<span class="gi">+    SchemaValidator,</span>
<span class="gi">+    core_schema,</span>
<span class="gi">+)</span>
<span class="w"> </span>from typing_extensions import TypeGuard
<span class="gi">+</span>
<span class="w"> </span>from ..errors import PydanticUndefinedAnnotation
<span class="w"> </span>from ..fields import FieldInfo
<span class="w"> </span>from ..plugin._schema_validator import PluggableSchemaValidator, create_schema_validator
<span class="gu">@@ -18,19 +27,18 @@ from ._generics import get_standard_typevars_map</span>
<span class="w"> </span>from ._mock_val_ser import set_dataclass_mocks
<span class="w"> </span>from ._schema_generation_shared import CallbackGetCoreSchemaHandler
<span class="w"> </span>from ._signature import generate_pydantic_signature
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from ..config import ConfigDict

<span class="gd">-</span>
<span class="w"> </span>    class StandardDataclass(typing.Protocol):
<span class="w"> </span>        __dataclass_fields__: ClassVar[dict[str, Any]]
<span class="gd">-        __dataclass_params__: ClassVar[Any]</span>
<span class="gi">+        __dataclass_params__: ClassVar[Any]  # in reality `dataclasses._DataclassParams`</span>
<span class="w"> </span>        __post_init__: ClassVar[Callable[..., None]]

<span class="gd">-        def __init__(self, *args: object, **kwargs: object) -&gt;None:</span>
<span class="gi">+        def __init__(self, *args: object, **kwargs: object) -&gt; None:</span>
<span class="w"> </span>            pass

<span class="gd">-</span>
<span class="w"> </span>    class PydanticDataclass(StandardDataclass, typing.Protocol):
<span class="w"> </span>        &quot;&quot;&quot;A protocol containing attributes only available once a class has been decorated as a Pydantic dataclass.

<span class="gu">@@ -43,21 +51,26 @@ if typing.TYPE_CHECKING:</span>
<span class="w"> </span>            __pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the dataclass.
<span class="w"> </span>            __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the dataclass.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        __pydantic_config__: ClassVar[ConfigDict]
<span class="w"> </span>        __pydantic_complete__: ClassVar[bool]
<span class="w"> </span>        __pydantic_core_schema__: ClassVar[core_schema.CoreSchema]
<span class="w"> </span>        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]
<span class="w"> </span>        __pydantic_fields__: ClassVar[dict[str, FieldInfo]]
<span class="w"> </span>        __pydantic_serializer__: ClassVar[SchemaSerializer]
<span class="gd">-        __pydantic_validator__: ClassVar[SchemaValidator |</span>
<span class="gd">-            PluggableSchemaValidator]</span>
<span class="gi">+        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20


<span class="gd">-def set_dataclass_fields(cls: type[StandardDataclass], types_namespace: (</span>
<span class="gd">-    dict[str, Any] | None)=None, config_wrapper: (_config.ConfigWrapper |</span>
<span class="gd">-    None)=None) -&gt;None:</span>
<span class="gi">+def set_dataclass_fields(</span>
<span class="gi">+    cls: type[StandardDataclass],</span>
<span class="gi">+    types_namespace: dict[str, Any] | None = None,</span>
<span class="gi">+    config_wrapper: _config.ConfigWrapper | None = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Collect and set `cls.__pydantic_fields__`.

<span class="w"> </span>    Args:
<span class="gu">@@ -65,12 +78,19 @@ def set_dataclass_fields(cls: type[StandardDataclass], types_namespace: (</span>
<span class="w"> </span>        types_namespace: The types namespace, defaults to `None`.
<span class="w"> </span>        config_wrapper: The config wrapper instance, defaults to `None`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    typevars_map = get_standard_typevars_map(cls)</span>
<span class="gi">+    fields = collect_dataclass_fields(cls, types_namespace, typevars_map=typevars_map, config_wrapper=config_wrapper)</span>

<span class="gi">+    cls.__pydantic_fields__ = fields  # type: ignore</span>

<span class="gd">-def complete_dataclass(cls: type[Any], config_wrapper: _config.</span>
<span class="gd">-    ConfigWrapper, *, raise_errors: bool=True, types_namespace: (dict[str,</span>
<span class="gd">-    Any] | None)) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def complete_dataclass(</span>
<span class="gi">+    cls: type[Any],</span>
<span class="gi">+    config_wrapper: _config.ConfigWrapper,</span>
<span class="gi">+    *,</span>
<span class="gi">+    raise_errors: bool = True,</span>
<span class="gi">+    types_namespace: dict[str, Any] | None,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Finish building a pydantic dataclass.

<span class="w"> </span>    This logic is called on a class which has already been wrapped in `dataclasses.dataclass()`.
<span class="gu">@@ -89,10 +109,92 @@ def complete_dataclass(cls: type[Any], config_wrapper: _config.</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_builtin_dataclass(_cls: type[Any]) -&gt;TypeGuard[type[StandardDataclass]]:</span>
<span class="gi">+    if hasattr(cls, &#39;__post_init_post_parse__&#39;):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;Support for `__post_init_post_parse__` has been dropped, the method will not be called&#39;, DeprecationWarning</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if types_namespace is None:</span>
<span class="gi">+        types_namespace = _typing_extra.get_cls_types_namespace(cls)</span>
<span class="gi">+</span>
<span class="gi">+    set_dataclass_fields(cls, types_namespace, config_wrapper=config_wrapper)</span>
<span class="gi">+</span>
<span class="gi">+    typevars_map = get_standard_typevars_map(cls)</span>
<span class="gi">+    gen_schema = GenerateSchema(</span>
<span class="gi">+        config_wrapper,</span>
<span class="gi">+        types_namespace,</span>
<span class="gi">+        typevars_map,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # This needs to be called before we change the __init__</span>
<span class="gi">+    sig = generate_pydantic_signature(</span>
<span class="gi">+        init=cls.__init__,</span>
<span class="gi">+        fields=cls.__pydantic_fields__,  # type: ignore</span>
<span class="gi">+        config_wrapper=config_wrapper,</span>
<span class="gi">+        is_dataclass=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # dataclass.__init__ must be defined here so its `__qualname__` can be changed since functions can&#39;t be copied.</span>
<span class="gi">+    def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        __tracebackhide__ = True</span>
<span class="gi">+        s = __dataclass_self__</span>
<span class="gi">+        s.__pydantic_validator__.validate_python(ArgsKwargs(args, kwargs), self_instance=s)</span>
<span class="gi">+</span>
<span class="gi">+    __init__.__qualname__ = f&#39;{cls.__qualname__}.__init__&#39;</span>
<span class="gi">+</span>
<span class="gi">+    cls.__init__ = __init__  # type: ignore</span>
<span class="gi">+    cls.__pydantic_config__ = config_wrapper.config_dict  # type: ignore</span>
<span class="gi">+    cls.__signature__ = sig  # type: ignore</span>
<span class="gi">+    get_core_schema = getattr(cls, &#39;__get_pydantic_core_schema__&#39;, None)</span>
<span class="gi">+    try:</span>
<span class="gi">+        if get_core_schema:</span>
<span class="gi">+            schema = get_core_schema(</span>
<span class="gi">+                cls,</span>
<span class="gi">+                CallbackGetCoreSchemaHandler(</span>
<span class="gi">+                    partial(gen_schema.generate_schema, from_dunder_get_core_schema=False),</span>
<span class="gi">+                    gen_schema,</span>
<span class="gi">+                    ref_mode=&#39;unpack&#39;,</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            schema = gen_schema.generate_schema(cls, from_dunder_get_core_schema=False)</span>
<span class="gi">+    except PydanticUndefinedAnnotation as e:</span>
<span class="gi">+        if raise_errors:</span>
<span class="gi">+            raise</span>
<span class="gi">+        set_dataclass_mocks(cls, cls.__name__, f&#39;`{e.name}`&#39;)</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    core_config = config_wrapper.core_config(cls)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        schema = gen_schema.clean_schema(schema)</span>
<span class="gi">+    except gen_schema.CollectedInvalid:</span>
<span class="gi">+        set_dataclass_mocks(cls, cls.__name__, &#39;all referenced types&#39;)</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # We are about to set all the remaining required properties expected for this cast;</span>
<span class="gi">+    # __pydantic_decorators__ and __pydantic_fields__ should already be set</span>
<span class="gi">+    cls = typing.cast(&#39;type[PydanticDataclass]&#39;, cls)</span>
<span class="gi">+    # debug(schema)</span>
<span class="gi">+</span>
<span class="gi">+    cls.__pydantic_core_schema__ = schema</span>
<span class="gi">+    cls.__pydantic_validator__ = validator = create_schema_validator(</span>
<span class="gi">+        schema, cls, cls.__module__, cls.__qualname__, &#39;dataclass&#39;, core_config, config_wrapper.plugin_settings</span>
<span class="gi">+    )</span>
<span class="gi">+    cls.__pydantic_serializer__ = SchemaSerializer(schema, core_config)</span>
<span class="gi">+</span>
<span class="gi">+    if config_wrapper.validate_assignment:</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(cls.__setattr__)</span>
<span class="gi">+        def validated_setattr(instance: Any, field: str, value: str, /) -&gt; None:</span>
<span class="gi">+            validator.validate_assignment(instance, field, value)</span>
<span class="gi">+</span>
<span class="gi">+        cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_builtin_dataclass(_cls: type[Any]) -&gt; TypeGuard[type[StandardDataclass]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns True if a class is a stdlib dataclass and *not* a pydantic dataclass.

<span class="w"> </span>    We check that
<span class="gu">@@ -122,4 +224,8 @@ def is_builtin_dataclass(_cls: type[Any]) -&gt;TypeGuard[type[StandardDataclass]]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `True` if the class is a stdlib dataclass, `False` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        dataclasses.is_dataclass(_cls)</span>
<span class="gi">+        and not hasattr(_cls, &#39;__pydantic_validator__&#39;)</span>
<span class="gi">+        and set(_cls.__dataclass_fields__).issuperset(set(getattr(_cls, &#39;__annotations__&#39;, {})))</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pydantic/_internal/_decorators.py b/pydantic/_internal/_decorators.py</span>
<span class="gh">index cc38227b5..66db2184a 100644</span>
<span class="gd">--- a/pydantic/_internal/_decorators.py</span>
<span class="gi">+++ b/pydantic/_internal/_decorators.py</span>
<span class="gu">@@ -1,17 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Logic related to validators applied to models etc. via the `@field_validator` and `@model_validator` decorators.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import deque
<span class="w"> </span>from dataclasses import dataclass, field
<span class="w"> </span>from functools import cached_property, partial, partialmethod
<span class="w"> </span>from inspect import Parameter, Signature, isdatadescriptor, ismethoddescriptor, signature
<span class="w"> </span>from itertools import islice
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, ClassVar, Generic, Iterable, TypeVar, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import PydanticUndefined, core_schema
<span class="w"> </span>from typing_extensions import Literal, TypeAlias, is_typeddict
<span class="gi">+</span>
<span class="w"> </span>from ..errors import PydanticUserError
<span class="w"> </span>from ._core_utils import get_type_ref
<span class="w"> </span>from ._internal_dataclass import slots_true
<span class="w"> </span>from ._typing_extra import get_function_type_hints
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ..fields import ComputedFieldInfo
<span class="w"> </span>    from ..functional_validators import FieldValidatorModes
<span class="gu">@@ -31,7 +36,9 @@ class ValidatorDecoratorInfo:</span>
<span class="w"> </span>        always: Whether this method and other validators should be called even if the value is missing.
<span class="w"> </span>        check_fields: Whether to check that the fields actually exist on the model.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    decorator_repr: ClassVar[str] = &#39;@validator&#39;
<span class="gi">+</span>
<span class="w"> </span>    fields: tuple[str, ...]
<span class="w"> </span>    mode: Literal[&#39;before&#39;, &#39;after&#39;]
<span class="w"> </span>    each_item: bool
<span class="gu">@@ -50,7 +57,9 @@ class FieldValidatorDecoratorInfo:</span>
<span class="w"> </span>        mode: The proposed validator mode.
<span class="w"> </span>        check_fields: Whether to check that the fields actually exist on the model.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    decorator_repr: ClassVar[str] = &#39;@field_validator&#39;
<span class="gi">+</span>
<span class="w"> </span>    fields: tuple[str, ...]
<span class="w"> </span>    mode: FieldValidatorModes
<span class="w"> </span>    check_fields: bool | None
<span class="gu">@@ -65,6 +74,7 @@ class RootValidatorDecoratorInfo:</span>
<span class="w"> </span>        decorator_repr: A class variable representing the decorator string, &#39;@root_validator&#39;.
<span class="w"> </span>        mode: The proposed validator mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    decorator_repr: ClassVar[str] = &#39;@root_validator&#39;
<span class="w"> </span>    mode: Literal[&#39;before&#39;, &#39;after&#39;]

<span class="gu">@@ -83,6 +93,7 @@ class FieldSerializerDecoratorInfo:</span>
<span class="w"> </span>            and `&#39;json-unless-none&#39;`.
<span class="w"> </span>        check_fields: Whether to check that the fields actually exist on the model.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    decorator_repr: ClassVar[str] = &#39;@field_serializer&#39;
<span class="w"> </span>    fields: tuple[str, ...]
<span class="w"> </span>    mode: Literal[&#39;plain&#39;, &#39;wrap&#39;]
<span class="gu">@@ -103,6 +114,7 @@ class ModelSerializerDecoratorInfo:</span>
<span class="w"> </span>        when_used: The serialization condition. Accepts a string with values `&#39;always&#39;`, `&#39;unless-none&#39;`, `&#39;json&#39;`,
<span class="w"> </span>            and `&#39;json-unless-none&#39;`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    decorator_repr: ClassVar[str] = &#39;@model_serializer&#39;
<span class="w"> </span>    mode: Literal[&#39;plain&#39;, &#39;wrap&#39;]
<span class="w"> </span>    return_type: Any
<span class="gu">@@ -118,6 +130,7 @@ class ModelValidatorDecoratorInfo:</span>
<span class="w"> </span>        decorator_repr: A class variable representing the decorator string, &#39;@model_serializer&#39;.
<span class="w"> </span>        mode: The proposed serializer mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    decorator_repr: ClassVar[str] = &#39;@model_validator&#39;
<span class="w"> </span>    mode: Literal[&#39;wrap&#39;, &#39;before&#39;, &#39;after&#39;]

<span class="gu">@@ -131,13 +144,14 @@ DecoratorInfo: TypeAlias = &quot;&quot;&quot;Union[</span>
<span class="w"> </span>    ModelValidatorDecoratorInfo,
<span class="w"> </span>    ComputedFieldInfo,
<span class="w"> </span>]&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>ReturnType = TypeVar(&#39;ReturnType&#39;)
<span class="w"> </span>DecoratedType: TypeAlias = (
<span class="w"> </span>    &#39;Union[classmethod[Any, Any, ReturnType], staticmethod[Any, ReturnType], Callable[..., ReturnType], property]&#39;
<span class="gd">-    )</span>
<span class="gi">+)</span>


<span class="gd">-@dataclass</span>
<span class="gi">+@dataclass  # can&#39;t use slots here since we set attributes on `__post_init__`</span>
<span class="w"> </span>class PydanticDescriptorProxy(Generic[ReturnType]):
<span class="w"> </span>    &quot;&quot;&quot;Wrap a classmethod, staticmethod, property or unbound function
<span class="w"> </span>    and act as a descriptor that allows us to detect decorated items
<span class="gu">@@ -151,28 +165,33 @@ class PydanticDescriptorProxy(Generic[ReturnType]):</span>
<span class="w"> </span>        decorator_info: The decorator info.
<span class="w"> </span>        shim: A wrapper function to wrap V1 style function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    wrapped: DecoratedType[ReturnType]
<span class="w"> </span>    decorator_info: DecoratorInfo
<span class="w"> </span>    shim: Callable[[Callable[..., Any]], Callable[..., Any]] | None = None

<span class="w"> </span>    def __post_init__(self):
<span class="gd">-        for attr in (&#39;setter&#39;, &#39;deleter&#39;):</span>
<span class="gi">+        for attr in &#39;setter&#39;, &#39;deleter&#39;:</span>
<span class="w"> </span>            if hasattr(self.wrapped, attr):
<span class="w"> </span>                f = partial(self._call_wrapped_attr, name=attr)
<span class="w"> </span>                setattr(self, attr, f)

<span class="gd">-    def __get__(self, obj: (object | None), obj_type: (type[object] | None)</span>
<span class="gd">-        =None) -&gt;PydanticDescriptorProxy[ReturnType]:</span>
<span class="gi">+    def _call_wrapped_attr(self, func: Callable[[Any], None], *, name: str) -&gt; PydanticDescriptorProxy[ReturnType]:</span>
<span class="gi">+        self.wrapped = getattr(self.wrapped, name)(func)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def __get__(self, obj: object | None, obj_type: type[object] | None = None) -&gt; PydanticDescriptorProxy[ReturnType]:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return self.wrapped.__get__(obj, obj_type)
<span class="w"> </span>        except AttributeError:
<span class="gd">-            return self.wrapped</span>
<span class="gi">+            # not a descriptor, e.g. a partial object</span>
<span class="gi">+            return self.wrapped  # type: ignore[return-value]</span>

<span class="gd">-    def __set_name__(self, instance: Any, name: str) -&gt;None:</span>
<span class="gi">+    def __set_name__(self, instance: Any, name: str) -&gt; None:</span>
<span class="w"> </span>        if hasattr(self.wrapped, &#39;__set_name__&#39;):
<span class="gd">-            self.wrapped.__set_name__(instance, name)</span>
<span class="gi">+            self.wrapped.__set_name__(instance, name)  # pyright: ignore[reportFunctionMemberAccess]</span>

<span class="gd">-    def __getattr__(self, __name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, __name: str) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Forward checks for __isabstractmethod__ and such.&quot;&quot;&quot;
<span class="w"> </span>        return getattr(self.wrapped, __name)

<span class="gu">@@ -194,6 +213,7 @@ class Decorator(Generic[DecoratorInfoType]):</span>
<span class="w"> </span>        shim: A wrapper function to wrap V1 style function.
<span class="w"> </span>        info: The decorator info.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    cls_ref: str
<span class="w"> </span>    cls_var_name: str
<span class="w"> </span>    func: Callable[..., Any]
<span class="gu">@@ -201,8 +221,13 @@ class Decorator(Generic[DecoratorInfoType]):</span>
<span class="w"> </span>    info: DecoratorInfoType

<span class="w"> </span>    @staticmethod
<span class="gd">-    def build(cls_: Any, *, cls_var_name: str, shim: (Callable[[Any], Any] |</span>
<span class="gd">-        None), info: DecoratorInfoType) -&gt;Decorator[DecoratorInfoType]:</span>
<span class="gi">+    def build(</span>
<span class="gi">+        cls_: Any,</span>
<span class="gi">+        *,</span>
<span class="gi">+        cls_var_name: str,</span>
<span class="gi">+        shim: Callable[[Any], Any] | None,</span>
<span class="gi">+        info: DecoratorInfoType,</span>
<span class="gi">+    ) -&gt; Decorator[DecoratorInfoType]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build a new decorator.

<span class="w"> </span>        Args:
<span class="gu">@@ -214,9 +239,24 @@ class Decorator(Generic[DecoratorInfoType]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The new decorator instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def bind_to_cls(self, cls: Any) -&gt;Decorator[DecoratorInfoType]:</span>
<span class="gi">+        func = get_attribute_from_bases(cls_, cls_var_name)</span>
<span class="gi">+        if shim is not None:</span>
<span class="gi">+            func = shim(func)</span>
<span class="gi">+        func = unwrap_wrapped_function(func, unwrap_partial=False)</span>
<span class="gi">+        if not callable(func):</span>
<span class="gi">+            # This branch will get hit for classmethod properties</span>
<span class="gi">+            attribute = get_attribute_from_base_dicts(cls_, cls_var_name)  # prevents the binding call to `__get__`</span>
<span class="gi">+            if isinstance(attribute, PydanticDescriptorProxy):</span>
<span class="gi">+                func = unwrap_wrapped_function(attribute.wrapped)</span>
<span class="gi">+        return Decorator(</span>
<span class="gi">+            cls_ref=get_type_ref(cls_),</span>
<span class="gi">+            cls_var_name=cls_var_name,</span>
<span class="gi">+            func=func,</span>
<span class="gi">+            shim=shim,</span>
<span class="gi">+            info=info,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def bind_to_cls(self, cls: Any) -&gt; Decorator[DecoratorInfoType]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bind the decorator to a class.

<span class="w"> </span>        Args:
<span class="gu">@@ -225,10 +265,15 @@ class Decorator(Generic[DecoratorInfoType]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The new decorator instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.build(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            cls_var_name=self.cls_var_name,</span>
<span class="gi">+            shim=self.shim,</span>
<span class="gi">+            info=self.info,</span>
<span class="gi">+        )</span>


<span class="gd">-def get_bases(tp: type[Any]) -&gt;tuple[type[Any], ...]:</span>
<span class="gi">+def get_bases(tp: type[Any]) -&gt; tuple[type[Any], ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the base classes of a class or typeddict.

<span class="w"> </span>    Args:
<span class="gu">@@ -237,22 +282,64 @@ def get_bases(tp: type[Any]) -&gt;tuple[type[Any], ...]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The base classes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_typeddict(tp):</span>
<span class="gi">+        return tp.__orig_bases__  # type: ignore</span>
<span class="gi">+    try:</span>
<span class="gi">+        return tp.__bases__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return ()</span>


<span class="gd">-def mro(tp: type[Any]) -&gt;tuple[type[Any], ...]:</span>
<span class="gi">+def mro(tp: type[Any]) -&gt; tuple[type[Any], ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Calculate the Method Resolution Order of bases using the C3 algorithm.

<span class="w"> </span>    See https://www.python.org/download/releases/2.3/mro/
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # try to use the existing mro, for performance mainly</span>
<span class="gi">+    # but also because it helps verify the implementation below</span>
<span class="gi">+    if not is_typeddict(tp):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return tp.__mro__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # GenericAlias and some other cases</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    bases = get_bases(tp)</span>
<span class="gi">+    return (tp,) + mro_for_bases(bases)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def mro_for_bases(bases: tuple[type[Any], ...]) -&gt; tuple[type[Any], ...]:</span>
<span class="gi">+    def merge_seqs(seqs: list[deque[type[Any]]]) -&gt; Iterable[type[Any]]:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            non_empty = [seq for seq in seqs if seq]</span>
<span class="gi">+            if not non_empty:</span>
<span class="gi">+                # Nothing left to process, we&#39;re done.</span>
<span class="gi">+                return</span>
<span class="gi">+            candidate: type[Any] | None = None</span>
<span class="gi">+            for seq in non_empty:  # Find merge candidates among seq heads.</span>
<span class="gi">+                candidate = seq[0]</span>
<span class="gi">+                not_head = [s for s in non_empty if candidate in islice(s, 1, None)]</span>
<span class="gi">+                if not_head:</span>
<span class="gi">+                    # Reject the candidate.</span>
<span class="gi">+                    candidate = None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            if not candidate:</span>
<span class="gi">+                raise TypeError(&#39;Inconsistent hierarchy, no C3 MRO is possible&#39;)</span>
<span class="gi">+            yield candidate</span>
<span class="gi">+            for seq in non_empty:</span>
<span class="gi">+                # Remove candidate.</span>
<span class="gi">+                if seq[0] == candidate:</span>
<span class="gi">+                    seq.popleft()</span>
<span class="gi">+</span>
<span class="gi">+    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]</span>
<span class="gi">+    return tuple(merge_seqs(seqs))</span>


<span class="w"> </span>_sentinel = object()


<span class="gd">-def get_attribute_from_bases(tp: (type[Any] | tuple[type[Any], ...]), name: str</span>
<span class="gd">-    ) -&gt;Any:</span>
<span class="gi">+def get_attribute_from_bases(tp: type[Any] | tuple[type[Any], ...], name: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the attribute from the next class in the MRO that has it,
<span class="w"> </span>    aiming to simulate calling the method on the actual class.

<span class="gu">@@ -271,10 +358,23 @@ def get_attribute_from_bases(tp: (type[Any] | tuple[type[Any], ...]), name: str</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        AttributeError: If the attribute is not found in any class in the MRO.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(tp, tuple):</span>
<span class="gi">+        for base in mro_for_bases(tp):</span>
<span class="gi">+            attribute = base.__dict__.get(name, _sentinel)</span>
<span class="gi">+            if attribute is not _sentinel:</span>
<span class="gi">+                attribute_get = getattr(attribute, &#39;__get__&#39;, None)</span>
<span class="gi">+                if attribute_get is not None:</span>
<span class="gi">+                    return attribute_get(None, tp)</span>
<span class="gi">+                return attribute</span>
<span class="gi">+        raise AttributeError(f&#39;{name} not found in {tp}&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return getattr(tp, name)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return get_attribute_from_bases(mro(tp), name)</span>


<span class="gd">-def get_attribute_from_base_dicts(tp: type[Any], name: str) -&gt;Any:</span>
<span class="gi">+def get_attribute_from_base_dicts(tp: type[Any], name: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get an attribute out of the `__dict__` following the MRO.
<span class="w"> </span>    This prevents the call to `__get__` on the descriptor, and allows
<span class="w"> </span>    us to get the original function for classmethod properties.
<span class="gu">@@ -289,7 +389,10 @@ def get_attribute_from_base_dicts(tp: type[Any], name: str) -&gt;Any:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        KeyError: If the attribute is not found in any class&#39;s `__dict__` in the MRO.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for base in reversed(mro(tp)):</span>
<span class="gi">+        if name in base.__dict__:</span>
<span class="gi">+            return base.__dict__[name]</span>
<span class="gi">+    return tp.__dict__[name]  # raise the error</span>


<span class="w"> </span>@dataclass(**slots_true)
<span class="gu">@@ -299,23 +402,17 @@ class DecoratorInfos:</span>
<span class="w"> </span>    note that the name in the class namespace is the function or attribute name
<span class="w"> </span>    not the field name!
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    validators: dict[str, Decorator[ValidatorDecoratorInfo]] = field(</span>
<span class="gd">-        default_factory=dict)</span>
<span class="gd">-    field_validators: dict[str, Decorator[FieldValidatorDecoratorInfo]</span>
<span class="gd">-        ] = field(default_factory=dict)</span>
<span class="gd">-    root_validators: dict[str, Decorator[RootValidatorDecoratorInfo]] = field(</span>
<span class="gd">-        default_factory=dict)</span>
<span class="gd">-    field_serializers: dict[str, Decorator[FieldSerializerDecoratorInfo]</span>
<span class="gd">-        ] = field(default_factory=dict)</span>
<span class="gd">-    model_serializers: dict[str, Decorator[ModelSerializerDecoratorInfo]</span>
<span class="gd">-        ] = field(default_factory=dict)</span>
<span class="gd">-    model_validators: dict[str, Decorator[ModelValidatorDecoratorInfo]</span>
<span class="gd">-        ] = field(default_factory=dict)</span>
<span class="gd">-    computed_fields: dict[str, Decorator[ComputedFieldInfo]] = field(</span>
<span class="gd">-        default_factory=dict)</span>
<span class="gi">+</span>
<span class="gi">+    validators: dict[str, Decorator[ValidatorDecoratorInfo]] = field(default_factory=dict)</span>
<span class="gi">+    field_validators: dict[str, Decorator[FieldValidatorDecoratorInfo]] = field(default_factory=dict)</span>
<span class="gi">+    root_validators: dict[str, Decorator[RootValidatorDecoratorInfo]] = field(default_factory=dict)</span>
<span class="gi">+    field_serializers: dict[str, Decorator[FieldSerializerDecoratorInfo]] = field(default_factory=dict)</span>
<span class="gi">+    model_serializers: dict[str, Decorator[ModelSerializerDecoratorInfo]] = field(default_factory=dict)</span>
<span class="gi">+    model_validators: dict[str, Decorator[ModelValidatorDecoratorInfo]] = field(default_factory=dict)</span>
<span class="gi">+    computed_fields: dict[str, Decorator[ComputedFieldInfo]] = field(default_factory=dict)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def build(model_dc: type[Any]) -&gt;DecoratorInfos:</span>
<span class="gi">+    def build(model_dc: type[Any]) -&gt; DecoratorInfos:  # noqa: C901 (ignore complexity)</span>
<span class="w"> </span>        &quot;&quot;&quot;We want to collect all DecFunc instances that exist as
<span class="w"> </span>        attributes in the namespace of the class (a BaseModel or dataclass)
<span class="w"> </span>        that called us
<span class="gu">@@ -328,11 +425,83 @@ class DecoratorInfos:</span>
<span class="w"> </span>        If we do replace any functions we put the replacement into the position
<span class="w"> </span>        the replaced function was in; that is, we maintain the order.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+        # reminder: dicts are ordered and replacement does not alter the order</span>
<span class="gi">+        res = DecoratorInfos()</span>
<span class="gi">+        for base in reversed(mro(model_dc)[1:]):</span>
<span class="gi">+            existing: DecoratorInfos | None = base.__dict__.get(&#39;__pydantic_decorators__&#39;)</span>
<span class="gi">+            if existing is None:</span>
<span class="gi">+                existing = DecoratorInfos.build(base)</span>
<span class="gi">+            res.validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.validators.items()})</span>
<span class="gi">+            res.field_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.field_validators.items()})</span>
<span class="gi">+            res.root_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.root_validators.items()})</span>
<span class="gi">+            res.field_serializers.update({k: v.bind_to_cls(model_dc) for k, v in existing.field_serializers.items()})</span>
<span class="gi">+            res.model_serializers.update({k: v.bind_to_cls(model_dc) for k, v in existing.model_serializers.items()})</span>
<span class="gi">+            res.model_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.model_validators.items()})</span>
<span class="gi">+            res.computed_fields.update({k: v.bind_to_cls(model_dc) for k, v in existing.computed_fields.items()})</span>
<span class="gi">+</span>
<span class="gi">+        to_replace: list[tuple[str, Any]] = []</span>
<span class="gi">+</span>
<span class="gi">+        for var_name, var_value in vars(model_dc).items():</span>
<span class="gi">+            if isinstance(var_value, PydanticDescriptorProxy):</span>
<span class="gi">+                info = var_value.decorator_info</span>
<span class="gi">+                if isinstance(info, ValidatorDecoratorInfo):</span>
<span class="gi">+                    res.validators[var_name] = Decorator.build(</span>
<span class="gi">+                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif isinstance(info, FieldValidatorDecoratorInfo):</span>
<span class="gi">+                    res.field_validators[var_name] = Decorator.build(</span>
<span class="gi">+                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif isinstance(info, RootValidatorDecoratorInfo):</span>
<span class="gi">+                    res.root_validators[var_name] = Decorator.build(</span>
<span class="gi">+                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif isinstance(info, FieldSerializerDecoratorInfo):</span>
<span class="gi">+                    # check whether a serializer function is already registered for fields</span>
<span class="gi">+                    for field_serializer_decorator in res.field_serializers.values():</span>
<span class="gi">+                        # check that each field has at most one serializer function.</span>
<span class="gi">+                        # serializer functions for the same field in subclasses are allowed,</span>
<span class="gi">+                        # and are treated as overrides</span>
<span class="gi">+                        if field_serializer_decorator.cls_var_name == var_name:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        for f in info.fields:</span>
<span class="gi">+                            if f in field_serializer_decorator.info.fields:</span>
<span class="gi">+                                raise PydanticUserError(</span>
<span class="gi">+                                    &#39;Multiple field serializer functions were defined &#39;</span>
<span class="gi">+                                    f&#39;for field {f!r}, this is not allowed.&#39;,</span>
<span class="gi">+                                    code=&#39;multiple-field-serializers&#39;,</span>
<span class="gi">+                                )</span>
<span class="gi">+                    res.field_serializers[var_name] = Decorator.build(</span>
<span class="gi">+                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif isinstance(info, ModelValidatorDecoratorInfo):</span>
<span class="gi">+                    res.model_validators[var_name] = Decorator.build(</span>
<span class="gi">+                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif isinstance(info, ModelSerializerDecoratorInfo):</span>
<span class="gi">+                    res.model_serializers[var_name] = Decorator.build(</span>
<span class="gi">+                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    from ..fields import ComputedFieldInfo</span>
<span class="gi">+</span>
<span class="gi">+                    isinstance(var_value, ComputedFieldInfo)</span>
<span class="gi">+                    res.computed_fields[var_name] = Decorator.build(</span>
<span class="gi">+                        model_dc, cls_var_name=var_name, shim=None, info=info</span>
<span class="gi">+                    )</span>
<span class="gi">+                to_replace.append((var_name, var_value.wrapped))</span>
<span class="gi">+        if to_replace:</span>
<span class="gi">+            # If we can save `__pydantic_decorators__` on the class we&#39;ll be able to check for it above</span>
<span class="gi">+            # so then we don&#39;t need to re-process the type, which means we can discard our descriptor wrappers</span>
<span class="gi">+            # and replace them with the thing they are wrapping (see the other setattr call below)</span>
<span class="gi">+            # which allows validator class methods to also function as regular class methods</span>
<span class="gi">+            setattr(model_dc, &#39;__pydantic_decorators__&#39;, res)</span>
<span class="gi">+            for name, value in to_replace:</span>
<span class="gi">+                setattr(model_dc, name, value)</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Look at a field or model validator function and determine whether it takes an info argument.

<span class="w"> </span>    An error is raised if the function has an invalid signature.
<span class="gu">@@ -344,11 +513,34 @@ def inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Whether the validator takes an info argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        sig = signature(validator)</span>
<span class="gi">+    except (ValueError, TypeError):</span>
<span class="gi">+        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.</span>
<span class="gi">+        # In this case, we assume no info argument is present:</span>
<span class="gi">+        return False</span>
<span class="gi">+    n_positional = count_positional_required_params(sig)</span>
<span class="gi">+    if mode == &#39;wrap&#39;:</span>
<span class="gi">+        if n_positional == 3:</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif n_positional == 2:</span>
<span class="gi">+            return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert mode in {&#39;before&#39;, &#39;after&#39;, &#39;plain&#39;}, f&quot;invalid mode: {mode!r}, expected &#39;before&#39;, &#39;after&#39; or &#39;plain&quot;</span>
<span class="gi">+        if n_positional == 2:</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif n_positional == 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    raise PydanticUserError(</span>
<span class="gi">+        f&#39;Unrecognized field_validator function signature for {validator} with `mode={mode}`:{sig}&#39;,</span>
<span class="gi">+        code=&#39;validator-signature&#39;,</span>
<span class="gi">+    )</span>


<span class="gd">-def inspect_field_serializer(serializer: Callable[..., Any], mode: Literal[</span>
<span class="gd">-    &#39;plain&#39;, &#39;wrap&#39;], computed_field: bool=False) -&gt;tuple[bool, bool]:</span>
<span class="gi">+def inspect_field_serializer(</span>
<span class="gi">+    serializer: Callable[..., Any], mode: Literal[&#39;plain&#39;, &#39;wrap&#39;], computed_field: bool = False</span>
<span class="gi">+) -&gt; tuple[bool, bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Look at a field serializer function and determine if it is a field serializer,
<span class="w"> </span>    and whether it takes an info argument.

<span class="gu">@@ -363,11 +555,38 @@ def inspect_field_serializer(serializer: Callable[..., Any], mode: Literal[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Tuple of (is_field_serializer, info_arg).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def inspect_annotated_serializer(serializer: Callable[..., Any], mode:</span>
<span class="gd">-    Literal[&#39;plain&#39;, &#39;wrap&#39;]) -&gt;bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        sig = signature(serializer)</span>
<span class="gi">+    except (ValueError, TypeError):</span>
<span class="gi">+        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.</span>
<span class="gi">+        # In this case, we assume no info argument is present and this is not a method:</span>
<span class="gi">+        return (False, False)</span>
<span class="gi">+</span>
<span class="gi">+    first = next(iter(sig.parameters.values()), None)</span>
<span class="gi">+    is_field_serializer = first is not None and first.name == &#39;self&#39;</span>
<span class="gi">+</span>
<span class="gi">+    n_positional = count_positional_required_params(sig)</span>
<span class="gi">+    if is_field_serializer:</span>
<span class="gi">+        # -1 to correct for self parameter</span>
<span class="gi">+        info_arg = _serializer_info_arg(mode, n_positional - 1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        info_arg = _serializer_info_arg(mode, n_positional)</span>
<span class="gi">+</span>
<span class="gi">+    if info_arg is None:</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            f&#39;Unrecognized field_serializer function signature for {serializer} with `mode={mode}`:{sig}&#39;,</span>
<span class="gi">+            code=&#39;field-serializer-signature&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+    if info_arg and computed_field:</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            &#39;field_serializer on computed_field does not use info signature&#39;, code=&#39;field-serializer-signature&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        return is_field_serializer, info_arg</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inspect_annotated_serializer(serializer: Callable[..., Any], mode: Literal[&#39;plain&#39;, &#39;wrap&#39;]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Look at a serializer function used via `Annotated` and determine whether it takes an info argument.

<span class="w"> </span>    An error is raised if the function has an invalid signature.
<span class="gu">@@ -379,11 +598,23 @@ def inspect_annotated_serializer(serializer: Callable[..., Any], mode:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        info_arg
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def inspect_model_serializer(serializer: Callable[..., Any], mode: Literal[</span>
<span class="gd">-    &#39;plain&#39;, &#39;wrap&#39;]) -&gt;bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        sig = signature(serializer)</span>
<span class="gi">+    except (ValueError, TypeError):</span>
<span class="gi">+        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.</span>
<span class="gi">+        # In this case, we assume no info argument is present:</span>
<span class="gi">+        return False</span>
<span class="gi">+    info_arg = _serializer_info_arg(mode, count_positional_required_params(sig))</span>
<span class="gi">+    if info_arg is None:</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            f&#39;Unrecognized field_serializer function signature for {serializer} with `mode={mode}`:{sig}&#39;,</span>
<span class="gi">+            code=&#39;field-serializer-signature&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        return info_arg</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inspect_model_serializer(serializer: Callable[..., Any], mode: Literal[&#39;plain&#39;, &#39;wrap&#39;]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Look at a model serializer function and determine whether it takes an info argument.

<span class="w"> </span>    An error is raised if the function has an invalid signature.
<span class="gu">@@ -395,15 +626,48 @@ def inspect_model_serializer(serializer: Callable[..., Any], mode: Literal[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `info_arg` - whether the function expects an info argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(serializer, (staticmethod, classmethod)) or not is_instance_method_from_sig(serializer):</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            &#39;`@model_serializer` must be applied to instance methods&#39;, code=&#39;model-serializer-instance-method&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    sig = signature(serializer)</span>
<span class="gi">+    info_arg = _serializer_info_arg(mode, count_positional_required_params(sig))</span>
<span class="gi">+    if info_arg is None:</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            f&#39;Unrecognized model_serializer function signature for {serializer} with `mode={mode}`:{sig}&#39;,</span>
<span class="gi">+            code=&#39;model-serializer-signature&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        return info_arg</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _serializer_info_arg(mode: Literal[&#39;plain&#39;, &#39;wrap&#39;], n_positional: int) -&gt; bool | None:</span>
<span class="gi">+    if mode == &#39;plain&#39;:</span>
<span class="gi">+        if n_positional == 1:</span>
<span class="gi">+            # (input_value: Any, /) -&gt; Any</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif n_positional == 2:</span>
<span class="gi">+            # (model: Any, input_value: Any, /) -&gt; Any</span>
<span class="gi">+            return True</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert mode == &#39;wrap&#39;, f&quot;invalid mode: {mode!r}, expected &#39;plain&#39; or &#39;wrap&#39;&quot;</span>
<span class="gi">+        if n_positional == 2:</span>
<span class="gi">+            # (input_value: Any, serializer: SerializerFunctionWrapHandler, /) -&gt; Any</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif n_positional == 3:</span>
<span class="gi">+            # (input_value: Any, serializer: SerializerFunctionWrapHandler, info: SerializationInfo, /) -&gt; Any</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>


<span class="w"> </span>AnyDecoratorCallable: TypeAlias = (
<span class="w"> </span>    &#39;Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any], Callable[..., Any]]&#39;
<span class="gd">-    )</span>
<span class="gi">+)</span>


<span class="gd">-def is_instance_method_from_sig(function: AnyDecoratorCallable) -&gt;bool:</span>
<span class="gi">+def is_instance_method_from_sig(function: AnyDecoratorCallable) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Whether the function is an instance method.

<span class="w"> </span>    It will consider a function as instance method if the first parameter of
<span class="gu">@@ -415,11 +679,14 @@ def is_instance_method_from_sig(function: AnyDecoratorCallable) -&gt;bool:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `True` if the function is an instance method, `False` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = signature(unwrap_wrapped_function(function))</span>
<span class="gi">+    first = next(iter(sig.parameters.values()), None)</span>
<span class="gi">+    if first and first.name == &#39;self&#39;:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def ensure_classmethod_based_on_signature(function: AnyDecoratorCallable</span>
<span class="gd">-    ) -&gt;Any:</span>
<span class="gi">+def ensure_classmethod_based_on_signature(function: AnyDecoratorCallable) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Apply the `@classmethod` decorator on the function.

<span class="w"> </span>    Args:
<span class="gu">@@ -428,11 +695,27 @@ def ensure_classmethod_based_on_signature(function: AnyDecoratorCallable</span>
<span class="w"> </span>    Return:
<span class="w"> </span>        The `@classmethod` decorator applied function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def unwrap_wrapped_function(func: Any, *, unwrap_partial: bool=True,</span>
<span class="gd">-    unwrap_class_static_method: bool=True) -&gt;Any:</span>
<span class="gi">+    if not isinstance(</span>
<span class="gi">+        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod</span>
<span class="gi">+    ) and _is_classmethod_from_sig(function):</span>
<span class="gi">+        return classmethod(function)  # type: ignore[arg-type]</span>
<span class="gi">+    return function</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_classmethod_from_sig(function: AnyDecoratorCallable) -&gt; bool:</span>
<span class="gi">+    sig = signature(unwrap_wrapped_function(function))</span>
<span class="gi">+    first = next(iter(sig.parameters.values()), None)</span>
<span class="gi">+    if first and first.name == &#39;cls&#39;:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def unwrap_wrapped_function(</span>
<span class="gi">+    func: Any,</span>
<span class="gi">+    *,</span>
<span class="gi">+    unwrap_partial: bool = True,</span>
<span class="gi">+    unwrap_class_static_method: bool = True,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursively unwraps a wrapped function until the underlying function is reached.
<span class="w"> </span>    This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod.

<span class="gu">@@ -445,11 +728,31 @@ def unwrap_wrapped_function(func: Any, *, unwrap_partial: bool=True,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The underlying function of the wrapped function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Define the types we want to check against as a single tuple.</span>
<span class="gi">+    unwrap_types = (</span>
<span class="gi">+        (property, cached_property)</span>
<span class="gi">+        + ((partial, partialmethod) if unwrap_partial else ())</span>
<span class="gi">+        + ((staticmethod, classmethod) if unwrap_class_static_method else ())</span>
<span class="gi">+    )</span>

<span class="gi">+    while isinstance(func, unwrap_types):</span>
<span class="gi">+        if unwrap_class_static_method and isinstance(func, (classmethod, staticmethod)):</span>
<span class="gi">+            func = func.__func__</span>
<span class="gi">+        elif isinstance(func, (partial, partialmethod)):</span>
<span class="gi">+            func = func.func</span>
<span class="gi">+        elif isinstance(func, property):</span>
<span class="gi">+            func = func.fget  # arbitrary choice, convenient for computed fields</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Make coverage happy as it can only get here in the last possible case</span>
<span class="gi">+            assert isinstance(func, cached_property)</span>
<span class="gi">+            func = func.func  # type: ignore</span>

<span class="gd">-def get_function_return_type(func: Any, explicit_return_type: Any,</span>
<span class="gd">-    types_namespace: (dict[str, Any] | None)=None) -&gt;Any:</span>
<span class="gi">+    return func</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_function_return_type(</span>
<span class="gi">+    func: Any, explicit_return_type: Any, types_namespace: dict[str, Any] | None = None</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the function return type.

<span class="w"> </span>    It gets the return type from the type annotation if `explicit_return_type` is `None`.
<span class="gu">@@ -463,10 +766,17 @@ def get_function_return_type(func: Any, explicit_return_type: Any,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The function return type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if explicit_return_type is PydanticUndefined:</span>
<span class="gi">+        # try to get it from the type annotation</span>
<span class="gi">+        hints = get_function_type_hints(</span>
<span class="gi">+            unwrap_wrapped_function(func), include_keys={&#39;return&#39;}, types_namespace=types_namespace</span>
<span class="gi">+        )</span>
<span class="gi">+        return hints.get(&#39;return&#39;, PydanticUndefined)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return explicit_return_type</span>


<span class="gd">-def count_positional_required_params(sig: Signature) -&gt;int:</span>
<span class="gi">+def count_positional_required_params(sig: Signature) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the number of positional (required) arguments of a signature.

<span class="w"> </span>    This function should only be used to inspect signatures of validation and serialization functions.
<span class="gu">@@ -476,10 +786,23 @@ def count_positional_required_params(sig: Signature) -&gt;int:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The number of positional arguments of a signature.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parameters = list(sig.parameters.values())</span>
<span class="gi">+    return sum(</span>
<span class="gi">+        1</span>
<span class="gi">+        for param in parameters</span>
<span class="gi">+        if can_be_positional(param)</span>
<span class="gi">+        # First argument is the value being validated/serialized, and can have a default value</span>
<span class="gi">+        # (e.g. `float`, which has signature `(x=0, /)`). We assume other parameters (the info arg</span>
<span class="gi">+        # for instance) should be required, and thus without any default value.</span>
<span class="gi">+        and (param.default is Parameter.empty or param == parameters[0])</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def can_be_positional(param: Parameter) -&gt; bool:</span>
<span class="gi">+    return param.kind in (Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD)</span>


<span class="gd">-def ensure_property(f: Any) -&gt;Any:</span>
<span class="gi">+def ensure_property(f: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Ensure that a function is a `property` or `cached_property`, or is a valid descriptor.

<span class="w"> </span>    Args:
<span class="gu">@@ -488,4 +811,7 @@ def ensure_property(f: Any) -&gt;Any:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The function, or a `property` or `cached_property` instance wrapping the function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if ismethoddescriptor(f) or isdatadescriptor(f):</span>
<span class="gi">+        return f</span>
<span class="gi">+    else:</span>
<span class="gi">+        return property(f)</span>
<span class="gh">diff --git a/pydantic/_internal/_decorators_v1.py b/pydantic/_internal/_decorators_v1.py</span>
<span class="gh">index 4645ddd95..0957e018b 100644</span>
<span class="gd">--- a/pydantic/_internal/_decorators_v1.py</span>
<span class="gi">+++ b/pydantic/_internal/_decorators_v1.py</span>
<span class="gu">@@ -1,9 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Logic for V1 validators, e.g. `@validator` and `@root_validator`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>from inspect import Parameter, signature
<span class="w"> </span>from typing import Any, Dict, Tuple, Union, cast
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import core_schema
<span class="w"> </span>from typing_extensions import Protocol
<span class="gi">+</span>
<span class="w"> </span>from ..errors import PydanticUserError
<span class="w"> </span>from ._decorators import can_be_positional

<span class="gu">@@ -11,45 +15,43 @@ from ._decorators import can_be_positional</span>
<span class="w"> </span>class V1OnlyValueValidator(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;A simple validator, supported for V1 validators and V2 validators.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, __value: Any) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, __value: Any) -&gt; Any: ...</span>


<span class="w"> </span>class V1ValidatorWithValues(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;A validator with `values` argument, supported for V1 validators and V2 validators.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, __value: Any, values: dict[str, Any]) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, __value: Any, values: dict[str, Any]) -&gt; Any: ...</span>


<span class="w"> </span>class V1ValidatorWithValuesKwOnly(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;A validator with keyword only `values` argument, supported for V1 validators and V2 validators.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, __value: Any, *, values: dict[str, Any]) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, __value: Any, *, values: dict[str, Any]) -&gt; Any: ...</span>


<span class="w"> </span>class V1ValidatorWithKwargs(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;A validator with `kwargs` argument, supported for V1 validators and V2 validators.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, __value: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, __value: Any, **kwargs: Any) -&gt; Any: ...</span>


<span class="w"> </span>class V1ValidatorWithValuesAndKwargs(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;A validator with `values` and `kwargs` arguments, supported for V1 validators and V2 validators.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, __value: Any, values: dict[str, Any], **kwargs: Any</span>
<span class="gd">-        ) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, __value: Any, values: dict[str, Any], **kwargs: Any) -&gt; Any: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+V1Validator = Union[</span>
<span class="gi">+    V1ValidatorWithValues, V1ValidatorWithValuesKwOnly, V1ValidatorWithKwargs, V1ValidatorWithValuesAndKwargs</span>
<span class="gi">+]</span>


<span class="gd">-V1Validator = Union[V1ValidatorWithValues, V1ValidatorWithValuesKwOnly,</span>
<span class="gd">-    V1ValidatorWithKwargs, V1ValidatorWithValuesAndKwargs]</span>
<span class="gi">+def can_be_keyword(param: Parameter) -&gt; bool:</span>
<span class="gi">+    return param.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)</span>


<span class="gd">-def make_generic_v1_field_validator(validator: V1Validator</span>
<span class="gd">-    ) -&gt;core_schema.WithInfoValidatorFunction:</span>
<span class="gi">+def make_generic_v1_field_validator(validator: V1Validator) -&gt; core_schema.WithInfoValidatorFunction:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wrap a V1 style field validator for V2 compatibility.

<span class="w"> </span>    Args:
<span class="gu">@@ -62,38 +64,75 @@ def make_generic_v1_field_validator(validator: V1Validator</span>
<span class="w"> </span>        PydanticUserError: If the signature is not supported or the parameters are
<span class="w"> </span>            not available in Pydantic V2.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = signature(validator)</span>
<span class="gi">+</span>
<span class="gi">+    needs_values_kw = False</span>
<span class="gi">+</span>
<span class="gi">+    for param_num, (param_name, parameter) in enumerate(sig.parameters.items()):</span>
<span class="gi">+        if can_be_keyword(parameter) and param_name in (&#39;field&#39;, &#39;config&#39;):</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;The `field` and `config` parameters are not available in Pydantic V2, &#39;</span>
<span class="gi">+                &#39;please use the `info` parameter instead.&#39;,</span>
<span class="gi">+                code=&#39;validator-field-config-info&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+        if parameter.kind is Parameter.VAR_KEYWORD:</span>
<span class="gi">+            needs_values_kw = True</span>
<span class="gi">+        elif can_be_keyword(parameter) and param_name == &#39;values&#39;:</span>
<span class="gi">+            needs_values_kw = True</span>
<span class="gi">+        elif can_be_positional(parameter) and param_num == 0:</span>
<span class="gi">+            # value</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif parameter.default is Parameter.empty:  # ignore params with defaults e.g. bound by functools.partial</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;Unsupported signature for V1 style validator {validator}: {sig} is not supported.&#39;,</span>
<span class="gi">+                code=&#39;validator-v1-signature&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    if needs_values_kw:</span>
<span class="gi">+        # (v, **kwargs), (v, values, **kwargs), (v, *, values, **kwargs) or (v, *, values)</span>
<span class="gi">+        val1 = cast(V1ValidatorWithValues, validator)</span>
<span class="gi">+</span>
<span class="gi">+        def wrapper1(value: Any, info: core_schema.ValidationInfo) -&gt; Any:</span>
<span class="gi">+            return val1(value, values=info.data)</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper1</span>
<span class="gi">+    else:</span>
<span class="gi">+        val2 = cast(V1OnlyValueValidator, validator)</span>
<span class="gi">+</span>
<span class="gi">+        def wrapper2(value: Any, _: core_schema.ValidationInfo) -&gt; Any:</span>
<span class="gi">+            return val2(value)</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper2</span>


<span class="w"> </span>RootValidatorValues = Dict[str, Any]
<span class="gi">+# technically tuple[model_dict, model_extra, fields_set] | tuple[dataclass_dict, init_vars]</span>
<span class="w"> </span>RootValidatorFieldsTuple = Tuple[Any, ...]


<span class="w"> </span>class V1RootValidatorFunction(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;A simple root validator, supported for V1 validators and V2 validators.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, __values: RootValidatorValues) -&gt;RootValidatorValues:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, __values: RootValidatorValues) -&gt; RootValidatorValues: ...</span>


<span class="w"> </span>class V2CoreBeforeRootValidator(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;V2 validator with mode=&#39;before&#39;.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, __values: RootValidatorValues, __info: core_schema.</span>
<span class="gd">-        ValidationInfo) -&gt;RootValidatorValues:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(self, __values: RootValidatorValues, __info: core_schema.ValidationInfo) -&gt; RootValidatorValues: ...</span>


<span class="w"> </span>class V2CoreAfterRootValidator(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;V2 validator with mode=&#39;after&#39;.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, __fields_tuple: RootValidatorFieldsTuple, __info:</span>
<span class="gd">-        core_schema.ValidationInfo) -&gt;RootValidatorFieldsTuple:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, __fields_tuple: RootValidatorFieldsTuple, __info: core_schema.ValidationInfo</span>
<span class="gi">+    ) -&gt; RootValidatorFieldsTuple: ...</span>


<span class="gd">-def make_v1_generic_root_validator(validator: V1RootValidatorFunction, pre:</span>
<span class="gd">-    bool) -&gt;(V2CoreBeforeRootValidator | V2CoreAfterRootValidator):</span>
<span class="gi">+def make_v1_generic_root_validator(</span>
<span class="gi">+    validator: V1RootValidatorFunction, pre: bool</span>
<span class="gi">+) -&gt; V2CoreBeforeRootValidator | V2CoreAfterRootValidator:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wrap a V1 style root validator for V2 compatibility.

<span class="w"> </span>    Args:
<span class="gu">@@ -103,4 +142,33 @@ def make_v1_generic_root_validator(validator: V1RootValidatorFunction, pre:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A wrapped V2 style validator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pre is True:</span>
<span class="gi">+        # mode=&#39;before&#39; for pydantic-core</span>
<span class="gi">+        def _wrapper1(values: RootValidatorValues, _: core_schema.ValidationInfo) -&gt; RootValidatorValues:</span>
<span class="gi">+            return validator(values)</span>
<span class="gi">+</span>
<span class="gi">+        return _wrapper1</span>
<span class="gi">+</span>
<span class="gi">+    # mode=&#39;after&#39; for pydantic-core</span>
<span class="gi">+    def _wrapper2(fields_tuple: RootValidatorFieldsTuple, _: core_schema.ValidationInfo) -&gt; RootValidatorFieldsTuple:</span>
<span class="gi">+        if len(fields_tuple) == 2:</span>
<span class="gi">+            # dataclass, this is easy</span>
<span class="gi">+            values, init_vars = fields_tuple</span>
<span class="gi">+            values = validator(values)</span>
<span class="gi">+            return values, init_vars</span>
<span class="gi">+        else:</span>
<span class="gi">+            # ugly hack: to match v1 behaviour, we merge values and model_extra, then split them up based on fields</span>
<span class="gi">+            # afterwards</span>
<span class="gi">+            model_dict, model_extra, fields_set = fields_tuple</span>
<span class="gi">+            if model_extra:</span>
<span class="gi">+                fields = set(model_dict.keys())</span>
<span class="gi">+                model_dict.update(model_extra)</span>
<span class="gi">+                model_dict_new = validator(model_dict)</span>
<span class="gi">+                for k in list(model_dict_new.keys()):</span>
<span class="gi">+                    if k not in fields:</span>
<span class="gi">+                        model_extra[k] = model_dict_new.pop(k)</span>
<span class="gi">+            else:</span>
<span class="gi">+                model_dict_new = validator(model_dict)</span>
<span class="gi">+            return model_dict_new, model_extra, fields_set</span>
<span class="gi">+</span>
<span class="gi">+    return _wrapper2</span>
<span class="gh">diff --git a/pydantic/_internal/_discriminated_union.py b/pydantic/_internal/_discriminated_union.py</span>
<span class="gh">index aa07168eb..a090c36f0 100644</span>
<span class="gd">--- a/pydantic/_internal/_discriminated_union.py</span>
<span class="gi">+++ b/pydantic/_internal/_discriminated_union.py</span>
<span class="gu">@@ -1,13 +1,20 @@</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Hashable, Sequence
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import CoreSchema, core_schema
<span class="gi">+</span>
<span class="w"> </span>from ..errors import PydanticUserError
<span class="w"> </span>from . import _core_utils
<span class="gd">-from ._core_utils import CoreSchemaField, collect_definitions</span>
<span class="gi">+from ._core_utils import (</span>
<span class="gi">+    CoreSchemaField,</span>
<span class="gi">+    collect_definitions,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ..types import Discriminator
<span class="gd">-CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY = (</span>
<span class="gd">-    &#39;pydantic.internal.union_discriminator&#39;)</span>
<span class="gi">+</span>
<span class="gi">+CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY = &#39;pydantic.internal.union_discriminator&#39;</span>


<span class="w"> </span>class MissingDefinitionForUnionRef(Exception):
<span class="gu">@@ -15,14 +22,47 @@ class MissingDefinitionForUnionRef(Exception):</span>
<span class="w"> </span>    requires a definition that is not yet defined
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, ref: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, ref: str) -&gt; None:</span>
<span class="w"> </span>        self.ref = ref
<span class="w"> </span>        super().__init__(f&#39;Missing definition for ref {self.ref!r}&#39;)


<span class="gd">-def apply_discriminator(schema: core_schema.CoreSchema, discriminator: (str |</span>
<span class="gd">-    Discriminator), definitions: (dict[str, core_schema.CoreSchema] | None)</span>
<span class="gd">-    =None) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+def set_discriminator_in_metadata(schema: CoreSchema, discriminator: Any) -&gt; None:</span>
<span class="gi">+    schema.setdefault(&#39;metadata&#39;, {})</span>
<span class="gi">+    metadata = schema.get(&#39;metadata&#39;)</span>
<span class="gi">+    assert metadata is not None</span>
<span class="gi">+    metadata[CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY] = discriminator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def apply_discriminators(schema: core_schema.CoreSchema) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+    # We recursively walk through the `schema` passed to `apply_discriminators`, applying discriminators</span>
<span class="gi">+    # where necessary at each level. During this recursion, we allow references to be resolved from the definitions</span>
<span class="gi">+    # that are originally present on the original, outermost `schema`. Before `apply_discriminators` is called,</span>
<span class="gi">+    # `simplify_schema_references` is called on the schema (in the `clean_schema` function),</span>
<span class="gi">+    # which often puts the definitions in the outermost schema.</span>
<span class="gi">+    global_definitions: dict[str, CoreSchema] = collect_definitions(schema)</span>
<span class="gi">+</span>
<span class="gi">+    def inner(s: core_schema.CoreSchema, recurse: _core_utils.Recurse) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        nonlocal global_definitions</span>
<span class="gi">+</span>
<span class="gi">+        s = recurse(s, inner)</span>
<span class="gi">+        if s[&#39;type&#39;] == &#39;tagged-union&#39;:</span>
<span class="gi">+            return s</span>
<span class="gi">+</span>
<span class="gi">+        metadata = s.get(&#39;metadata&#39;, {})</span>
<span class="gi">+        discriminator = metadata.pop(CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY, None)</span>
<span class="gi">+        if discriminator is not None:</span>
<span class="gi">+            s = apply_discriminator(s, discriminator, global_definitions)</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    return _core_utils.walk_core_schema(schema, inner)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def apply_discriminator(</span>
<span class="gi">+    schema: core_schema.CoreSchema,</span>
<span class="gi">+    discriminator: str | Discriminator,</span>
<span class="gi">+    definitions: dict[str, core_schema.CoreSchema] | None = None,</span>
<span class="gi">+) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>    &quot;&quot;&quot;Applies the discriminator and returns a new core schema.

<span class="w"> </span>    Args:
<span class="gu">@@ -46,7 +86,15 @@ def apply_discriminator(schema: core_schema.CoreSchema, discriminator: (str |</span>
<span class="w"> </span>            - If discriminator fields have different aliases.
<span class="w"> </span>            - If discriminator field not of type `Literal`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..types import Discriminator</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(discriminator, Discriminator):</span>
<span class="gi">+        if isinstance(discriminator.discriminator, str):</span>
<span class="gi">+            discriminator = discriminator.discriminator</span>
<span class="gi">+        else:</span>
<span class="gi">+            return discriminator._convert_schema(schema)</span>
<span class="gi">+</span>
<span class="gi">+    return _ApplyInferredDiscriminator(discriminator, definitions or {}).apply(schema)</span>


<span class="w"> </span>class _ApplyInferredDiscriminator:
<span class="gu">@@ -62,18 +110,61 @@ class _ApplyInferredDiscriminator:</span>
<span class="w"> </span>    to make it easier to maintain state while recursively walking the provided CoreSchema.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, discriminator: str, definitions: dict[str,</span>
<span class="gd">-        core_schema.CoreSchema]):</span>
<span class="gi">+    def __init__(self, discriminator: str, definitions: dict[str, core_schema.CoreSchema]):</span>
<span class="gi">+        # `discriminator` should be the name of the field which will serve as the discriminator.</span>
<span class="gi">+        # It must be the python name of the field, and *not* the field&#39;s alias. Note that as of now,</span>
<span class="gi">+        # all members of a discriminated union _must_ use a field with the same name as the discriminator.</span>
<span class="gi">+        # This may change if/when we expose a way to manually specify the TaggedUnionSchema&#39;s choices.</span>
<span class="w"> </span>        self.discriminator = discriminator
<span class="gi">+</span>
<span class="gi">+        # `definitions` should contain a mapping of schema ref to schema for all schemas which might</span>
<span class="gi">+        # be referenced by some choice</span>
<span class="w"> </span>        self.definitions = definitions
<span class="gi">+</span>
<span class="gi">+        # `_discriminator_alias` will hold the value, if present, of the alias for the discriminator</span>
<span class="gi">+        #</span>
<span class="gi">+        # Note: following the v1 implementation, we currently disallow the use of different aliases</span>
<span class="gi">+        # for different choices. This is not a limitation of pydantic_core, but if we try to handle</span>
<span class="gi">+        # this, the inference logic gets complicated very quickly, and could result in confusing</span>
<span class="gi">+        # debugging challenges for users making subtle mistakes.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Rather than trying to do the most powerful inference possible, I think we should eventually</span>
<span class="gi">+        # expose a way to more-manually control the way the TaggedUnionSchema is constructed through</span>
<span class="gi">+        # the use of a new type which would be placed as an Annotation on the Union type. This would</span>
<span class="gi">+        # provide the full flexibility/power of pydantic_core&#39;s TaggedUnionSchema where necessary for</span>
<span class="gi">+        # more complex cases, without over-complicating the inference logic for the common cases.</span>
<span class="w"> </span>        self._discriminator_alias: str | None = None
<span class="gi">+</span>
<span class="gi">+        # `_should_be_nullable` indicates whether the converted union has `None` as an allowed value.</span>
<span class="gi">+        # If `None` is an acceptable value of the (possibly-wrapped) union, we ignore it while</span>
<span class="gi">+        # constructing the TaggedUnionSchema, but set the `_should_be_nullable` attribute to True.</span>
<span class="gi">+        # Once we have constructed the TaggedUnionSchema, if `_should_be_nullable` is True, we ensure</span>
<span class="gi">+        # that the final schema gets wrapped as a NullableSchema. This has the same semantics on the</span>
<span class="gi">+        # python side, but resolves the issue that `None` cannot correspond to any discriminator values.</span>
<span class="w"> </span>        self._should_be_nullable = False
<span class="gi">+</span>
<span class="gi">+        # `_is_nullable` is used to track if the final produced schema will definitely be nullable;</span>
<span class="gi">+        # we set it to True if the input schema is wrapped in a nullable schema that we know will be preserved</span>
<span class="gi">+        # as an indication that, even if None is discovered as one of the union choices, we will not need to wrap</span>
<span class="gi">+        # the final value in another nullable schema.</span>
<span class="gi">+        #</span>
<span class="gi">+        # This is more complicated than just checking for the final outermost schema having type &#39;nullable&#39; thanks</span>
<span class="gi">+        # to the possible presence of other wrapper schemas such as DefinitionsSchema, WithDefaultSchema, etc.</span>
<span class="w"> </span>        self._is_nullable = False
<span class="gi">+</span>
<span class="gi">+        # `_choices_to_handle` serves as a stack of choices to add to the tagged union. Initially, choices</span>
<span class="gi">+        # from the union in the wrapped schema will be appended to this list, and the recursive choice-handling</span>
<span class="gi">+        # algorithm may add more choices to this stack as (nested) unions are encountered.</span>
<span class="w"> </span>        self._choices_to_handle: list[core_schema.CoreSchema] = []
<span class="gi">+</span>
<span class="gi">+        # `_tagged_union_choices` is built during the call to `apply`, and will hold the choices to be included</span>
<span class="gi">+        # in the output TaggedUnionSchema that will replace the union from the input schema</span>
<span class="w"> </span>        self._tagged_union_choices: dict[Hashable, core_schema.CoreSchema] = {}
<span class="gi">+</span>
<span class="gi">+        # `_used` is changed to True after applying the discriminator to prevent accidental re-use</span>
<span class="w"> </span>        self._used = False

<span class="gd">-    def apply(self, schema: core_schema.CoreSchema) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def apply(self, schema: core_schema.CoreSchema) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new CoreSchema based on `schema` that uses a tagged-union with the discriminator provided
<span class="w"> </span>        to this class.

<span class="gu">@@ -96,17 +187,70 @@ class _ApplyInferredDiscriminator:</span>
<span class="w"> </span>                - If discriminator fields have different aliases.
<span class="w"> </span>                - If discriminator field not of type `Literal`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert not self._used</span>
<span class="gi">+        schema = self._apply_to_root(schema)</span>
<span class="gi">+        if self._should_be_nullable and not self._is_nullable:</span>
<span class="gi">+            schema = core_schema.nullable_schema(schema)</span>
<span class="gi">+        self._used = True</span>
<span class="gi">+        return schema</span>

<span class="gd">-    def _apply_to_root(self, schema: core_schema.CoreSchema</span>
<span class="gd">-        ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def _apply_to_root(self, schema: core_schema.CoreSchema) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method handles the outer-most stage of recursion over the input schema:
<span class="w"> </span>        unwrapping nullable or definitions schemas, and calling the `_handle_choice`
<span class="w"> </span>        method iteratively on the choices extracted (recursively) from the possibly-wrapped union.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if schema[&#39;type&#39;] == &#39;nullable&#39;:</span>
<span class="gi">+            self._is_nullable = True</span>
<span class="gi">+            wrapped = self._apply_to_root(schema[&#39;schema&#39;])</span>
<span class="gi">+            nullable_wrapper = schema.copy()</span>
<span class="gi">+            nullable_wrapper[&#39;schema&#39;] = wrapped</span>
<span class="gi">+            return nullable_wrapper</span>

<span class="gd">-    def _handle_choice(self, choice: core_schema.CoreSchema) -&gt;None:</span>
<span class="gi">+        if schema[&#39;type&#39;] == &#39;definitions&#39;:</span>
<span class="gi">+            wrapped = self._apply_to_root(schema[&#39;schema&#39;])</span>
<span class="gi">+            definitions_wrapper = schema.copy()</span>
<span class="gi">+            definitions_wrapper[&#39;schema&#39;] = wrapped</span>
<span class="gi">+            return definitions_wrapper</span>
<span class="gi">+</span>
<span class="gi">+        if schema[&#39;type&#39;] != &#39;union&#39;:</span>
<span class="gi">+            # If the schema is not a union, it probably means it just had a single member and</span>
<span class="gi">+            # was flattened by pydantic_core.</span>
<span class="gi">+            # However, it still may make sense to apply the discriminator to this schema,</span>
<span class="gi">+            # as a way to get discriminated-union-style error messages, so we allow this here.</span>
<span class="gi">+            schema = core_schema.union_schema([schema])</span>
<span class="gi">+</span>
<span class="gi">+        # Reverse the choices list before extending the stack so that they get handled in the order they occur</span>
<span class="gi">+        choices_schemas = [v[0] if isinstance(v, tuple) else v for v in schema[&#39;choices&#39;][::-1]]</span>
<span class="gi">+        self._choices_to_handle.extend(choices_schemas)</span>
<span class="gi">+        while self._choices_to_handle:</span>
<span class="gi">+            choice = self._choices_to_handle.pop()</span>
<span class="gi">+            self._handle_choice(choice)</span>
<span class="gi">+</span>
<span class="gi">+        if self._discriminator_alias is not None and self._discriminator_alias != self.discriminator:</span>
<span class="gi">+            # * We need to annotate `discriminator` as a union here to handle both branches of this conditional</span>
<span class="gi">+            # * We need to annotate `discriminator` as list[list[str | int]] and not list[list[str]] due to the</span>
<span class="gi">+            #   invariance of list, and because list[list[str | int]] is the type of the discriminator argument</span>
<span class="gi">+            #   to tagged_union_schema below</span>
<span class="gi">+            # * See the docstring of pydantic_core.core_schema.tagged_union_schema for more details about how to</span>
<span class="gi">+            #   interpret the value of the discriminator argument to tagged_union_schema. (The list[list[str]] here</span>
<span class="gi">+            #   is the appropriate way to provide a list of fallback attributes to check for a discriminator value.)</span>
<span class="gi">+            discriminator: str | list[list[str | int]] = [[self.discriminator], [self._discriminator_alias]]</span>
<span class="gi">+        else:</span>
<span class="gi">+            discriminator = self.discriminator</span>
<span class="gi">+        return core_schema.tagged_union_schema(</span>
<span class="gi">+            choices=self._tagged_union_choices,</span>
<span class="gi">+            discriminator=discriminator,</span>
<span class="gi">+            custom_error_type=schema.get(&#39;custom_error_type&#39;),</span>
<span class="gi">+            custom_error_message=schema.get(&#39;custom_error_message&#39;),</span>
<span class="gi">+            custom_error_context=schema.get(&#39;custom_error_context&#39;),</span>
<span class="gi">+            strict=False,</span>
<span class="gi">+            from_attributes=True,</span>
<span class="gi">+            ref=schema.get(&#39;ref&#39;),</span>
<span class="gi">+            metadata=schema.get(&#39;metadata&#39;),</span>
<span class="gi">+            serialization=schema.get(&#39;serialization&#39;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_choice(self, choice: core_schema.CoreSchema) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method handles the &quot;middle&quot; stage of recursion over the input schema.
<span class="w"> </span>        Specifically, it is responsible for handling each choice of the outermost union
<span class="w"> </span>        (and any &quot;coalesced&quot; choices obtained from inner unions).
<span class="gu">@@ -117,43 +261,243 @@ class _ApplyInferredDiscriminator:</span>
<span class="w"> </span>        * Validating that each allowed discriminator value maps to a unique choice
<span class="w"> </span>        * Updating the _tagged_union_choices mapping that will ultimately be used to build the TaggedUnionSchema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if choice[&#39;type&#39;] == &#39;definition-ref&#39;:</span>
<span class="gi">+            if choice[&#39;schema_ref&#39;] not in self.definitions:</span>
<span class="gi">+                raise MissingDefinitionForUnionRef(choice[&#39;schema_ref&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        if choice[&#39;type&#39;] == &#39;none&#39;:</span>
<span class="gi">+            self._should_be_nullable = True</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;definitions&#39;:</span>
<span class="gi">+            self._handle_choice(choice[&#39;schema&#39;])</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;nullable&#39;:</span>
<span class="gi">+            self._should_be_nullable = True</span>
<span class="gi">+            self._handle_choice(choice[&#39;schema&#39;])  # unwrap the nullable schema</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;union&#39;:</span>
<span class="gi">+            # Reverse the choices list before extending the stack so that they get handled in the order they occur</span>
<span class="gi">+            choices_schemas = [v[0] if isinstance(v, tuple) else v for v in choice[&#39;choices&#39;][::-1]]</span>
<span class="gi">+            self._choices_to_handle.extend(choices_schemas)</span>
<span class="gi">+        elif choice[&#39;type&#39;] not in {</span>
<span class="gi">+            &#39;model&#39;,</span>
<span class="gi">+            &#39;typed-dict&#39;,</span>
<span class="gi">+            &#39;tagged-union&#39;,</span>
<span class="gi">+            &#39;lax-or-strict&#39;,</span>
<span class="gi">+            &#39;dataclass&#39;,</span>
<span class="gi">+            &#39;dataclass-args&#39;,</span>
<span class="gi">+            &#39;definition-ref&#39;,</span>
<span class="gi">+        } and not _core_utils.is_function_with_inner_schema(choice):</span>
<span class="gi">+            # We should eventually handle &#39;definition-ref&#39; as well</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&#39;{choice[&quot;type&quot;]!r} is not a valid discriminated union variant;&#39;</span>
<span class="gi">+                &#39; should be a `BaseModel` or `dataclass`&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            if choice[&#39;type&#39;] == &#39;tagged-union&#39; and self._is_discriminator_shared(choice):</span>
<span class="gi">+                # In this case, this inner tagged-union is compatible with the outer tagged-union,</span>
<span class="gi">+                # and its choices can be coalesced into the outer TaggedUnionSchema.</span>
<span class="gi">+                subchoices = [x for x in choice[&#39;choices&#39;].values() if not isinstance(x, (str, int))]</span>
<span class="gi">+                # Reverse the choices list before extending the stack so that they get handled in the order they occur</span>
<span class="gi">+                self._choices_to_handle.extend(subchoices[::-1])</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            inferred_discriminator_values = self._infer_discriminator_values_for_choice(choice, source_name=None)</span>
<span class="gi">+            self._set_unique_choice_for_values(choice, inferred_discriminator_values)</span>

<span class="gd">-    def _is_discriminator_shared(self, choice: core_schema.TaggedUnionSchema</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def _is_discriminator_shared(self, choice: core_schema.TaggedUnionSchema) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method returns a boolean indicating whether the discriminator for the `choice`
<span class="w"> </span>        is the same as that being used for the outermost tagged union. This is used to
<span class="w"> </span>        determine whether this TaggedUnionSchema choice should be &quot;coalesced&quot; into the top level,
<span class="w"> </span>        or whether it should be treated as a separate (nested) choice.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inner_discriminator = choice[&#39;discriminator&#39;]</span>
<span class="gi">+        return inner_discriminator == self.discriminator or (</span>
<span class="gi">+            isinstance(inner_discriminator, list)</span>
<span class="gi">+            and (self.discriminator in inner_discriminator or [self.discriminator] in inner_discriminator)</span>
<span class="gi">+        )</span>

<span class="gd">-    def _infer_discriminator_values_for_choice(self, choice: core_schema.</span>
<span class="gd">-        CoreSchema, source_name: (str | None)) -&gt;list[str | int]:</span>
<span class="gi">+    def _infer_discriminator_values_for_choice(  # noqa C901</span>
<span class="gi">+        self, choice: core_schema.CoreSchema, source_name: str | None</span>
<span class="gi">+    ) -&gt; list[str | int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This function recurses over `choice`, extracting all discriminator values that should map to this choice.

<span class="w"> </span>        `model_name` is accepted for the purpose of producing useful error messages.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if choice[&#39;type&#39;] == &#39;definitions&#39;:</span>
<span class="gi">+            return self._infer_discriminator_values_for_choice(choice[&#39;schema&#39;], source_name=source_name)</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;function-plain&#39;:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&#39;{choice[&quot;type&quot;]!r} is not a valid discriminated union variant;&#39;</span>
<span class="gi">+                &#39; should be a `BaseModel` or `dataclass`&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        elif _core_utils.is_function_with_inner_schema(choice):</span>
<span class="gi">+            return self._infer_discriminator_values_for_choice(choice[&#39;schema&#39;], source_name=source_name)</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;lax-or-strict&#39;:</span>
<span class="gi">+            return sorted(</span>
<span class="gi">+                set(</span>
<span class="gi">+                    self._infer_discriminator_values_for_choice(choice[&#39;lax_schema&#39;], source_name=None)</span>
<span class="gi">+                    + self._infer_discriminator_values_for_choice(choice[&#39;strict_schema&#39;], source_name=None)</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;tagged-union&#39;:</span>
<span class="gi">+            values: list[str | int] = []</span>
<span class="gi">+            # Ignore str/int &quot;choices&quot; since these are just references to other choices</span>
<span class="gi">+            subchoices = [x for x in choice[&#39;choices&#39;].values() if not isinstance(x, (str, int))]</span>
<span class="gi">+            for subchoice in subchoices:</span>
<span class="gi">+                subchoice_values = self._infer_discriminator_values_for_choice(subchoice, source_name=None)</span>
<span class="gi">+                values.extend(subchoice_values)</span>
<span class="gi">+            return values</span>
<span class="gi">+</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;union&#39;:</span>
<span class="gi">+            values = []</span>
<span class="gi">+            for subchoice in choice[&#39;choices&#39;]:</span>
<span class="gi">+                subchoice_schema = subchoice[0] if isinstance(subchoice, tuple) else subchoice</span>
<span class="gi">+                subchoice_values = self._infer_discriminator_values_for_choice(subchoice_schema, source_name=None)</span>
<span class="gi">+                values.extend(subchoice_values)</span>
<span class="gi">+            return values</span>
<span class="gi">+</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;nullable&#39;:</span>
<span class="gi">+            self._should_be_nullable = True</span>
<span class="gi">+            return self._infer_discriminator_values_for_choice(choice[&#39;schema&#39;], source_name=None)</span>
<span class="gi">+</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;model&#39;:</span>
<span class="gi">+            return self._infer_discriminator_values_for_choice(choice[&#39;schema&#39;], source_name=choice[&#39;cls&#39;].__name__)</span>
<span class="gi">+</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;dataclass&#39;:</span>
<span class="gi">+            return self._infer_discriminator_values_for_choice(choice[&#39;schema&#39;], source_name=choice[&#39;cls&#39;].__name__)</span>
<span class="gi">+</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;model-fields&#39;:</span>
<span class="gi">+            return self._infer_discriminator_values_for_model_choice(choice, source_name=source_name)</span>

<span class="gd">-    def _infer_discriminator_values_for_typed_dict_choice(self, choice:</span>
<span class="gd">-        core_schema.TypedDictSchema, source_name: (str | None)=None) -&gt;list[</span>
<span class="gd">-        str | int]:</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;dataclass-args&#39;:</span>
<span class="gi">+            return self._infer_discriminator_values_for_dataclass_choice(choice, source_name=source_name)</span>
<span class="gi">+</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;typed-dict&#39;:</span>
<span class="gi">+            return self._infer_discriminator_values_for_typed_dict_choice(choice, source_name=source_name)</span>
<span class="gi">+</span>
<span class="gi">+        elif choice[&#39;type&#39;] == &#39;definition-ref&#39;:</span>
<span class="gi">+            schema_ref = choice[&#39;schema_ref&#39;]</span>
<span class="gi">+            if schema_ref not in self.definitions:</span>
<span class="gi">+                raise MissingDefinitionForUnionRef(schema_ref)</span>
<span class="gi">+            return self._infer_discriminator_values_for_choice(self.definitions[schema_ref], source_name=source_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&#39;{choice[&quot;type&quot;]!r} is not a valid discriminated union variant;&#39;</span>
<span class="gi">+                &#39; should be a `BaseModel` or `dataclass`&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _infer_discriminator_values_for_typed_dict_choice(</span>
<span class="gi">+        self, choice: core_schema.TypedDictSchema, source_name: str | None = None</span>
<span class="gi">+    ) -&gt; list[str | int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method just extracts the _infer_discriminator_values_for_choice logic specific to TypedDictSchema
<span class="w"> </span>        for the sake of readability.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        source = &#39;TypedDict&#39; if source_name is None else f&#39;TypedDict {source_name!r}&#39;</span>
<span class="gi">+        field = choice[&#39;fields&#39;].get(self.discriminator)</span>
<span class="gi">+        if field is None:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;{source} needs a discriminator field for key {self.discriminator!r}&#39;, code=&#39;discriminator-no-field&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        return self._infer_discriminator_values_for_field(field, source)</span>
<span class="gi">+</span>
<span class="gi">+    def _infer_discriminator_values_for_model_choice(</span>
<span class="gi">+        self, choice: core_schema.ModelFieldsSchema, source_name: str | None = None</span>
<span class="gi">+    ) -&gt; list[str | int]:</span>
<span class="gi">+        source = &#39;ModelFields&#39; if source_name is None else f&#39;Model {source_name!r}&#39;</span>
<span class="gi">+        field = choice[&#39;fields&#39;].get(self.discriminator)</span>
<span class="gi">+        if field is None:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;{source} needs a discriminator field for key {self.discriminator!r}&#39;, code=&#39;discriminator-no-field&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        return self._infer_discriminator_values_for_field(field, source)</span>
<span class="gi">+</span>
<span class="gi">+    def _infer_discriminator_values_for_dataclass_choice(</span>
<span class="gi">+        self, choice: core_schema.DataclassArgsSchema, source_name: str | None = None</span>
<span class="gi">+    ) -&gt; list[str | int]:</span>
<span class="gi">+        source = &#39;DataclassArgs&#39; if source_name is None else f&#39;Dataclass {source_name!r}&#39;</span>
<span class="gi">+        for field in choice[&#39;fields&#39;]:</span>
<span class="gi">+            if field[&#39;name&#39;] == self.discriminator:</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;{source} needs a discriminator field for key {self.discriminator!r}&#39;, code=&#39;discriminator-no-field&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        return self._infer_discriminator_values_for_field(field, source)</span>
<span class="gi">+</span>
<span class="gi">+    def _infer_discriminator_values_for_field(self, field: CoreSchemaField, source: str) -&gt; list[str | int]:</span>
<span class="gi">+        if field[&#39;type&#39;] == &#39;computed-field&#39;:</span>
<span class="gi">+            # This should never occur as a discriminator, as it is only relevant to serialization</span>
<span class="gi">+            return []</span>
<span class="gi">+        alias = field.get(&#39;validation_alias&#39;, self.discriminator)</span>
<span class="gi">+        if not isinstance(alias, str):</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;Alias {alias!r} is not supported in a discriminated union&#39;, code=&#39;discriminator-alias-type&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        if self._discriminator_alias is None:</span>
<span class="gi">+            self._discriminator_alias = alias</span>
<span class="gi">+        elif self._discriminator_alias != alias:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;Aliases for discriminator {self.discriminator!r} must be the same &#39;</span>
<span class="gi">+                f&#39;(got {alias}, {self._discriminator_alias})&#39;,</span>
<span class="gi">+                code=&#39;discriminator-alias&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+        return self._infer_discriminator_values_for_inner_schema(field[&#39;schema&#39;], source)</span>

<span class="gd">-    def _infer_discriminator_values_for_inner_schema(self, schema:</span>
<span class="gd">-        core_schema.CoreSchema, source: str) -&gt;list[str | int]:</span>
<span class="gi">+    def _infer_discriminator_values_for_inner_schema(</span>
<span class="gi">+        self, schema: core_schema.CoreSchema, source: str</span>
<span class="gi">+    ) -&gt; list[str | int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;When inferring discriminator values for a field, we typically extract the expected values from a literal
<span class="w"> </span>        schema. This function does that, but also handles nested unions and defaults.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if schema[&#39;type&#39;] == &#39;literal&#39;:</span>
<span class="gi">+            return schema[&#39;expected&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        elif schema[&#39;type&#39;] == &#39;union&#39;:</span>
<span class="gi">+            # Generally when multiple values are allowed they should be placed in a single `Literal`, but</span>
<span class="gi">+            # we add this case to handle the situation where a field is annotated as a `Union` of `Literal`s.</span>
<span class="gi">+            # For example, this lets us handle `Union[Literal[&#39;key&#39;], Union[Literal[&#39;Key&#39;], Literal[&#39;KEY&#39;]]]`</span>
<span class="gi">+            values: list[Any] = []</span>
<span class="gi">+            for choice in schema[&#39;choices&#39;]:</span>
<span class="gi">+                choice_schema = choice[0] if isinstance(choice, tuple) else choice</span>
<span class="gi">+                choice_values = self._infer_discriminator_values_for_inner_schema(choice_schema, source)</span>
<span class="gi">+                values.extend(choice_values)</span>
<span class="gi">+            return values</span>
<span class="gi">+</span>
<span class="gi">+        elif schema[&#39;type&#39;] == &#39;default&#39;:</span>
<span class="gi">+            # This will happen if the field has a default value; we ignore it while extracting the discriminator values</span>
<span class="gi">+            return self._infer_discriminator_values_for_inner_schema(schema[&#39;schema&#39;], source)</span>
<span class="gi">+</span>
<span class="gi">+        elif schema[&#39;type&#39;] == &#39;function-after&#39;:</span>
<span class="gi">+            # After validators don&#39;t affect the discriminator values</span>
<span class="gi">+            return self._infer_discriminator_values_for_inner_schema(schema[&#39;schema&#39;], source)</span>
<span class="gi">+</span>
<span class="gi">+        elif schema[&#39;type&#39;] in {&#39;function-before&#39;, &#39;function-wrap&#39;, &#39;function-plain&#39;}:</span>
<span class="gi">+            validator_type = repr(schema[&#39;type&#39;].split(&#39;-&#39;)[1])</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;Cannot use a mode={validator_type} validator in the&#39;</span>
<span class="gi">+                f&#39; discriminator field {self.discriminator!r} of {source}&#39;,</span>
<span class="gi">+                code=&#39;discriminator-validator&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;{source} needs field {self.discriminator!r} to be of type `Literal`&#39;,</span>
<span class="gi">+                code=&#39;discriminator-needs-literal&#39;,</span>
<span class="gi">+            )</span>

<span class="gd">-    def _set_unique_choice_for_values(self, choice: core_schema.CoreSchema,</span>
<span class="gd">-        values: Sequence[str | int]) -&gt;None:</span>
<span class="gi">+    def _set_unique_choice_for_values(self, choice: core_schema.CoreSchema, values: Sequence[str | int]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method updates `self.tagged_union_choices` so that all provided (discriminator) `values` map to the
<span class="w"> </span>        provided `choice`, validating that none of these values already map to another (different) choice.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for discriminator_value in values:</span>
<span class="gi">+            if discriminator_value in self._tagged_union_choices:</span>
<span class="gi">+                # It is okay if `value` is already in tagged_union_choices as long as it maps to the same value.</span>
<span class="gi">+                # Because tagged_union_choices may map values to other values, we need to walk the choices dict</span>
<span class="gi">+                # until we get to a &quot;real&quot; choice, and confirm that is equal to the one assigned.</span>
<span class="gi">+                existing_choice = self._tagged_union_choices[discriminator_value]</span>
<span class="gi">+                if existing_choice != choice:</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        f&#39;Value {discriminator_value!r} for discriminator &#39;</span>
<span class="gi">+                        f&#39;{self.discriminator!r} mapped to multiple choices&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._tagged_union_choices[discriminator_value] = choice</span>
<span class="gh">diff --git a/pydantic/_internal/_docs_extraction.py b/pydantic/_internal/_docs_extraction.py</span>
<span class="gh">index 88a14e9ff..685a6d069 100644</span>
<span class="gd">--- a/pydantic/_internal/_docs_extraction.py</span>
<span class="gi">+++ b/pydantic/_internal/_docs_extraction.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities related to attribute docstring extraction.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>import inspect
<span class="w"> </span>import textwrap
<span class="gu">@@ -7,16 +9,76 @@ from typing import Any</span>


<span class="w"> </span>class DocstringVisitor(ast.NodeVisitor):
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="gi">+</span>
<span class="w"> </span>        self.target: str | None = None
<span class="w"> </span>        self.attrs: dict[str, str] = {}
<span class="w"> </span>        self.previous_node_type: type[ast.AST] | None = None

<span class="gi">+    def visit(self, node: ast.AST) -&gt; Any:</span>
<span class="gi">+        node_result = super().visit(node)</span>
<span class="gi">+        self.previous_node_type = type(node)</span>
<span class="gi">+        return node_result</span>
<span class="gi">+</span>
<span class="gi">+    def visit_AnnAssign(self, node: ast.AnnAssign) -&gt; Any:</span>
<span class="gi">+        if isinstance(node.target, ast.Name):</span>
<span class="gi">+            self.target = node.target.id</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Expr(self, node: ast.Expr) -&gt; Any:</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.value, ast.Constant)</span>
<span class="gi">+            and isinstance(node.value.value, str)</span>
<span class="gi">+            and self.previous_node_type is ast.AnnAssign</span>
<span class="gi">+        ):</span>
<span class="gi">+            docstring = inspect.cleandoc(node.value.value)</span>
<span class="gi">+            if self.target:</span>
<span class="gi">+                self.attrs[self.target] = docstring</span>
<span class="gi">+            self.target = None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dedent_source_lines(source: list[str]) -&gt; str:</span>
<span class="gi">+    # Required for nested class definitions, e.g. in a function block</span>
<span class="gi">+    dedent_source = textwrap.dedent(&#39;&#39;.join(source))</span>
<span class="gi">+    if dedent_source.startswith((&#39; &#39;, &#39;\t&#39;)):</span>
<span class="gi">+        # We are in the case where there&#39;s a dedented (usually multiline) string</span>
<span class="gi">+        # at a lower indentation level than the class itself. We wrap our class</span>
<span class="gi">+        # in a function as a workaround.</span>
<span class="gi">+        dedent_source = f&#39;def dedent_workaround():\n{dedent_source}&#39;</span>
<span class="gi">+    return dedent_source</span>

<span class="gd">-def extract_docstrings_from_cls(cls: type[Any], use_inspect: bool=False</span>
<span class="gd">-    ) -&gt;dict[str, str]:</span>
<span class="gi">+</span>
<span class="gi">+def _extract_source_from_frame(cls: type[Any]) -&gt; list[str] | None:</span>
<span class="gi">+    frame = inspect.currentframe()</span>
<span class="gi">+</span>
<span class="gi">+    while frame:</span>
<span class="gi">+        if inspect.getmodule(frame) is inspect.getmodule(cls):</span>
<span class="gi">+            lnum = frame.f_lineno</span>
<span class="gi">+            try:</span>
<span class="gi">+                lines, _ = inspect.findsource(frame)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # Source can&#39;t be retrieved (maybe because running in an interactive terminal),</span>
<span class="gi">+                # we don&#39;t want to error here.</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                block_lines = inspect.getblock(lines[lnum - 1 :])</span>
<span class="gi">+                dedent_source = _dedent_source_lines(block_lines)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    block_tree = ast.parse(dedent_source)</span>
<span class="gi">+                except SyntaxError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    stmt = block_tree.body[0]</span>
<span class="gi">+                    if isinstance(stmt, ast.FunctionDef) and stmt.name == &#39;dedent_workaround&#39;:</span>
<span class="gi">+                        # `_dedent_source_lines` wrapped the class around the workaround function</span>
<span class="gi">+                        stmt = stmt.body[0]</span>
<span class="gi">+                    if isinstance(stmt, ast.ClassDef) and stmt.name == cls.__name__:</span>
<span class="gi">+                        return block_lines</span>
<span class="gi">+</span>
<span class="gi">+        frame = frame.f_back</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_docstrings_from_cls(cls: type[Any], use_inspect: bool = False) -&gt; dict[str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Map model attributes and their corresponding docstring.

<span class="w"> </span>    Args:
<span class="gu">@@ -27,4 +89,20 @@ def extract_docstrings_from_cls(cls: type[Any], use_inspect: bool=False</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A mapping containing attribute names and their corresponding docstring.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if use_inspect:</span>
<span class="gi">+        # Might not work as expected if two classes have the same name in the same source file.</span>
<span class="gi">+        try:</span>
<span class="gi">+            source, _ = inspect.getsourcelines(cls)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            return {}</span>
<span class="gi">+    else:</span>
<span class="gi">+        source = _extract_source_from_frame(cls)</span>
<span class="gi">+</span>
<span class="gi">+    if not source:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    dedent_source = _dedent_source_lines(source)</span>
<span class="gi">+</span>
<span class="gi">+    visitor = DocstringVisitor()</span>
<span class="gi">+    visitor.visit(ast.parse(dedent_source))</span>
<span class="gi">+    return visitor.attrs</span>
<span class="gh">diff --git a/pydantic/_internal/_fields.py b/pydantic/_internal/_fields.py</span>
<span class="gh">index 7e8b6c926..52cd08bf0 100644</span>
<span class="gd">--- a/pydantic/_internal/_fields.py</span>
<span class="gi">+++ b/pydantic/_internal/_fields.py</span>
<span class="gu">@@ -1,28 +1,38 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Private logic related to fields (the `Field()` function and `FieldInfo` class), and arguments to `Annotated`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from copy import copy
<span class="w"> </span>from functools import lru_cache
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import PydanticUndefined
<span class="gi">+</span>
<span class="w"> </span>from pydantic.errors import PydanticUserError
<span class="gi">+</span>
<span class="w"> </span>from . import _typing_extra
<span class="w"> </span>from ._config import ConfigWrapper
<span class="w"> </span>from ._docs_extraction import extract_docstrings_from_cls
<span class="w"> </span>from ._repr import Representation
<span class="w"> </span>from ._typing_extra import get_cls_type_hints_lenient, get_type_hints, is_classvar, is_finalvar
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from annotated_types import BaseMetadata
<span class="gi">+</span>
<span class="w"> </span>    from ..fields import FieldInfo
<span class="w"> </span>    from ..main import BaseModel
<span class="w"> </span>    from ._dataclasses import StandardDataclass
<span class="w"> </span>    from ._decorators import DecoratorInfos


<span class="gd">-def get_type_hints_infer_globalns(obj: Any, localns: (dict[str, Any] | None</span>
<span class="gd">-    )=None, include_extras: bool=False) -&gt;dict[str, Any]:</span>
<span class="gi">+def get_type_hints_infer_globalns(</span>
<span class="gi">+    obj: Any,</span>
<span class="gi">+    localns: dict[str, Any] | None = None,</span>
<span class="gi">+    include_extras: bool = False,</span>
<span class="gi">+) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Gets type hints for an object by inferring the global namespace.

<span class="w"> </span>    It uses the `typing.get_type_hints`, The only thing that we do here is fetching
<span class="gu">@@ -36,15 +46,24 @@ def get_type_hints_infer_globalns(obj: Any, localns: (dict[str, Any] | None</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The object type hints.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module_name = getattr(obj, &#39;__module__&#39;, None)</span>
<span class="gi">+    globalns: dict[str, Any] | None = None</span>
<span class="gi">+    if module_name:</span>
<span class="gi">+        try:</span>
<span class="gi">+            globalns = sys.modules[module_name].__dict__</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363</span>
<span class="gi">+            pass</span>
<span class="gi">+    return get_type_hints(obj, globalns=globalns, localns=localns, include_extras=include_extras)</span>


<span class="w"> </span>class PydanticMetadata(Representation):
<span class="w"> </span>    &quot;&quot;&quot;Base class for annotation markers like `Strict`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()


<span class="gd">-def pydantic_general_metadata(**metadata: Any) -&gt;BaseMetadata:</span>
<span class="gi">+def pydantic_general_metadata(**metadata: Any) -&gt; BaseMetadata:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a new `_PydanticGeneralMetadata` class with the given metadata.

<span class="w"> </span>    Args:
<span class="gu">@@ -53,19 +72,39 @@ def pydantic_general_metadata(**metadata: Any) -&gt;BaseMetadata:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The new `_PydanticGeneralMetadata` class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _general_metadata_cls()(metadata)  # type: ignore</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="gd">-def _general_metadata_cls() -&gt;type[BaseMetadata]:</span>
<span class="gi">+def _general_metadata_cls() -&gt; type[BaseMetadata]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Do it this way to avoid importing `annotated_types` at import time.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from annotated_types import BaseMetadata</span>
<span class="gi">+</span>
<span class="gi">+    class _PydanticGeneralMetadata(PydanticMetadata, BaseMetadata):</span>
<span class="gi">+        &quot;&quot;&quot;Pydantic general metadata like `max_digits`.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def __init__(self, metadata: Any):</span>
<span class="gi">+            self.__dict__ = metadata</span>
<span class="gi">+</span>
<span class="gi">+    return _PydanticGeneralMetadata  # type: ignore</span>
<span class="gi">+</span>

<span class="gi">+def _update_fields_from_docstrings(cls: type[Any], fields: dict[str, FieldInfo], config_wrapper: ConfigWrapper) -&gt; None:</span>
<span class="gi">+    if config_wrapper.use_attribute_docstrings:</span>
<span class="gi">+        fields_docs = extract_docstrings_from_cls(cls)</span>
<span class="gi">+        for ann_name, field_info in fields.items():</span>
<span class="gi">+            if field_info.description is None and ann_name in fields_docs:</span>
<span class="gi">+                field_info.description = fields_docs[ann_name]</span>

<span class="gd">-def collect_model_fields(cls: type[BaseModel], bases: tuple[type[Any], ...],</span>
<span class="gd">-    config_wrapper: ConfigWrapper, types_namespace: (dict[str, Any] | None),</span>
<span class="gd">-    *, typevars_map: (dict[Any, Any] | None)=None) -&gt;tuple[dict[str,</span>
<span class="gd">-    FieldInfo], set[str]]:</span>
<span class="gi">+</span>
<span class="gi">+def collect_model_fields(  # noqa: C901</span>
<span class="gi">+    cls: type[BaseModel],</span>
<span class="gi">+    bases: tuple[type[Any], ...],</span>
<span class="gi">+    config_wrapper: ConfigWrapper,</span>
<span class="gi">+    types_namespace: dict[str, Any] | None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    typevars_map: dict[Any, Any] | None = None,</span>
<span class="gi">+) -&gt; tuple[dict[str, FieldInfo], set[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Collect the fields of a nascent pydantic model.

<span class="w"> </span>    Also collect the names of any ClassVars present in the type hints.
<span class="gu">@@ -88,12 +127,167 @@ def collect_model_fields(cls: type[BaseModel], bases: tuple[type[Any], ...],</span>
<span class="w"> </span>            - If there is a field other than `root` in `RootModel`.
<span class="w"> </span>            - If a field shadows an attribute in the parent model.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+    type_hints = get_cls_type_hints_lenient(cls, types_namespace)</span>
<span class="gi">+</span>
<span class="gi">+    # https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-object-in-python-3-9-and-older</span>
<span class="gi">+    # annotations is only used for finding fields in parent classes</span>
<span class="gi">+    annotations = cls.__dict__.get(&#39;__annotations__&#39;, {})</span>
<span class="gi">+    fields: dict[str, FieldInfo] = {}</span>
<span class="gi">+</span>
<span class="gi">+    class_vars: set[str] = set()</span>
<span class="gi">+    for ann_name, ann_type in type_hints.items():</span>
<span class="gi">+        if ann_name == &#39;model_config&#39;:</span>
<span class="gi">+            # We never want to treat `model_config` as a field</span>
<span class="gi">+            # Note: we may need to change this logic if/when we introduce a `BareModel` class with no</span>
<span class="gi">+            # protected namespaces (where `model_config` might be allowed as a field name)</span>
<span class="gi">+            continue</span>
<span class="gi">+        for protected_namespace in config_wrapper.protected_namespaces:</span>
<span class="gi">+            if ann_name.startswith(protected_namespace):</span>
<span class="gi">+                for b in bases:</span>
<span class="gi">+                    if hasattr(b, ann_name):</span>
<span class="gi">+                        from ..main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+                        if not (issubclass(b, BaseModel) and ann_name in b.model_fields):</span>
<span class="gi">+                            raise NameError(</span>
<span class="gi">+                                f&#39;Field &quot;{ann_name}&quot; conflicts with member {getattr(b, ann_name)}&#39;</span>
<span class="gi">+                                f&#39; of protected namespace &quot;{protected_namespace}&quot;.&#39;</span>
<span class="gi">+                            )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    valid_namespaces = tuple(</span>
<span class="gi">+                        x for x in config_wrapper.protected_namespaces if not ann_name.startswith(x)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    warnings.warn(</span>
<span class="gi">+                        f&#39;Field &quot;{ann_name}&quot; has conflict with protected namespace &quot;{protected_namespace}&quot;.&#39;</span>
<span class="gi">+                        &#39;\n\nYou may be able to resolve this warning by setting&#39;</span>
<span class="gi">+                        f&quot; `model_config[&#39;protected_namespaces&#39;] = {valid_namespaces}`.&quot;,</span>
<span class="gi">+                        UserWarning,</span>
<span class="gi">+                    )</span>
<span class="gi">+        if is_classvar(ann_type):</span>
<span class="gi">+            class_vars.add(ann_name)</span>
<span class="gi">+            continue</span>
<span class="gi">+        if _is_finalvar_with_default_val(ann_type, getattr(cls, ann_name, PydanticUndefined)):</span>
<span class="gi">+            class_vars.add(ann_name)</span>
<span class="gi">+            continue</span>
<span class="gi">+        if not is_valid_field_name(ann_name):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if cls.__pydantic_root_model__ and ann_name != &#39;root&#39;:</span>
<span class="gi">+            raise NameError(</span>
<span class="gi">+                f&quot;Unexpected field with name {ann_name!r}; only &#39;root&#39; is allowed as a field of a `RootModel`&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don&#39;t get</span>
<span class="gi">+        # &quot;... shadows an attribute&quot; warnings</span>
<span class="gi">+        generic_origin = getattr(cls, &#39;__pydantic_generic_metadata__&#39;, {}).get(&#39;origin&#39;)</span>
<span class="gi">+        for base in bases:</span>
<span class="gi">+            dataclass_fields = {</span>
<span class="gi">+                field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())</span>
<span class="gi">+            }</span>
<span class="gi">+            if hasattr(base, ann_name):</span>
<span class="gi">+                if base is generic_origin:</span>
<span class="gi">+                    # Don&#39;t warn when &quot;shadowing&quot; of attributes in parametrized generics</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if ann_name in dataclass_fields:</span>
<span class="gi">+                    # Don&#39;t warn when inheriting stdlib dataclasses whose fields are &quot;shadowed&quot; by defaults being set</span>
<span class="gi">+                    # on the class instance.</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if ann_name not in annotations:</span>
<span class="gi">+                    # Don&#39;t warn when a field exists in a parent class but has not been defined in the current class</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&#39;Field name &quot;{ann_name}&quot; in &quot;{cls.__qualname__}&quot; shadows an attribute in parent &#39;</span>
<span class="gi">+                    f&#39;&quot;{base.__qualname__}&quot;&#39;,</span>
<span class="gi">+                    UserWarning,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            default = getattr(cls, ann_name, PydanticUndefined)</span>
<span class="gi">+            if default is PydanticUndefined:</span>
<span class="gi">+                raise AttributeError</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            if ann_name in annotations:</span>
<span class="gi">+                field_info = FieldInfo.from_annotation(ann_type)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # if field has no default value and is not in __annotations__ this means that it is</span>
<span class="gi">+                # defined in a base class and we can take it from there</span>
<span class="gi">+                model_fields_lookup: dict[str, FieldInfo] = {}</span>
<span class="gi">+                for x in cls.__bases__[::-1]:</span>
<span class="gi">+                    model_fields_lookup.update(getattr(x, &#39;model_fields&#39;, {}))</span>
<span class="gi">+                if ann_name in model_fields_lookup:</span>
<span class="gi">+                    # The field was present on one of the (possibly multiple) base classes</span>
<span class="gi">+                    # copy the field to make sure typevar substitutions don&#39;t cause issues with the base classes</span>
<span class="gi">+                    field_info = copy(model_fields_lookup[ann_name])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # The field was not found on any base classes; this seems to be caused by fields not getting</span>
<span class="gi">+                    # generated thanks to models not being fully defined while initializing recursive models.</span>
<span class="gi">+                    # Nothing stops us from just creating a new FieldInfo for this type hint, so we do this.</span>
<span class="gi">+                    field_info = FieldInfo.from_annotation(ann_type)</span>
<span class="gi">+        else:</span>
<span class="gi">+            _warn_on_nested_alias_in_annotation(ann_type, ann_name)</span>
<span class="gi">+            field_info = FieldInfo.from_annotated_attribute(ann_type, default)</span>
<span class="gi">+            # attributes which are fields are removed from the class namespace:</span>
<span class="gi">+            # 1. To match the behaviour of annotation-only fields</span>
<span class="gi">+            # 2. To avoid false positives in the NameError check above</span>
<span class="gi">+            try:</span>
<span class="gi">+                delattr(cls, ann_name)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                pass  # indicates the attribute was on a parent class</span>
<span class="gi">+</span>
<span class="gi">+        # Use cls.__dict__[&#39;__pydantic_decorators__&#39;] instead of cls.__pydantic_decorators__</span>
<span class="gi">+        # to make sure the decorators have already been built for this exact class</span>
<span class="gi">+        decorators: DecoratorInfos = cls.__dict__[&#39;__pydantic_decorators__&#39;]</span>
<span class="gi">+        if ann_name in decorators.computed_fields:</span>
<span class="gi">+            raise ValueError(&quot;you can&#39;t override a field with a computed field&quot;)</span>
<span class="gi">+        fields[ann_name] = field_info</span>
<span class="gi">+</span>
<span class="gi">+    if typevars_map:</span>
<span class="gi">+        for field in fields.values():</span>
<span class="gi">+            field.apply_typevars_map(typevars_map, types_namespace)</span>

<span class="gi">+    _update_fields_from_docstrings(cls, fields, config_wrapper)</span>

<span class="gd">-def collect_dataclass_fields(cls: type[StandardDataclass], types_namespace:</span>
<span class="gd">-    (dict[str, Any] | None), *, typevars_map: (dict[Any, Any] | None)=None,</span>
<span class="gd">-    config_wrapper: (ConfigWrapper | None)=None) -&gt;dict[str, FieldInfo]:</span>
<span class="gi">+    return fields, class_vars</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _warn_on_nested_alias_in_annotation(ann_type: type[Any], ann_name: str):</span>
<span class="gi">+    from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(ann_type, &#39;__args__&#39;):</span>
<span class="gi">+        for anno_arg in ann_type.__args__:</span>
<span class="gi">+            if _typing_extra.is_annotated(anno_arg):</span>
<span class="gi">+                for anno_type_arg in _typing_extra.get_args(anno_arg):</span>
<span class="gi">+                    if isinstance(anno_type_arg, FieldInfo) and anno_type_arg.alias is not None:</span>
<span class="gi">+                        warnings.warn(</span>
<span class="gi">+                            f&#39;`alias` specification on field &quot;{ann_name}&quot; must be set on outermost annotation to take effect.&#39;,</span>
<span class="gi">+                            UserWarning,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_finalvar_with_default_val(type_: type[Any], val: Any) -&gt; bool:</span>
<span class="gi">+    from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+    if not is_finalvar(type_):</span>
<span class="gi">+        return False</span>
<span class="gi">+    elif val is PydanticUndefined:</span>
<span class="gi">+        return False</span>
<span class="gi">+    elif isinstance(val, FieldInfo) and (val.default is PydanticUndefined and val.default_factory is None):</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def collect_dataclass_fields(</span>
<span class="gi">+    cls: type[StandardDataclass],</span>
<span class="gi">+    types_namespace: dict[str, Any] | None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    typevars_map: dict[Any, Any] | None = None,</span>
<span class="gi">+    config_wrapper: ConfigWrapper | None = None,</span>
<span class="gi">+) -&gt; dict[str, FieldInfo]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Collect the fields of a dataclass.

<span class="w"> </span>    Args:
<span class="gu">@@ -105,4 +299,63 @@ def collect_dataclass_fields(cls: type[StandardDataclass], types_namespace:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The dataclass fields.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+    fields: dict[str, FieldInfo] = {}</span>
<span class="gi">+    dataclass_fields: dict[str, dataclasses.Field] = cls.__dataclass_fields__</span>
<span class="gi">+    cls_localns = dict(vars(cls))  # this matches get_cls_type_hints_lenient, but all tests pass with `= None` instead</span>
<span class="gi">+</span>
<span class="gi">+    source_module = sys.modules.get(cls.__module__)</span>
<span class="gi">+    if source_module is not None:</span>
<span class="gi">+        types_namespace = {**source_module.__dict__, **(types_namespace or {})}</span>
<span class="gi">+</span>
<span class="gi">+    for ann_name, dataclass_field in dataclass_fields.items():</span>
<span class="gi">+        ann_type = _typing_extra.eval_type_lenient(dataclass_field.type, types_namespace, cls_localns)</span>
<span class="gi">+        if is_classvar(ann_type):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            not dataclass_field.init</span>
<span class="gi">+            and dataclass_field.default == dataclasses.MISSING</span>
<span class="gi">+            and dataclass_field.default_factory == dataclasses.MISSING</span>
<span class="gi">+        ):</span>
<span class="gi">+            # TODO: We should probably do something with this so that validate_assignment behaves properly</span>
<span class="gi">+            #   Issue: https://github.com/pydantic/pydantic/issues/5470</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(dataclass_field.default, FieldInfo):</span>
<span class="gi">+            if dataclass_field.default.init_var:</span>
<span class="gi">+                if dataclass_field.default.init is False:</span>
<span class="gi">+                    raise PydanticUserError(</span>
<span class="gi">+                        f&#39;Dataclass field {ann_name} has init=False and init_var=True, but these are mutually exclusive.&#39;,</span>
<span class="gi">+                        code=&#39;clashing-init-and-init-var&#39;,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                # TODO: same note as above re validate_assignment</span>
<span class="gi">+                continue</span>
<span class="gi">+            field_info = FieldInfo.from_annotated_attribute(ann_type, dataclass_field.default)</span>
<span class="gi">+        else:</span>
<span class="gi">+            field_info = FieldInfo.from_annotated_attribute(ann_type, dataclass_field)</span>
<span class="gi">+</span>
<span class="gi">+        fields[ann_name] = field_info</span>
<span class="gi">+</span>
<span class="gi">+        if field_info.default is not PydanticUndefined and isinstance(getattr(cls, ann_name, field_info), FieldInfo):</span>
<span class="gi">+            # We need this to fix the default when the &quot;default&quot; from __dataclass_fields__ is a pydantic.FieldInfo</span>
<span class="gi">+            setattr(cls, ann_name, field_info.default)</span>
<span class="gi">+</span>
<span class="gi">+    if typevars_map:</span>
<span class="gi">+        for field in fields.values():</span>
<span class="gi">+            field.apply_typevars_map(typevars_map, types_namespace)</span>
<span class="gi">+</span>
<span class="gi">+    if config_wrapper is not None:</span>
<span class="gi">+        _update_fields_from_docstrings(cls, fields, config_wrapper)</span>
<span class="gi">+</span>
<span class="gi">+    return fields</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_valid_field_name(name: str) -&gt; bool:</span>
<span class="gi">+    return not name.startswith(&#39;_&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_valid_privateattr_name(name: str) -&gt; bool:</span>
<span class="gi">+    return name.startswith(&#39;_&#39;) and not name.startswith(&#39;__&#39;)</span>
<span class="gh">diff --git a/pydantic/_internal/_forward_ref.py b/pydantic/_internal/_forward_ref.py</span>
<span class="gh">index 65d359cca..231f81d11 100644</span>
<span class="gd">--- a/pydantic/_internal/_forward_ref.py</span>
<span class="gi">+++ b/pydantic/_internal/_forward_ref.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from typing import Union

<span class="gu">@@ -6,16 +7,17 @@ from typing import Union</span>
<span class="w"> </span>@dataclass
<span class="w"> </span>class PydanticRecursiveRef:
<span class="w"> </span>    type_ref: str
<span class="gi">+</span>
<span class="w"> </span>    __name__ = &#39;PydanticRecursiveRef&#39;
<span class="w"> </span>    __hash__ = object.__hash__

<span class="gd">-    def __call__(self) -&gt;None:</span>
<span class="gi">+    def __call__(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Defining __call__ is necessary for the `typing` module to let you use an instance of
<span class="w"> </span>        this class as the result of resolving a standard ForwardRef.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="w"> </span>    def __or__(self, other):
<span class="gd">-        return Union[self, other]</span>
<span class="gi">+        return Union[self, other]  # type: ignore</span>

<span class="w"> </span>    def __ror__(self, other):
<span class="gd">-        return Union[other, self]</span>
<span class="gi">+        return Union[other, self]  # type: ignore</span>
<span class="gh">diff --git a/pydantic/_internal/_generate_schema.py b/pydantic/_internal/_generate_schema.py</span>
<span class="gh">index c7465578b..edd8e722c 100644</span>
<span class="gd">--- a/pydantic/_internal/_generate_schema.py</span>
<span class="gi">+++ b/pydantic/_internal/_generate_schema.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Convert python types to pydantic-core schema.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import collections.abc
<span class="w"> </span>import dataclasses
<span class="w"> </span>import inspect
<span class="gu">@@ -15,10 +17,27 @@ from inspect import Parameter, _ParameterKind, signature</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from operator import attrgetter
<span class="w"> </span>from types import FunctionType, LambdaType, MethodType
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, Dict, Final, ForwardRef, Iterable, Iterator, Mapping, Type, TypeVar, Union, cast, overload</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Final,</span>
<span class="gi">+    ForwardRef,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    overload,</span>
<span class="gi">+)</span>
<span class="w"> </span>from warnings import warn
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import CoreSchema, PydanticUndefined, core_schema, to_jsonable_python
<span class="w"> </span>from typing_extensions import Annotated, Literal, TypeAliasType, TypedDict, get_args, get_origin, is_typeddict
<span class="gi">+</span>
<span class="w"> </span>from ..aliases import AliasGenerator
<span class="w"> </span>from ..annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler
<span class="w"> </span>from ..config import ConfigDict, JsonDict, JsonEncoder
<span class="gu">@@ -29,8 +48,31 @@ from ..warnings import PydanticDeprecatedSince20</span>
<span class="w"> </span>from . import _core_utils, _decorators, _discriminated_union, _known_annotated_metadata, _typing_extra
<span class="w"> </span>from ._config import ConfigWrapper, ConfigWrapperStack
<span class="w"> </span>from ._core_metadata import CoreMetadataHandler, build_metadata_dict
<span class="gd">-from ._core_utils import CoreSchemaOrField, collect_invalid_schemas, define_expected_missing_refs, get_ref, get_type_ref, is_function_with_inner_schema, is_list_like_schema_with_items_schema, simplify_schema_references, validate_core_schema</span>
<span class="gd">-from ._decorators import Decorator, DecoratorInfos, FieldSerializerDecoratorInfo, FieldValidatorDecoratorInfo, ModelSerializerDecoratorInfo, ModelValidatorDecoratorInfo, RootValidatorDecoratorInfo, ValidatorDecoratorInfo, get_attribute_from_bases, inspect_field_serializer, inspect_model_serializer, inspect_validator</span>
<span class="gi">+from ._core_utils import (</span>
<span class="gi">+    CoreSchemaOrField,</span>
<span class="gi">+    collect_invalid_schemas,</span>
<span class="gi">+    define_expected_missing_refs,</span>
<span class="gi">+    get_ref,</span>
<span class="gi">+    get_type_ref,</span>
<span class="gi">+    is_function_with_inner_schema,</span>
<span class="gi">+    is_list_like_schema_with_items_schema,</span>
<span class="gi">+    simplify_schema_references,</span>
<span class="gi">+    validate_core_schema,</span>
<span class="gi">+)</span>
<span class="gi">+from ._decorators import (</span>
<span class="gi">+    Decorator,</span>
<span class="gi">+    DecoratorInfos,</span>
<span class="gi">+    FieldSerializerDecoratorInfo,</span>
<span class="gi">+    FieldValidatorDecoratorInfo,</span>
<span class="gi">+    ModelSerializerDecoratorInfo,</span>
<span class="gi">+    ModelValidatorDecoratorInfo,</span>
<span class="gi">+    RootValidatorDecoratorInfo,</span>
<span class="gi">+    ValidatorDecoratorInfo,</span>
<span class="gi">+    get_attribute_from_bases,</span>
<span class="gi">+    inspect_field_serializer,</span>
<span class="gi">+    inspect_model_serializer,</span>
<span class="gi">+    inspect_validator,</span>
<span class="gi">+)</span>
<span class="w"> </span>from ._docs_extraction import extract_docstrings_from_cls
<span class="w"> </span>from ._fields import collect_dataclass_fields, get_type_hints_infer_globalns
<span class="w"> </span>from ._forward_ref import PydanticRecursiveRef
<span class="gu">@@ -39,6 +81,7 @@ from ._mock_val_ser import MockCoreSchema</span>
<span class="w"> </span>from ._schema_generation_shared import CallbackGetCoreSchemaHandler
<span class="w"> </span>from ._typing_extra import is_finalvar, is_self_type
<span class="w"> </span>from ._utils import lenient_issubclass
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ..fields import ComputedFieldInfo, FieldInfo
<span class="w"> </span>    from ..main import BaseModel
<span class="gu">@@ -46,28 +89,32 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from ..validators import FieldValidatorModes
<span class="w"> </span>    from ._dataclasses import StandardDataclass
<span class="w"> </span>    from ._schema_generation_shared import GetJsonSchemaFunction
<span class="gi">+</span>
<span class="w"> </span>_SUPPORTS_TYPEDDICT = sys.version_info &gt;= (3, 12)
<span class="w"> </span>_AnnotatedType = type(Annotated[int, 123])
<span class="gd">-FieldDecoratorInfo = Union[ValidatorDecoratorInfo,</span>
<span class="gd">-    FieldValidatorDecoratorInfo, FieldSerializerDecoratorInfo]</span>
<span class="gd">-FieldDecoratorInfoType = TypeVar(&#39;FieldDecoratorInfoType&#39;, bound=</span>
<span class="gd">-    FieldDecoratorInfo)</span>
<span class="gd">-AnyFieldDecorator = Union[Decorator[ValidatorDecoratorInfo], Decorator[</span>
<span class="gd">-    FieldValidatorDecoratorInfo], Decorator[FieldSerializerDecoratorInfo]]</span>
<span class="gi">+</span>
<span class="gi">+FieldDecoratorInfo = Union[ValidatorDecoratorInfo, FieldValidatorDecoratorInfo, FieldSerializerDecoratorInfo]</span>
<span class="gi">+FieldDecoratorInfoType = TypeVar(&#39;FieldDecoratorInfoType&#39;, bound=FieldDecoratorInfo)</span>
<span class="gi">+AnyFieldDecorator = Union[</span>
<span class="gi">+    Decorator[ValidatorDecoratorInfo],</span>
<span class="gi">+    Decorator[FieldValidatorDecoratorInfo],</span>
<span class="gi">+    Decorator[FieldSerializerDecoratorInfo],</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>ModifyCoreSchemaWrapHandler = GetCoreSchemaHandler
<span class="gd">-GetCoreSchemaFunction = Callable[[Any, ModifyCoreSchemaWrapHandler],</span>
<span class="gd">-    core_schema.CoreSchema]</span>
<span class="gi">+GetCoreSchemaFunction = Callable[[Any, ModifyCoreSchemaWrapHandler], core_schema.CoreSchema]</span>
<span class="gi">+</span>
<span class="w"> </span>TUPLE_TYPES: list[type] = [tuple, typing.Tuple]
<span class="w"> </span>LIST_TYPES: list[type] = [list, typing.List, collections.abc.MutableSequence]
<span class="w"> </span>SET_TYPES: list[type] = [set, typing.Set, collections.abc.MutableSet]
<span class="gd">-FROZEN_SET_TYPES: list[type] = [frozenset, typing.FrozenSet, collections.</span>
<span class="gd">-    abc.Set]</span>
<span class="gd">-DICT_TYPES: list[type] = [dict, typing.Dict, collections.abc.MutableMapping,</span>
<span class="gd">-    collections.abc.Mapping]</span>
<span class="gi">+FROZEN_SET_TYPES: list[type] = [frozenset, typing.FrozenSet, collections.abc.Set]</span>
<span class="gi">+DICT_TYPES: list[type] = [dict, typing.Dict, collections.abc.MutableMapping, collections.abc.Mapping]</span>


<span class="gd">-def check_validator_fields_against_field_name(info: FieldDecoratorInfo,</span>
<span class="gd">-    field: str) -&gt;bool:</span>
<span class="gi">+def check_validator_fields_against_field_name(</span>
<span class="gi">+    info: FieldDecoratorInfo,</span>
<span class="gi">+    field: str,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if field name is in validator fields.

<span class="w"> </span>    Args:
<span class="gu">@@ -77,11 +124,15 @@ def check_validator_fields_against_field_name(info: FieldDecoratorInfo,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `True` if field name is in validator fields, `False` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;*&#39; in info.fields:</span>
<span class="gi">+        return True</span>
<span class="gi">+    for v_field_name in info.fields:</span>
<span class="gi">+        if v_field_name == field:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def check_decorator_fields_exist(decorators: Iterable[AnyFieldDecorator],</span>
<span class="gd">-    fields: Iterable[str]) -&gt;None:</span>
<span class="gi">+def check_decorator_fields_exist(decorators: Iterable[AnyFieldDecorator], fields: Iterable[str]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the defined fields in decorators exist in `fields` param.

<span class="w"> </span>    It ignores the check for a decorator if the decorator has `*` as field or `check_fields=False`.
<span class="gu">@@ -93,12 +144,71 @@ def check_decorator_fields_exist(decorators: Iterable[AnyFieldDecorator],</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticUserError: If one of the field names does not exist in `fields` param.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def modify_model_json_schema(schema_or_field: CoreSchemaOrField, handler:</span>
<span class="gd">-    GetJsonSchemaHandler, *, cls: Any, title: (str | None)=None</span>
<span class="gd">-    ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    fields = set(fields)</span>
<span class="gi">+    for dec in decorators:</span>
<span class="gi">+        if &#39;*&#39; in dec.info.fields:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if dec.info.check_fields is False:</span>
<span class="gi">+            continue</span>
<span class="gi">+        for field in dec.info.fields:</span>
<span class="gi">+            if field not in fields:</span>
<span class="gi">+                raise PydanticUserError(</span>
<span class="gi">+                    f&#39;Decorators defined with incorrect fields: {dec.cls_ref}.{dec.cls_var_name}&#39;</span>
<span class="gi">+                    &quot; (use check_fields=False if you&#39;re inheriting from the model and intended this)&quot;,</span>
<span class="gi">+                    code=&#39;decorator-missing-field&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def filter_field_decorator_info_by_field(</span>
<span class="gi">+    validator_functions: Iterable[Decorator[FieldDecoratorInfoType]], field: str</span>
<span class="gi">+) -&gt; list[Decorator[FieldDecoratorInfoType]]:</span>
<span class="gi">+    return [dec for dec in validator_functions if check_validator_fields_against_field_name(dec.info, field)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def apply_each_item_validators(</span>
<span class="gi">+    schema: core_schema.CoreSchema,</span>
<span class="gi">+    each_item_validators: list[Decorator[ValidatorDecoratorInfo]],</span>
<span class="gi">+    field_name: str | None,</span>
<span class="gi">+) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+    # This V1 compatibility shim should eventually be removed</span>
<span class="gi">+</span>
<span class="gi">+    # push down any `each_item=True` validators</span>
<span class="gi">+    # note that this won&#39;t work for any Annotated types that get wrapped by a function validator</span>
<span class="gi">+    # but that&#39;s okay because that didn&#39;t exist in V1</span>
<span class="gi">+    if schema[&#39;type&#39;] == &#39;nullable&#39;:</span>
<span class="gi">+        schema[&#39;schema&#39;] = apply_each_item_validators(schema[&#39;schema&#39;], each_item_validators, field_name)</span>
<span class="gi">+        return schema</span>
<span class="gi">+    elif schema[&#39;type&#39;] == &#39;tuple&#39;:</span>
<span class="gi">+        if (variadic_item_index := schema.get(&#39;variadic_item_index&#39;)) is not None:</span>
<span class="gi">+            schema[&#39;items_schema&#39;][variadic_item_index] = apply_validators(</span>
<span class="gi">+                schema[&#39;items_schema&#39;][variadic_item_index], each_item_validators, field_name</span>
<span class="gi">+            )</span>
<span class="gi">+    elif is_list_like_schema_with_items_schema(schema):</span>
<span class="gi">+        inner_schema = schema.get(&#39;items_schema&#39;, None)</span>
<span class="gi">+        if inner_schema is None:</span>
<span class="gi">+            inner_schema = core_schema.any_schema()</span>
<span class="gi">+        schema[&#39;items_schema&#39;] = apply_validators(inner_schema, each_item_validators, field_name)</span>
<span class="gi">+    elif schema[&#39;type&#39;] == &#39;dict&#39;:</span>
<span class="gi">+        # push down any `each_item=True` validators onto dict _values_</span>
<span class="gi">+        # this is super arbitrary but it&#39;s the V1 behavior</span>
<span class="gi">+        inner_schema = schema.get(&#39;values_schema&#39;, None)</span>
<span class="gi">+        if inner_schema is None:</span>
<span class="gi">+            inner_schema = core_schema.any_schema()</span>
<span class="gi">+        schema[&#39;values_schema&#39;] = apply_validators(inner_schema, each_item_validators, field_name)</span>
<span class="gi">+    elif each_item_validators:</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            f&quot;`@validator(..., each_item=True)` cannot be applied to fields with a schema of {schema[&#39;type&#39;]}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    return schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def modify_model_json_schema(</span>
<span class="gi">+    schema_or_field: CoreSchemaOrField,</span>
<span class="gi">+    handler: GetJsonSchemaHandler,</span>
<span class="gi">+    *,</span>
<span class="gi">+    cls: Any,</span>
<span class="gi">+    title: str | None = None,</span>
<span class="gi">+) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add title and description for model-like classes&#39; JSON schema.

<span class="w"> </span>    Args:
<span class="gu">@@ -110,14 +220,37 @@ def modify_model_json_schema(schema_or_field: CoreSchemaOrField, handler:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        JsonSchemaValue: The updated JSON schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..dataclasses import is_pydantic_dataclass</span>
<span class="gi">+    from ..main import BaseModel</span>
<span class="gi">+    from ..root_model import RootModel</span>
<span class="gi">+    from ._dataclasses import is_builtin_dataclass</span>
<span class="gi">+</span>
<span class="gi">+    json_schema = handler(schema_or_field)</span>
<span class="gi">+    original_schema = handler.resolve_ref_schema(json_schema)</span>
<span class="gi">+    # Preserve the fact that definitions schemas should never have sibling keys:</span>
<span class="gi">+    if &#39;$ref&#39; in original_schema:</span>
<span class="gi">+        ref = original_schema[&#39;$ref&#39;]</span>
<span class="gi">+        original_schema.clear()</span>
<span class="gi">+        original_schema[&#39;allOf&#39;] = [{&#39;$ref&#39;: ref}]</span>
<span class="gi">+    if title is not None:</span>
<span class="gi">+        original_schema[&#39;title&#39;] = title</span>
<span class="gi">+    elif &#39;title&#39; not in original_schema:</span>
<span class="gi">+        original_schema[&#39;title&#39;] = cls.__name__</span>
<span class="gi">+    # BaseModel + Dataclass; don&#39;t use cls.__doc__ as it will contain the verbose class signature by default</span>
<span class="gi">+    docstring = None if cls is BaseModel or is_builtin_dataclass(cls) or is_pydantic_dataclass(cls) else cls.__doc__</span>
<span class="gi">+    if docstring and &#39;description&#39; not in original_schema:</span>
<span class="gi">+        original_schema[&#39;description&#39;] = inspect.cleandoc(docstring)</span>
<span class="gi">+    elif issubclass(cls, RootModel) and cls.model_fields[&#39;root&#39;].description:</span>
<span class="gi">+        original_schema[&#39;description&#39;] = cls.model_fields[&#39;root&#39;].description</span>
<span class="gi">+    return json_schema</span>


<span class="w"> </span>JsonEncoders = Dict[Type[Any], JsonEncoder]


<span class="gd">-def _add_custom_serialization_from_json_encoders(json_encoders: (</span>
<span class="gd">-    JsonEncoders | None), tp: Any, schema: CoreSchema) -&gt;CoreSchema:</span>
<span class="gi">+def _add_custom_serialization_from_json_encoders(</span>
<span class="gi">+    json_encoders: JsonEncoders | None, tp: Any, schema: CoreSchema</span>
<span class="gi">+) -&gt; CoreSchema:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over the json_encoders and add the first matching encoder to the schema.

<span class="w"> </span>    Args:
<span class="gu">@@ -125,7 +258,28 @@ def _add_custom_serialization_from_json_encoders(json_encoders: (</span>
<span class="w"> </span>        tp: The type to check for a matching encoder.
<span class="w"> </span>        schema: The schema to add the encoder to.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not json_encoders:</span>
<span class="gi">+        return schema</span>
<span class="gi">+    if &#39;serialization&#39; in schema:</span>
<span class="gi">+        return schema</span>
<span class="gi">+    # Check the class type and its superclasses for a matching encoder</span>
<span class="gi">+    # Decimal.__class__.__mro__ (and probably other cases) doesn&#39;t include Decimal itself</span>
<span class="gi">+    # if the type is a GenericAlias (e.g. from list[int]) we need to use __class__ instead of .__mro__</span>
<span class="gi">+    for base in (tp, *getattr(tp, &#39;__mro__&#39;, tp.__class__.__mro__)[:-1]):</span>
<span class="gi">+        encoder = json_encoders.get(base)</span>
<span class="gi">+        if encoder is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            f&#39;`json_encoders` is deprecated. See https://docs.pydantic.dev/{version_short()}/concepts/serialization/#custom-serializers for alternatives&#39;,</span>
<span class="gi">+            PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # TODO: in theory we should check that the schema accepts a serialization key</span>
<span class="gi">+        schema[&#39;serialization&#39;] = core_schema.plain_serializer_function_ser_schema(encoder, when_used=&#39;json&#39;)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    return schema</span>


<span class="w"> </span>TypesNamespace = Union[Dict[str, Any], None]
<span class="gu">@@ -137,24 +291,48 @@ class TypesNamespaceStack:</span>
<span class="w"> </span>    def __init__(self, types_namespace: TypesNamespace):
<span class="w"> </span>        self._types_namespace_stack: list[TypesNamespace] = [types_namespace]

<span class="gi">+    @property</span>
<span class="gi">+    def tail(self) -&gt; TypesNamespace:</span>
<span class="gi">+        return self._types_namespace_stack[-1]</span>

<span class="gd">-def _get_first_non_null(a: Any, b: Any) -&gt;Any:</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def push(self, for_type: type[Any]):</span>
<span class="gi">+        types_namespace = {**_typing_extra.get_cls_types_namespace(for_type), **(self.tail or {})}</span>
<span class="gi">+        self._types_namespace_stack.append(types_namespace)</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._types_namespace_stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_first_non_null(a: Any, b: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the first argument if it is not None, otherwise return the second argument.

<span class="w"> </span>    Use case: serialization_alias (argument a) and alias (argument b) are both defined, and serialization_alias is &#39;&#39;.
<span class="w"> </span>    This function will return serialization_alias, which is the first argument, even though it is an empty string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return a if a is not None else b</span>


<span class="w"> </span>class GenerateSchema:
<span class="w"> </span>    &quot;&quot;&quot;Generate core schema for a Pydantic model, dataclass and types like `str`, `datetime`, ... .&quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;_config_wrapper_stack&#39;, &#39;_types_namespace_stack&#39;,</span>
<span class="gd">-        &#39;_typevars_map&#39;, &#39;field_name_stack&#39;, &#39;model_type_stack&#39;, &#39;defs&#39;)</span>

<span class="gd">-    def __init__(self, config_wrapper: ConfigWrapper, types_namespace: (</span>
<span class="gd">-        dict[str, Any] | None), typevars_map: (dict[Any, Any] | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;_config_wrapper_stack&#39;,</span>
<span class="gi">+        &#39;_types_namespace_stack&#39;,</span>
<span class="gi">+        &#39;_typevars_map&#39;,</span>
<span class="gi">+        &#39;field_name_stack&#39;,</span>
<span class="gi">+        &#39;model_type_stack&#39;,</span>
<span class="gi">+        &#39;defs&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        config_wrapper: ConfigWrapper,</span>
<span class="gi">+        types_namespace: dict[str, Any] | None,</span>
<span class="gi">+        typevars_map: dict[Any, Any] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # we need a stack for recursing into child models</span>
<span class="w"> </span>        self._config_wrapper_stack = ConfigWrapperStack(config_wrapper)
<span class="w"> </span>        self._types_namespace_stack = TypesNamespaceStack(types_namespace)
<span class="w"> </span>        self._typevars_map = typevars_map
<span class="gu">@@ -162,16 +340,145 @@ class GenerateSchema:</span>
<span class="w"> </span>        self.model_type_stack = _ModelTypeStack()
<span class="w"> </span>        self.defs = _Definitions()

<span class="gd">-    def str_schema(self) -&gt;CoreSchema:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def __from_parent(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        config_wrapper_stack: ConfigWrapperStack,</span>
<span class="gi">+        types_namespace_stack: TypesNamespaceStack,</span>
<span class="gi">+        model_type_stack: _ModelTypeStack,</span>
<span class="gi">+        typevars_map: dict[Any, Any] | None,</span>
<span class="gi">+        defs: _Definitions,</span>
<span class="gi">+    ) -&gt; GenerateSchema:</span>
<span class="gi">+        obj = cls.__new__(cls)</span>
<span class="gi">+        obj._config_wrapper_stack = config_wrapper_stack</span>
<span class="gi">+        obj._types_namespace_stack = types_namespace_stack</span>
<span class="gi">+        obj.model_type_stack = model_type_stack</span>
<span class="gi">+        obj._typevars_map = typevars_map</span>
<span class="gi">+        obj.field_name_stack = _FieldNameStack()</span>
<span class="gi">+        obj.defs = defs</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _config_wrapper(self) -&gt; ConfigWrapper:</span>
<span class="gi">+        return self._config_wrapper_stack.tail</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _types_namespace(self) -&gt; dict[str, Any] | None:</span>
<span class="gi">+        return self._types_namespace_stack.tail</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _current_generate_schema(self) -&gt; GenerateSchema:</span>
<span class="gi">+        cls = self._config_wrapper.schema_generator or GenerateSchema</span>
<span class="gi">+        return cls.__from_parent(</span>
<span class="gi">+            self._config_wrapper_stack,</span>
<span class="gi">+            self._types_namespace_stack,</span>
<span class="gi">+            self.model_type_stack,</span>
<span class="gi">+            self._typevars_map,</span>
<span class="gi">+            self.defs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _arbitrary_types(self) -&gt; bool:</span>
<span class="gi">+        return self._config_wrapper.arbitrary_types_allowed</span>
<span class="gi">+</span>
<span class="gi">+    def str_schema(self) -&gt; CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a CoreSchema for `str`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        return core_schema.str_schema()</span>
<span class="gi">+</span>
<span class="gi">+    # the following methods can be overridden but should be considered</span>
<span class="gi">+    # unstable / private APIs</span>
<span class="gi">+    def _list_schema(self, tp: Any, items_type: Any) -&gt; CoreSchema:</span>
<span class="gi">+        return core_schema.list_schema(self.generate_schema(items_type))</span>
<span class="gi">+</span>
<span class="gi">+    def _dict_schema(self, tp: Any, keys_type: Any, values_type: Any) -&gt; CoreSchema:</span>
<span class="gi">+        return core_schema.dict_schema(self.generate_schema(keys_type), self.generate_schema(values_type))</span>
<span class="gi">+</span>
<span class="gi">+    def _set_schema(self, tp: Any, items_type: Any) -&gt; CoreSchema:</span>
<span class="gi">+        return core_schema.set_schema(self.generate_schema(items_type))</span>
<span class="gi">+</span>
<span class="gi">+    def _frozenset_schema(self, tp: Any, items_type: Any) -&gt; CoreSchema:</span>
<span class="gi">+        return core_schema.frozenset_schema(self.generate_schema(items_type))</span>
<span class="gi">+</span>
<span class="gi">+    def _arbitrary_type_schema(self, tp: Any) -&gt; CoreSchema:</span>
<span class="gi">+        if not isinstance(tp, type):</span>
<span class="gi">+            warn(</span>
<span class="gi">+                f&#39;{tp!r} is not a Python type (it may be an instance of an object),&#39;</span>
<span class="gi">+                &#39; Pydantic will allow any object with no validation since we cannot even&#39;</span>
<span class="gi">+                &#39; enforce that the input is an instance of the given type.&#39;</span>
<span class="gi">+                &#39; To get rid of this error wrap the type with `pydantic.SkipValidation`.&#39;,</span>
<span class="gi">+                UserWarning,</span>
<span class="gi">+            )</span>
<span class="gi">+            return core_schema.any_schema()</span>
<span class="gi">+        return core_schema.is_instance_schema(tp)</span>
<span class="gi">+</span>
<span class="gi">+    def _unknown_type_schema(self, obj: Any) -&gt; CoreSchema:</span>
<span class="gi">+        raise PydanticSchemaGenerationError(</span>
<span class="gi">+            f&#39;Unable to generate pydantic-core schema for {obj!r}. &#39;</span>
<span class="gi">+            &#39;Set `arbitrary_types_allowed=True` in the model_config to ignore this error&#39;</span>
<span class="gi">+            &#39; or implement `__get_pydantic_core_schema__` on your type to fully support it.&#39;</span>
<span class="gi">+            &#39;\n\nIf you got this error by calling handler(&lt;some type&gt;) within&#39;</span>
<span class="gi">+            &#39; `__get_pydantic_core_schema__` then you likely need to call&#39;</span>
<span class="gi">+            &#39; `handler.generate_schema(&lt;some type&gt;)` since we do not call&#39;</span>
<span class="gi">+            &#39; `__get_pydantic_core_schema__` on `&lt;some type&gt;` otherwise to avoid infinite recursion.&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_discriminator_to_union(</span>
<span class="gi">+        self, schema: CoreSchema, discriminator: str | Discriminator | None</span>
<span class="gi">+    ) -&gt; CoreSchema:</span>
<span class="gi">+        if discriminator is None:</span>
<span class="gi">+            return schema</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _discriminated_union.apply_discriminator(</span>
<span class="gi">+                schema,</span>
<span class="gi">+                discriminator,</span>
<span class="gi">+            )</span>
<span class="gi">+        except _discriminated_union.MissingDefinitionForUnionRef:</span>
<span class="gi">+            # defer until defs are resolved</span>
<span class="gi">+            _discriminated_union.set_discriminator_in_metadata(</span>
<span class="gi">+                schema,</span>
<span class="gi">+                discriminator,</span>
<span class="gi">+            )</span>
<span class="gi">+            return schema</span>

<span class="w"> </span>    class CollectedInvalid(Exception):
<span class="w"> </span>        pass

<span class="gd">-    def generate_schema(self, obj: Any, from_dunder_get_core_schema: bool=True</span>
<span class="gd">-        ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def clean_schema(self, schema: CoreSchema) -&gt; CoreSchema:</span>
<span class="gi">+        schema = self.collect_definitions(schema)</span>
<span class="gi">+        schema = simplify_schema_references(schema)</span>
<span class="gi">+        if collect_invalid_schemas(schema):</span>
<span class="gi">+            raise self.CollectedInvalid()</span>
<span class="gi">+        schema = _discriminated_union.apply_discriminators(schema)</span>
<span class="gi">+        schema = validate_core_schema(schema)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def collect_definitions(self, schema: CoreSchema) -&gt; CoreSchema:</span>
<span class="gi">+        ref = cast(&#39;str | None&#39;, schema.get(&#39;ref&#39;, None))</span>
<span class="gi">+        if ref:</span>
<span class="gi">+            self.defs.definitions[ref] = schema</span>
<span class="gi">+        if &#39;ref&#39; in schema:</span>
<span class="gi">+            schema = core_schema.definition_reference_schema(schema[&#39;ref&#39;])</span>
<span class="gi">+        return core_schema.definitions_schema(</span>
<span class="gi">+            schema,</span>
<span class="gi">+            list(self.defs.definitions.values()),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _add_js_function(self, metadata_schema: CoreSchema, js_function: Callable[..., Any]) -&gt; None:</span>
<span class="gi">+        metadata = CoreMetadataHandler(metadata_schema).metadata</span>
<span class="gi">+        pydantic_js_functions = metadata.setdefault(&#39;pydantic_js_functions&#39;, [])</span>
<span class="gi">+        # because of how we generate core schemas for nested generic models</span>
<span class="gi">+        # we can end up adding `BaseModel.__get_pydantic_json_schema__` multiple times</span>
<span class="gi">+        # this check may fail to catch duplicates if the function is a `functools.partial`</span>
<span class="gi">+        # or something like that</span>
<span class="gi">+        # but if it does it&#39;ll fail by inserting the duplicate</span>
<span class="gi">+        if js_function not in pydantic_js_functions:</span>
<span class="gi">+            pydantic_js_functions.append(js_function)</span>
<span class="gi">+</span>
<span class="gi">+    def generate_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        obj: Any,</span>
<span class="gi">+        from_dunder_get_core_schema: bool = True,</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate core schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -194,36 +501,294 @@ class GenerateSchema:</span>
<span class="w"> </span>                - If `typing.TypedDict` is used instead of `typing_extensions.TypedDict` on Python &lt; 3.12.
<span class="w"> </span>                - If `__modify_schema__` method is used instead of `__get_pydantic_json_schema__`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        schema: CoreSchema | None = None</span>
<span class="gi">+</span>
<span class="gi">+        if from_dunder_get_core_schema:</span>
<span class="gi">+            from_property = self._generate_schema_from_property(obj, obj)</span>
<span class="gi">+            if from_property is not None:</span>
<span class="gi">+                schema = from_property</span>

<span class="gd">-    def _model_schema(self, cls: type[BaseModel]) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        if schema is None:</span>
<span class="gi">+            schema = self._generate_schema_inner(obj)</span>
<span class="gi">+</span>
<span class="gi">+        metadata_js_function = _extract_get_pydantic_json_schema(obj, schema)</span>
<span class="gi">+        if metadata_js_function is not None:</span>
<span class="gi">+            metadata_schema = resolve_original_schema(schema, self.defs.definitions)</span>
<span class="gi">+            if metadata_schema:</span>
<span class="gi">+                self._add_js_function(metadata_schema, metadata_js_function)</span>
<span class="gi">+</span>
<span class="gi">+        schema = _add_custom_serialization_from_json_encoders(self._config_wrapper.json_encoders, obj, schema)</span>
<span class="gi">+</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def _model_schema(self, cls: type[BaseModel]) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a Pydantic model.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.defs.get_schema_or_ref(cls) as (model_ref, maybe_schema):</span>
<span class="gi">+            if maybe_schema is not None:</span>
<span class="gi">+                return maybe_schema</span>
<span class="gi">+</span>
<span class="gi">+            fields = cls.model_fields</span>
<span class="gi">+            decorators = cls.__pydantic_decorators__</span>
<span class="gi">+            computed_fields = decorators.computed_fields</span>
<span class="gi">+            check_decorator_fields_exist(</span>
<span class="gi">+                chain(</span>
<span class="gi">+                    decorators.field_validators.values(),</span>
<span class="gi">+                    decorators.field_serializers.values(),</span>
<span class="gi">+                    decorators.validators.values(),</span>
<span class="gi">+                ),</span>
<span class="gi">+                {*fields.keys(), *computed_fields.keys()},</span>
<span class="gi">+            )</span>
<span class="gi">+            config_wrapper = ConfigWrapper(cls.model_config, check=False)</span>
<span class="gi">+            core_config = config_wrapper.core_config(cls)</span>
<span class="gi">+            title = self._get_model_title_from_config(cls, config_wrapper)</span>
<span class="gi">+            metadata = build_metadata_dict(js_functions=[partial(modify_model_json_schema, cls=cls, title=title)])</span>
<span class="gi">+</span>
<span class="gi">+            model_validators = decorators.model_validators.values()</span>
<span class="gi">+</span>
<span class="gi">+            extras_schema = None</span>
<span class="gi">+            if core_config.get(&#39;extra_fields_behavior&#39;) == &#39;allow&#39;:</span>
<span class="gi">+                assert cls.__mro__[0] is cls</span>
<span class="gi">+                assert cls.__mro__[-1] is object</span>
<span class="gi">+                for candidate_cls in cls.__mro__[:-1]:</span>
<span class="gi">+                    extras_annotation = getattr(candidate_cls, &#39;__annotations__&#39;, {}).get(&#39;__pydantic_extra__&#39;, None)</span>
<span class="gi">+                    if extras_annotation is not None:</span>
<span class="gi">+                        if isinstance(extras_annotation, str):</span>
<span class="gi">+                            extras_annotation = _typing_extra.eval_type_backport(</span>
<span class="gi">+                                _typing_extra._make_forward_ref(extras_annotation, is_argument=False, is_class=True),</span>
<span class="gi">+                                self._types_namespace,</span>
<span class="gi">+                            )</span>
<span class="gi">+                        tp = get_origin(extras_annotation)</span>
<span class="gi">+                        if tp not in (Dict, dict):</span>
<span class="gi">+                            raise PydanticSchemaGenerationError(</span>
<span class="gi">+                                &#39;The type annotation for `__pydantic_extra__` must be `Dict[str, ...]`&#39;</span>
<span class="gi">+                            )</span>
<span class="gi">+                        extra_items_type = self._get_args_resolving_forward_refs(</span>
<span class="gi">+                            extras_annotation,</span>
<span class="gi">+                            required=True,</span>
<span class="gi">+                        )[1]</span>
<span class="gi">+                        if extra_items_type is not Any:</span>
<span class="gi">+                            extras_schema = self.generate_schema(extra_items_type)</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+            with self._config_wrapper_stack.push(config_wrapper), self._types_namespace_stack.push(cls):</span>
<span class="gi">+                self = self._current_generate_schema</span>
<span class="gi">+                if cls.__pydantic_root_model__:</span>
<span class="gi">+                    root_field = self._common_field_schema(&#39;root&#39;, fields[&#39;root&#39;], decorators)</span>
<span class="gi">+                    inner_schema = root_field[&#39;schema&#39;]</span>
<span class="gi">+                    inner_schema = apply_model_validators(inner_schema, model_validators, &#39;inner&#39;)</span>
<span class="gi">+                    model_schema = core_schema.model_schema(</span>
<span class="gi">+                        cls,</span>
<span class="gi">+                        inner_schema,</span>
<span class="gi">+                        custom_init=getattr(cls, &#39;__pydantic_custom_init__&#39;, None),</span>
<span class="gi">+                        root_model=True,</span>
<span class="gi">+                        post_init=getattr(cls, &#39;__pydantic_post_init__&#39;, None),</span>
<span class="gi">+                        config=core_config,</span>
<span class="gi">+                        ref=model_ref,</span>
<span class="gi">+                        metadata=metadata,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    fields_schema: core_schema.CoreSchema = core_schema.model_fields_schema(</span>
<span class="gi">+                        {k: self._generate_md_field_schema(k, v, decorators) for k, v in fields.items()},</span>
<span class="gi">+                        computed_fields=[</span>
<span class="gi">+                            self._computed_field_schema(d, decorators.field_serializers)</span>
<span class="gi">+                            for d in computed_fields.values()</span>
<span class="gi">+                        ],</span>
<span class="gi">+                        extras_schema=extras_schema,</span>
<span class="gi">+                        model_name=cls.__name__,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    inner_schema = apply_validators(fields_schema, decorators.root_validators.values(), None)</span>
<span class="gi">+                    new_inner_schema = define_expected_missing_refs(inner_schema, recursively_defined_type_refs())</span>
<span class="gi">+                    if new_inner_schema is not None:</span>
<span class="gi">+                        inner_schema = new_inner_schema</span>
<span class="gi">+                    inner_schema = apply_model_validators(inner_schema, model_validators, &#39;inner&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                    model_schema = core_schema.model_schema(</span>
<span class="gi">+                        cls,</span>
<span class="gi">+                        inner_schema,</span>
<span class="gi">+                        custom_init=getattr(cls, &#39;__pydantic_custom_init__&#39;, None),</span>
<span class="gi">+                        root_model=False,</span>
<span class="gi">+                        post_init=getattr(cls, &#39;__pydantic_post_init__&#39;, None),</span>
<span class="gi">+                        config=core_config,</span>
<span class="gi">+                        ref=model_ref,</span>
<span class="gi">+                        metadata=metadata,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                schema = self._apply_model_serializers(model_schema, decorators.model_serializers.values())</span>
<span class="gi">+                schema = apply_model_validators(schema, model_validators, &#39;outer&#39;)</span>
<span class="gi">+                self.defs.definitions[model_ref] = schema</span>
<span class="gi">+                return core_schema.definition_reference_schema(model_ref)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _get_model_title_from_config(model: type[BaseModel |</span>
<span class="gd">-        StandardDataclass], config_wrapper: (ConfigWrapper | None)=None) -&gt;(str</span>
<span class="gd">-         | None):</span>
<span class="gi">+    def _get_model_title_from_config(</span>
<span class="gi">+        model: type[BaseModel | StandardDataclass], config_wrapper: ConfigWrapper | None = None</span>
<span class="gi">+    ) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the title of a model if `model_title_generator` or `title` are set in the config, else return None&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if config_wrapper is None:</span>
<span class="gi">+            return None</span>

<span class="gd">-    def _unpack_refs_defs(self, schema: CoreSchema) -&gt;CoreSchema:</span>
<span class="gi">+        if config_wrapper.title:</span>
<span class="gi">+            return config_wrapper.title</span>
<span class="gi">+</span>
<span class="gi">+        model_title_generator = config_wrapper.model_title_generator</span>
<span class="gi">+        if model_title_generator:</span>
<span class="gi">+            title = model_title_generator(model)</span>
<span class="gi">+            if not isinstance(title, str):</span>
<span class="gi">+                raise TypeError(f&#39;model_title_generator {model_title_generator} must return str, not {title.__class__}&#39;)</span>
<span class="gi">+            return title</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack_refs_defs(self, schema: CoreSchema) -&gt; CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Unpack all &#39;definitions&#39; schemas into `GenerateSchema.defs.definitions`
<span class="w"> </span>        and return the inner schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _generate_schema_from_property(self, obj: Any, source: Any) -&gt;(</span>
<span class="gd">-        core_schema.CoreSchema | None):</span>
<span class="gi">+        def get_ref(s: CoreSchema) -&gt; str:</span>
<span class="gi">+            return s[&#39;ref&#39;]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        if schema[&#39;type&#39;] == &#39;definitions&#39;:</span>
<span class="gi">+            self.defs.definitions.update({get_ref(s): s for s in schema[&#39;definitions&#39;]})</span>
<span class="gi">+            schema = schema[&#39;schema&#39;]</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_schema_from_property(self, obj: Any, source: Any) -&gt; core_schema.CoreSchema | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to generate schema from either the `__get_pydantic_core_schema__` function or
<span class="w"> </span>        `__pydantic_core_schema__` property.

<span class="w"> </span>        Note: `__get_pydantic_core_schema__` takes priority so it can
<span class="w"> </span>        decide whether to use a `__pydantic_core_schema__` attribute, or generate a fresh schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def match_type(self, obj: Any) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        # avoid calling `__get_pydantic_core_schema__` if we&#39;ve already visited this object</span>
<span class="gi">+        if is_self_type(obj):</span>
<span class="gi">+            obj = self.model_type_stack.get()</span>
<span class="gi">+        with self.defs.get_schema_or_ref(obj) as (_, maybe_schema):</span>
<span class="gi">+            if maybe_schema is not None:</span>
<span class="gi">+                return maybe_schema</span>
<span class="gi">+        if obj is source:</span>
<span class="gi">+            ref_mode = &#39;unpack&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            ref_mode = &#39;to-def&#39;</span>
<span class="gi">+</span>
<span class="gi">+        schema: CoreSchema</span>
<span class="gi">+</span>
<span class="gi">+        if (get_schema := getattr(obj, &#39;__get_pydantic_core_schema__&#39;, None)) is not None:</span>
<span class="gi">+            if len(inspect.signature(get_schema).parameters) == 1:</span>
<span class="gi">+                # (source) -&gt; CoreSchema</span>
<span class="gi">+                schema = get_schema(source)</span>
<span class="gi">+            else:</span>
<span class="gi">+                schema = get_schema(</span>
<span class="gi">+                    source, CallbackGetCoreSchemaHandler(self._generate_schema_inner, self, ref_mode=ref_mode)</span>
<span class="gi">+                )</span>
<span class="gi">+        # fmt: off</span>
<span class="gi">+        elif (</span>
<span class="gi">+            (existing_schema := getattr(obj, &#39;__pydantic_core_schema__&#39;, None)) is not None</span>
<span class="gi">+            and not isinstance(existing_schema, MockCoreSchema)</span>
<span class="gi">+            and existing_schema.get(&#39;cls&#39;, None) == obj</span>
<span class="gi">+        ):</span>
<span class="gi">+            schema = existing_schema</span>
<span class="gi">+        # fmt: on</span>
<span class="gi">+        elif (validators := getattr(obj, &#39;__get_validators__&#39;, None)) is not None:</span>
<span class="gi">+            warn(</span>
<span class="gi">+                &#39;`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.&#39;,</span>
<span class="gi">+                PydanticDeprecatedSince20,</span>
<span class="gi">+            )</span>
<span class="gi">+            schema = core_schema.chain_schema([core_schema.with_info_plain_validator_function(v) for v in validators()])</span>
<span class="gi">+        else:</span>
<span class="gi">+            # we have no existing schema information on the property, exit early so that we can go generate a schema</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        schema = self._unpack_refs_defs(schema)</span>
<span class="gi">+</span>
<span class="gi">+        if is_function_with_inner_schema(schema):</span>
<span class="gi">+            ref = schema[&#39;schema&#39;].pop(&#39;ref&#39;, None)  # pyright: ignore[reportCallIssue, reportArgumentType]</span>
<span class="gi">+            if ref:</span>
<span class="gi">+                schema[&#39;ref&#39;] = ref</span>
<span class="gi">+        else:</span>
<span class="gi">+            ref = get_ref(schema)</span>
<span class="gi">+</span>
<span class="gi">+        if ref:</span>
<span class="gi">+            self.defs.definitions[ref] = schema</span>
<span class="gi">+            return core_schema.definition_reference_schema(ref)</span>
<span class="gi">+</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def _resolve_forward_ref(self, obj: Any) -&gt; Any:</span>
<span class="gi">+        # we assume that types_namespace has the target of forward references in its scope,</span>
<span class="gi">+        # but this could fail, for example, if calling Validator on an imported type which contains</span>
<span class="gi">+        # forward references to other types only defined in the module from which it was imported</span>
<span class="gi">+        # `Validator(SomeImportedTypeAliasWithAForwardReference)`</span>
<span class="gi">+        # or the equivalent for BaseModel</span>
<span class="gi">+        # class Model(BaseModel):</span>
<span class="gi">+        #   x: SomeImportedTypeAliasWithAForwardReference</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj = _typing_extra.eval_type_backport(obj, globalns=self._types_namespace)</span>
<span class="gi">+        except NameError as e:</span>
<span class="gi">+            raise PydanticUndefinedAnnotation.from_name_error(e) from e</span>
<span class="gi">+</span>
<span class="gi">+        # if obj is still a ForwardRef, it means we can&#39;t evaluate it, raise PydanticUndefinedAnnotation</span>
<span class="gi">+        if isinstance(obj, ForwardRef):</span>
<span class="gi">+            raise PydanticUndefinedAnnotation(obj.__forward_arg__, f&#39;Unable to evaluate forward reference {obj}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self._typevars_map:</span>
<span class="gi">+            obj = replace_types(obj, self._typevars_map)</span>
<span class="gi">+</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def _get_args_resolving_forward_refs(self, obj: Any, required: Literal[True]) -&gt; tuple[Any, ...]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def _get_args_resolving_forward_refs(self, obj: Any) -&gt; tuple[Any, ...] | None: ...</span>
<span class="gi">+</span>
<span class="gi">+    def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -&gt; tuple[Any, ...] | None:</span>
<span class="gi">+        args = get_args(obj)</span>
<span class="gi">+        if args:</span>
<span class="gi">+            args = tuple([self._resolve_forward_ref(a) if isinstance(a, ForwardRef) else a for a in args])</span>
<span class="gi">+        elif required:  # pragma: no cover</span>
<span class="gi">+            raise TypeError(f&#39;Expected {obj} to have generic parameters but it had none&#39;)</span>
<span class="gi">+        return args</span>
<span class="gi">+</span>
<span class="gi">+    def _get_first_arg_or_any(self, obj: Any) -&gt; Any:</span>
<span class="gi">+        args = self._get_args_resolving_forward_refs(obj)</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            return Any</span>
<span class="gi">+        return args[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_first_two_args_or_any(self, obj: Any) -&gt; tuple[Any, Any]:</span>
<span class="gi">+        args = self._get_args_resolving_forward_refs(obj)</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            return (Any, Any)</span>
<span class="gi">+        if len(args) &lt; 2:</span>
<span class="gi">+            origin = get_origin(obj)</span>
<span class="gi">+            raise TypeError(f&#39;Expected two type arguments for {origin}, got 1&#39;)</span>
<span class="gi">+        return args[0], args[1]</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_schema_inner(self, obj: Any) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        if isinstance(obj, _AnnotatedType):</span>
<span class="gi">+            return self._annotated_schema(obj)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(obj, dict):</span>
<span class="gi">+            # we assume this is already a valid schema</span>
<span class="gi">+            return obj  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(obj, str):</span>
<span class="gi">+            obj = ForwardRef(obj)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(obj, ForwardRef):</span>
<span class="gi">+            return self.generate_schema(self._resolve_forward_ref(obj))</span>
<span class="gi">+</span>
<span class="gi">+        from ..main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+        if lenient_issubclass(obj, BaseModel):</span>
<span class="gi">+            with self.model_type_stack.push(obj):</span>
<span class="gi">+                return self._model_schema(obj)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(obj, PydanticRecursiveRef):</span>
<span class="gi">+            return core_schema.definition_reference_schema(schema_ref=obj.type_ref)</span>
<span class="gi">+</span>
<span class="gi">+        return self.match_type(obj)</span>
<span class="gi">+</span>
<span class="gi">+    def match_type(self, obj: Any) -&gt; core_schema.CoreSchema:  # noqa: C901</span>
<span class="w"> </span>        &quot;&quot;&quot;Main mapping of types to schemas.

<span class="w"> </span>        The general structure is a series of if statements starting with the simple cases
<span class="gu">@@ -236,28 +801,184 @@ class GenerateSchema:</span>
<span class="w"> </span>        The idea is that we&#39;ll evolve this into adding more and more user facing methods over time
<span class="w"> </span>        as they get requested and we figure out what the right API for them is.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _generate_td_field_schema(self, name: str, field_info: FieldInfo,</span>
<span class="gd">-        decorators: DecoratorInfos, *, required: bool=True</span>
<span class="gd">-        ) -&gt;core_schema.TypedDictField:</span>
<span class="gi">+        if obj is str:</span>
<span class="gi">+            return self.str_schema()</span>
<span class="gi">+        elif obj is bytes:</span>
<span class="gi">+            return core_schema.bytes_schema()</span>
<span class="gi">+        elif obj is int:</span>
<span class="gi">+            return core_schema.int_schema()</span>
<span class="gi">+        elif obj is float:</span>
<span class="gi">+            return core_schema.float_schema()</span>
<span class="gi">+        elif obj is bool:</span>
<span class="gi">+            return core_schema.bool_schema()</span>
<span class="gi">+        elif obj is Any or obj is object:</span>
<span class="gi">+            return core_schema.any_schema()</span>
<span class="gi">+        elif obj is None or obj is _typing_extra.NoneType:</span>
<span class="gi">+            return core_schema.none_schema()</span>
<span class="gi">+        elif obj in TUPLE_TYPES:</span>
<span class="gi">+            return self._tuple_schema(obj)</span>
<span class="gi">+        elif obj in LIST_TYPES:</span>
<span class="gi">+            return self._list_schema(obj, self._get_first_arg_or_any(obj))</span>
<span class="gi">+        elif obj in SET_TYPES:</span>
<span class="gi">+            return self._set_schema(obj, self._get_first_arg_or_any(obj))</span>
<span class="gi">+        elif obj in FROZEN_SET_TYPES:</span>
<span class="gi">+            return self._frozenset_schema(obj, self._get_first_arg_or_any(obj))</span>
<span class="gi">+        elif obj in DICT_TYPES:</span>
<span class="gi">+            return self._dict_schema(obj, *self._get_first_two_args_or_any(obj))</span>
<span class="gi">+        elif isinstance(obj, TypeAliasType):</span>
<span class="gi">+            return self._type_alias_type_schema(obj)</span>
<span class="gi">+        elif obj is type:</span>
<span class="gi">+            return self._type_schema()</span>
<span class="gi">+        elif _typing_extra.is_callable_type(obj):</span>
<span class="gi">+            return core_schema.callable_schema()</span>
<span class="gi">+        elif _typing_extra.is_literal_type(obj):</span>
<span class="gi">+            return self._literal_schema(obj)</span>
<span class="gi">+        elif is_typeddict(obj):</span>
<span class="gi">+            return self._typed_dict_schema(obj, None)</span>
<span class="gi">+        elif _typing_extra.is_namedtuple(obj):</span>
<span class="gi">+            return self._namedtuple_schema(obj, None)</span>
<span class="gi">+        elif _typing_extra.is_new_type(obj):</span>
<span class="gi">+            # NewType, can&#39;t use isinstance because it fails &lt;3.10</span>
<span class="gi">+            return self.generate_schema(obj.__supertype__)</span>
<span class="gi">+        elif obj == re.Pattern:</span>
<span class="gi">+            return self._pattern_schema(obj)</span>
<span class="gi">+        elif obj is collections.abc.Hashable or obj is typing.Hashable:</span>
<span class="gi">+            return self._hashable_schema()</span>
<span class="gi">+        elif isinstance(obj, typing.TypeVar):</span>
<span class="gi">+            return self._unsubstituted_typevar_schema(obj)</span>
<span class="gi">+        elif is_finalvar(obj):</span>
<span class="gi">+            if obj is Final:</span>
<span class="gi">+                return core_schema.any_schema()</span>
<span class="gi">+            return self.generate_schema(</span>
<span class="gi">+                self._get_first_arg_or_any(obj),</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(obj, (FunctionType, LambdaType, MethodType, partial)):</span>
<span class="gi">+            return self._callable_schema(obj)</span>
<span class="gi">+        elif inspect.isclass(obj) and issubclass(obj, Enum):</span>
<span class="gi">+            from ._std_types_schema import get_enum_core_schema</span>
<span class="gi">+</span>
<span class="gi">+            return get_enum_core_schema(obj, self._config_wrapper.config_dict)</span>
<span class="gi">+</span>
<span class="gi">+        if _typing_extra.is_dataclass(obj):</span>
<span class="gi">+            return self._dataclass_schema(obj, None)</span>
<span class="gi">+        res = self._get_prepare_pydantic_annotations_for_known_type(obj, ())</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            source_type, annotations = res</span>
<span class="gi">+            return self._apply_annotations(source_type, annotations)</span>
<span class="gi">+</span>
<span class="gi">+        origin = get_origin(obj)</span>
<span class="gi">+        if origin is not None:</span>
<span class="gi">+            return self._match_generic_type(obj, origin)</span>
<span class="gi">+</span>
<span class="gi">+        if self._arbitrary_types:</span>
<span class="gi">+            return self._arbitrary_type_schema(obj)</span>
<span class="gi">+        return self._unknown_type_schema(obj)</span>
<span class="gi">+</span>
<span class="gi">+    def _match_generic_type(self, obj: Any, origin: Any) -&gt; CoreSchema:  # noqa: C901</span>
<span class="gi">+        if isinstance(origin, TypeAliasType):</span>
<span class="gi">+            return self._type_alias_type_schema(obj)</span>
<span class="gi">+</span>
<span class="gi">+        # Need to handle generic dataclasses before looking for the schema properties because attribute accesses</span>
<span class="gi">+        # on _GenericAlias delegate to the origin type, so lose the information about the concrete parametrization</span>
<span class="gi">+        # As a result, currently, there is no way to cache the schema for generic dataclasses. This may be possible</span>
<span class="gi">+        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game.</span>
<span class="gi">+        if _typing_extra.is_dataclass(origin):</span>
<span class="gi">+            return self._dataclass_schema(obj, origin)</span>
<span class="gi">+        if _typing_extra.is_namedtuple(origin):</span>
<span class="gi">+            return self._namedtuple_schema(obj, origin)</span>
<span class="gi">+</span>
<span class="gi">+        from_property = self._generate_schema_from_property(origin, obj)</span>
<span class="gi">+        if from_property is not None:</span>
<span class="gi">+            return from_property</span>
<span class="gi">+</span>
<span class="gi">+        if _typing_extra.origin_is_union(origin):</span>
<span class="gi">+            return self._union_schema(obj)</span>
<span class="gi">+        elif origin in TUPLE_TYPES:</span>
<span class="gi">+            return self._tuple_schema(obj)</span>
<span class="gi">+        elif origin in LIST_TYPES:</span>
<span class="gi">+            return self._list_schema(obj, self._get_first_arg_or_any(obj))</span>
<span class="gi">+        elif origin in SET_TYPES:</span>
<span class="gi">+            return self._set_schema(obj, self._get_first_arg_or_any(obj))</span>
<span class="gi">+        elif origin in FROZEN_SET_TYPES:</span>
<span class="gi">+            return self._frozenset_schema(obj, self._get_first_arg_or_any(obj))</span>
<span class="gi">+        elif origin in DICT_TYPES:</span>
<span class="gi">+            return self._dict_schema(obj, *self._get_first_two_args_or_any(obj))</span>
<span class="gi">+        elif is_typeddict(origin):</span>
<span class="gi">+            return self._typed_dict_schema(obj, origin)</span>
<span class="gi">+        elif origin in (typing.Type, type):</span>
<span class="gi">+            return self._subclass_schema(obj)</span>
<span class="gi">+        elif origin in {typing.Sequence, collections.abc.Sequence}:</span>
<span class="gi">+            return self._sequence_schema(obj)</span>
<span class="gi">+        elif origin in {typing.Iterable, collections.abc.Iterable, typing.Generator, collections.abc.Generator}:</span>
<span class="gi">+            return self._iterable_schema(obj)</span>
<span class="gi">+        elif origin in (re.Pattern, typing.Pattern):</span>
<span class="gi">+            return self._pattern_schema(obj)</span>
<span class="gi">+</span>
<span class="gi">+        if self._arbitrary_types:</span>
<span class="gi">+            return self._arbitrary_type_schema(origin)</span>
<span class="gi">+        return self._unknown_type_schema(obj)</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_td_field_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        field_info: FieldInfo,</span>
<span class="gi">+        decorators: DecoratorInfos,</span>
<span class="gi">+        *,</span>
<span class="gi">+        required: bool = True,</span>
<span class="gi">+    ) -&gt; core_schema.TypedDictField:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepare a TypedDictField to represent a model or typeddict field.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _generate_md_field_schema(self, name: str, field_info: FieldInfo,</span>
<span class="gd">-        decorators: DecoratorInfos) -&gt;core_schema.ModelField:</span>
<span class="gi">+        common_field = self._common_field_schema(name, field_info, decorators)</span>
<span class="gi">+        return core_schema.typed_dict_field(</span>
<span class="gi">+            common_field[&#39;schema&#39;],</span>
<span class="gi">+            required=False if not field_info.is_required() else required,</span>
<span class="gi">+            serialization_exclude=common_field[&#39;serialization_exclude&#39;],</span>
<span class="gi">+            validation_alias=common_field[&#39;validation_alias&#39;],</span>
<span class="gi">+            serialization_alias=common_field[&#39;serialization_alias&#39;],</span>
<span class="gi">+            metadata=common_field[&#39;metadata&#39;],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_md_field_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        field_info: FieldInfo,</span>
<span class="gi">+        decorators: DecoratorInfos,</span>
<span class="gi">+    ) -&gt; core_schema.ModelField:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepare a ModelField to represent a model field.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _generate_dc_field_schema(self, name: str, field_info: FieldInfo,</span>
<span class="gd">-        decorators: DecoratorInfos) -&gt;core_schema.DataclassField:</span>
<span class="gi">+        common_field = self._common_field_schema(name, field_info, decorators)</span>
<span class="gi">+        return core_schema.model_field(</span>
<span class="gi">+            common_field[&#39;schema&#39;],</span>
<span class="gi">+            serialization_exclude=common_field[&#39;serialization_exclude&#39;],</span>
<span class="gi">+            validation_alias=common_field[&#39;validation_alias&#39;],</span>
<span class="gi">+            serialization_alias=common_field[&#39;serialization_alias&#39;],</span>
<span class="gi">+            frozen=common_field[&#39;frozen&#39;],</span>
<span class="gi">+            metadata=common_field[&#39;metadata&#39;],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_dc_field_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        field_info: FieldInfo,</span>
<span class="gi">+        decorators: DecoratorInfos,</span>
<span class="gi">+    ) -&gt; core_schema.DataclassField:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepare a DataclassField to represent the parameter/field, of a dataclass.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        common_field = self._common_field_schema(name, field_info, decorators)</span>
<span class="gi">+        return core_schema.dataclass_field(</span>
<span class="gi">+            name,</span>
<span class="gi">+            common_field[&#39;schema&#39;],</span>
<span class="gi">+            init=field_info.init,</span>
<span class="gi">+            init_only=field_info.init_var or None,</span>
<span class="gi">+            kw_only=None if field_info.kw_only else False,</span>
<span class="gi">+            serialization_exclude=common_field[&#39;serialization_exclude&#39;],</span>
<span class="gi">+            validation_alias=common_field[&#39;validation_alias&#39;],</span>
<span class="gi">+            serialization_alias=common_field[&#39;serialization_alias&#39;],</span>
<span class="gi">+            frozen=common_field[&#39;frozen&#39;],</span>
<span class="gi">+            metadata=common_field[&#39;metadata&#39;],</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _apply_alias_generator_to_field_info(alias_generator: (Callable[[</span>
<span class="gd">-        str], str] | AliasGenerator), field_info: FieldInfo, field_name: str</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _apply_alias_generator_to_field_info(</span>
<span class="gi">+        alias_generator: Callable[[str], str] | AliasGenerator, field_info: FieldInfo, field_name: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply an alias_generator to aliases on a FieldInfo instance if appropriate.

<span class="w"> </span>        Args:
<span class="gu">@@ -265,12 +986,51 @@ class GenerateSchema:</span>
<span class="w"> </span>            field_info: The FieldInfo instance to which the alias_generator is (maybe) applied.
<span class="w"> </span>            field_name: The name of the field from which to generate the alias.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Apply an alias_generator if</span>
<span class="gi">+        # 1. An alias is not specified</span>
<span class="gi">+        # 2. An alias is specified, but the priority is &lt;= 1</span>
<span class="gi">+        if (</span>
<span class="gi">+            field_info.alias_priority is None</span>
<span class="gi">+            or field_info.alias_priority &lt;= 1</span>
<span class="gi">+            or field_info.alias is None</span>
<span class="gi">+            or field_info.validation_alias is None</span>
<span class="gi">+            or field_info.serialization_alias is None</span>
<span class="gi">+        ):</span>
<span class="gi">+            alias, validation_alias, serialization_alias = None, None, None</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(alias_generator, AliasGenerator):</span>
<span class="gi">+                alias, validation_alias, serialization_alias = alias_generator.generate_aliases(field_name)</span>
<span class="gi">+            elif isinstance(alias_generator, Callable):</span>
<span class="gi">+                alias = alias_generator(field_name)</span>
<span class="gi">+                if not isinstance(alias, str):</span>
<span class="gi">+                    raise TypeError(f&#39;alias_generator {alias_generator} must return str, not {alias.__class__}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            # if priority is not set, we set to 1</span>
<span class="gi">+            # which supports the case where the alias_generator from a child class is used</span>
<span class="gi">+            # to generate an alias for a field in a parent class</span>
<span class="gi">+            if field_info.alias_priority is None or field_info.alias_priority &lt;= 1:</span>
<span class="gi">+                field_info.alias_priority = 1</span>
<span class="gi">+</span>
<span class="gi">+            # if the priority is 1, then we set the aliases to the generated alias</span>
<span class="gi">+            if field_info.alias_priority == 1:</span>
<span class="gi">+                field_info.serialization_alias = _get_first_non_null(serialization_alias, alias)</span>
<span class="gi">+                field_info.validation_alias = _get_first_non_null(validation_alias, alias)</span>
<span class="gi">+                field_info.alias = alias</span>
<span class="gi">+</span>
<span class="gi">+            # if any of the aliases are not set, then we set them to the corresponding generated alias</span>
<span class="gi">+            if field_info.alias is None:</span>
<span class="gi">+                field_info.alias = alias</span>
<span class="gi">+            if field_info.serialization_alias is None:</span>
<span class="gi">+                field_info.serialization_alias = _get_first_non_null(serialization_alias, alias)</span>
<span class="gi">+            if field_info.validation_alias is None:</span>
<span class="gi">+                field_info.validation_alias = _get_first_non_null(validation_alias, alias)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _apply_alias_generator_to_computed_field_info(alias_generator: (</span>
<span class="gd">-        Callable[[str], str] | AliasGenerator), computed_field_info:</span>
<span class="gd">-        ComputedFieldInfo, computed_field_name: str):</span>
<span class="gi">+    def _apply_alias_generator_to_computed_field_info(</span>
<span class="gi">+        alias_generator: Callable[[str], str] | AliasGenerator,</span>
<span class="gi">+        computed_field_info: ComputedFieldInfo,</span>
<span class="gi">+        computed_field_name: str,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply an alias_generator to alias on a ComputedFieldInfo instance if appropriate.

<span class="w"> </span>        Args:
<span class="gu">@@ -278,30 +1038,219 @@ class GenerateSchema:</span>
<span class="w"> </span>            computed_field_info: The ComputedFieldInfo instance to which the alias_generator is (maybe) applied.
<span class="w"> </span>            computed_field_name: The name of the computed field from which to generate the alias.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Apply an alias_generator if</span>
<span class="gi">+        # 1. An alias is not specified</span>
<span class="gi">+        # 2. An alias is specified, but the priority is &lt;= 1</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            computed_field_info.alias_priority is None</span>
<span class="gi">+            or computed_field_info.alias_priority &lt;= 1</span>
<span class="gi">+            or computed_field_info.alias is None</span>
<span class="gi">+        ):</span>
<span class="gi">+            alias, validation_alias, serialization_alias = None, None, None</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(alias_generator, AliasGenerator):</span>
<span class="gi">+                alias, validation_alias, serialization_alias = alias_generator.generate_aliases(computed_field_name)</span>
<span class="gi">+            elif isinstance(alias_generator, Callable):</span>
<span class="gi">+                alias = alias_generator(computed_field_name)</span>
<span class="gi">+                if not isinstance(alias, str):</span>
<span class="gi">+                    raise TypeError(f&#39;alias_generator {alias_generator} must return str, not {alias.__class__}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            # if priority is not set, we set to 1</span>
<span class="gi">+            # which supports the case where the alias_generator from a child class is used</span>
<span class="gi">+            # to generate an alias for a field in a parent class</span>
<span class="gi">+            if computed_field_info.alias_priority is None or computed_field_info.alias_priority &lt;= 1:</span>
<span class="gi">+                computed_field_info.alias_priority = 1</span>
<span class="gi">+</span>
<span class="gi">+            # if the priority is 1, then we set the aliases to the generated alias</span>
<span class="gi">+            # note that we use the serialization_alias with priority over alias, as computed_field</span>
<span class="gi">+            # aliases are used for serialization only (not validation)</span>
<span class="gi">+            if computed_field_info.alias_priority == 1:</span>
<span class="gi">+                computed_field_info.alias = _get_first_non_null(serialization_alias, alias)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _apply_field_title_generator_to_field_info(config_wrapper:</span>
<span class="gd">-        ConfigWrapper, field_info: (FieldInfo | ComputedFieldInfo),</span>
<span class="gd">-        field_name: str) -&gt;None:</span>
<span class="gi">+    def _apply_field_title_generator_to_field_info(</span>
<span class="gi">+        config_wrapper: ConfigWrapper, field_info: FieldInfo | ComputedFieldInfo, field_name: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply a field_title_generator on a FieldInfo or ComputedFieldInfo instance if appropriate
<span class="w"> </span>        Args:
<span class="w"> </span>            config_wrapper: The config of the model
<span class="w"> </span>            field_info: The FieldInfo or ComputedField instance to which the title_generator is (maybe) applied.
<span class="w"> </span>            field_name: The name of the field from which to generate the title.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _union_schema(self, union_type: Any) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        field_title_generator = field_info.field_title_generator or config_wrapper.field_title_generator</span>
<span class="gi">+</span>
<span class="gi">+        if field_title_generator is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if field_info.title is None:</span>
<span class="gi">+            title = field_title_generator(field_name, field_info)  # type: ignore</span>
<span class="gi">+            if not isinstance(title, str):</span>
<span class="gi">+                raise TypeError(f&#39;field_title_generator {field_title_generator} must return str, not {title.__class__}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            field_info.title = title</span>
<span class="gi">+</span>
<span class="gi">+    def _common_field_schema(  # C901</span>
<span class="gi">+        self, name: str, field_info: FieldInfo, decorators: DecoratorInfos</span>
<span class="gi">+    ) -&gt; _CommonField:</span>
<span class="gi">+        # Update FieldInfo annotation if appropriate:</span>
<span class="gi">+        from .. import AliasChoices, AliasPath</span>
<span class="gi">+        from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+        if has_instance_in_type(field_info.annotation, (ForwardRef, str)):</span>
<span class="gi">+            types_namespace = self._types_namespace</span>
<span class="gi">+            if self._typevars_map:</span>
<span class="gi">+                types_namespace = (types_namespace or {}).copy()</span>
<span class="gi">+                # Ensure that typevars get mapped to their concrete types:</span>
<span class="gi">+                types_namespace.update({k.__name__: v for k, v in self._typevars_map.items()})</span>
<span class="gi">+</span>
<span class="gi">+            evaluated = _typing_extra.eval_type_lenient(field_info.annotation, types_namespace)</span>
<span class="gi">+            if evaluated is not field_info.annotation and not has_instance_in_type(evaluated, PydanticRecursiveRef):</span>
<span class="gi">+                new_field_info = FieldInfo.from_annotation(evaluated)</span>
<span class="gi">+                field_info.annotation = new_field_info.annotation</span>
<span class="gi">+</span>
<span class="gi">+                # Handle any field info attributes that may have been obtained from now-resolved annotations</span>
<span class="gi">+                for k, v in new_field_info._attributes_set.items():</span>
<span class="gi">+                    # If an attribute is already set, it means it was set by assigning to a call to Field (or just a</span>
<span class="gi">+                    # default value), and that should take the highest priority. So don&#39;t overwrite existing attributes.</span>
<span class="gi">+                    # We skip over &quot;attributes&quot; that are present in the metadata_lookup dict because these won&#39;t</span>
<span class="gi">+                    # actually end up as attributes of the `FieldInfo` instance.</span>
<span class="gi">+                    if k not in field_info._attributes_set and k not in field_info.metadata_lookup:</span>
<span class="gi">+                        setattr(field_info, k, v)</span>
<span class="gi">+</span>
<span class="gi">+                # Finally, ensure the field info also reflects all the `_attributes_set` that are actually metadata.</span>
<span class="gi">+                field_info.metadata = [*new_field_info.metadata, *field_info.metadata]</span>
<span class="gi">+</span>
<span class="gi">+        source_type, annotations = field_info.annotation, field_info.metadata</span>
<span class="gi">+</span>
<span class="gi">+        def set_discriminator(schema: CoreSchema) -&gt; CoreSchema:</span>
<span class="gi">+            schema = self._apply_discriminator_to_union(schema, field_info.discriminator)</span>
<span class="gi">+            return schema</span>
<span class="gi">+</span>
<span class="gi">+        with self.field_name_stack.push(name):</span>
<span class="gi">+            if field_info.discriminator is not None:</span>
<span class="gi">+                schema = self._apply_annotations(source_type, annotations, transform_inner_schema=set_discriminator)</span>
<span class="gi">+            else:</span>
<span class="gi">+                schema = self._apply_annotations(</span>
<span class="gi">+                    source_type,</span>
<span class="gi">+                    annotations,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # This V1 compatibility shim should eventually be removed</span>
<span class="gi">+        # push down any `each_item=True` validators</span>
<span class="gi">+        # note that this won&#39;t work for any Annotated types that get wrapped by a function validator</span>
<span class="gi">+        # but that&#39;s okay because that didn&#39;t exist in V1</span>
<span class="gi">+        this_field_validators = filter_field_decorator_info_by_field(decorators.validators.values(), name)</span>
<span class="gi">+        if _validators_require_validate_default(this_field_validators):</span>
<span class="gi">+            field_info.validate_default = True</span>
<span class="gi">+        each_item_validators = [v for v in this_field_validators if v.info.each_item is True]</span>
<span class="gi">+        this_field_validators = [v for v in this_field_validators if v not in each_item_validators]</span>
<span class="gi">+        schema = apply_each_item_validators(schema, each_item_validators, name)</span>
<span class="gi">+</span>
<span class="gi">+        schema = apply_validators(schema, filter_field_decorator_info_by_field(this_field_validators, name), name)</span>
<span class="gi">+        schema = apply_validators(</span>
<span class="gi">+            schema, filter_field_decorator_info_by_field(decorators.field_validators.values(), name), name</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # the default validator needs to go outside of any other validators</span>
<span class="gi">+        # so that it is the topmost validator for the field validator</span>
<span class="gi">+        # which uses it to check if the field has a default value or not</span>
<span class="gi">+        if not field_info.is_required():</span>
<span class="gi">+            schema = wrap_default(field_info, schema)</span>
<span class="gi">+</span>
<span class="gi">+        schema = self._apply_field_serializers(</span>
<span class="gi">+            schema, filter_field_decorator_info_by_field(decorators.field_serializers.values(), name)</span>
<span class="gi">+        )</span>
<span class="gi">+        self._apply_field_title_generator_to_field_info(self._config_wrapper, field_info, name)</span>
<span class="gi">+</span>
<span class="gi">+        json_schema_updates = {</span>
<span class="gi">+            &#39;title&#39;: field_info.title,</span>
<span class="gi">+            &#39;description&#39;: field_info.description,</span>
<span class="gi">+            &#39;deprecated&#39;: bool(field_info.deprecated) or field_info.deprecated == &#39;&#39; or None,</span>
<span class="gi">+            &#39;examples&#39;: to_jsonable_python(field_info.examples),</span>
<span class="gi">+        }</span>
<span class="gi">+        json_schema_updates = {k: v for k, v in json_schema_updates.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+        json_schema_extra = field_info.json_schema_extra</span>
<span class="gi">+</span>
<span class="gi">+        metadata = build_metadata_dict(</span>
<span class="gi">+            js_annotation_functions=[get_json_schema_update_func(json_schema_updates, json_schema_extra)]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        alias_generator = self._config_wrapper.alias_generator</span>
<span class="gi">+        if alias_generator is not None:</span>
<span class="gi">+            self._apply_alias_generator_to_field_info(alias_generator, field_info, name)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(field_info.validation_alias, (AliasChoices, AliasPath)):</span>
<span class="gi">+            validation_alias = field_info.validation_alias.convert_to_aliases()</span>
<span class="gi">+        else:</span>
<span class="gi">+            validation_alias = field_info.validation_alias</span>
<span class="gi">+</span>
<span class="gi">+        return _common_field(</span>
<span class="gi">+            schema,</span>
<span class="gi">+            serialization_exclude=True if field_info.exclude else None,</span>
<span class="gi">+            validation_alias=validation_alias,</span>
<span class="gi">+            serialization_alias=field_info.serialization_alias,</span>
<span class="gi">+            frozen=field_info.frozen,</span>
<span class="gi">+            metadata=metadata,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _union_schema(self, union_type: Any) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a Union.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _literal_schema(self, literal_type: Any) -&gt;CoreSchema:</span>
<span class="gi">+        args = self._get_args_resolving_forward_refs(union_type, required=True)</span>
<span class="gi">+        choices: list[CoreSchema] = []</span>
<span class="gi">+        nullable = False</span>
<span class="gi">+        for arg in args:</span>
<span class="gi">+            if arg is None or arg is _typing_extra.NoneType:</span>
<span class="gi">+                nullable = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                choices.append(self.generate_schema(arg))</span>
<span class="gi">+</span>
<span class="gi">+        if len(choices) == 1:</span>
<span class="gi">+            s = choices[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            choices_with_tags: list[CoreSchema | tuple[CoreSchema, str]] = []</span>
<span class="gi">+            for choice in choices:</span>
<span class="gi">+                tag = choice.get(&#39;metadata&#39;, {}).get(_core_utils.TAGGED_UNION_TAG_KEY)</span>
<span class="gi">+                if tag is not None:</span>
<span class="gi">+                    choices_with_tags.append((choice, tag))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    choices_with_tags.append(choice)</span>
<span class="gi">+            s = core_schema.union_schema(choices_with_tags)</span>
<span class="gi">+</span>
<span class="gi">+        if nullable:</span>
<span class="gi">+            s = core_schema.nullable_schema(s)</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def _type_alias_type_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        obj: Any,  # TypeAliasType</span>
<span class="gi">+    ) -&gt; CoreSchema:</span>
<span class="gi">+        with self.defs.get_schema_or_ref(obj) as (ref, maybe_schema):</span>
<span class="gi">+            if maybe_schema is not None:</span>
<span class="gi">+                return maybe_schema</span>
<span class="gi">+</span>
<span class="gi">+            origin = get_origin(obj) or obj</span>
<span class="gi">+</span>
<span class="gi">+            annotation = origin.__value__</span>
<span class="gi">+            typevars_map = get_standard_typevars_map(obj)</span>
<span class="gi">+</span>
<span class="gi">+            with self._types_namespace_stack.push(origin):</span>
<span class="gi">+                annotation = _typing_extra.eval_type_lenient(annotation, self._types_namespace)</span>
<span class="gi">+                annotation = replace_types(annotation, typevars_map)</span>
<span class="gi">+                schema = self.generate_schema(annotation)</span>
<span class="gi">+                assert schema[&#39;type&#39;] != &#39;definitions&#39;</span>
<span class="gi">+                schema[&#39;ref&#39;] = ref  # type: ignore</span>
<span class="gi">+            self.defs.definitions[ref] = schema</span>
<span class="gi">+            return core_schema.definition_reference_schema(ref)</span>
<span class="gi">+</span>
<span class="gi">+    def _literal_schema(self, literal_type: Any) -&gt; CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a Literal.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expected = _typing_extra.all_literal_values(literal_type)</span>
<span class="gi">+        assert expected, f&#39;literal &quot;expected&quot; cannot be empty, obj={literal_type}&#39;</span>
<span class="gi">+        return core_schema.literal_schema(expected)</span>

<span class="gd">-    def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any</span>
<span class="gd">-        ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a TypedDict.

<span class="w"> </span>        It is not possible to track required/optional keys in TypedDict without __required_keys__
<span class="gu">@@ -317,106 +1266,846 @@ class GenerateSchema:</span>
<span class="w"> </span>        Hence to avoid creating validators that do not do what users expect we only
<span class="w"> </span>        support typing.TypedDict on Python &gt;= 3.12 or typing_extension.TypedDict on all versions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _namedtuple_schema(self, namedtuple_cls: Any, origin: Any</span>
<span class="gd">-        ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+        with self.model_type_stack.push(typed_dict_cls), self.defs.get_schema_or_ref(typed_dict_cls) as (</span>
<span class="gi">+            typed_dict_ref,</span>
<span class="gi">+            maybe_schema,</span>
<span class="gi">+        ):</span>
<span class="gi">+            if maybe_schema is not None:</span>
<span class="gi">+                return maybe_schema</span>
<span class="gi">+</span>
<span class="gi">+            typevars_map = get_standard_typevars_map(typed_dict_cls)</span>
<span class="gi">+            if origin is not None:</span>
<span class="gi">+                typed_dict_cls = origin</span>
<span class="gi">+</span>
<span class="gi">+            if not _SUPPORTS_TYPEDDICT and type(typed_dict_cls).__module__ == &#39;typing&#39;:</span>
<span class="gi">+                raise PydanticUserError(</span>
<span class="gi">+                    &#39;Please use `typing_extensions.TypedDict` instead of `typing.TypedDict` on Python &lt; 3.12.&#39;,</span>
<span class="gi">+                    code=&#39;typed-dict-version&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                config: ConfigDict | None = get_attribute_from_bases(typed_dict_cls, &#39;__pydantic_config__&#39;)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                config = None</span>
<span class="gi">+</span>
<span class="gi">+            with self._config_wrapper_stack.push(config), self._types_namespace_stack.push(typed_dict_cls):</span>
<span class="gi">+                core_config = self._config_wrapper.core_config(typed_dict_cls)</span>
<span class="gi">+</span>
<span class="gi">+                self = self._current_generate_schema</span>
<span class="gi">+</span>
<span class="gi">+                required_keys: frozenset[str] = typed_dict_cls.__required_keys__</span>
<span class="gi">+</span>
<span class="gi">+                fields: dict[str, core_schema.TypedDictField] = {}</span>
<span class="gi">+</span>
<span class="gi">+                decorators = DecoratorInfos.build(typed_dict_cls)</span>
<span class="gi">+</span>
<span class="gi">+                if self._config_wrapper.use_attribute_docstrings:</span>
<span class="gi">+                    field_docstrings = extract_docstrings_from_cls(typed_dict_cls, use_inspect=True)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    field_docstrings = None</span>
<span class="gi">+</span>
<span class="gi">+                for field_name, annotation in get_type_hints_infer_globalns(</span>
<span class="gi">+                    typed_dict_cls, localns=self._types_namespace, include_extras=True</span>
<span class="gi">+                ).items():</span>
<span class="gi">+                    annotation = replace_types(annotation, typevars_map)</span>
<span class="gi">+                    required = field_name in required_keys</span>
<span class="gi">+</span>
<span class="gi">+                    if get_origin(annotation) == _typing_extra.Required:</span>
<span class="gi">+                        required = True</span>
<span class="gi">+                        annotation = self._get_args_resolving_forward_refs(</span>
<span class="gi">+                            annotation,</span>
<span class="gi">+                            required=True,</span>
<span class="gi">+                        )[0]</span>
<span class="gi">+                    elif get_origin(annotation) == _typing_extra.NotRequired:</span>
<span class="gi">+                        required = False</span>
<span class="gi">+                        annotation = self._get_args_resolving_forward_refs(</span>
<span class="gi">+                            annotation,</span>
<span class="gi">+                            required=True,</span>
<span class="gi">+                        )[0]</span>
<span class="gi">+</span>
<span class="gi">+                    field_info = FieldInfo.from_annotation(annotation)</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        field_docstrings is not None</span>
<span class="gi">+                        and field_info.description is None</span>
<span class="gi">+                        and field_name in field_docstrings</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        field_info.description = field_docstrings[field_name]</span>
<span class="gi">+                    self._apply_field_title_generator_to_field_info(self._config_wrapper, field_info, field_name)</span>
<span class="gi">+                    fields[field_name] = self._generate_td_field_schema(</span>
<span class="gi">+                        field_name, field_info, decorators, required=required</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                title = self._get_model_title_from_config(typed_dict_cls, ConfigWrapper(config))</span>
<span class="gi">+                metadata = build_metadata_dict(</span>
<span class="gi">+                    js_functions=[partial(modify_model_json_schema, cls=typed_dict_cls, title=title)],</span>
<span class="gi">+                    typed_dict_cls=typed_dict_cls,</span>
<span class="gi">+                )</span>
<span class="gi">+                td_schema = core_schema.typed_dict_schema(</span>
<span class="gi">+                    fields,</span>
<span class="gi">+                    computed_fields=[</span>
<span class="gi">+                        self._computed_field_schema(d, decorators.field_serializers)</span>
<span class="gi">+                        for d in decorators.computed_fields.values()</span>
<span class="gi">+                    ],</span>
<span class="gi">+                    ref=typed_dict_ref,</span>
<span class="gi">+                    metadata=metadata,</span>
<span class="gi">+                    config=core_config,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                schema = self._apply_model_serializers(td_schema, decorators.model_serializers.values())</span>
<span class="gi">+                schema = apply_model_validators(schema, decorators.model_validators.values(), &#39;all&#39;)</span>
<span class="gi">+                self.defs.definitions[typed_dict_ref] = schema</span>
<span class="gi">+                return core_schema.definition_reference_schema(typed_dict_ref)</span>
<span class="gi">+</span>
<span class="gi">+    def _namedtuple_schema(self, namedtuple_cls: Any, origin: Any) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a NamedTuple.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _generate_parameter_schema(self, name: str, annotation: type[Any],</span>
<span class="gd">-        default: Any=Parameter.empty, mode: (Literal[&#39;positional_only&#39;,</span>
<span class="gd">-        &#39;positional_or_keyword&#39;, &#39;keyword_only&#39;] | None)=None</span>
<span class="gd">-        ) -&gt;core_schema.ArgumentsParameter:</span>
<span class="gi">+        with self.model_type_stack.push(namedtuple_cls), self.defs.get_schema_or_ref(namedtuple_cls) as (</span>
<span class="gi">+            namedtuple_ref,</span>
<span class="gi">+            maybe_schema,</span>
<span class="gi">+        ):</span>
<span class="gi">+            if maybe_schema is not None:</span>
<span class="gi">+                return maybe_schema</span>
<span class="gi">+            typevars_map = get_standard_typevars_map(namedtuple_cls)</span>
<span class="gi">+            if origin is not None:</span>
<span class="gi">+                namedtuple_cls = origin</span>
<span class="gi">+</span>
<span class="gi">+            annotations: dict[str, Any] = get_type_hints_infer_globalns(</span>
<span class="gi">+                namedtuple_cls, include_extras=True, localns=self._types_namespace</span>
<span class="gi">+            )</span>
<span class="gi">+            if not annotations:</span>
<span class="gi">+                # annotations is empty, happens if namedtuple_cls defined via collections.namedtuple(...)</span>
<span class="gi">+                annotations = {k: Any for k in namedtuple_cls._fields}</span>
<span class="gi">+</span>
<span class="gi">+            if typevars_map:</span>
<span class="gi">+                annotations = {</span>
<span class="gi">+                    field_name: replace_types(annotation, typevars_map)</span>
<span class="gi">+                    for field_name, annotation in annotations.items()</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+            arguments_schema = core_schema.arguments_schema(</span>
<span class="gi">+                [</span>
<span class="gi">+                    self._generate_parameter_schema(</span>
<span class="gi">+                        field_name, annotation, default=namedtuple_cls._field_defaults.get(field_name, Parameter.empty)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for field_name, annotation in annotations.items()</span>
<span class="gi">+                ],</span>
<span class="gi">+                metadata=build_metadata_dict(js_prefer_positional_arguments=True),</span>
<span class="gi">+            )</span>
<span class="gi">+            return core_schema.call_schema(arguments_schema, namedtuple_cls, ref=namedtuple_ref)</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_parameter_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        annotation: type[Any],</span>
<span class="gi">+        default: Any = Parameter.empty,</span>
<span class="gi">+        mode: Literal[&#39;positional_only&#39;, &#39;positional_or_keyword&#39;, &#39;keyword_only&#39;] | None = None,</span>
<span class="gi">+    ) -&gt; core_schema.ArgumentsParameter:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepare a ArgumentsParameter to represent a field in a namedtuple or function signature.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _tuple_schema(self, tuple_type: Any) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+        if default is Parameter.empty:</span>
<span class="gi">+            field = FieldInfo.from_annotation(annotation)</span>
<span class="gi">+        else:</span>
<span class="gi">+            field = FieldInfo.from_annotated_attribute(annotation, default)</span>
<span class="gi">+        assert field.annotation is not None, &#39;field.annotation should not be None when generating a schema&#39;</span>
<span class="gi">+        source_type, annotations = field.annotation, field.metadata</span>
<span class="gi">+        with self.field_name_stack.push(name):</span>
<span class="gi">+            schema = self._apply_annotations(source_type, annotations)</span>
<span class="gi">+</span>
<span class="gi">+        if not field.is_required():</span>
<span class="gi">+            schema = wrap_default(field, schema)</span>
<span class="gi">+</span>
<span class="gi">+        parameter_schema = core_schema.arguments_parameter(name, schema)</span>
<span class="gi">+        if mode is not None:</span>
<span class="gi">+            parameter_schema[&#39;mode&#39;] = mode</span>
<span class="gi">+        if field.alias is not None:</span>
<span class="gi">+            parameter_schema[&#39;alias&#39;] = field.alias</span>
<span class="gi">+        else:</span>
<span class="gi">+            alias_generator = self._config_wrapper.alias_generator</span>
<span class="gi">+            if isinstance(alias_generator, AliasGenerator) and alias_generator.alias is not None:</span>
<span class="gi">+                parameter_schema[&#39;alias&#39;] = alias_generator.alias(name)</span>
<span class="gi">+            elif isinstance(alias_generator, Callable):</span>
<span class="gi">+                parameter_schema[&#39;alias&#39;] = alias_generator(name)</span>
<span class="gi">+        return parameter_schema</span>
<span class="gi">+</span>
<span class="gi">+    def _tuple_schema(self, tuple_type: Any) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a Tuple, e.g. `tuple[int, str]` or `tuple[int, ...]`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _union_is_subclass_schema(self, union_type: Any</span>
<span class="gd">-        ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        # TODO: do we really need to resolve type vars here?</span>
<span class="gi">+        typevars_map = get_standard_typevars_map(tuple_type)</span>
<span class="gi">+        params = self._get_args_resolving_forward_refs(tuple_type)</span>
<span class="gi">+</span>
<span class="gi">+        if typevars_map and params:</span>
<span class="gi">+            params = tuple(replace_types(param, typevars_map) for param in params)</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: subtle difference: `tuple[()]` gives `params=()`, whereas `typing.Tuple[()]` gives `params=((),)`</span>
<span class="gi">+        # This is only true for &lt;3.11, on Python 3.11+ `typing.Tuple[()]` gives `params=()`</span>
<span class="gi">+        if not params:</span>
<span class="gi">+            if tuple_type in TUPLE_TYPES:</span>
<span class="gi">+                return core_schema.tuple_schema([core_schema.any_schema()], variadic_item_index=0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # special case for `tuple[()]` which means `tuple[]` - an empty tuple</span>
<span class="gi">+                return core_schema.tuple_schema([])</span>
<span class="gi">+        elif params[-1] is Ellipsis:</span>
<span class="gi">+            if len(params) == 2:</span>
<span class="gi">+                return core_schema.tuple_schema([self.generate_schema(params[0])], variadic_item_index=0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # TODO: something like https://github.com/pydantic/pydantic/issues/5952</span>
<span class="gi">+                raise ValueError(&#39;Variable tuples can only have one type&#39;)</span>
<span class="gi">+        elif len(params) == 1 and params[0] == ():</span>
<span class="gi">+            # special case for `Tuple[()]` which means `Tuple[]` - an empty tuple</span>
<span class="gi">+            # NOTE: This conditional can be removed when we drop support for Python 3.10.</span>
<span class="gi">+            return core_schema.tuple_schema([])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return core_schema.tuple_schema([self.generate_schema(param) for param in params])</span>
<span class="gi">+</span>
<span class="gi">+    def _type_schema(self) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.custom_error_schema(</span>
<span class="gi">+            core_schema.is_instance_schema(type),</span>
<span class="gi">+            custom_error_type=&#39;is_type&#39;,</span>
<span class="gi">+            custom_error_message=&#39;Input should be a type&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _union_is_subclass_schema(self, union_type: Any) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for `Type[Union[X, ...]]`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        args = self._get_args_resolving_forward_refs(union_type, required=True)</span>
<span class="gi">+        return core_schema.union_schema([self.generate_schema(typing.Type[args]) for args in args])</span>

<span class="gd">-    def _subclass_schema(self, type_: Any) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def _subclass_schema(self, type_: Any) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a Type, e.g. `Type[int]`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _sequence_schema(self, sequence_type: Any) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        type_param = self._get_first_arg_or_any(type_)</span>
<span class="gi">+        if type_param == Any:</span>
<span class="gi">+            return self._type_schema()</span>
<span class="gi">+        elif isinstance(type_param, typing.TypeVar):</span>
<span class="gi">+            if type_param.__bound__:</span>
<span class="gi">+                if _typing_extra.origin_is_union(get_origin(type_param.__bound__)):</span>
<span class="gi">+                    return self._union_is_subclass_schema(type_param.__bound__)</span>
<span class="gi">+                return core_schema.is_subclass_schema(type_param.__bound__)</span>
<span class="gi">+            elif type_param.__constraints__:</span>
<span class="gi">+                return core_schema.union_schema(</span>
<span class="gi">+                    [self.generate_schema(typing.Type[c]) for c in type_param.__constraints__]</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self._type_schema()</span>
<span class="gi">+        elif _typing_extra.origin_is_union(get_origin(type_param)):</span>
<span class="gi">+            return self._union_is_subclass_schema(type_param)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return core_schema.is_subclass_schema(type_param)</span>
<span class="gi">+</span>
<span class="gi">+    def _sequence_schema(self, sequence_type: Any) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a Sequence, e.g. `Sequence[int]`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from ._std_types_schema import serialize_sequence_via_list</span>

<span class="gd">-    def _iterable_schema(self, type_: Any) -&gt;core_schema.GeneratorSchema:</span>
<span class="gd">-        &quot;&quot;&quot;Generate a schema for an `Iterable`.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        item_type = self._get_first_arg_or_any(sequence_type)</span>
<span class="gi">+        item_type_schema = self.generate_schema(item_type)</span>
<span class="gi">+        list_schema = core_schema.list_schema(item_type_schema)</span>

<span class="gd">-    def _dataclass_schema(self, dataclass: type[StandardDataclass], origin:</span>
<span class="gd">-        (type[StandardDataclass] | None)) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        &quot;&quot;&quot;Generate schema for a dataclass.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        python_schema = core_schema.is_instance_schema(typing.Sequence, cls_repr=&#39;Sequence&#39;)</span>
<span class="gi">+        if item_type != Any:</span>
<span class="gi">+            from ._validators import sequence_validator</span>

<span class="gd">-    def _callable_schema(self, function: Callable[..., Any]</span>
<span class="gd">-        ) -&gt;core_schema.CallSchema:</span>
<span class="gi">+            python_schema = core_schema.chain_schema(</span>
<span class="gi">+                [python_schema, core_schema.no_info_wrap_validator_function(sequence_validator, list_schema)],</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        serialization = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gi">+            serialize_sequence_via_list, schema=item_type_schema, info_arg=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return core_schema.json_or_python_schema(</span>
<span class="gi">+            json_schema=list_schema, python_schema=python_schema, serialization=serialization</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _iterable_schema(self, type_: Any) -&gt; core_schema.GeneratorSchema:</span>
<span class="gi">+        &quot;&quot;&quot;Generate a schema for an `Iterable`.&quot;&quot;&quot;</span>
<span class="gi">+        item_type = self._get_first_arg_or_any(type_)</span>
<span class="gi">+</span>
<span class="gi">+        return core_schema.generator_schema(self.generate_schema(item_type))</span>
<span class="gi">+</span>
<span class="gi">+    def _pattern_schema(self, pattern_type: Any) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        from . import _validators</span>
<span class="gi">+</span>
<span class="gi">+        metadata = build_metadata_dict(js_functions=[lambda _1, _2: {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;regex&#39;}])</span>
<span class="gi">+        ser = core_schema.plain_serializer_function_ser_schema(</span>
<span class="gi">+            attrgetter(&#39;pattern&#39;), when_used=&#39;json&#39;, return_schema=core_schema.str_schema()</span>
<span class="gi">+        )</span>
<span class="gi">+        if pattern_type == typing.Pattern or pattern_type == re.Pattern:</span>
<span class="gi">+            # bare type</span>
<span class="gi">+            return core_schema.no_info_plain_validator_function(</span>
<span class="gi">+                _validators.pattern_either_validator, serialization=ser, metadata=metadata</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        param = self._get_args_resolving_forward_refs(</span>
<span class="gi">+            pattern_type,</span>
<span class="gi">+            required=True,</span>
<span class="gi">+        )[0]</span>
<span class="gi">+        if param is str:</span>
<span class="gi">+            return core_schema.no_info_plain_validator_function(</span>
<span class="gi">+                _validators.pattern_str_validator, serialization=ser, metadata=metadata</span>
<span class="gi">+            )</span>
<span class="gi">+        elif param is bytes:</span>
<span class="gi">+            return core_schema.no_info_plain_validator_function(</span>
<span class="gi">+                _validators.pattern_bytes_validator, serialization=ser, metadata=metadata</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticSchemaGenerationError(f&#39;Unable to generate pydantic-core schema for {pattern_type!r}.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _hashable_schema(self) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.custom_error_schema(</span>
<span class="gi">+            core_schema.is_instance_schema(collections.abc.Hashable),</span>
<span class="gi">+            custom_error_type=&#39;is_hashable&#39;,</span>
<span class="gi">+            custom_error_message=&#39;Input should be hashable&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _dataclass_schema(</span>
<span class="gi">+        self, dataclass: type[StandardDataclass], origin: type[StandardDataclass] | None</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        &quot;&quot;&quot;Generate schema for a dataclass.&quot;&quot;&quot;</span>
<span class="gi">+        with self.model_type_stack.push(dataclass), self.defs.get_schema_or_ref(dataclass) as (</span>
<span class="gi">+            dataclass_ref,</span>
<span class="gi">+            maybe_schema,</span>
<span class="gi">+        ):</span>
<span class="gi">+            if maybe_schema is not None:</span>
<span class="gi">+                return maybe_schema</span>
<span class="gi">+</span>
<span class="gi">+            typevars_map = get_standard_typevars_map(dataclass)</span>
<span class="gi">+            if origin is not None:</span>
<span class="gi">+                dataclass = origin</span>
<span class="gi">+</span>
<span class="gi">+            with ExitStack() as dataclass_bases_stack:</span>
<span class="gi">+                # Pushing a namespace prioritises items already in the stack, so iterate though the MRO forwards</span>
<span class="gi">+                for dataclass_base in dataclass.__mro__:</span>
<span class="gi">+                    if dataclasses.is_dataclass(dataclass_base):</span>
<span class="gi">+                        dataclass_bases_stack.enter_context(self._types_namespace_stack.push(dataclass_base))</span>
<span class="gi">+</span>
<span class="gi">+                # Pushing a config overwrites the previous config, so iterate though the MRO backwards</span>
<span class="gi">+                config = None</span>
<span class="gi">+                for dataclass_base in reversed(dataclass.__mro__):</span>
<span class="gi">+                    if dataclasses.is_dataclass(dataclass_base):</span>
<span class="gi">+                        config = getattr(dataclass_base, &#39;__pydantic_config__&#39;, None)</span>
<span class="gi">+                        dataclass_bases_stack.enter_context(self._config_wrapper_stack.push(config))</span>
<span class="gi">+</span>
<span class="gi">+                core_config = self._config_wrapper.core_config(dataclass)</span>
<span class="gi">+</span>
<span class="gi">+                self = self._current_generate_schema</span>
<span class="gi">+</span>
<span class="gi">+                from ..dataclasses import is_pydantic_dataclass</span>
<span class="gi">+</span>
<span class="gi">+                if is_pydantic_dataclass(dataclass):</span>
<span class="gi">+                    fields = deepcopy(dataclass.__pydantic_fields__)</span>
<span class="gi">+                    if typevars_map:</span>
<span class="gi">+                        for field in fields.values():</span>
<span class="gi">+                            field.apply_typevars_map(typevars_map, self._types_namespace)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    fields = collect_dataclass_fields(</span>
<span class="gi">+                        dataclass,</span>
<span class="gi">+                        self._types_namespace,</span>
<span class="gi">+                        typevars_map=typevars_map,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                # disallow combination of init=False on a dataclass field and extra=&#39;allow&#39; on a dataclass</span>
<span class="gi">+                if self._config_wrapper_stack.tail.extra == &#39;allow&#39;:</span>
<span class="gi">+                    # disallow combination of init=False on a dataclass field and extra=&#39;allow&#39; on a dataclass</span>
<span class="gi">+                    for field_name, field in fields.items():</span>
<span class="gi">+                        if field.init is False:</span>
<span class="gi">+                            raise PydanticUserError(</span>
<span class="gi">+                                f&#39;Field {field_name} has `init=False` and dataclass has config setting `extra=&quot;allow&quot;`. &#39;</span>
<span class="gi">+                                f&#39;This combination is not allowed.&#39;,</span>
<span class="gi">+                                code=&#39;dataclass-init-false-extra-allow&#39;,</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+                decorators = dataclass.__dict__.get(&#39;__pydantic_decorators__&#39;) or DecoratorInfos.build(dataclass)</span>
<span class="gi">+                # Move kw_only=False args to the start of the list, as this is how vanilla dataclasses work.</span>
<span class="gi">+                # Note that when kw_only is missing or None, it is treated as equivalent to kw_only=True</span>
<span class="gi">+                args = sorted(</span>
<span class="gi">+                    (self._generate_dc_field_schema(k, v, decorators) for k, v in fields.items()),</span>
<span class="gi">+                    key=lambda a: a.get(&#39;kw_only&#39;) is not False,</span>
<span class="gi">+                )</span>
<span class="gi">+                has_post_init = hasattr(dataclass, &#39;__post_init__&#39;)</span>
<span class="gi">+                has_slots = hasattr(dataclass, &#39;__slots__&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                args_schema = core_schema.dataclass_args_schema(</span>
<span class="gi">+                    dataclass.__name__,</span>
<span class="gi">+                    args,</span>
<span class="gi">+                    computed_fields=[</span>
<span class="gi">+                        self._computed_field_schema(d, decorators.field_serializers)</span>
<span class="gi">+                        for d in decorators.computed_fields.values()</span>
<span class="gi">+                    ],</span>
<span class="gi">+                    collect_init_only=has_post_init,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                inner_schema = apply_validators(args_schema, decorators.root_validators.values(), None)</span>
<span class="gi">+</span>
<span class="gi">+                model_validators = decorators.model_validators.values()</span>
<span class="gi">+                inner_schema = apply_model_validators(inner_schema, model_validators, &#39;inner&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                title = self._get_model_title_from_config(dataclass, ConfigWrapper(config))</span>
<span class="gi">+                metadata = build_metadata_dict(</span>
<span class="gi">+                    js_functions=[partial(modify_model_json_schema, cls=dataclass, title=title)]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                dc_schema = core_schema.dataclass_schema(</span>
<span class="gi">+                    dataclass,</span>
<span class="gi">+                    inner_schema,</span>
<span class="gi">+                    post_init=has_post_init,</span>
<span class="gi">+                    ref=dataclass_ref,</span>
<span class="gi">+                    fields=[field.name for field in dataclasses.fields(dataclass)],</span>
<span class="gi">+                    slots=has_slots,</span>
<span class="gi">+                    config=core_config,</span>
<span class="gi">+                    metadata=metadata,</span>
<span class="gi">+                )</span>
<span class="gi">+                schema = self._apply_model_serializers(dc_schema, decorators.model_serializers.values())</span>
<span class="gi">+                schema = apply_model_validators(schema, model_validators, &#39;outer&#39;)</span>
<span class="gi">+                self.defs.definitions[dataclass_ref] = schema</span>
<span class="gi">+                return core_schema.definition_reference_schema(dataclass_ref)</span>
<span class="gi">+</span>
<span class="gi">+            # Type checkers seem to assume ExitStack may suppress exceptions and therefore</span>
<span class="gi">+            # control flow can exit the `with` block without returning.</span>
<span class="gi">+            assert False, &#39;Unreachable&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def _callable_schema(self, function: Callable[..., Any]) -&gt; core_schema.CallSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for a Callable.

<span class="w"> </span>        TODO support functional validators once we support them in Config
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _annotated_schema(self, annotated_type: Any) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        sig = signature(function)</span>
<span class="gi">+</span>
<span class="gi">+        type_hints = _typing_extra.get_function_type_hints(function, types_namespace=self._types_namespace)</span>
<span class="gi">+</span>
<span class="gi">+        mode_lookup: dict[_ParameterKind, Literal[&#39;positional_only&#39;, &#39;positional_or_keyword&#39;, &#39;keyword_only&#39;]] = {</span>
<span class="gi">+            Parameter.POSITIONAL_ONLY: &#39;positional_only&#39;,</span>
<span class="gi">+            Parameter.POSITIONAL_OR_KEYWORD: &#39;positional_or_keyword&#39;,</span>
<span class="gi">+            Parameter.KEYWORD_ONLY: &#39;keyword_only&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        arguments_list: list[core_schema.ArgumentsParameter] = []</span>
<span class="gi">+        var_args_schema: core_schema.CoreSchema | None = None</span>
<span class="gi">+        var_kwargs_schema: core_schema.CoreSchema | None = None</span>
<span class="gi">+</span>
<span class="gi">+        for name, p in sig.parameters.items():</span>
<span class="gi">+            if p.annotation is sig.empty:</span>
<span class="gi">+                annotation = typing.cast(Any, Any)</span>
<span class="gi">+            else:</span>
<span class="gi">+                annotation = type_hints[name]</span>
<span class="gi">+</span>
<span class="gi">+            parameter_mode = mode_lookup.get(p.kind)</span>
<span class="gi">+            if parameter_mode is not None:</span>
<span class="gi">+                arg_schema = self._generate_parameter_schema(name, annotation, p.default, parameter_mode)</span>
<span class="gi">+                arguments_list.append(arg_schema)</span>
<span class="gi">+            elif p.kind == Parameter.VAR_POSITIONAL:</span>
<span class="gi">+                var_args_schema = self.generate_schema(annotation)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert p.kind == Parameter.VAR_KEYWORD, p.kind</span>
<span class="gi">+                var_kwargs_schema = self.generate_schema(annotation)</span>
<span class="gi">+</span>
<span class="gi">+        return_schema: core_schema.CoreSchema | None = None</span>
<span class="gi">+        config_wrapper = self._config_wrapper</span>
<span class="gi">+        if config_wrapper.validate_return:</span>
<span class="gi">+            return_hint = type_hints.get(&#39;return&#39;)</span>
<span class="gi">+            if return_hint is not None:</span>
<span class="gi">+                return_schema = self.generate_schema(return_hint)</span>
<span class="gi">+</span>
<span class="gi">+        return core_schema.call_schema(</span>
<span class="gi">+            core_schema.arguments_schema(</span>
<span class="gi">+                arguments_list,</span>
<span class="gi">+                var_args_schema=var_args_schema,</span>
<span class="gi">+                var_kwargs_schema=var_kwargs_schema,</span>
<span class="gi">+                populate_by_name=config_wrapper.populate_by_name,</span>
<span class="gi">+            ),</span>
<span class="gi">+            function,</span>
<span class="gi">+            return_schema=return_schema,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        assert isinstance(typevar, typing.TypeVar)</span>
<span class="gi">+</span>
<span class="gi">+        bound = typevar.__bound__</span>
<span class="gi">+        constraints = typevar.__constraints__</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            typevar_has_default = typevar.has_default()  # type: ignore</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # could still have a default if it&#39;s an old version of typing_extensions.TypeVar</span>
<span class="gi">+            typevar_has_default = getattr(typevar, &#39;__default__&#39;, None) is not None</span>
<span class="gi">+</span>
<span class="gi">+        if (bound is not None) + (len(constraints) != 0) + typevar_has_default &gt; 1:</span>
<span class="gi">+            raise NotImplementedError(</span>
<span class="gi">+                &#39;Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if typevar_has_default:</span>
<span class="gi">+            return self.generate_schema(typevar.__default__)  # type: ignore</span>
<span class="gi">+        elif constraints:</span>
<span class="gi">+            return self._union_schema(typing.Union[constraints])  # type: ignore</span>
<span class="gi">+        elif bound:</span>
<span class="gi">+            schema = self.generate_schema(bound)</span>
<span class="gi">+            schema[&#39;serialization&#39;] = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gi">+                lambda x, h: h(x), schema=core_schema.any_schema()</span>
<span class="gi">+            )</span>
<span class="gi">+            return schema</span>
<span class="gi">+        else:</span>
<span class="gi">+            return core_schema.any_schema()</span>
<span class="gi">+</span>
<span class="gi">+    def _computed_field_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        d: Decorator[ComputedFieldInfo],</span>
<span class="gi">+        field_serializers: dict[str, Decorator[FieldSerializerDecoratorInfo]],</span>
<span class="gi">+    ) -&gt; core_schema.ComputedField:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return_type = _decorators.get_function_return_type(d.func, d.info.return_type, self._types_namespace)</span>
<span class="gi">+        except NameError as e:</span>
<span class="gi">+            raise PydanticUndefinedAnnotation.from_name_error(e) from e</span>
<span class="gi">+        if return_type is PydanticUndefined:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;Computed field is missing return type annotation or specifying `return_type`&#39;</span>
<span class="gi">+                &#39; to the `@computed_field` decorator (e.g. `@computed_field(return_type=int|str)`)&#39;,</span>
<span class="gi">+                code=&#39;model-field-missing-annotation&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return_type = replace_types(return_type, self._typevars_map)</span>
<span class="gi">+        # Create a new ComputedFieldInfo so that different type parametrizations of the same</span>
<span class="gi">+        # generic model&#39;s computed field can have different return types.</span>
<span class="gi">+        d.info = dataclasses.replace(d.info, return_type=return_type)</span>
<span class="gi">+        return_type_schema = self.generate_schema(return_type)</span>
<span class="gi">+        # Apply serializers to computed field if there exist</span>
<span class="gi">+        return_type_schema = self._apply_field_serializers(</span>
<span class="gi">+            return_type_schema,</span>
<span class="gi">+            filter_field_decorator_info_by_field(field_serializers.values(), d.cls_var_name),</span>
<span class="gi">+            computed_field=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        alias_generator = self._config_wrapper.alias_generator</span>
<span class="gi">+        if alias_generator is not None:</span>
<span class="gi">+            self._apply_alias_generator_to_computed_field_info(</span>
<span class="gi">+                alias_generator=alias_generator, computed_field_info=d.info, computed_field_name=d.cls_var_name</span>
<span class="gi">+            )</span>
<span class="gi">+        self._apply_field_title_generator_to_field_info(self._config_wrapper, d.info, d.cls_var_name)</span>
<span class="gi">+</span>
<span class="gi">+        def set_computed_field_metadata(schema: CoreSchemaOrField, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue:</span>
<span class="gi">+            json_schema = handler(schema)</span>
<span class="gi">+</span>
<span class="gi">+            json_schema[&#39;readOnly&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+            title = d.info.title</span>
<span class="gi">+            if title is not None:</span>
<span class="gi">+                json_schema[&#39;title&#39;] = title</span>
<span class="gi">+</span>
<span class="gi">+            description = d.info.description</span>
<span class="gi">+            if description is not None:</span>
<span class="gi">+                json_schema[&#39;description&#39;] = description</span>
<span class="gi">+</span>
<span class="gi">+            if d.info.deprecated or d.info.deprecated == &#39;&#39;:</span>
<span class="gi">+                json_schema[&#39;deprecated&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+            examples = d.info.examples</span>
<span class="gi">+            if examples is not None:</span>
<span class="gi">+                json_schema[&#39;examples&#39;] = to_jsonable_python(examples)</span>
<span class="gi">+</span>
<span class="gi">+            json_schema_extra = d.info.json_schema_extra</span>
<span class="gi">+            if json_schema_extra is not None:</span>
<span class="gi">+                add_json_schema_extra(json_schema, json_schema_extra)</span>
<span class="gi">+</span>
<span class="gi">+            return json_schema</span>
<span class="gi">+</span>
<span class="gi">+        metadata = build_metadata_dict(js_annotation_functions=[set_computed_field_metadata])</span>
<span class="gi">+        return core_schema.computed_field(</span>
<span class="gi">+            d.cls_var_name, return_schema=return_type_schema, alias=d.info.alias, metadata=metadata</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _annotated_schema(self, annotated_type: Any) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate schema for an Annotated type, e.g. `Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _apply_annotations(self, source_type: Any, annotations: list[Any],</span>
<span class="gd">-        transform_inner_schema: Callable[[CoreSchema], CoreSchema]=lambda x: x</span>
<span class="gd">-        ) -&gt;CoreSchema:</span>
<span class="gi">+        from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+        source_type, *annotations = self._get_args_resolving_forward_refs(</span>
<span class="gi">+            annotated_type,</span>
<span class="gi">+            required=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        schema = self._apply_annotations(source_type, annotations)</span>
<span class="gi">+        # put the default validator last so that TypeAdapter.get_default_value() works</span>
<span class="gi">+        # even if there are function validators involved</span>
<span class="gi">+        for annotation in annotations:</span>
<span class="gi">+            if isinstance(annotation, FieldInfo):</span>
<span class="gi">+                schema = wrap_default(annotation, schema)</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def _get_prepare_pydantic_annotations_for_known_type(</span>
<span class="gi">+        self, obj: Any, annotations: tuple[Any, ...]</span>
<span class="gi">+    ) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+        from ._std_types_schema import PREPARE_METHODS</span>
<span class="gi">+</span>
<span class="gi">+        # Check for hashability</span>
<span class="gi">+        try:</span>
<span class="gi">+            hash(obj)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            # obj is definitely not a known type if this fails</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        for gen in PREPARE_METHODS:</span>
<span class="gi">+            res = gen(obj, annotations, self._config_wrapper.config_dict)</span>
<span class="gi">+            if res is not None:</span>
<span class="gi">+                return res</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_annotations(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source_type: Any,</span>
<span class="gi">+        annotations: list[Any],</span>
<span class="gi">+        transform_inner_schema: Callable[[CoreSchema], CoreSchema] = lambda x: x,</span>
<span class="gi">+    ) -&gt; CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply arguments from `Annotated` or from `FieldInfo` to a schema.

<span class="w"> </span>        This gets called by `GenerateSchema._annotated_schema` but differs from it in that it does
<span class="w"> </span>        not expect `source_type` to be an `Annotated` object, it expects it to be  the first argument of that
<span class="w"> </span>        (in other words, `GenerateSchema._annotated_schema` just unpacks `Annotated`, this process it).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _apply_field_serializers(self, schema: core_schema.CoreSchema,</span>
<span class="gi">+        annotations = list(_known_annotated_metadata.expand_grouped_metadata(annotations))</span>
<span class="gi">+        res = self._get_prepare_pydantic_annotations_for_known_type(source_type, tuple(annotations))</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            source_type, annotations = res</span>
<span class="gi">+</span>
<span class="gi">+        pydantic_js_annotation_functions: list[GetJsonSchemaFunction] = []</span>
<span class="gi">+</span>
<span class="gi">+        def inner_handler(obj: Any) -&gt; CoreSchema:</span>
<span class="gi">+            from_property = self._generate_schema_from_property(obj, source_type)</span>
<span class="gi">+            if from_property is None:</span>
<span class="gi">+                schema = self._generate_schema_inner(obj)</span>
<span class="gi">+            else:</span>
<span class="gi">+                schema = from_property</span>
<span class="gi">+            metadata_js_function = _extract_get_pydantic_json_schema(obj, schema)</span>
<span class="gi">+            if metadata_js_function is not None:</span>
<span class="gi">+                metadata_schema = resolve_original_schema(schema, self.defs.definitions)</span>
<span class="gi">+                if metadata_schema is not None:</span>
<span class="gi">+                    self._add_js_function(metadata_schema, metadata_js_function)</span>
<span class="gi">+            return transform_inner_schema(schema)</span>
<span class="gi">+</span>
<span class="gi">+        get_inner_schema = CallbackGetCoreSchemaHandler(inner_handler, self)</span>
<span class="gi">+</span>
<span class="gi">+        for annotation in annotations:</span>
<span class="gi">+            if annotation is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            get_inner_schema = self._get_wrapped_inner_schema(</span>
<span class="gi">+                get_inner_schema, annotation, pydantic_js_annotation_functions</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        schema = get_inner_schema(source_type)</span>
<span class="gi">+        if pydantic_js_annotation_functions:</span>
<span class="gi">+            metadata = CoreMetadataHandler(schema).metadata</span>
<span class="gi">+            metadata.setdefault(&#39;pydantic_js_annotation_functions&#39;, []).extend(pydantic_js_annotation_functions)</span>
<span class="gi">+        return _add_custom_serialization_from_json_encoders(self._config_wrapper.json_encoders, source_type, schema)</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_single_annotation(self, schema: core_schema.CoreSchema, metadata: Any) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(metadata, FieldInfo):</span>
<span class="gi">+            for field_metadata in metadata.metadata:</span>
<span class="gi">+                schema = self._apply_single_annotation(schema, field_metadata)</span>
<span class="gi">+</span>
<span class="gi">+            if metadata.discriminator is not None:</span>
<span class="gi">+                schema = self._apply_discriminator_to_union(schema, metadata.discriminator)</span>
<span class="gi">+            return schema</span>
<span class="gi">+</span>
<span class="gi">+        if schema[&#39;type&#39;] == &#39;nullable&#39;:</span>
<span class="gi">+            # for nullable schemas, metadata is automatically applied to the inner schema</span>
<span class="gi">+            inner = schema.get(&#39;schema&#39;, core_schema.any_schema())</span>
<span class="gi">+            inner = self._apply_single_annotation(inner, metadata)</span>
<span class="gi">+            if inner:</span>
<span class="gi">+                schema[&#39;schema&#39;] = inner</span>
<span class="gi">+            return schema</span>
<span class="gi">+</span>
<span class="gi">+        original_schema = schema</span>
<span class="gi">+        ref = schema.get(&#39;ref&#39;, None)</span>
<span class="gi">+        if ref is not None:</span>
<span class="gi">+            schema = schema.copy()</span>
<span class="gi">+            new_ref = ref + f&#39;_{repr(metadata)}&#39;</span>
<span class="gi">+            if new_ref in self.defs.definitions:</span>
<span class="gi">+                return self.defs.definitions[new_ref]</span>
<span class="gi">+            schema[&#39;ref&#39;] = new_ref  # type: ignore</span>
<span class="gi">+        elif schema[&#39;type&#39;] == &#39;definition-ref&#39;:</span>
<span class="gi">+            ref = schema[&#39;schema_ref&#39;]</span>
<span class="gi">+            if ref in self.defs.definitions:</span>
<span class="gi">+                schema = self.defs.definitions[ref].copy()</span>
<span class="gi">+                new_ref = ref + f&#39;_{repr(metadata)}&#39;</span>
<span class="gi">+                if new_ref in self.defs.definitions:</span>
<span class="gi">+                    return self.defs.definitions[new_ref]</span>
<span class="gi">+                schema[&#39;ref&#39;] = new_ref  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        maybe_updated_schema = _known_annotated_metadata.apply_known_metadata(metadata, schema.copy())</span>
<span class="gi">+</span>
<span class="gi">+        if maybe_updated_schema is not None:</span>
<span class="gi">+            return maybe_updated_schema</span>
<span class="gi">+        return original_schema</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_single_annotation_json_schema(</span>
<span class="gi">+        self, schema: core_schema.CoreSchema, metadata: Any</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(metadata, FieldInfo):</span>
<span class="gi">+            for field_metadata in metadata.metadata:</span>
<span class="gi">+                schema = self._apply_single_annotation_json_schema(schema, field_metadata)</span>
<span class="gi">+            json_schema_update: JsonSchemaValue = {}</span>
<span class="gi">+            if metadata.title:</span>
<span class="gi">+                json_schema_update[&#39;title&#39;] = metadata.title</span>
<span class="gi">+            if metadata.description:</span>
<span class="gi">+                json_schema_update[&#39;description&#39;] = metadata.description</span>
<span class="gi">+            if metadata.examples:</span>
<span class="gi">+                json_schema_update[&#39;examples&#39;] = to_jsonable_python(metadata.examples)</span>
<span class="gi">+</span>
<span class="gi">+            json_schema_extra = metadata.json_schema_extra</span>
<span class="gi">+            if json_schema_update or json_schema_extra:</span>
<span class="gi">+                CoreMetadataHandler(schema).metadata.setdefault(&#39;pydantic_js_annotation_functions&#39;, []).append(</span>
<span class="gi">+                    get_json_schema_update_func(json_schema_update, json_schema_extra)</span>
<span class="gi">+                )</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def _get_wrapped_inner_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        get_inner_schema: GetCoreSchemaHandler,</span>
<span class="gi">+        annotation: Any,</span>
<span class="gi">+        pydantic_js_annotation_functions: list[GetJsonSchemaFunction],</span>
<span class="gi">+    ) -&gt; CallbackGetCoreSchemaHandler:</span>
<span class="gi">+        metadata_get_schema: GetCoreSchemaFunction = getattr(annotation, &#39;__get_pydantic_core_schema__&#39;, None) or (</span>
<span class="gi">+            lambda source, handler: handler(source)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def new_handler(source: Any) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+            schema = metadata_get_schema(source, get_inner_schema)</span>
<span class="gi">+            schema = self._apply_single_annotation(schema, annotation)</span>
<span class="gi">+            schema = self._apply_single_annotation_json_schema(schema, annotation)</span>
<span class="gi">+</span>
<span class="gi">+            metadata_js_function = _extract_get_pydantic_json_schema(annotation, schema)</span>
<span class="gi">+            if metadata_js_function is not None:</span>
<span class="gi">+                pydantic_js_annotation_functions.append(metadata_js_function)</span>
<span class="gi">+            return schema</span>
<span class="gi">+</span>
<span class="gi">+        return CallbackGetCoreSchemaHandler(new_handler, self)</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_field_serializers(</span>
<span class="gi">+        self,</span>
<span class="gi">+        schema: core_schema.CoreSchema,</span>
<span class="w"> </span>        serializers: list[Decorator[FieldSerializerDecoratorInfo]],
<span class="gd">-        computed_field: bool=False) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        computed_field: bool = False,</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply field serializers to a schema.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _apply_model_serializers(self, schema: core_schema.CoreSchema,</span>
<span class="gd">-        serializers: Iterable[Decorator[ModelSerializerDecoratorInfo]]</span>
<span class="gd">-        ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        if serializers:</span>
<span class="gi">+            schema = copy(schema)</span>
<span class="gi">+            if schema[&#39;type&#39;] == &#39;definitions&#39;:</span>
<span class="gi">+                inner_schema = schema[&#39;schema&#39;]</span>
<span class="gi">+                schema[&#39;schema&#39;] = self._apply_field_serializers(inner_schema, serializers)</span>
<span class="gi">+                return schema</span>
<span class="gi">+            else:</span>
<span class="gi">+                ref = typing.cast(&#39;str|None&#39;, schema.get(&#39;ref&#39;, None))</span>
<span class="gi">+                if ref is not None:</span>
<span class="gi">+                    schema = core_schema.definition_reference_schema(ref)</span>
<span class="gi">+</span>
<span class="gi">+            # use the last serializer to make it easy to override a serializer set on a parent model</span>
<span class="gi">+            serializer = serializers[-1]</span>
<span class="gi">+            is_field_serializer, info_arg = inspect_field_serializer(</span>
<span class="gi">+                serializer.func, serializer.info.mode, computed_field=computed_field</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                return_type = _decorators.get_function_return_type(</span>
<span class="gi">+                    serializer.func, serializer.info.return_type, self._types_namespace</span>
<span class="gi">+                )</span>
<span class="gi">+            except NameError as e:</span>
<span class="gi">+                raise PydanticUndefinedAnnotation.from_name_error(e) from e</span>
<span class="gi">+</span>
<span class="gi">+            if return_type is PydanticUndefined:</span>
<span class="gi">+                return_schema = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                return_schema = self.generate_schema(return_type)</span>
<span class="gi">+</span>
<span class="gi">+            if serializer.info.mode == &#39;wrap&#39;:</span>
<span class="gi">+                schema[&#39;serialization&#39;] = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gi">+                    serializer.func,</span>
<span class="gi">+                    is_field_serializer=is_field_serializer,</span>
<span class="gi">+                    info_arg=info_arg,</span>
<span class="gi">+                    return_schema=return_schema,</span>
<span class="gi">+                    when_used=serializer.info.when_used,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert serializer.info.mode == &#39;plain&#39;</span>
<span class="gi">+                schema[&#39;serialization&#39;] = core_schema.plain_serializer_function_ser_schema(</span>
<span class="gi">+                    serializer.func,</span>
<span class="gi">+                    is_field_serializer=is_field_serializer,</span>
<span class="gi">+                    info_arg=info_arg,</span>
<span class="gi">+                    return_schema=return_schema,</span>
<span class="gi">+                    when_used=serializer.info.when_used,</span>
<span class="gi">+                )</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_model_serializers(</span>
<span class="gi">+        self, schema: core_schema.CoreSchema, serializers: Iterable[Decorator[ModelSerializerDecoratorInfo]]</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply model serializers to a schema.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_VALIDATOR_F_MATCH: Mapping[tuple[FieldValidatorModes, Literal[&#39;no-info&#39;,</span>
<span class="gd">-    &#39;with-info&#39;]], Callable[[Callable[..., Any], core_schema.CoreSchema, </span>
<span class="gd">-    str | None], core_schema.CoreSchema]] = {(&#39;before&#39;, &#39;no-info&#39;): lambda</span>
<span class="gd">-    f, schema, _: core_schema.no_info_before_validator_function(f, schema),</span>
<span class="gd">-    (&#39;after&#39;, &#39;no-info&#39;): lambda f, schema, _: core_schema.</span>
<span class="gd">-    no_info_after_validator_function(f, schema), (&#39;plain&#39;, &#39;no-info&#39;): lambda</span>
<span class="gd">-    f, _1, _2: core_schema.no_info_plain_validator_function(f), (&#39;wrap&#39;,</span>
<span class="gd">-    &#39;no-info&#39;): lambda f, schema, _: core_schema.</span>
<span class="gd">-    no_info_wrap_validator_function(f, schema), (&#39;before&#39;, &#39;with-info&#39;): lambda</span>
<span class="gd">-    f, schema, field_name: core_schema.with_info_before_validator_function(</span>
<span class="gd">-    f, schema, field_name=field_name), (&#39;after&#39;, &#39;with-info&#39;): lambda f,</span>
<span class="gd">-    schema, field_name: core_schema.with_info_after_validator_function(f,</span>
<span class="gd">-    schema, field_name=field_name), (&#39;plain&#39;, &#39;with-info&#39;): lambda f, _,</span>
<span class="gd">-    field_name: core_schema.with_info_plain_validator_function(f,</span>
<span class="gd">-    field_name=field_name), (&#39;wrap&#39;, &#39;with-info&#39;): lambda f, schema,</span>
<span class="gd">-    field_name: core_schema.with_info_wrap_validator_function(f, schema,</span>
<span class="gd">-    field_name=field_name)}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def apply_validators(schema: core_schema.CoreSchema, validators: (Iterable[</span>
<span class="gd">-    Decorator[RootValidatorDecoratorInfo]] | Iterable[Decorator[</span>
<span class="gd">-    ValidatorDecoratorInfo]] | Iterable[Decorator[</span>
<span class="gd">-    FieldValidatorDecoratorInfo]]), field_name: (str | None)</span>
<span class="gd">-    ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        ref: str | None = schema.pop(&#39;ref&#39;, None)  # type: ignore</span>
<span class="gi">+        if serializers:</span>
<span class="gi">+            serializer = list(serializers)[-1]</span>
<span class="gi">+            info_arg = inspect_model_serializer(serializer.func, serializer.info.mode)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                return_type = _decorators.get_function_return_type(</span>
<span class="gi">+                    serializer.func, serializer.info.return_type, self._types_namespace</span>
<span class="gi">+                )</span>
<span class="gi">+            except NameError as e:</span>
<span class="gi">+                raise PydanticUndefinedAnnotation.from_name_error(e) from e</span>
<span class="gi">+            if return_type is PydanticUndefined:</span>
<span class="gi">+                return_schema = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                return_schema = self.generate_schema(return_type)</span>
<span class="gi">+</span>
<span class="gi">+            if serializer.info.mode == &#39;wrap&#39;:</span>
<span class="gi">+                ser_schema: core_schema.SerSchema = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gi">+                    serializer.func,</span>
<span class="gi">+                    info_arg=info_arg,</span>
<span class="gi">+                    return_schema=return_schema,</span>
<span class="gi">+                    when_used=serializer.info.when_used,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                # plain</span>
<span class="gi">+                ser_schema = core_schema.plain_serializer_function_ser_schema(</span>
<span class="gi">+                    serializer.func,</span>
<span class="gi">+                    info_arg=info_arg,</span>
<span class="gi">+                    return_schema=return_schema,</span>
<span class="gi">+                    when_used=serializer.info.when_used,</span>
<span class="gi">+                )</span>
<span class="gi">+            schema[&#39;serialization&#39;] = ser_schema</span>
<span class="gi">+        if ref:</span>
<span class="gi">+            schema[&#39;ref&#39;] = ref  # type: ignore</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_VALIDATOR_F_MATCH: Mapping[</span>
<span class="gi">+    tuple[FieldValidatorModes, Literal[&#39;no-info&#39;, &#39;with-info&#39;]],</span>
<span class="gi">+    Callable[[Callable[..., Any], core_schema.CoreSchema, str | None], core_schema.CoreSchema],</span>
<span class="gi">+] = {</span>
<span class="gi">+    (&#39;before&#39;, &#39;no-info&#39;): lambda f, schema, _: core_schema.no_info_before_validator_function(f, schema),</span>
<span class="gi">+    (&#39;after&#39;, &#39;no-info&#39;): lambda f, schema, _: core_schema.no_info_after_validator_function(f, schema),</span>
<span class="gi">+    (&#39;plain&#39;, &#39;no-info&#39;): lambda f, _1, _2: core_schema.no_info_plain_validator_function(f),</span>
<span class="gi">+    (&#39;wrap&#39;, &#39;no-info&#39;): lambda f, schema, _: core_schema.no_info_wrap_validator_function(f, schema),</span>
<span class="gi">+    (&#39;before&#39;, &#39;with-info&#39;): lambda f, schema, field_name: core_schema.with_info_before_validator_function(</span>
<span class="gi">+        f, schema, field_name=field_name</span>
<span class="gi">+    ),</span>
<span class="gi">+    (&#39;after&#39;, &#39;with-info&#39;): lambda f, schema, field_name: core_schema.with_info_after_validator_function(</span>
<span class="gi">+        f, schema, field_name=field_name</span>
<span class="gi">+    ),</span>
<span class="gi">+    (&#39;plain&#39;, &#39;with-info&#39;): lambda f, _, field_name: core_schema.with_info_plain_validator_function(</span>
<span class="gi">+        f, field_name=field_name</span>
<span class="gi">+    ),</span>
<span class="gi">+    (&#39;wrap&#39;, &#39;with-info&#39;): lambda f, schema, field_name: core_schema.with_info_wrap_validator_function(</span>
<span class="gi">+        f, schema, field_name=field_name</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def apply_validators(</span>
<span class="gi">+    schema: core_schema.CoreSchema,</span>
<span class="gi">+    validators: Iterable[Decorator[RootValidatorDecoratorInfo]]</span>
<span class="gi">+    | Iterable[Decorator[ValidatorDecoratorInfo]]</span>
<span class="gi">+    | Iterable[Decorator[FieldValidatorDecoratorInfo]],</span>
<span class="gi">+    field_name: str | None,</span>
<span class="gi">+) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>    &quot;&quot;&quot;Apply validators to a schema.

<span class="w"> </span>    Args:
<span class="gu">@@ -427,11 +2116,15 @@ def apply_validators(schema: core_schema.CoreSchema, validators: (Iterable[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The updated schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for validator in validators:</span>
<span class="gi">+        info_arg = inspect_validator(validator.func, validator.info.mode)</span>
<span class="gi">+        val_type = &#39;with-info&#39; if info_arg else &#39;no-info&#39;</span>
<span class="gi">+</span>
<span class="gi">+        schema = _VALIDATOR_F_MATCH[(validator.info.mode, val_type)](validator.func, schema, field_name)</span>
<span class="gi">+    return schema</span>


<span class="gd">-def _validators_require_validate_default(validators: Iterable[Decorator[</span>
<span class="gd">-    ValidatorDecoratorInfo]]) -&gt;bool:</span>
<span class="gi">+def _validators_require_validate_default(validators: Iterable[Decorator[ValidatorDecoratorInfo]]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;In v1, if any of the validators for a field had `always=True`, the default value would be validated.

<span class="w"> </span>    This serves as an auxiliary function for re-implementing that logic, by looping over a provided
<span class="gu">@@ -441,12 +2134,17 @@ def _validators_require_validate_default(validators: Iterable[Decorator[</span>
<span class="w"> </span>    for v1-style validator decorators. (Or we can extend it and keep it if we add something equivalent
<span class="w"> </span>    to the v1-validator `always` kwarg to `field_validator`.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for validator in validators:</span>
<span class="gi">+        if validator.info.always:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def apply_model_validators(schema: core_schema.CoreSchema, validators:</span>
<span class="gd">-    Iterable[Decorator[ModelValidatorDecoratorInfo]], mode: Literal[&#39;inner&#39;,</span>
<span class="gd">-    &#39;outer&#39;, &#39;all&#39;]) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+def apply_model_validators(</span>
<span class="gi">+    schema: core_schema.CoreSchema,</span>
<span class="gi">+    validators: Iterable[Decorator[ModelValidatorDecoratorInfo]],</span>
<span class="gi">+    mode: Literal[&#39;inner&#39;, &#39;outer&#39;, &#39;all&#39;],</span>
<span class="gi">+) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>    &quot;&quot;&quot;Apply model validators to a schema.

<span class="w"> </span>    If mode == &#39;inner&#39;, only &quot;before&quot; validators are applied
<span class="gu">@@ -461,11 +2159,35 @@ def apply_model_validators(schema: core_schema.CoreSchema, validators:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The updated schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def wrap_default(field_info: FieldInfo, schema: core_schema.CoreSchema</span>
<span class="gd">-    ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    ref: str | None = schema.pop(&#39;ref&#39;, None)  # type: ignore</span>
<span class="gi">+    for validator in validators:</span>
<span class="gi">+        if mode == &#39;inner&#39; and validator.info.mode != &#39;before&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if mode == &#39;outer&#39; and validator.info.mode == &#39;before&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        info_arg = inspect_validator(validator.func, validator.info.mode)</span>
<span class="gi">+        if validator.info.mode == &#39;wrap&#39;:</span>
<span class="gi">+            if info_arg:</span>
<span class="gi">+                schema = core_schema.with_info_wrap_validator_function(function=validator.func, schema=schema)</span>
<span class="gi">+            else:</span>
<span class="gi">+                schema = core_schema.no_info_wrap_validator_function(function=validator.func, schema=schema)</span>
<span class="gi">+        elif validator.info.mode == &#39;before&#39;:</span>
<span class="gi">+            if info_arg:</span>
<span class="gi">+                schema = core_schema.with_info_before_validator_function(function=validator.func, schema=schema)</span>
<span class="gi">+            else:</span>
<span class="gi">+                schema = core_schema.no_info_before_validator_function(function=validator.func, schema=schema)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert validator.info.mode == &#39;after&#39;</span>
<span class="gi">+            if info_arg:</span>
<span class="gi">+                schema = core_schema.with_info_after_validator_function(function=validator.func, schema=schema)</span>
<span class="gi">+            else:</span>
<span class="gi">+                schema = core_schema.no_info_after_validator_function(function=validator.func, schema=schema)</span>
<span class="gi">+    if ref:</span>
<span class="gi">+        schema[&#39;ref&#39;] = ref  # type: ignore</span>
<span class="gi">+    return schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def wrap_default(field_info: FieldInfo, schema: core_schema.CoreSchema) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wrap schema with default schema if default value or `default_factory` are available.

<span class="w"> </span>    Args:
<span class="gu">@@ -475,13 +2197,69 @@ def wrap_default(field_info: FieldInfo, schema: core_schema.CoreSchema</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Updated schema by default value or `default_factory`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if field_info.default_factory:</span>
<span class="gi">+        return core_schema.with_default_schema(</span>
<span class="gi">+            schema, default_factory=field_info.default_factory, validate_default=field_info.validate_default</span>
<span class="gi">+        )</span>
<span class="gi">+    elif field_info.default is not PydanticUndefined:</span>
<span class="gi">+        return core_schema.with_default_schema(</span>
<span class="gi">+            schema, default=field_info.default, validate_default=field_info.validate_default</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _extract_get_pydantic_json_schema(tp: Any, schema: CoreSchema) -&gt; GetJsonSchemaFunction | None:</span>
<span class="gi">+    &quot;&quot;&quot;Extract `__get_pydantic_json_schema__` from a type, handling the deprecated `__modify_schema__`.&quot;&quot;&quot;</span>
<span class="gi">+    js_modify_function = getattr(tp, &#39;__get_pydantic_json_schema__&#39;, None)</span>

<span class="gi">+    if hasattr(tp, &#39;__modify_schema__&#39;):</span>
<span class="gi">+        from pydantic import BaseModel  # circular reference</span>
<span class="gi">+</span>
<span class="gi">+        has_custom_v2_modify_js_func = (</span>
<span class="gi">+            js_modify_function is not None</span>
<span class="gi">+            and BaseModel.__get_pydantic_json_schema__.__func__  # type: ignore</span>
<span class="gi">+            not in (js_modify_function, getattr(js_modify_function, &#39;__func__&#39;, None))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if not has_custom_v2_modify_js_func:</span>
<span class="gi">+            cls_name = getattr(tp, &#39;__name__&#39;, None)</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;The `__modify_schema__` method is not supported in Pydantic v2. &#39;</span>
<span class="gi">+                f&#39;Use `__get_pydantic_json_schema__` instead{f&quot; in class `{cls_name}`&quot; if cls_name else &quot;&quot;}.&#39;,</span>
<span class="gi">+                code=&#39;custom-json-schema&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # handle GenericAlias&#39; but ignore Annotated which &quot;lies&quot; about its origin (in this case it would be `int`)</span>
<span class="gi">+    if hasattr(tp, &#39;__origin__&#39;) and not isinstance(tp, type(Annotated[int, &#39;placeholder&#39;])):</span>
<span class="gi">+        return _extract_get_pydantic_json_schema(tp.__origin__, schema)</span>
<span class="gi">+</span>
<span class="gi">+    if js_modify_function is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    return js_modify_function</span>

<span class="gd">-def _extract_get_pydantic_json_schema(tp: Any, schema: CoreSchema) -&gt;(</span>
<span class="gd">-    GetJsonSchemaFunction | None):</span>
<span class="gd">-    &quot;&quot;&quot;Extract `__get_pydantic_json_schema__` from a type, handling the deprecated `__modify_schema__`.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+def get_json_schema_update_func(</span>
<span class="gi">+    json_schema_update: JsonSchemaValue, json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None</span>
<span class="gi">+) -&gt; GetJsonSchemaFunction:</span>
<span class="gi">+    def json_schema_update_func(</span>
<span class="gi">+        core_schema_or_field: CoreSchemaOrField, handler: GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="gi">+        json_schema = {**handler(core_schema_or_field), **json_schema_update}</span>
<span class="gi">+        add_json_schema_extra(json_schema, json_schema_extra)</span>
<span class="gi">+        return json_schema</span>
<span class="gi">+</span>
<span class="gi">+    return json_schema_update_func</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add_json_schema_extra(</span>
<span class="gi">+    json_schema: JsonSchemaValue, json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None</span>
<span class="gi">+):</span>
<span class="gi">+    if isinstance(json_schema_extra, dict):</span>
<span class="gi">+        json_schema.update(to_jsonable_python(json_schema_extra))</span>
<span class="gi">+    elif callable(json_schema_extra):</span>
<span class="gi">+        json_schema_extra(json_schema)</span>


<span class="w"> </span>class _CommonField(TypedDict):
<span class="gu">@@ -493,16 +2271,34 @@ class _CommonField(TypedDict):</span>
<span class="w"> </span>    metadata: dict[str, Any]


<span class="gi">+def _common_field(</span>
<span class="gi">+    schema: core_schema.CoreSchema,</span>
<span class="gi">+    *,</span>
<span class="gi">+    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,</span>
<span class="gi">+    serialization_alias: str | None = None,</span>
<span class="gi">+    serialization_exclude: bool | None = None,</span>
<span class="gi">+    frozen: bool | None = None,</span>
<span class="gi">+    metadata: Any = None,</span>
<span class="gi">+) -&gt; _CommonField:</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;schema&#39;: schema,</span>
<span class="gi">+        &#39;validation_alias&#39;: validation_alias,</span>
<span class="gi">+        &#39;serialization_alias&#39;: serialization_alias,</span>
<span class="gi">+        &#39;serialization_exclude&#39;: serialization_exclude,</span>
<span class="gi">+        &#39;frozen&#39;: frozen,</span>
<span class="gi">+        &#39;metadata&#39;: metadata,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class _Definitions:
<span class="w"> </span>    &quot;&quot;&quot;Keeps track of references and definitions.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.seen: set[str] = set()
<span class="w"> </span>        self.definitions: dict[str, core_schema.CoreSchema] = {}

<span class="w"> </span>    @contextmanager
<span class="gd">-    def get_schema_or_ref(self, tp: Any) -&gt;Iterator[tuple[str, None] |</span>
<span class="gd">-        tuple[str, CoreSchema]]:</span>
<span class="gi">+    def get_schema_or_ref(self, tp: Any) -&gt; Iterator[tuple[str, None] | tuple[str, CoreSchema]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a definition for `tp` if one exists.

<span class="w"> </span>        If a definition exists, a tuple of `(ref_string, CoreSchema)` is returned.
<span class="gu">@@ -521,18 +2317,60 @@ class _Definitions:</span>
<span class="w"> </span>        - TypedDict
<span class="w"> </span>        - TypeAliasType
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ref = get_type_ref(tp)</span>
<span class="gi">+        # return the reference if we&#39;re either (1) in a cycle or (2) it was already defined</span>
<span class="gi">+        if ref in self.seen or ref in self.definitions:</span>
<span class="gi">+            yield (ref, core_schema.definition_reference_schema(ref))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.seen.add(ref)</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield (ref, None)</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self.seen.discard(ref)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve_original_schema(schema: CoreSchema, definitions: dict[str, CoreSchema]) -&gt; CoreSchema | None:</span>
<span class="gi">+    if schema[&#39;type&#39;] == &#39;definition-ref&#39;:</span>
<span class="gi">+        return definitions.get(schema[&#39;schema_ref&#39;], None)</span>
<span class="gi">+    elif schema[&#39;type&#39;] == &#39;definitions&#39;:</span>
<span class="gi">+        return schema[&#39;schema&#39;]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return schema</span>


<span class="w"> </span>class _FieldNameStack:
<span class="gd">-    __slots__ = &#39;_stack&#39;,</span>
<span class="gi">+    __slots__ = (&#39;_stack&#39;,)</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._stack: list[str] = []

<span class="gi">+    @contextmanager</span>
<span class="gi">+    def push(self, field_name: str) -&gt; Iterator[None]:</span>
<span class="gi">+        self._stack.append(field_name)</span>
<span class="gi">+        yield</span>
<span class="gi">+        self._stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def get(self) -&gt; str | None:</span>
<span class="gi">+        if self._stack:</span>
<span class="gi">+            return self._stack[-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>

<span class="w"> </span>class _ModelTypeStack:
<span class="gd">-    __slots__ = &#39;_stack&#39;,</span>
<span class="gi">+    __slots__ = (&#39;_stack&#39;,)</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._stack: list[type] = []
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def push(self, type_obj: type) -&gt; Iterator[None]:</span>
<span class="gi">+        self._stack.append(type_obj)</span>
<span class="gi">+        yield</span>
<span class="gi">+        self._stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def get(self) -&gt; type | None:</span>
<span class="gi">+        if self._stack:</span>
<span class="gi">+            return self._stack[-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gh">diff --git a/pydantic/_internal/_generics.py b/pydantic/_internal/_generics.py</span>
<span class="gh">index 6087db94e..0bd106b24 100644</span>
<span class="gd">--- a/pydantic/_internal/_generics.py</span>
<span class="gi">+++ b/pydantic/_internal/_generics.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="w"> </span>import typing
<span class="gu">@@ -8,58 +9,70 @@ from contextvars import ContextVar</span>
<span class="w"> </span>from types import prepare_class
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Iterator, List, Mapping, MutableMapping, Tuple, TypeVar
<span class="w"> </span>from weakref import WeakValueDictionary
<span class="gi">+</span>
<span class="w"> </span>import typing_extensions
<span class="gi">+</span>
<span class="w"> </span>from ._core_utils import get_type_ref
<span class="w"> </span>from ._forward_ref import PydanticRecursiveRef
<span class="w"> </span>from ._typing_extra import TypeVarType, typing_base
<span class="w"> </span>from ._utils import all_identical, is_model_class
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):
<span class="gd">-    from typing import _UnionGenericAlias</span>
<span class="gi">+    from typing import _UnionGenericAlias  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ..main import BaseModel
<span class="gi">+</span>
<span class="w"> </span>GenericTypesCacheKey = Tuple[Any, Any, Tuple[Any, ...]]
<span class="gi">+</span>
<span class="gi">+# Note: We want to remove LimitedDict, but to do this, we&#39;d need to improve the handling of generics caching.</span>
<span class="gi">+#   Right now, to handle recursive generics, we some types must remain cached for brief periods without references.</span>
<span class="gi">+#   By chaining the WeakValuesDict with a LimitedDict, we have a way to retain caching for all types with references,</span>
<span class="gi">+#   while also retaining a limited number of types even without references. This is generally enough to build</span>
<span class="gi">+#   specific recursive generic models without losing required items out of the cache.</span>
<span class="gi">+</span>
<span class="w"> </span>KT = TypeVar(&#39;KT&#39;)
<span class="w"> </span>VT = TypeVar(&#39;VT&#39;)
<span class="w"> </span>_LIMITED_DICT_SIZE = 100
<span class="w"> </span>if TYPE_CHECKING:

<span class="gd">-</span>
<span class="w"> </span>    class LimitedDict(dict, MutableMapping[KT, VT]):
<span class="gi">+        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE): ...</span>

<span class="gd">-        def __init__(self, size_limit: int=_LIMITED_DICT_SIZE):</span>
<span class="gd">-            ...</span>
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class LimitedDict(dict):
<span class="w"> </span>        &quot;&quot;&quot;Limit the size/length of a dict used for caching to avoid unlimited increase in memory usage.

<span class="w"> </span>        Since the dict is ordered, and we always remove elements from the beginning, this is effectively a FIFO cache.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-        def __init__(self, size_limit: int=_LIMITED_DICT_SIZE):</span>
<span class="gi">+        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE):</span>
<span class="w"> </span>            self.size_limit = size_limit
<span class="w"> </span>            super().__init__()

<span class="gd">-        def __setitem__(self, key: Any, value: Any, /) -&gt;None:</span>
<span class="gi">+        def __setitem__(self, key: Any, value: Any, /) -&gt; None:</span>
<span class="w"> </span>            super().__setitem__(key, value)
<span class="w"> </span>            if len(self) &gt; self.size_limit:
<span class="w"> </span>                excess = len(self) - self.size_limit + self.size_limit // 10
<span class="w"> </span>                to_remove = list(self.keys())[:excess]
<span class="w"> </span>                for k in to_remove:
<span class="w"> </span>                    del self[k]
<span class="gd">-if sys.version_info &gt;= (3, 9):</span>
<span class="gd">-    GenericTypesCache = WeakValueDictionary[GenericTypesCacheKey,</span>
<span class="gd">-        &#39;type[BaseModel]&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# weak dictionaries allow the dynamically created parametrized versions of generic models to get collected</span>
<span class="gi">+# once they are no longer referenced by the caller.</span>
<span class="gi">+if sys.version_info &gt;= (3, 9):  # Typing for weak dictionaries available at 3.9</span>
<span class="gi">+    GenericTypesCache = WeakValueDictionary[GenericTypesCacheKey, &#39;type[BaseModel]&#39;]</span>
<span class="w"> </span>else:
<span class="w"> </span>    GenericTypesCache = WeakValueDictionary
<span class="gd">-if TYPE_CHECKING:</span>

<span class="gi">+if TYPE_CHECKING:</span>

<span class="gd">-    class DeepChainMap(ChainMap[KT, VT]):</span>
<span class="gi">+    class DeepChainMap(ChainMap[KT, VT]):  # type: ignore</span>
<span class="w"> </span>        ...
<span class="gd">-else:</span>

<span class="gi">+else:</span>

<span class="w"> </span>    class DeepChainMap(ChainMap):
<span class="w"> </span>        &quot;&quot;&quot;Variant of ChainMap that allows direct updates to inner scopes.
<span class="gu">@@ -68,11 +81,15 @@ else:</span>
<span class="w"> </span>        with some light modifications for this use case.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-        def __setitem__(self, key: KT, value: VT) -&gt;None:</span>
<span class="gi">+        def clear(self) -&gt; None:</span>
<span class="gi">+            for mapping in self.maps:</span>
<span class="gi">+                mapping.clear()</span>
<span class="gi">+</span>
<span class="gi">+        def __setitem__(self, key: KT, value: VT) -&gt; None:</span>
<span class="w"> </span>            for mapping in self.maps:
<span class="w"> </span>                mapping[key] = value

<span class="gd">-        def __delitem__(self, key: KT) -&gt;None:</span>
<span class="gi">+        def __delitem__(self, key: KT) -&gt; None:</span>
<span class="w"> </span>            hit = False
<span class="w"> </span>            for mapping in self.maps:
<span class="w"> </span>                if key in mapping:
<span class="gu">@@ -80,17 +97,24 @@ else:</span>
<span class="w"> </span>                    hit = True
<span class="w"> </span>            if not hit:
<span class="w"> </span>                raise KeyError(key)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Despite the fact that LimitedDict _seems_ no longer necessary, I&#39;m very nervous to actually remove it</span>
<span class="gi">+# and discover later on that we need to re-add all this infrastructure...</span>
<span class="gi">+# _GENERIC_TYPES_CACHE = DeepChainMap(GenericTypesCache(), LimitedDict())</span>
<span class="gi">+</span>
<span class="w"> </span>_GENERIC_TYPES_CACHE = GenericTypesCache()


<span class="w"> </span>class PydanticGenericMetadata(typing_extensions.TypedDict):
<span class="gd">-    origin: type[BaseModel] | None</span>
<span class="gd">-    args: tuple[Any, ...]</span>
<span class="gd">-    parameters: tuple[type[Any], ...]</span>
<span class="gi">+    origin: type[BaseModel] | None  # analogous to typing._GenericAlias.__origin__</span>
<span class="gi">+    args: tuple[Any, ...]  # analogous to typing._GenericAlias.__args__</span>
<span class="gi">+    parameters: tuple[type[Any], ...]  # analogous to typing.Generic.__parameters__</span>


<span class="gd">-def create_generic_submodel(model_name: str, origin: type[BaseModel], args:</span>
<span class="gd">-    tuple[Any, ...], params: tuple[Any, ...]) -&gt;type[BaseModel]:</span>
<span class="gi">+def create_generic_submodel(</span>
<span class="gi">+    model_name: str, origin: type[BaseModel], args: tuple[Any, ...], params: tuple[Any, ...]</span>
<span class="gi">+) -&gt; type[BaseModel]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Dynamically create a submodel of a provided (generic) BaseModel.

<span class="w"> </span>    This is used when producing concrete parametrizations of generic models. This function
<span class="gu">@@ -106,10 +130,36 @@ def create_generic_submodel(model_name: str, origin: type[BaseModel], args:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The created submodel.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _get_caller_frame_info(depth: int=2) -&gt;tuple[str | None, bool]:</span>
<span class="gi">+    namespace: dict[str, Any] = {&#39;__module__&#39;: origin.__module__}</span>
<span class="gi">+    bases = (origin,)</span>
<span class="gi">+    meta, ns, kwds = prepare_class(model_name, bases)</span>
<span class="gi">+    namespace.update(ns)</span>
<span class="gi">+    created_model = meta(</span>
<span class="gi">+        model_name,</span>
<span class="gi">+        bases,</span>
<span class="gi">+        namespace,</span>
<span class="gi">+        __pydantic_generic_metadata__={</span>
<span class="gi">+            &#39;origin&#39;: origin,</span>
<span class="gi">+            &#39;args&#39;: args,</span>
<span class="gi">+            &#39;parameters&#39;: params,</span>
<span class="gi">+        },</span>
<span class="gi">+        __pydantic_reset_parent_namespace__=False,</span>
<span class="gi">+        **kwds,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    model_module, called_globally = _get_caller_frame_info(depth=3)</span>
<span class="gi">+    if called_globally:  # create global reference and therefore allow pickling</span>
<span class="gi">+        object_by_reference = None</span>
<span class="gi">+        reference_name = model_name</span>
<span class="gi">+        reference_module_globals = sys.modules[created_model.__module__].__dict__</span>
<span class="gi">+        while object_by_reference is not created_model:</span>
<span class="gi">+            object_by_reference = reference_module_globals.setdefault(reference_name, created_model)</span>
<span class="gi">+            reference_name += &#39;_&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return created_model</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_caller_frame_info(depth: int = 2) -&gt; tuple[str | None, bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Used inside a function to check whether it was called globally.

<span class="w"> </span>    Args:
<span class="gu">@@ -121,41 +171,85 @@ def _get_caller_frame_info(depth: int=2) -&gt;tuple[str | None, bool]:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        RuntimeError: If the function is not called inside a function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        previous_caller_frame = sys._getframe(depth)</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise RuntimeError(&#39;This function must be used inside another function&#39;) from e</span>
<span class="gi">+    except AttributeError:  # sys module does not have _getframe function, so there&#39;s nothing we can do about it</span>
<span class="gi">+        return None, False</span>
<span class="gi">+    frame_globals = previous_caller_frame.f_globals</span>
<span class="gi">+    return frame_globals.get(&#39;__name__&#39;), previous_caller_frame.f_locals is frame_globals</span>


<span class="w"> </span>DictValues: type[Any] = {}.values().__class__


<span class="gd">-def iter_contained_typevars(v: Any) -&gt;Iterator[TypeVarType]:</span>
<span class="gi">+def iter_contained_typevars(v: Any) -&gt; Iterator[TypeVarType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.

<span class="w"> </span>    This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,
<span class="w"> </span>    since __parameters__ of (nested) generic BaseModel subclasses won&#39;t show up in that list.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_standard_typevars_map(cls: type[Any]) -&gt;(dict[TypeVarType, Any] | None</span>
<span class="gd">-    ):</span>
<span class="gi">+    if isinstance(v, TypeVar):</span>
<span class="gi">+        yield v</span>
<span class="gi">+    elif is_model_class(v):</span>
<span class="gi">+        yield from v.__pydantic_generic_metadata__[&#39;parameters&#39;]</span>
<span class="gi">+    elif isinstance(v, (DictValues, list)):</span>
<span class="gi">+        for var in v:</span>
<span class="gi">+            yield from iter_contained_typevars(var)</span>
<span class="gi">+    else:</span>
<span class="gi">+        args = get_args(v)</span>
<span class="gi">+        for arg in args:</span>
<span class="gi">+            yield from iter_contained_typevars(arg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_args(v: Any) -&gt; Any:</span>
<span class="gi">+    pydantic_generic_metadata: PydanticGenericMetadata | None = getattr(v, &#39;__pydantic_generic_metadata__&#39;, None)</span>
<span class="gi">+    if pydantic_generic_metadata:</span>
<span class="gi">+        return pydantic_generic_metadata.get(&#39;args&#39;)</span>
<span class="gi">+    return typing_extensions.get_args(v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_origin(v: Any) -&gt; Any:</span>
<span class="gi">+    pydantic_generic_metadata: PydanticGenericMetadata | None = getattr(v, &#39;__pydantic_generic_metadata__&#39;, None)</span>
<span class="gi">+    if pydantic_generic_metadata:</span>
<span class="gi">+        return pydantic_generic_metadata.get(&#39;origin&#39;)</span>
<span class="gi">+    return typing_extensions.get_origin(v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_standard_typevars_map(cls: type[Any]) -&gt; dict[TypeVarType, Any] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Package a generic type&#39;s typevars and parametrization (if present) into a dictionary compatible with the
<span class="w"> </span>    `replace_types` function. Specifically, this works with standard typing generics and typing._GenericAlias.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    origin = get_origin(cls)</span>
<span class="gi">+    if origin is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if not hasattr(origin, &#39;__parameters__&#39;):</span>
<span class="gi">+        return None</span>

<span class="gi">+    # In this case, we know that cls is a _GenericAlias, and origin is the generic type</span>
<span class="gi">+    # So it is safe to access cls.__args__ and origin.__parameters__</span>
<span class="gi">+    args: tuple[Any, ...] = cls.__args__  # type: ignore</span>
<span class="gi">+    parameters: tuple[TypeVarType, ...] = origin.__parameters__</span>
<span class="gi">+    return dict(zip(parameters, args))</span>

<span class="gd">-def get_model_typevars_map(cls: type[BaseModel]) -&gt;(dict[TypeVarType, Any] |</span>
<span class="gd">-    None):</span>
<span class="gi">+</span>
<span class="gi">+def get_model_typevars_map(cls: type[BaseModel]) -&gt; dict[TypeVarType, Any] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Package a generic BaseModel&#39;s typevars and concrete parametrization (if present) into a dictionary compatible
<span class="w"> </span>    with the `replace_types` function.

<span class="w"> </span>    Since BaseModel.__class_getitem__ does not produce a typing._GenericAlias, and the BaseModel generic info is
<span class="w"> </span>    stored in the __pydantic_generic_metadata__ attribute, we need special handling here.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO: This could be unified with `get_standard_typevars_map` if we stored the generic metadata</span>
<span class="gi">+    #   in the __origin__, __args__, and __parameters__ attributes of the model.</span>
<span class="gi">+    generic_metadata = cls.__pydantic_generic_metadata__</span>
<span class="gi">+    origin = generic_metadata[&#39;origin&#39;]</span>
<span class="gi">+    args = generic_metadata[&#39;args&#39;]</span>
<span class="gi">+    return dict(zip(iter_contained_typevars(origin), args))</span>


<span class="gd">-def replace_types(type_: Any, type_map: (Mapping[Any, Any] | None)) -&gt;Any:</span>
<span class="gi">+def replace_types(type_: Any, type_map: Mapping[Any, Any] | None) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return type with all occurrences of `type_map` keys recursively replaced with their values.

<span class="w"> </span>    Args:
<span class="gu">@@ -176,18 +270,99 @@ def replace_types(type_: Any, type_map: (Mapping[Any, Any] | None)) -&gt;Any:</span>
<span class="w"> </span>        #&gt; Tuple[int, Union[List[int], float]]
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def has_instance_in_type(type_: Any, isinstance_target: Any) -&gt;bool:</span>
<span class="gi">+    if not type_map:</span>
<span class="gi">+        return type_</span>
<span class="gi">+</span>
<span class="gi">+    type_args = get_args(type_)</span>
<span class="gi">+    origin_type = get_origin(type_)</span>
<span class="gi">+</span>
<span class="gi">+    if origin_type is typing_extensions.Annotated:</span>
<span class="gi">+        annotated_type, *annotations = type_args</span>
<span class="gi">+        annotated = replace_types(annotated_type, type_map)</span>
<span class="gi">+        for annotation in annotations:</span>
<span class="gi">+            annotated = typing_extensions.Annotated[annotated, annotation]</span>
<span class="gi">+        return annotated</span>
<span class="gi">+</span>
<span class="gi">+    # Having type args is a good indicator that this is a typing module</span>
<span class="gi">+    # class instantiation or a generic alias of some sort.</span>
<span class="gi">+    if type_args:</span>
<span class="gi">+        resolved_type_args = tuple(replace_types(arg, type_map) for arg in type_args)</span>
<span class="gi">+        if all_identical(type_args, resolved_type_args):</span>
<span class="gi">+            # If all arguments are the same, there is no need to modify the</span>
<span class="gi">+            # type or create a new object at all</span>
<span class="gi">+            return type_</span>
<span class="gi">+        if (</span>
<span class="gi">+            origin_type is not None</span>
<span class="gi">+            and isinstance(type_, typing_base)</span>
<span class="gi">+            and not isinstance(origin_type, typing_base)</span>
<span class="gi">+            and getattr(type_, &#39;_name&#39;, None) is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            # In python &lt; 3.9 generic aliases don&#39;t exist so any of these like `list`,</span>
<span class="gi">+            # `type` or `collections.abc.Callable` need to be translated.</span>
<span class="gi">+            # See: https://www.python.org/dev/peps/pep-0585</span>
<span class="gi">+            origin_type = getattr(typing, type_._name)</span>
<span class="gi">+        assert origin_type is not None</span>
<span class="gi">+        # PEP-604 syntax (Ex.: list | str) is represented with a types.UnionType object that does not have __getitem__.</span>
<span class="gi">+        # We also cannot use isinstance() since we have to compare types.</span>
<span class="gi">+        if sys.version_info &gt;= (3, 10) and origin_type is types.UnionType:</span>
<span class="gi">+            return _UnionGenericAlias(origin_type, resolved_type_args)</span>
<span class="gi">+        # NotRequired[T] and Required[T] don&#39;t support tuple type resolved_type_args, hence the condition below</span>
<span class="gi">+        return origin_type[resolved_type_args[0] if len(resolved_type_args) == 1 else resolved_type_args]</span>
<span class="gi">+</span>
<span class="gi">+    # We handle pydantic generic models separately as they don&#39;t have the same</span>
<span class="gi">+    # semantics as &quot;typing&quot; classes or generic aliases</span>
<span class="gi">+</span>
<span class="gi">+    if not origin_type and is_model_class(type_):</span>
<span class="gi">+        parameters = type_.__pydantic_generic_metadata__[&#39;parameters&#39;]</span>
<span class="gi">+        if not parameters:</span>
<span class="gi">+            return type_</span>
<span class="gi">+        resolved_type_args = tuple(replace_types(t, type_map) for t in parameters)</span>
<span class="gi">+        if all_identical(parameters, resolved_type_args):</span>
<span class="gi">+            return type_</span>
<span class="gi">+        return type_[resolved_type_args]</span>
<span class="gi">+</span>
<span class="gi">+    # Handle special case for typehints that can have lists as arguments.</span>
<span class="gi">+    # `typing.Callable[[int, str], int]` is an example for this.</span>
<span class="gi">+    if isinstance(type_, (List, list)):</span>
<span class="gi">+        resolved_list = list(replace_types(element, type_map) for element in type_)</span>
<span class="gi">+        if all_identical(type_, resolved_list):</span>
<span class="gi">+            return type_</span>
<span class="gi">+        return resolved_list</span>
<span class="gi">+</span>
<span class="gi">+    # If all else fails, we try to resolve the type directly and otherwise just</span>
<span class="gi">+    # return the input with no modifications.</span>
<span class="gi">+    return type_map.get(type_, type_)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def has_instance_in_type(type_: Any, isinstance_target: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if the type, or any of its arbitrary nested args, satisfy
<span class="w"> </span>    `isinstance(&lt;type&gt;, isinstance_target)`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(type_, isinstance_target):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    type_args = get_args(type_)</span>
<span class="gi">+    origin_type = get_origin(type_)</span>
<span class="gi">+</span>
<span class="gi">+    if origin_type is typing_extensions.Annotated:</span>
<span class="gi">+        annotated_type, *annotations = type_args</span>
<span class="gi">+        return has_instance_in_type(annotated_type, isinstance_target)</span>

<span class="gi">+    # Having type args is a good indicator that this is a typing module</span>
<span class="gi">+    # class instantiation or a generic alias of some sort.</span>
<span class="gi">+    if any(has_instance_in_type(a, isinstance_target) for a in type_args):</span>
<span class="gi">+        return True</span>

<span class="gd">-def check_parameters_count(cls: type[BaseModel], parameters: tuple[Any, ...]</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+    # Handle special case for typehints that can have lists as arguments.</span>
<span class="gi">+    # `typing.Callable[[int, str], int]` is an example for this.</span>
<span class="gi">+    if isinstance(type_, (List, list)) and not isinstance(type_, typing_extensions.ParamSpec):</span>
<span class="gi">+        if any(has_instance_in_type(element, isinstance_target) for element in type_):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def check_parameters_count(cls: type[BaseModel], parameters: tuple[Any, ...]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check the generic model parameters count is equal.

<span class="w"> </span>    Args:
<span class="gu">@@ -197,16 +372,20 @@ def check_parameters_count(cls: type[BaseModel], parameters: tuple[Any, ...]</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        TypeError: If the passed parameters count is not equal to generic model parameters count.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    actual = len(parameters)</span>
<span class="gi">+    expected = len(cls.__pydantic_generic_metadata__[&#39;parameters&#39;])</span>
<span class="gi">+    if actual != expected:</span>
<span class="gi">+        description = &#39;many&#39; if actual &gt; expected else &#39;few&#39;</span>
<span class="gi">+        raise TypeError(f&#39;Too {description} parameters for {cls}; actual {actual}, expected {expected}&#39;)</span>


<span class="gd">-_generic_recursion_cache: ContextVar[set[str] | None] = ContextVar(</span>
<span class="gd">-    &#39;_generic_recursion_cache&#39;, default=None)</span>
<span class="gi">+_generic_recursion_cache: ContextVar[set[str] | None] = ContextVar(&#39;_generic_recursion_cache&#39;, default=None)</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def generic_recursion_self_type(origin: type[BaseModel], args: tuple[Any, ...]</span>
<span class="gd">-    ) -&gt;Iterator[PydanticRecursiveRef | None]:</span>
<span class="gi">+def generic_recursion_self_type(</span>
<span class="gi">+    origin: type[BaseModel], args: tuple[Any, ...]</span>
<span class="gi">+) -&gt; Iterator[PydanticRecursiveRef | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;This contextmanager should be placed around the recursive calls used to build a generic type,
<span class="w"> </span>    and accept as arguments the generic origin type and the type arguments being passed to it.

<span class="gu">@@ -214,11 +393,35 @@ def generic_recursion_self_type(origin: type[BaseModel], args: tuple[Any, ...]</span>
<span class="w"> </span>    can be used while building the core schema, and will produce a schema_ref that will be valid in the
<span class="w"> </span>    final parent schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_cached_generic_type_early(parent: type[BaseModel], typevar_values: Any</span>
<span class="gd">-    ) -&gt;(type[BaseModel] | None):</span>
<span class="gi">+    previously_seen_type_refs = _generic_recursion_cache.get()</span>
<span class="gi">+    if previously_seen_type_refs is None:</span>
<span class="gi">+        previously_seen_type_refs = set()</span>
<span class="gi">+        token = _generic_recursion_cache.set(previously_seen_type_refs)</span>
<span class="gi">+    else:</span>
<span class="gi">+        token = None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        type_ref = get_type_ref(origin, args_override=args)</span>
<span class="gi">+        if type_ref in previously_seen_type_refs:</span>
<span class="gi">+            self_type = PydanticRecursiveRef(type_ref=type_ref)</span>
<span class="gi">+            yield self_type</span>
<span class="gi">+        else:</span>
<span class="gi">+            previously_seen_type_refs.add(type_ref)</span>
<span class="gi">+            yield None</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if token:</span>
<span class="gi">+            _generic_recursion_cache.reset(token)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def recursively_defined_type_refs() -&gt; set[str]:</span>
<span class="gi">+    visited = _generic_recursion_cache.get()</span>
<span class="gi">+    if not visited:</span>
<span class="gi">+        return set()  # not in a generic recursion, so there are no types</span>
<span class="gi">+</span>
<span class="gi">+    return visited.copy()  # don&#39;t allow modifications</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_cached_generic_type_early(parent: type[BaseModel], typevar_values: Any) -&gt; type[BaseModel] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;The use of a two-stage cache lookup approach was necessary to have the highest performance possible for
<span class="w"> </span>    repeated calls to `__class_getitem__` on generic types (which may happen in tighter loops during runtime),
<span class="w"> </span>    while still ensuring that certain alternative parametrizations ultimately resolve to the same type.
<span class="gu">@@ -235,26 +438,37 @@ def get_cached_generic_type_early(parent: type[BaseModel], typevar_values: Any</span>
<span class="w"> </span>    during validation, I think it is worthwhile to ensure that types that are functionally equivalent are actually
<span class="w"> </span>    equal.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _GENERIC_TYPES_CACHE.get(_early_cache_key(parent, typevar_values))</span>


<span class="gd">-def get_cached_generic_type_late(parent: type[BaseModel], typevar_values:</span>
<span class="gd">-    Any, origin: type[BaseModel], args: tuple[Any, ...]) -&gt;(type[BaseModel] |</span>
<span class="gd">-    None):</span>
<span class="gi">+def get_cached_generic_type_late(</span>
<span class="gi">+    parent: type[BaseModel], typevar_values: Any, origin: type[BaseModel], args: tuple[Any, ...]</span>
<span class="gi">+) -&gt; type[BaseModel] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;See the docstring of `get_cached_generic_type_early` for more information about the two-stage cache lookup.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def set_cached_generic_type(parent: type[BaseModel], typevar_values: tuple[</span>
<span class="gd">-    Any, ...], type_: type[BaseModel], origin: (type[BaseModel] | None)=</span>
<span class="gd">-    None, args: (tuple[Any, ...] | None)=None) -&gt;None:</span>
<span class="gi">+    cached = _GENERIC_TYPES_CACHE.get(_late_cache_key(origin, args, typevar_values))</span>
<span class="gi">+    if cached is not None:</span>
<span class="gi">+        set_cached_generic_type(parent, typevar_values, cached, origin, args)</span>
<span class="gi">+    return cached</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_cached_generic_type(</span>
<span class="gi">+    parent: type[BaseModel],</span>
<span class="gi">+    typevar_values: tuple[Any, ...],</span>
<span class="gi">+    type_: type[BaseModel],</span>
<span class="gi">+    origin: type[BaseModel] | None = None,</span>
<span class="gi">+    args: tuple[Any, ...] | None = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;See the docstring of `get_cached_generic_type_early` for more information about why items are cached with
<span class="w"> </span>    two different keys.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values)] = type_</span>
<span class="gi">+    if len(typevar_values) == 1:</span>
<span class="gi">+        _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values[0])] = type_</span>
<span class="gi">+    if origin and args:</span>
<span class="gi">+        _GENERIC_TYPES_CACHE[_late_cache_key(origin, args, typevar_values)] = type_</span>


<span class="gd">-def _union_orderings_key(typevar_values: Any) -&gt;Any:</span>
<span class="gi">+def _union_orderings_key(typevar_values: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;This is intended to help differentiate between Union types with the same arguments in different order.

<span class="w"> </span>    Thanks to caching internal to the `typing` module, it is not possible to distinguish between
<span class="gu">@@ -267,11 +481,18 @@ def _union_orderings_key(typevar_values: Any) -&gt;Any:</span>
<span class="w"> </span>    get the exact-correct order of items in the union, but that would require a change to the `typing` module itself.
<span class="w"> </span>    (See https://github.com/python/cpython/issues/86483 for reference.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _early_cache_key(cls: type[BaseModel], typevar_values: Any</span>
<span class="gd">-    ) -&gt;GenericTypesCacheKey:</span>
<span class="gi">+    if isinstance(typevar_values, tuple):</span>
<span class="gi">+        args_data = []</span>
<span class="gi">+        for value in typevar_values:</span>
<span class="gi">+            args_data.append(_union_orderings_key(value))</span>
<span class="gi">+        return tuple(args_data)</span>
<span class="gi">+    elif typing_extensions.get_origin(typevar_values) is typing.Union:</span>
<span class="gi">+        return get_args(typevar_values)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return ()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _early_cache_key(cls: type[BaseModel], typevar_values: Any) -&gt; GenericTypesCacheKey:</span>
<span class="w"> </span>    &quot;&quot;&quot;This is intended for minimal computational overhead during lookups of cached types.

<span class="w"> </span>    Note that this is overly simplistic, and it&#39;s possible that two different cls/typevar_values
<span class="gu">@@ -280,14 +501,16 @@ def _early_cache_key(cls: type[BaseModel], typevar_values: Any</span>
<span class="w"> </span>    lookup fails, and should result in a cache hit _precisely_ when the inputs to __class_getitem__
<span class="w"> </span>    would result in the same type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls, typevar_values, _union_orderings_key(typevar_values)</span>


<span class="gd">-def _late_cache_key(origin: type[BaseModel], args: tuple[Any, ...],</span>
<span class="gd">-    typevar_values: Any) -&gt;GenericTypesCacheKey:</span>
<span class="gi">+def _late_cache_key(origin: type[BaseModel], args: tuple[Any, ...], typevar_values: Any) -&gt; GenericTypesCacheKey:</span>
<span class="w"> </span>    &quot;&quot;&quot;This is intended for use later in the process of creating a new type, when we have more information
<span class="w"> </span>    about the exact args that will be passed. If it turns out that a different set of inputs to
<span class="w"> </span>    __class_getitem__ resulted in the same inputs to the generic type creation process, we can still
<span class="w"> </span>    return the cached type, and update the cache with the _early_cache_key as well.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The _union_orderings_key is placed at the start here to ensure there cannot be a collision with an</span>
<span class="gi">+    # _early_cache_key, as that function will always produce a BaseModel subclass as the first item in the key,</span>
<span class="gi">+    # whereas this function will always produce a tuple as the first item in the key.</span>
<span class="gi">+    return _union_orderings_key(typevar_values), origin, args</span>
<span class="gh">diff --git a/pydantic/_internal/_git.py b/pydantic/_internal/_git.py</span>
<span class="gh">index c2419c23d..bff0dca38 100644</span>
<span class="gd">--- a/pydantic/_internal/_git.py</span>
<span class="gi">+++ b/pydantic/_internal/_git.py</span>
<span class="gu">@@ -1,19 +1,27 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Git utilities, adopted from mypy&#39;s git utilities (https://github.com/python/mypy/blob/master/mypy/git.py).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess


<span class="gd">-def is_git_repo(dir: str) -&gt;bool:</span>
<span class="gi">+def is_git_repo(dir: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is the given directory version-controlled with git?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.path.exists(os.path.join(dir, &#39;.git&#39;))</span>


<span class="gd">-def have_git() -&gt;bool:</span>
<span class="gi">+def have_git() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Can we run the git executable?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        subprocess.check_output([&#39;git&#39;, &#39;--help&#39;])</span>
<span class="gi">+        return True</span>
<span class="gi">+    except subprocess.CalledProcessError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        return False</span>


<span class="gd">-def git_revision(dir: str) -&gt;str:</span>
<span class="gi">+def git_revision(dir: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the SHA-1 of the HEAD of a git repository.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return subprocess.check_output([&#39;git&#39;, &#39;rev-parse&#39;, &#39;--short&#39;, &#39;HEAD&#39;], cwd=dir).decode(&#39;utf-8&#39;).strip()</span>
<span class="gh">diff --git a/pydantic/_internal/_internal_dataclass.py b/pydantic/_internal/_internal_dataclass.py</span>
<span class="gh">index 3c25d53b8..33e152cc8 100644</span>
<span class="gd">--- a/pydantic/_internal/_internal_dataclass.py</span>
<span class="gi">+++ b/pydantic/_internal/_internal_dataclass.py</span>
<span class="gu">@@ -1,4 +1,6 @@</span>
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+# `slots` is available on Python &gt;= 3.10</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):
<span class="w"> </span>    slots_true = {&#39;slots&#39;: True}
<span class="w"> </span>else:
<span class="gh">diff --git a/pydantic/_internal/_known_annotated_metadata.py b/pydantic/_internal/_known_annotated_metadata.py</span>
<span class="gh">index 4df2ee94b..971ab6856 100644</span>
<span class="gd">--- a/pydantic/_internal/_known_annotated_metadata.py</span>
<span class="gi">+++ b/pydantic/_internal/_known_annotated_metadata.py</span>
<span class="gu">@@ -1,65 +1,123 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from copy import copy
<span class="w"> </span>from functools import lru_cache, partial
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Iterable
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import CoreSchema, PydanticCustomError, to_jsonable_python
<span class="w"> </span>from pydantic_core import core_schema as cs
<span class="gi">+</span>
<span class="w"> </span>from ._fields import PydanticMetadata
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ..annotated_handlers import GetJsonSchemaHandler
<span class="gi">+</span>
<span class="w"> </span>STRICT = {&#39;strict&#39;}
<span class="w"> </span>FAIL_FAST = {&#39;fail_fast&#39;}
<span class="w"> </span>LENGTH_CONSTRAINTS = {&#39;min_length&#39;, &#39;max_length&#39;}
<span class="w"> </span>INEQUALITY = {&#39;le&#39;, &#39;ge&#39;, &#39;lt&#39;, &#39;gt&#39;}
<span class="w"> </span>NUMERIC_CONSTRAINTS = {&#39;multiple_of&#39;, *INEQUALITY}
<span class="w"> </span>ALLOW_INF_NAN = {&#39;allow_inf_nan&#39;}
<span class="gd">-STR_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT, &#39;strip_whitespace&#39;,</span>
<span class="gd">-    &#39;to_lower&#39;, &#39;to_upper&#39;, &#39;pattern&#39;, &#39;coerce_numbers_to_str&#39;}</span>
<span class="gi">+</span>
<span class="gi">+STR_CONSTRAINTS = {</span>
<span class="gi">+    *LENGTH_CONSTRAINTS,</span>
<span class="gi">+    *STRICT,</span>
<span class="gi">+    &#39;strip_whitespace&#39;,</span>
<span class="gi">+    &#39;to_lower&#39;,</span>
<span class="gi">+    &#39;to_upper&#39;,</span>
<span class="gi">+    &#39;pattern&#39;,</span>
<span class="gi">+    &#39;coerce_numbers_to_str&#39;,</span>
<span class="gi">+}</span>
<span class="w"> </span>BYTES_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT}
<span class="gi">+</span>
<span class="w"> </span>LIST_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT, *FAIL_FAST}
<span class="w"> </span>TUPLE_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT, *FAIL_FAST}
<span class="w"> </span>SET_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT, *FAIL_FAST}
<span class="w"> </span>DICT_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT}
<span class="w"> </span>GENERATOR_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT}
<span class="w"> </span>SEQUENCE_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *FAIL_FAST}
<span class="gi">+</span>
<span class="w"> </span>FLOAT_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *ALLOW_INF_NAN, *STRICT}
<span class="w"> </span>DECIMAL_CONSTRAINTS = {&#39;max_digits&#39;, &#39;decimal_places&#39;, *FLOAT_CONSTRAINTS}
<span class="w"> </span>INT_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *ALLOW_INF_NAN, *STRICT}
<span class="w"> </span>BOOL_CONSTRAINTS = STRICT
<span class="w"> </span>UUID_CONSTRAINTS = STRICT
<span class="gi">+</span>
<span class="w"> </span>DATE_TIME_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *STRICT}
<span class="w"> </span>TIMEDELTA_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *STRICT}
<span class="w"> </span>TIME_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *STRICT}
<span class="w"> </span>LAX_OR_STRICT_CONSTRAINTS = STRICT
<span class="w"> </span>ENUM_CONSTRAINTS = STRICT
<span class="gi">+</span>
<span class="w"> </span>UNION_CONSTRAINTS = {&#39;union_mode&#39;}
<span class="gd">-URL_CONSTRAINTS = {&#39;max_length&#39;, &#39;allowed_schemes&#39;, &#39;host_required&#39;,</span>
<span class="gd">-    &#39;default_host&#39;, &#39;default_port&#39;, &#39;default_path&#39;}</span>
<span class="gd">-TEXT_SCHEMA_TYPES = &#39;str&#39;, &#39;bytes&#39;, &#39;url&#39;, &#39;multi-host-url&#39;</span>
<span class="gd">-SEQUENCE_SCHEMA_TYPES = (&#39;list&#39;, &#39;tuple&#39;, &#39;set&#39;, &#39;frozenset&#39;, &#39;generator&#39;,</span>
<span class="gd">-    *TEXT_SCHEMA_TYPES)</span>
<span class="gd">-NUMERIC_SCHEMA_TYPES = &#39;float&#39;, &#39;int&#39;, &#39;date&#39;, &#39;time&#39;, &#39;timedelta&#39;, &#39;datetime&#39;</span>
<span class="gi">+URL_CONSTRAINTS = {</span>
<span class="gi">+    &#39;max_length&#39;,</span>
<span class="gi">+    &#39;allowed_schemes&#39;,</span>
<span class="gi">+    &#39;host_required&#39;,</span>
<span class="gi">+    &#39;default_host&#39;,</span>
<span class="gi">+    &#39;default_port&#39;,</span>
<span class="gi">+    &#39;default_path&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+TEXT_SCHEMA_TYPES = (&#39;str&#39;, &#39;bytes&#39;, &#39;url&#39;, &#39;multi-host-url&#39;)</span>
<span class="gi">+SEQUENCE_SCHEMA_TYPES = (&#39;list&#39;, &#39;tuple&#39;, &#39;set&#39;, &#39;frozenset&#39;, &#39;generator&#39;, *TEXT_SCHEMA_TYPES)</span>
<span class="gi">+NUMERIC_SCHEMA_TYPES = (&#39;float&#39;, &#39;int&#39;, &#39;date&#39;, &#39;time&#39;, &#39;timedelta&#39;, &#39;datetime&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>CONSTRAINTS_TO_ALLOWED_SCHEMAS: dict[str, set[str]] = defaultdict(set)
<span class="gd">-constraint_schema_pairings: list[tuple[set[str], tuple[str, ...]]] = [(</span>
<span class="gd">-    STR_CONSTRAINTS, TEXT_SCHEMA_TYPES), (BYTES_CONSTRAINTS, (&#39;bytes&#39;,)), (</span>
<span class="gd">-    LIST_CONSTRAINTS, (&#39;list&#39;,)), (TUPLE_CONSTRAINTS, (&#39;tuple&#39;,)), (</span>
<span class="gd">-    SET_CONSTRAINTS, (&#39;set&#39;, &#39;frozenset&#39;)), (DICT_CONSTRAINTS, (&#39;dict&#39;,)),</span>
<span class="gd">-    (GENERATOR_CONSTRAINTS, (&#39;generator&#39;,)), (FLOAT_CONSTRAINTS, (&#39;float&#39;,)</span>
<span class="gd">-    ), (INT_CONSTRAINTS, (&#39;int&#39;,)), (DATE_TIME_CONSTRAINTS, (&#39;date&#39;, &#39;time&#39;,</span>
<span class="gd">-    &#39;datetime&#39;)), (TIMEDELTA_CONSTRAINTS, (&#39;timedelta&#39;,)), (</span>
<span class="gd">-    TIME_CONSTRAINTS, (&#39;time&#39;,)), (STRICT, (*TEXT_SCHEMA_TYPES, *</span>
<span class="gd">-    SEQUENCE_SCHEMA_TYPES, *NUMERIC_SCHEMA_TYPES, &#39;typed-dict&#39;, &#39;model&#39;)),</span>
<span class="gd">-    (UNION_CONSTRAINTS, (&#39;union&#39;,)), (URL_CONSTRAINTS, (&#39;url&#39;,</span>
<span class="gd">-    &#39;multi-host-url&#39;)), (BOOL_CONSTRAINTS, (&#39;bool&#39;,)), (UUID_CONSTRAINTS, (</span>
<span class="gd">-    &#39;uuid&#39;,)), (LAX_OR_STRICT_CONSTRAINTS, (&#39;lax-or-strict&#39;,)), (</span>
<span class="gd">-    ENUM_CONSTRAINTS, (&#39;enum&#39;,)), (DECIMAL_CONSTRAINTS, (&#39;decimal&#39;,))]</span>
<span class="gi">+</span>
<span class="gi">+constraint_schema_pairings: list[tuple[set[str], tuple[str, ...]]] = [</span>
<span class="gi">+    (STR_CONSTRAINTS, TEXT_SCHEMA_TYPES),</span>
<span class="gi">+    (BYTES_CONSTRAINTS, (&#39;bytes&#39;,)),</span>
<span class="gi">+    (LIST_CONSTRAINTS, (&#39;list&#39;,)),</span>
<span class="gi">+    (TUPLE_CONSTRAINTS, (&#39;tuple&#39;,)),</span>
<span class="gi">+    (SET_CONSTRAINTS, (&#39;set&#39;, &#39;frozenset&#39;)),</span>
<span class="gi">+    (DICT_CONSTRAINTS, (&#39;dict&#39;,)),</span>
<span class="gi">+    (GENERATOR_CONSTRAINTS, (&#39;generator&#39;,)),</span>
<span class="gi">+    (FLOAT_CONSTRAINTS, (&#39;float&#39;,)),</span>
<span class="gi">+    (INT_CONSTRAINTS, (&#39;int&#39;,)),</span>
<span class="gi">+    (DATE_TIME_CONSTRAINTS, (&#39;date&#39;, &#39;time&#39;, &#39;datetime&#39;)),</span>
<span class="gi">+    (TIMEDELTA_CONSTRAINTS, (&#39;timedelta&#39;,)),</span>
<span class="gi">+    (TIME_CONSTRAINTS, (&#39;time&#39;,)),</span>
<span class="gi">+    # TODO: this is a bit redundant, we could probably avoid some of these</span>
<span class="gi">+    (STRICT, (*TEXT_SCHEMA_TYPES, *SEQUENCE_SCHEMA_TYPES, *NUMERIC_SCHEMA_TYPES, &#39;typed-dict&#39;, &#39;model&#39;)),</span>
<span class="gi">+    (UNION_CONSTRAINTS, (&#39;union&#39;,)),</span>
<span class="gi">+    (URL_CONSTRAINTS, (&#39;url&#39;, &#39;multi-host-url&#39;)),</span>
<span class="gi">+    (BOOL_CONSTRAINTS, (&#39;bool&#39;,)),</span>
<span class="gi">+    (UUID_CONSTRAINTS, (&#39;uuid&#39;,)),</span>
<span class="gi">+    (LAX_OR_STRICT_CONSTRAINTS, (&#39;lax-or-strict&#39;,)),</span>
<span class="gi">+    (ENUM_CONSTRAINTS, (&#39;enum&#39;,)),</span>
<span class="gi">+    (DECIMAL_CONSTRAINTS, (&#39;decimal&#39;,)),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>for constraints, schemas in constraint_schema_pairings:
<span class="w"> </span>    for c in constraints:
<span class="w"> </span>        CONSTRAINTS_TO_ALLOWED_SCHEMAS[c].update(schemas)


<span class="gd">-def expand_grouped_metadata(annotations: Iterable[Any]) -&gt;Iterable[Any]:</span>
<span class="gi">+def add_js_update_schema(s: cs.CoreSchema, f: Callable[[], dict[str, Any]]) -&gt; None:</span>
<span class="gi">+    def update_js_schema(s: cs.CoreSchema, handler: GetJsonSchemaHandler) -&gt; dict[str, Any]:</span>
<span class="gi">+        js_schema = handler(s)</span>
<span class="gi">+        js_schema.update(f())</span>
<span class="gi">+        return js_schema</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;metadata&#39; in s:</span>
<span class="gi">+        metadata = s[&#39;metadata&#39;]</span>
<span class="gi">+        if &#39;pydantic_js_functions&#39; in s:</span>
<span class="gi">+            metadata[&#39;pydantic_js_functions&#39;].append(update_js_schema)</span>
<span class="gi">+        else:</span>
<span class="gi">+            metadata[&#39;pydantic_js_functions&#39;] = [update_js_schema]</span>
<span class="gi">+    else:</span>
<span class="gi">+        s[&#39;metadata&#39;] = {&#39;pydantic_js_functions&#39;: [update_js_schema]}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def as_jsonable_value(v: Any) -&gt; Any:</span>
<span class="gi">+    if type(v) not in (int, str, float, bytes, bool, type(None)):</span>
<span class="gi">+        return to_jsonable_python(v)</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def expand_grouped_metadata(annotations: Iterable[Any]) -&gt; Iterable[Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Expand the annotations.

<span class="w"> </span>    Args:
<span class="gu">@@ -78,11 +136,29 @@ def expand_grouped_metadata(annotations: Iterable[Any]) -&gt;Iterable[Any]:</span>
<span class="w"> </span>        #&gt; [Ge(ge=4), MinLen(min_length=5)]
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import annotated_types as at</span>
<span class="gi">+</span>
<span class="gi">+    from pydantic.fields import FieldInfo  # circular import</span>
<span class="gi">+</span>
<span class="gi">+    for annotation in annotations:</span>
<span class="gi">+        if isinstance(annotation, at.GroupedMetadata):</span>
<span class="gi">+            yield from annotation</span>
<span class="gi">+        elif isinstance(annotation, FieldInfo):</span>
<span class="gi">+            yield from annotation.metadata</span>
<span class="gi">+            # this is a bit problematic in that it results in duplicate metadata</span>
<span class="gi">+            # all of our &quot;consumers&quot; can handle it, but it is not ideal</span>
<span class="gi">+            # we probably should split up FieldInfo into:</span>
<span class="gi">+            # - annotated types metadata</span>
<span class="gi">+            # - individual metadata known only to Pydantic</span>
<span class="gi">+            annotation = copy(annotation)</span>
<span class="gi">+            annotation.metadata = []</span>
<span class="gi">+            yield annotation</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield annotation</span>


<span class="w"> </span>@lru_cache
<span class="gd">-def _get_at_to_constraint_map() -&gt;dict[type, str]:</span>
<span class="gi">+def _get_at_to_constraint_map() -&gt; dict[type, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a mapping of annotated types to constraints.

<span class="w"> </span>    Normally, we would define a mapping like this in the module scope, but we can&#39;t do that
<span class="gu">@@ -90,11 +166,20 @@ def _get_at_to_constraint_map() -&gt;dict[type, str]:</span>
<span class="w"> </span>    the import time of `pydantic`. We still only want to have this dictionary defined in one place,
<span class="w"> </span>    so we use this function to cache the result.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import annotated_types as at</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        at.Gt: &#39;gt&#39;,</span>
<span class="gi">+        at.Ge: &#39;ge&#39;,</span>
<span class="gi">+        at.Lt: &#39;lt&#39;,</span>
<span class="gi">+        at.Le: &#39;le&#39;,</span>
<span class="gi">+        at.MultipleOf: &#39;multiple_of&#39;,</span>
<span class="gi">+        at.MinLen: &#39;min_length&#39;,</span>
<span class="gi">+        at.MaxLen: &#39;max_length&#39;,</span>
<span class="gi">+    }</span>


<span class="gd">-def apply_known_metadata(annotation: Any, schema: CoreSchema) -&gt;(CoreSchema |</span>
<span class="gd">-    None):</span>
<span class="gi">+def apply_known_metadata(annotation: Any, schema: CoreSchema) -&gt; CoreSchema | None:  # noqa: C901</span>
<span class="w"> </span>    &quot;&quot;&quot;Apply `annotation` to `schema` if it is an annotation we know about (Gt, Le, etc.).
<span class="w"> </span>    Otherwise return `None`.

<span class="gu">@@ -113,11 +198,104 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -&gt;(CoreSchema |</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticCustomError: If `Predicate` fails.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import annotated_types as at</span>
<span class="gi">+</span>
<span class="gi">+    from ._validators import forbid_inf_nan_check, get_constraint_validator</span>
<span class="gi">+</span>
<span class="gi">+    schema = schema.copy()</span>
<span class="gi">+    schema_update, other_metadata = collect_known_metadata([annotation])</span>
<span class="gi">+    schema_type = schema[&#39;type&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    chain_schema_constraints: set[str] = {</span>
<span class="gi">+        &#39;pattern&#39;,</span>
<span class="gi">+        &#39;strip_whitespace&#39;,</span>
<span class="gi">+        &#39;to_lower&#39;,</span>
<span class="gi">+        &#39;to_upper&#39;,</span>
<span class="gi">+        &#39;coerce_numbers_to_str&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+    chain_schema_steps: list[CoreSchema] = []</span>
<span class="gi">+</span>
<span class="gi">+    for constraint, value in schema_update.items():</span>
<span class="gi">+        if constraint not in CONSTRAINTS_TO_ALLOWED_SCHEMAS:</span>
<span class="gi">+            raise ValueError(f&#39;Unknown constraint {constraint}&#39;)</span>
<span class="gi">+        allowed_schemas = CONSTRAINTS_TO_ALLOWED_SCHEMAS[constraint]</span>
<span class="gi">+</span>
<span class="gi">+        # if it becomes necessary to handle more than one constraint</span>
<span class="gi">+        # in this recursive case with function-after or function-wrap, we should refactor</span>
<span class="gi">+        # this is a bit challenging because we sometimes want to apply constraints to the inner schema,</span>
<span class="gi">+        # whereas other times we want to wrap the existing schema with a new one that enforces a new constraint.</span>
<span class="gi">+        if schema_type in {&#39;function-before&#39;, &#39;function-wrap&#39;, &#39;function-after&#39;} and constraint == &#39;strict&#39;:</span>
<span class="gi">+            schema[&#39;schema&#39;] = apply_known_metadata(annotation, schema[&#39;schema&#39;])  # type: ignore  # schema is function-after schema</span>
<span class="gi">+            return schema</span>
<span class="gi">+</span>
<span class="gi">+        if schema_type in allowed_schemas:</span>
<span class="gi">+            if constraint == &#39;union_mode&#39; and schema_type == &#39;union&#39;:</span>
<span class="gi">+                schema[&#39;mode&#39;] = value  # type: ignore  # schema is UnionSchema</span>
<span class="gi">+            else:</span>
<span class="gi">+                schema[constraint] = value</span>
<span class="gi">+            continue</span>

<span class="gi">+        if constraint in chain_schema_constraints:</span>
<span class="gi">+            chain_schema_steps.append(cs.str_schema(**{constraint: value}))</span>
<span class="gi">+        elif constraint in {*NUMERIC_CONSTRAINTS, *LENGTH_CONSTRAINTS}:</span>
<span class="gi">+            if constraint in NUMERIC_CONSTRAINTS:</span>
<span class="gi">+                json_schema_constraint = constraint</span>
<span class="gi">+            elif constraint in LENGTH_CONSTRAINTS:</span>
<span class="gi">+                inner_schema = schema</span>
<span class="gi">+                while inner_schema[&#39;type&#39;] in {&#39;function-before&#39;, &#39;function-wrap&#39;, &#39;function-after&#39;}:</span>
<span class="gi">+                    inner_schema = inner_schema[&#39;schema&#39;]  # type: ignore</span>
<span class="gi">+                inner_schema_type = inner_schema[&#39;type&#39;]</span>
<span class="gi">+                if inner_schema_type == &#39;list&#39; or (</span>
<span class="gi">+                    inner_schema_type == &#39;json-or-python&#39; and inner_schema[&#39;json_schema&#39;][&#39;type&#39;] == &#39;list&#39;  # type: ignore</span>
<span class="gi">+                ):</span>
<span class="gi">+                    json_schema_constraint = &#39;minItems&#39; if constraint == &#39;min_length&#39; else &#39;maxItems&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    json_schema_constraint = &#39;minLength&#39; if constraint == &#39;min_length&#39; else &#39;maxLength&#39;</span>

<span class="gd">-def collect_known_metadata(annotations: Iterable[Any]) -&gt;tuple[dict[str,</span>
<span class="gd">-    Any], list[Any]]:</span>
<span class="gi">+            schema = cs.no_info_after_validator_function(</span>
<span class="gi">+                partial(get_constraint_validator(constraint), **{constraint: value}), schema</span>
<span class="gi">+            )</span>
<span class="gi">+            add_js_update_schema(schema, lambda: {json_schema_constraint: as_jsonable_value(value)})</span>
<span class="gi">+        elif constraint == &#39;allow_inf_nan&#39; and value is False:</span>
<span class="gi">+            schema = cs.no_info_after_validator_function(</span>
<span class="gi">+                forbid_inf_nan_check,</span>
<span class="gi">+                schema,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuntimeError(f&#39;Unable to apply constraint {constraint} to schema {schema_type}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    for annotation in other_metadata:</span>
<span class="gi">+        if (annotation_type := type(annotation)) in (at_to_constraint_map := _get_at_to_constraint_map()):</span>
<span class="gi">+            constraint = at_to_constraint_map[annotation_type]</span>
<span class="gi">+            schema = cs.no_info_after_validator_function(</span>
<span class="gi">+                partial(get_constraint_validator(constraint), {constraint: getattr(annotation, constraint)}), schema</span>
<span class="gi">+            )</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif isinstance(annotation, at.Predicate):</span>
<span class="gi">+            predicate_name = f&#39;{annotation.func.__qualname__} &#39; if hasattr(annotation.func, &#39;__qualname__&#39;) else &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+            def val_func(v: Any) -&gt; Any:</span>
<span class="gi">+                # annotation.func may also raise an exception, let it pass through</span>
<span class="gi">+                if not annotation.func(v):</span>
<span class="gi">+                    raise PydanticCustomError(</span>
<span class="gi">+                        &#39;predicate_failed&#39;,</span>
<span class="gi">+                        f&#39;Predicate {predicate_name}failed&#39;,  # type: ignore</span>
<span class="gi">+                    )</span>
<span class="gi">+                return v</span>
<span class="gi">+</span>
<span class="gi">+            schema = cs.no_info_after_validator_function(val_func, schema)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # ignore any other unknown metadata</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    if chain_schema_steps:</span>
<span class="gi">+        chain_schema_steps = [schema] + chain_schema_steps</span>
<span class="gi">+        return cs.chain_schema(chain_schema_steps)</span>
<span class="gi">+</span>
<span class="gi">+    return schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def collect_known_metadata(annotations: Iterable[Any]) -&gt; tuple[dict[str, Any], list[Any]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split `annotations` into known metadata and unknown annotations.

<span class="w"> </span>    Args:
<span class="gu">@@ -136,11 +314,33 @@ def collect_known_metadata(annotations: Iterable[Any]) -&gt;tuple[dict[str,</span>
<span class="w"> </span>        #&gt; ({&#39;gt&#39;: 1, &#39;min_length&#39;: 42}, [Ellipsis])
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    annotations = expand_grouped_metadata(annotations)</span>
<span class="gi">+</span>
<span class="gi">+    res: dict[str, Any] = {}</span>
<span class="gi">+    remaining: list[Any] = []</span>
<span class="gi">+</span>
<span class="gi">+    for annotation in annotations:</span>
<span class="gi">+        # isinstance(annotation, PydanticMetadata) also covers ._fields:_PydanticGeneralMetadata</span>
<span class="gi">+        if isinstance(annotation, PydanticMetadata):</span>
<span class="gi">+            res.update(annotation.__dict__)</span>
<span class="gi">+        # we don&#39;t use dataclasses.asdict because that recursively calls asdict on the field values</span>
<span class="gi">+        elif (annotation_type := type(annotation)) in (at_to_constraint_map := _get_at_to_constraint_map()):</span>
<span class="gi">+            constraint = at_to_constraint_map[annotation_type]</span>
<span class="gi">+            res[constraint] = getattr(annotation, constraint)</span>
<span class="gi">+        elif isinstance(annotation, type) and issubclass(annotation, PydanticMetadata):</span>
<span class="gi">+            # also support PydanticMetadata classes being used without initialisation,</span>
<span class="gi">+            # e.g. `Annotated[int, Strict]` as well as `Annotated[int, Strict()]`</span>
<span class="gi">+            res.update({k: v for k, v in vars(annotation).items() if not k.startswith(&#39;_&#39;)})</span>
<span class="gi">+        else:</span>
<span class="gi">+            remaining.append(annotation)</span>
<span class="gi">+    # Nones can sneak in but pydantic-core will reject them</span>
<span class="gi">+    # it&#39;d be nice to clean things up so we don&#39;t put in None (we probably don&#39;t _need_ to, it was just easier)</span>
<span class="gi">+    # but this is simple enough to kick that can down the road</span>
<span class="gi">+    res = {k: v for k, v in res.items() if v is not None}</span>
<span class="gi">+    return res, remaining</span>


<span class="gd">-def check_metadata(metadata: dict[str, Any], allowed: Iterable[str],</span>
<span class="gd">-    source_type: Any) -&gt;None:</span>
<span class="gi">+def check_metadata(metadata: dict[str, Any], allowed: Iterable[str], source_type: Any) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;A small utility function to validate that the given metadata can be applied to the target.
<span class="w"> </span>    More than saving lines of code, this gives us a consistent error message for all of our internal implementations.

<span class="gu">@@ -152,4 +352,8 @@ def check_metadata(metadata: dict[str, Any], allowed: Iterable[str],</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        TypeError: If there is metadatas that can&#39;t be applied on source type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    unknown = metadata.keys() - set(allowed)</span>
<span class="gi">+    if unknown:</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            f&#39;The following constraints cannot be applied to {source_type!r}: {&quot;, &quot;.join([f&quot;{k!r}&quot; for k in unknown])}&#39;</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/pydantic/_internal/_mock_val_ser.py b/pydantic/_internal/_mock_val_ser.py</span>
<span class="gh">index ff4c61394..3e55af70d 100644</span>
<span class="gd">--- a/pydantic/_internal/_mock_val_ser.py</span>
<span class="gi">+++ b/pydantic/_internal/_mock_val_ser.py</span>
<span class="gu">@@ -1,14 +1,19 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Generic, Iterator, Mapping, TypeVar, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator
<span class="w"> </span>from typing_extensions import Literal
<span class="gi">+</span>
<span class="w"> </span>from ..errors import PydanticErrorCodes, PydanticUserError
<span class="w"> </span>from ..plugin._schema_validator import PluggableSchemaValidator
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ..dataclasses import PydanticDataclass
<span class="w"> </span>    from ..main import BaseModel
<span class="gd">-ValSer = TypeVar(&#39;ValSer&#39;, bound=Union[SchemaValidator,</span>
<span class="gd">-    PluggableSchemaValidator, SchemaSerializer])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ValSer = TypeVar(&#39;ValSer&#39;, bound=Union[SchemaValidator, PluggableSchemaValidator, SchemaSerializer])</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)


<span class="gu">@@ -16,52 +21,94 @@ class MockCoreSchema(Mapping[str, Any]):</span>
<span class="w"> </span>    &quot;&quot;&quot;Mocker for `pydantic_core.CoreSchema` which optionally attempts to
<span class="w"> </span>    rebuild the thing it&#39;s mocking when one of its methods is accessed and raises an error if that fails.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = &#39;_error_message&#39;, &#39;_code&#39;, &#39;_attempt_rebuild&#39;, &#39;_built_memo&#39;

<span class="gd">-    def __init__(self, error_message: str, *, code: PydanticErrorCodes,</span>
<span class="gd">-        attempt_rebuild: (Callable[[], CoreSchema | None] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        error_message: str,</span>
<span class="gi">+        *,</span>
<span class="gi">+        code: PydanticErrorCodes,</span>
<span class="gi">+        attempt_rebuild: Callable[[], CoreSchema | None] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._error_message = error_message
<span class="w"> </span>        self._code: PydanticErrorCodes = code
<span class="w"> </span>        self._attempt_rebuild = attempt_rebuild
<span class="w"> </span>        self._built_memo: CoreSchema | None = None

<span class="gd">-    def __getitem__(self, key: str) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, key: str) -&gt; Any:</span>
<span class="w"> </span>        return self._get_built().__getitem__(key)

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return self._get_built().__len__()

<span class="gd">-    def __iter__(self) -&gt;Iterator[str]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[str]:</span>
<span class="w"> </span>        return self._get_built().__iter__()

<span class="gi">+    def _get_built(self) -&gt; CoreSchema:</span>
<span class="gi">+        if self._built_memo is not None:</span>
<span class="gi">+            return self._built_memo</span>
<span class="gi">+</span>
<span class="gi">+        if self._attempt_rebuild:</span>
<span class="gi">+            schema = self._attempt_rebuild()</span>
<span class="gi">+            if schema is not None:</span>
<span class="gi">+                self._built_memo = schema</span>
<span class="gi">+                return schema</span>
<span class="gi">+        raise PydanticUserError(self._error_message, code=self._code)</span>
<span class="gi">+</span>
<span class="gi">+    def rebuild(self) -&gt; CoreSchema | None:</span>
<span class="gi">+        self._built_memo = None</span>
<span class="gi">+        if self._attempt_rebuild:</span>
<span class="gi">+            val_ser = self._attempt_rebuild()</span>
<span class="gi">+            if val_ser is not None:</span>
<span class="gi">+                return val_ser</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise PydanticUserError(self._error_message, code=self._code)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class MockValSer(Generic[ValSer]):
<span class="w"> </span>    &quot;&quot;&quot;Mocker for `pydantic_core.SchemaValidator` or `pydantic_core.SchemaSerializer` which optionally attempts to
<span class="w"> </span>    rebuild the thing it&#39;s mocking when one of its methods is accessed and raises an error if that fails.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = &#39;_error_message&#39;, &#39;_code&#39;, &#39;_val_or_ser&#39;, &#39;_attempt_rebuild&#39;

<span class="gd">-    def __init__(self, error_message: str, *, code: PydanticErrorCodes,</span>
<span class="gd">-        val_or_ser: Literal[&#39;validator&#39;, &#39;serializer&#39;], attempt_rebuild: (</span>
<span class="gd">-        Callable[[], ValSer | None] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        error_message: str,</span>
<span class="gi">+        *,</span>
<span class="gi">+        code: PydanticErrorCodes,</span>
<span class="gi">+        val_or_ser: Literal[&#39;validator&#39;, &#39;serializer&#39;],</span>
<span class="gi">+        attempt_rebuild: Callable[[], ValSer | None] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._error_message = error_message
<span class="gd">-        self._val_or_ser = (SchemaValidator if val_or_ser == &#39;validator&#39; else</span>
<span class="gd">-            SchemaSerializer)</span>
<span class="gi">+        self._val_or_ser = SchemaValidator if val_or_ser == &#39;validator&#39; else SchemaSerializer</span>
<span class="w"> </span>        self._code: PydanticErrorCodes = code
<span class="w"> </span>        self._attempt_rebuild = attempt_rebuild

<span class="gd">-    def __getattr__(self, item: str) -&gt;None:</span>
<span class="gi">+    def __getattr__(self, item: str) -&gt; None:</span>
<span class="w"> </span>        __tracebackhide__ = True
<span class="w"> </span>        if self._attempt_rebuild:
<span class="w"> </span>            val_ser = self._attempt_rebuild()
<span class="w"> </span>            if val_ser is not None:
<span class="w"> </span>                return getattr(val_ser, item)
<span class="gi">+</span>
<span class="gi">+        # raise an AttributeError if `item` doesn&#39;t exist</span>
<span class="w"> </span>        getattr(self._val_or_ser, item)
<span class="w"> </span>        raise PydanticUserError(self._error_message, code=self._code)

<span class="gi">+    def rebuild(self) -&gt; ValSer | None:</span>
<span class="gi">+        if self._attempt_rebuild:</span>
<span class="gi">+            val_ser = self._attempt_rebuild()</span>
<span class="gi">+            if val_ser is not None:</span>
<span class="gi">+                return val_ser</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise PydanticUserError(self._error_message, code=self._code)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="gd">-def set_model_mocks(cls: type[BaseModel], cls_name: str, undefined_name:</span>
<span class="gd">-    str=&#39;all referenced types&#39;) -&gt;None:</span>
<span class="gi">+def set_model_mocks(cls: type[BaseModel], cls_name: str, undefined_name: str = &#39;all referenced types&#39;) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set `__pydantic_validator__` and `__pydantic_serializer__` to `MockValSer`s on a model.

<span class="w"> </span>    Args:
<span class="gu">@@ -69,11 +116,42 @@ def set_model_mocks(cls: type[BaseModel], cls_name: str, undefined_name:</span>
<span class="w"> </span>        cls_name: Name of the model class, used in error messages
<span class="w"> </span>        undefined_name: Name of the undefined thing, used in error messages
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def set_dataclass_mocks(cls: type[PydanticDataclass], cls_name: str,</span>
<span class="gd">-    undefined_name: str=&#39;all referenced types&#39;) -&gt;None:</span>
<span class="gi">+    undefined_type_error_message = (</span>
<span class="gi">+        f&#39;`{cls_name}` is not fully defined; you should define {undefined_name},&#39;</span>
<span class="gi">+        f&#39; then call `{cls_name}.model_rebuild()`.&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def attempt_rebuild_fn(attr_fn: Callable[[type[BaseModel]], T]) -&gt; Callable[[], T | None]:</span>
<span class="gi">+        def handler() -&gt; T | None:</span>
<span class="gi">+            if cls.model_rebuild(raise_errors=False, _parent_namespace_depth=5) is not False:</span>
<span class="gi">+                return attr_fn(cls)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        return handler</span>
<span class="gi">+</span>
<span class="gi">+    cls.__pydantic_core_schema__ = MockCoreSchema(  # type: ignore[assignment]</span>
<span class="gi">+        undefined_type_error_message,</span>
<span class="gi">+        code=&#39;class-not-fully-defined&#39;,</span>
<span class="gi">+        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_core_schema__),</span>
<span class="gi">+    )</span>
<span class="gi">+    cls.__pydantic_validator__ = MockValSer(  # type: ignore[assignment]</span>
<span class="gi">+        undefined_type_error_message,</span>
<span class="gi">+        code=&#39;class-not-fully-defined&#39;,</span>
<span class="gi">+        val_or_ser=&#39;validator&#39;,</span>
<span class="gi">+        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_validator__),</span>
<span class="gi">+    )</span>
<span class="gi">+    cls.__pydantic_serializer__ = MockValSer(  # type: ignore[assignment]</span>
<span class="gi">+        undefined_type_error_message,</span>
<span class="gi">+        code=&#39;class-not-fully-defined&#39;,</span>
<span class="gi">+        val_or_ser=&#39;serializer&#39;,</span>
<span class="gi">+        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_serializer__),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_dataclass_mocks(</span>
<span class="gi">+    cls: type[PydanticDataclass], cls_name: str, undefined_name: str = &#39;all referenced types&#39;</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set `__pydantic_validator__` and `__pydantic_serializer__` to `MockValSer`s on a dataclass.

<span class="w"> </span>    Args:
<span class="gu">@@ -81,4 +159,36 @@ def set_dataclass_mocks(cls: type[PydanticDataclass], cls_name: str,</span>
<span class="w"> </span>        cls_name: Name of the model class, used in error messages
<span class="w"> </span>        undefined_name: Name of the undefined thing, used in error messages
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..dataclasses import rebuild_dataclass</span>
<span class="gi">+</span>
<span class="gi">+    undefined_type_error_message = (</span>
<span class="gi">+        f&#39;`{cls_name}` is not fully defined; you should define {undefined_name},&#39;</span>
<span class="gi">+        f&#39; then call `pydantic.dataclasses.rebuild_dataclass({cls_name})`.&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def attempt_rebuild_fn(attr_fn: Callable[[type[PydanticDataclass]], T]) -&gt; Callable[[], T | None]:</span>
<span class="gi">+        def handler() -&gt; T | None:</span>
<span class="gi">+            if rebuild_dataclass(cls, raise_errors=False, _parent_namespace_depth=5) is not False:</span>
<span class="gi">+                return attr_fn(cls)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        return handler</span>
<span class="gi">+</span>
<span class="gi">+    cls.__pydantic_core_schema__ = MockCoreSchema(  # type: ignore[assignment]</span>
<span class="gi">+        undefined_type_error_message,</span>
<span class="gi">+        code=&#39;class-not-fully-defined&#39;,</span>
<span class="gi">+        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_core_schema__),</span>
<span class="gi">+    )</span>
<span class="gi">+    cls.__pydantic_validator__ = MockValSer(  # type: ignore[assignment]</span>
<span class="gi">+        undefined_type_error_message,</span>
<span class="gi">+        code=&#39;class-not-fully-defined&#39;,</span>
<span class="gi">+        val_or_ser=&#39;validator&#39;,</span>
<span class="gi">+        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_validator__),</span>
<span class="gi">+    )</span>
<span class="gi">+    cls.__pydantic_serializer__ = MockValSer(  # type: ignore[assignment]</span>
<span class="gi">+        undefined_type_error_message,</span>
<span class="gi">+        code=&#39;class-not-fully-defined&#39;,</span>
<span class="gi">+        val_or_ser=&#39;validator&#39;,</span>
<span class="gi">+        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_serializer__),</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pydantic/_internal/_model_construction.py b/pydantic/_internal/_model_construction.py</span>
<span class="gh">index f8876857b..3212476cf 100644</span>
<span class="gd">--- a/pydantic/_internal/_model_construction.py</span>
<span class="gi">+++ b/pydantic/_internal/_model_construction.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Private logic for creating models.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import builtins
<span class="w"> </span>import operator
<span class="w"> </span>import typing
<span class="gu">@@ -9,9 +11,11 @@ from abc import ABCMeta</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from types import FunctionType
<span class="w"> </span>from typing import Any, Callable, Generic, NoReturn
<span class="gi">+</span>
<span class="w"> </span>import typing_extensions
<span class="w"> </span>from pydantic_core import PydanticUndefined, SchemaSerializer
<span class="w"> </span>from typing_extensions import dataclass_transform, deprecated
<span class="gi">+</span>
<span class="w"> </span>from ..errors import PydanticUndefinedAnnotation, PydanticUserError
<span class="w"> </span>from ..plugin._schema_validator import create_schema_validator
<span class="w"> </span>from ..warnings import GenericBeforeBaseModelWarning, PydanticDeprecatedSince20
<span class="gu">@@ -26,15 +30,19 @@ from ._signature import generate_pydantic_signature</span>
<span class="w"> </span>from ._typing_extra import get_cls_types_namespace, is_annotated, is_classvar, parent_frame_namespace
<span class="w"> </span>from ._utils import ClassAttribute, SafeGetItemProxy
<span class="w"> </span>from ._validate_call import ValidateCallWrapper
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from ..fields import Field as PydanticModelField
<span class="w"> </span>    from ..fields import FieldInfo, ModelPrivateAttr
<span class="w"> </span>    from ..fields import PrivateAttr as PydanticModelPrivateAttr
<span class="w"> </span>    from ..main import BaseModel
<span class="w"> </span>else:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20
<span class="w"> </span>    PydanticModelField = object()
<span class="w"> </span>    PydanticModelPrivateAttr = object()
<span class="gi">+</span>
<span class="w"> </span>object_setattr = object.__setattr__


<span class="gu">@@ -43,25 +51,26 @@ class _ModelNamespaceDict(dict):</span>
<span class="w"> </span>    warns about overriding of decorators.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __setitem__(self, k: str, v: object) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, k: str, v: object) -&gt; None:</span>
<span class="w"> </span>        existing: Any = self.get(k, None)
<span class="gd">-        if existing and v is not existing and isinstance(existing,</span>
<span class="gd">-            PydanticDescriptorProxy):</span>
<span class="gd">-            warnings.warn(</span>
<span class="gd">-                f&#39;`{k}` overrides an existing Pydantic `{existing.decorator_info.decorator_repr}` decorator&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+        if existing and v is not existing and isinstance(existing, PydanticDescriptorProxy):</span>
<span class="gi">+            warnings.warn(f&#39;`{k}` overrides an existing Pydantic `{existing.decorator_info.decorator_repr}` decorator&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>        return super().__setitem__(k, v)


<span class="gd">-@dataclass_transform(kw_only_default=True, field_specifiers=(</span>
<span class="gd">-    PydanticModelField, PydanticModelPrivateAttr))</span>
<span class="gi">+@dataclass_transform(kw_only_default=True, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr))</span>
<span class="w"> </span>class ModelMetaclass(ABCMeta):
<span class="gd">-</span>
<span class="gd">-    def __new__(mcs, cls_name: str, bases: tuple[type[Any], ...], namespace:</span>
<span class="gd">-        dict[str, Any], __pydantic_generic_metadata__: (</span>
<span class="gd">-        PydanticGenericMetadata | None)=None,</span>
<span class="gd">-        __pydantic_reset_parent_namespace__: bool=True,</span>
<span class="gd">-        _create_model_module: (str | None)=None, **kwargs: Any) -&gt;type:</span>
<span class="gi">+    def __new__(</span>
<span class="gi">+        mcs,</span>
<span class="gi">+        cls_name: str,</span>
<span class="gi">+        bases: tuple[type[Any], ...],</span>
<span class="gi">+        namespace: dict[str, Any],</span>
<span class="gi">+        __pydantic_generic_metadata__: PydanticGenericMetadata | None = None,</span>
<span class="gi">+        __pydantic_reset_parent_namespace__: bool = True,</span>
<span class="gi">+        _create_model_module: str | None = None,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; type:</span>
<span class="w"> </span>        &quot;&quot;&quot;Metaclass for creating Pydantic models.

<span class="w"> </span>        Args:
<span class="gu">@@ -76,111 +85,151 @@ class ModelMetaclass(ABCMeta):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The new class created by the metaclass.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact</span>
<span class="gi">+        # that `BaseModel` itself won&#39;t have any bases, but any subclass of it will, to determine whether the `__new__`</span>
<span class="gi">+        # call we&#39;re in the middle of is for the `BaseModel` class.</span>
<span class="w"> </span>        if bases:
<span class="gd">-            base_field_names, class_vars, base_private_attributes = (mcs.</span>
<span class="gd">-                _collect_bases_data(bases))</span>
<span class="gi">+            base_field_names, class_vars, base_private_attributes = mcs._collect_bases_data(bases)</span>
<span class="gi">+</span>
<span class="w"> </span>            config_wrapper = ConfigWrapper.for_model(bases, namespace, kwargs)
<span class="w"> </span>            namespace[&#39;model_config&#39;] = config_wrapper.config_dict
<span class="gd">-            private_attributes = inspect_namespace(namespace,</span>
<span class="gd">-                config_wrapper.ignored_types, class_vars, base_field_names)</span>
<span class="gi">+            private_attributes = inspect_namespace(</span>
<span class="gi">+                namespace, config_wrapper.ignored_types, class_vars, base_field_names</span>
<span class="gi">+            )</span>
<span class="w"> </span>            if private_attributes or base_private_attributes:
<span class="gd">-                original_model_post_init = get_model_post_init(namespace, bases</span>
<span class="gd">-                    )</span>
<span class="gi">+                original_model_post_init = get_model_post_init(namespace, bases)</span>
<span class="w"> </span>                if original_model_post_init is not None:
<span class="gi">+                    # if there are private_attributes and a model_post_init function, we handle both</span>

<span class="gd">-                    def wrapped_model_post_init(self: BaseModel, context:</span>
<span class="gd">-                        Any, /) -&gt;None:</span>
<span class="gi">+                    def wrapped_model_post_init(self: BaseModel, context: Any, /) -&gt; None:</span>
<span class="w"> </span>                        &quot;&quot;&quot;We need to both initialize private attributes and call the user-defined model_post_init
<span class="w"> </span>                        method.
<span class="w"> </span>                        &quot;&quot;&quot;
<span class="w"> </span>                        init_private_attributes(self, context)
<span class="w"> </span>                        original_model_post_init(self, context)
<span class="gi">+</span>
<span class="w"> </span>                    namespace[&#39;model_post_init&#39;] = wrapped_model_post_init
<span class="w"> </span>                else:
<span class="w"> </span>                    namespace[&#39;model_post_init&#39;] = init_private_attributes
<span class="gi">+</span>
<span class="w"> </span>            namespace[&#39;__class_vars__&#39;] = class_vars
<span class="gd">-            namespace[&#39;__private_attributes__&#39;] = {**</span>
<span class="gd">-                base_private_attributes, **private_attributes}</span>
<span class="gd">-            cls: type[BaseModel] = super().__new__(mcs, cls_name, bases,</span>
<span class="gd">-                namespace, **kwargs)</span>
<span class="gi">+            namespace[&#39;__private_attributes__&#39;] = {**base_private_attributes, **private_attributes}</span>
<span class="gi">+</span>
<span class="gi">+            cls: type[BaseModel] = super().__new__(mcs, cls_name, bases, namespace, **kwargs)  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>            from ..main import BaseModel
<span class="gi">+</span>
<span class="w"> </span>            mro = cls.__mro__
<span class="w"> </span>            if Generic in mro and mro.index(Generic) &lt; mro.index(BaseModel):
<span class="gd">-                warnings.warn(GenericBeforeBaseModelWarning(</span>
<span class="gd">-                    &#39;Classes should inherit from `BaseModel` before generic classes (e.g. `typing.Generic[T]`) for pydantic generics to work properly.&#39;</span>
<span class="gd">-                    ), stacklevel=2)</span>
<span class="gd">-            cls.__pydantic_custom_init__ = not getattr(cls.__init__,</span>
<span class="gd">-                &#39;__pydantic_base_init__&#39;, False)</span>
<span class="gd">-            cls.__pydantic_post_init__ = (None if cls.model_post_init is</span>
<span class="gd">-                BaseModel.model_post_init else &#39;model_post_init&#39;)</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    GenericBeforeBaseModelWarning(</span>
<span class="gi">+                        &#39;Classes should inherit from `BaseModel` before generic classes (e.g. `typing.Generic[T]`) &#39;</span>
<span class="gi">+                        &#39;for pydantic generics to work properly.&#39;</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    stacklevel=2,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            cls.__pydantic_custom_init__ = not getattr(cls.__init__, &#39;__pydantic_base_init__&#39;, False)</span>
<span class="gi">+            cls.__pydantic_post_init__ = None if cls.model_post_init is BaseModel.model_post_init else &#39;model_post_init&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>            cls.__pydantic_decorators__ = DecoratorInfos.build(cls)
<span class="gi">+</span>
<span class="gi">+            # Use the getattr below to grab the __parameters__ from the `typing.Generic` parent class</span>
<span class="w"> </span>            if __pydantic_generic_metadata__:
<span class="gd">-                cls.__pydantic_generic_metadata__ = (</span>
<span class="gd">-                    __pydantic_generic_metadata__)</span>
<span class="gi">+                cls.__pydantic_generic_metadata__ = __pydantic_generic_metadata__</span>
<span class="w"> </span>            else:
<span class="gd">-                parent_parameters = getattr(cls,</span>
<span class="gd">-                    &#39;__pydantic_generic_metadata__&#39;, {}).get(&#39;parameters&#39;, ())</span>
<span class="gd">-                parameters = getattr(cls, &#39;__parameters__&#39;, None</span>
<span class="gd">-                    ) or parent_parameters</span>
<span class="gd">-                if parameters and parent_parameters and not all(x in</span>
<span class="gd">-                    parameters for x in parent_parameters):</span>
<span class="gi">+                parent_parameters = getattr(cls, &#39;__pydantic_generic_metadata__&#39;, {}).get(&#39;parameters&#39;, ())</span>
<span class="gi">+                parameters = getattr(cls, &#39;__parameters__&#39;, None) or parent_parameters</span>
<span class="gi">+                if parameters and parent_parameters and not all(x in parameters for x in parent_parameters):</span>
<span class="w"> </span>                    from ..root_model import RootModelRootType
<span class="gd">-                    missing_parameters = tuple(x for x in parameters if x</span>
<span class="gd">-                         not in parent_parameters)</span>
<span class="gd">-                    if (RootModelRootType in parent_parameters and </span>
<span class="gd">-                        RootModelRootType not in parameters):</span>
<span class="gd">-                        parameters_str = &#39;, &#39;.join([x.__name__ for x in</span>
<span class="gd">-                            missing_parameters])</span>
<span class="gi">+</span>
<span class="gi">+                    missing_parameters = tuple(x for x in parameters if x not in parent_parameters)</span>
<span class="gi">+                    if RootModelRootType in parent_parameters and RootModelRootType not in parameters:</span>
<span class="gi">+                        # This is a special case where the user has subclassed `RootModel`, but has not parametrized</span>
<span class="gi">+                        # RootModel with the generic type identifiers being used. Ex:</span>
<span class="gi">+                        # class MyModel(RootModel, Generic[T]):</span>
<span class="gi">+                        #    root: T</span>
<span class="gi">+                        # Should instead just be:</span>
<span class="gi">+                        # class MyModel(RootModel[T]):</span>
<span class="gi">+                        #   root: T</span>
<span class="gi">+                        parameters_str = &#39;, &#39;.join([x.__name__ for x in missing_parameters])</span>
<span class="w"> </span>                        error_message = (
<span class="gd">-                            f&#39;{cls.__name__} is a subclass of `RootModel`, but does not include the generic type identifier(s) {parameters_str} in its parameters. You should parametrize RootModel directly, e.g., `class {cls.__name__}(RootModel[{parameters_str}]): ...`.&#39;</span>
<span class="gd">-                            )</span>
<span class="gi">+                            f&#39;{cls.__name__} is a subclass of `RootModel`, but does not include the generic type identifier(s) &#39;</span>
<span class="gi">+                            f&#39;{parameters_str} in its parameters. &#39;</span>
<span class="gi">+                            f&#39;You should parametrize RootModel directly, e.g., `class {cls.__name__}(RootModel[{parameters_str}]): ...`.&#39;</span>
<span class="gi">+                        )</span>
<span class="w"> </span>                    else:
<span class="gd">-                        combined_parameters = (parent_parameters +</span>
<span class="gd">-                            missing_parameters)</span>
<span class="gd">-                        parameters_str = &#39;, &#39;.join([str(x) for x in</span>
<span class="gd">-                            combined_parameters])</span>
<span class="gd">-                        generic_type_label = (</span>
<span class="gd">-                            f&#39;typing.Generic[{parameters_str}]&#39;)</span>
<span class="gi">+                        combined_parameters = parent_parameters + missing_parameters</span>
<span class="gi">+                        parameters_str = &#39;, &#39;.join([str(x) for x in combined_parameters])</span>
<span class="gi">+                        generic_type_label = f&#39;typing.Generic[{parameters_str}]&#39;</span>
<span class="w"> </span>                        error_message = (
<span class="gd">-                            f&#39;All parameters must be present on typing.Generic; you should inherit from {generic_type_label}.&#39;</span>
<span class="gd">-                            )</span>
<span class="gd">-                        if Generic not in bases:</span>
<span class="gd">-                            bases_str = &#39;, &#39;.join([x.__name__ for x in</span>
<span class="gd">-                                bases] + [generic_type_label])</span>
<span class="gi">+                            f&#39;All parameters must be present on typing.Generic;&#39;</span>
<span class="gi">+                            f&#39; you should inherit from {generic_type_label}.&#39;</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if Generic not in bases:  # pragma: no cover</span>
<span class="gi">+                            # We raise an error here not because it is desirable, but because some cases are mishandled.</span>
<span class="gi">+                            # It would be nice to remove this error and still have things behave as expected, it&#39;s just</span>
<span class="gi">+                            # challenging because we are using a custom `__class_getitem__` to parametrize generic models,</span>
<span class="gi">+                            # and not returning a typing._GenericAlias from it.</span>
<span class="gi">+                            bases_str = &#39;, &#39;.join([x.__name__ for x in bases] + [generic_type_label])</span>
<span class="w"> </span>                            error_message += (
<span class="w"> </span>                                f&#39; Note: `typing.Generic` must go last: `class {cls.__name__}({bases_str}): ...`)&#39;
<span class="gd">-                                )</span>
<span class="gi">+                            )</span>
<span class="w"> </span>                    raise TypeError(error_message)
<span class="gd">-                cls.__pydantic_generic_metadata__ = {&#39;origin&#39;: None, &#39;args&#39;:</span>
<span class="gd">-                    (), &#39;parameters&#39;: parameters}</span>
<span class="gd">-            cls.__pydantic_complete__ = False</span>
<span class="gi">+</span>
<span class="gi">+                cls.__pydantic_generic_metadata__ = {</span>
<span class="gi">+                    &#39;origin&#39;: None,</span>
<span class="gi">+                    &#39;args&#39;: (),</span>
<span class="gi">+                    &#39;parameters&#39;: parameters,</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+            cls.__pydantic_complete__ = False  # Ensure this specific class gets completed</span>
<span class="gi">+</span>
<span class="gi">+            # preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487</span>
<span class="gi">+            # for attributes not in `new_namespace` (e.g. private attributes)</span>
<span class="w"> </span>            for name, obj in private_attributes.items():
<span class="w"> </span>                obj.__set_name__(cls, name)
<span class="gi">+</span>
<span class="w"> </span>            if __pydantic_reset_parent_namespace__:
<span class="gd">-                cls.__pydantic_parent_namespace__ = (</span>
<span class="gd">-                    build_lenient_weakvaluedict(parent_frame_namespace()))</span>
<span class="gd">-            parent_namespace = getattr(cls, &#39;__pydantic_parent_namespace__&#39;,</span>
<span class="gd">-                None)</span>
<span class="gi">+                cls.__pydantic_parent_namespace__ = build_lenient_weakvaluedict(parent_frame_namespace())</span>
<span class="gi">+            parent_namespace = getattr(cls, &#39;__pydantic_parent_namespace__&#39;, None)</span>
<span class="w"> </span>            if isinstance(parent_namespace, dict):
<span class="gd">-                parent_namespace = unpack_lenient_weakvaluedict(</span>
<span class="gd">-                    parent_namespace)</span>
<span class="gi">+                parent_namespace = unpack_lenient_weakvaluedict(parent_namespace)</span>
<span class="gi">+</span>
<span class="w"> </span>            types_namespace = get_cls_types_namespace(cls, parent_namespace)
<span class="w"> </span>            set_model_fields(cls, bases, config_wrapper, types_namespace)
<span class="gi">+</span>
<span class="w"> </span>            if config_wrapper.frozen and &#39;__hash__&#39; not in namespace:
<span class="w"> </span>                set_default_hash_func(cls, bases)
<span class="gd">-            complete_model_class(cls, cls_name, config_wrapper,</span>
<span class="gd">-                raise_errors=False, types_namespace=types_namespace,</span>
<span class="gd">-                create_model_module=_create_model_module)</span>
<span class="gd">-            cls.model_computed_fields = {k: v.info for k, v in cls.</span>
<span class="gd">-                __pydantic_decorators__.computed_fields.items()}</span>
<span class="gi">+</span>
<span class="gi">+            complete_model_class(</span>
<span class="gi">+                cls,</span>
<span class="gi">+                cls_name,</span>
<span class="gi">+                config_wrapper,</span>
<span class="gi">+                raise_errors=False,</span>
<span class="gi">+                types_namespace=types_namespace,</span>
<span class="gi">+                create_model_module=_create_model_module,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # If this is placed before the complete_model_class call above,</span>
<span class="gi">+            # the generic computed fields return type is set to PydanticUndefined</span>
<span class="gi">+            cls.model_computed_fields = {k: v.info for k, v in cls.__pydantic_decorators__.computed_fields.items()}</span>
<span class="gi">+</span>
<span class="w"> </span>            set_deprecated_descriptors(cls)
<span class="gd">-            super(cls, cls).__pydantic_init_subclass__(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            # using super(cls, cls) on the next line ensures we only call the parent class&#39;s __pydantic_init_subclass__</span>
<span class="gi">+            # I believe the `type: ignore` is only necessary because mypy doesn&#39;t realize that this code branch is</span>
<span class="gi">+            # only hit for _proper_ subclasses of BaseModel</span>
<span class="gi">+            super(cls, cls).__pydantic_init_subclass__(**kwargs)  # type: ignore[misc]</span>
<span class="w"> </span>            return cls
<span class="w"> </span>        else:
<span class="gi">+            # this is the BaseModel class itself being created, no logic required</span>
<span class="w"> </span>            return super().__new__(mcs, cls_name, bases, namespace, **kwargs)
<span class="gd">-    if not typing.TYPE_CHECKING:</span>

<span class="gd">-        def __getattr__(self, item: str) -&gt;Any:</span>
<span class="gi">+    if not typing.TYPE_CHECKING:  # pragma: no branch</span>
<span class="gi">+        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access</span>
<span class="gi">+</span>
<span class="gi">+        def __getattr__(self, item: str) -&gt; Any:</span>
<span class="w"> </span>            &quot;&quot;&quot;This is necessary to keep attribute access working for class attribute access.&quot;&quot;&quot;
<span class="w"> </span>            private_attributes = self.__dict__.get(&#39;__private_attributes__&#39;)
<span class="w"> </span>            if private_attributes and item in private_attributes:
<span class="gu">@@ -188,35 +237,47 @@ class ModelMetaclass(ABCMeta):</span>
<span class="w"> </span>            raise AttributeError(item)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __prepare__(cls, *args: Any, **kwargs: Any) -&gt;dict[str, object]:</span>
<span class="gi">+    def __prepare__(cls, *args: Any, **kwargs: Any) -&gt; dict[str, object]:</span>
<span class="w"> </span>        return _ModelNamespaceDict()

<span class="gd">-    def __instancecheck__(self, instance: Any) -&gt;bool:</span>
<span class="gi">+    def __instancecheck__(self, instance: Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Avoid calling ABC _abc_subclasscheck unless we&#39;re pretty sure.

<span class="w"> </span>        See #3829 and python/cpython#92810
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return hasattr(instance, &#39;__pydantic_validator__&#39;) and super(</span>
<span class="gd">-            ).__instancecheck__(instance)</span>
<span class="gi">+        return hasattr(instance, &#39;__pydantic_validator__&#39;) and super().__instancecheck__(instance)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _collect_bases_data(bases: tuple[type[Any], ...]) -&gt; tuple[set[str], set[str], dict[str, ModelPrivateAttr]]:</span>
<span class="gi">+        from ..main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+        field_names: set[str] = set()</span>
<span class="gi">+        class_vars: set[str] = set()</span>
<span class="gi">+        private_attributes: dict[str, ModelPrivateAttr] = {}</span>
<span class="gi">+        for base in bases:</span>
<span class="gi">+            if issubclass(base, BaseModel) and base is not BaseModel:</span>
<span class="gi">+                # model_fields might not be defined yet in the case of generics, so we use getattr here:</span>
<span class="gi">+                field_names.update(getattr(base, &#39;model_fields&#39;, {}).keys())</span>
<span class="gi">+                class_vars.update(base.__class_vars__)</span>
<span class="gi">+                private_attributes.update(base.__private_attributes__)</span>
<span class="gi">+        return field_names, class_vars, private_attributes</span>

<span class="w"> </span>    @property
<span class="gd">-    @deprecated(</span>
<span class="gd">-        &#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;</span>
<span class="gd">-        , category=None)</span>
<span class="gd">-    def __fields__(self) -&gt;dict[str, FieldInfo]:</span>
<span class="gi">+    @deprecated(&#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;, category=None)</span>
<span class="gi">+    def __fields__(self) -&gt; dict[str, FieldInfo]:</span>
<span class="w"> </span>        warnings.warn(
<span class="gd">-            &#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;</span>
<span class="gd">-            , PydanticDeprecatedSince20)</span>
<span class="gd">-        return self.model_fields</span>
<span class="gi">+            &#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;, PydanticDeprecatedSince20</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.model_fields  # type: ignore</span>

<span class="gd">-    def __dir__(self) -&gt;list[str]:</span>
<span class="gi">+    def __dir__(self) -&gt; list[str]:</span>
<span class="w"> </span>        attributes = list(super().__dir__())
<span class="w"> </span>        if &#39;__fields__&#39; in attributes:
<span class="w"> </span>            attributes.remove(&#39;__fields__&#39;)
<span class="w"> </span>        return attributes


<span class="gd">-def init_private_attributes(self: BaseModel, context: Any, /) -&gt;None:</span>
<span class="gi">+def init_private_attributes(self: BaseModel, context: Any, /) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;This function is meant to behave like a BaseModel method to initialise private attributes.

<span class="w"> </span>    It takes context as an argument since that&#39;s what pydantic-core passes when calling it.
<span class="gu">@@ -225,18 +286,33 @@ def init_private_attributes(self: BaseModel, context: Any, /) -&gt;None:</span>
<span class="w"> </span>        self: The BaseModel instance.
<span class="w"> </span>        context: The context.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if getattr(self, &#39;__pydantic_private__&#39;, None) is None:</span>
<span class="gi">+        pydantic_private = {}</span>
<span class="gi">+        for name, private_attr in self.__private_attributes__.items():</span>
<span class="gi">+            default = private_attr.get_default()</span>
<span class="gi">+            if default is not PydanticUndefined:</span>
<span class="gi">+                pydantic_private[name] = default</span>
<span class="gi">+        object_setattr(self, &#39;__pydantic_private__&#39;, pydantic_private)</span>


<span class="gd">-def get_model_post_init(namespace: dict[str, Any], bases: tuple[type[Any], ...]</span>
<span class="gd">-    ) -&gt;(Callable[..., Any] | None):</span>
<span class="gi">+def get_model_post_init(namespace: dict[str, Any], bases: tuple[type[Any], ...]) -&gt; Callable[..., Any] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the `model_post_init` method from the namespace or the class bases, or `None` if not defined.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;model_post_init&#39; in namespace:</span>
<span class="gi">+        return namespace[&#39;model_post_init&#39;]</span>

<span class="gi">+    from ..main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    model_post_init = get_attribute_from_bases(bases, &#39;model_post_init&#39;)</span>
<span class="gi">+    if model_post_init is not BaseModel.model_post_init:</span>
<span class="gi">+        return model_post_init</span>

<span class="gd">-def inspect_namespace(namespace: dict[str, Any], ignored_types: tuple[type[</span>
<span class="gd">-    Any], ...], base_class_vars: set[str], base_class_fields: set[str]) -&gt;dict[</span>
<span class="gd">-    str, ModelPrivateAttr]:</span>
<span class="gi">+</span>
<span class="gi">+def inspect_namespace(  # noqa C901</span>
<span class="gi">+    namespace: dict[str, Any],</span>
<span class="gi">+    ignored_types: tuple[type[Any], ...],</span>
<span class="gi">+    base_class_vars: set[str],</span>
<span class="gi">+    base_class_fields: set[str],</span>
<span class="gi">+) -&gt; dict[str, ModelPrivateAttr]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over the namespace and:
<span class="w"> </span>    * gather private attributes
<span class="w"> </span>    * check for items which look like fields but are not (e.g. have no annotation) and warn.
<span class="gu">@@ -257,11 +333,130 @@ def inspect_namespace(namespace: dict[str, Any], ignored_types: tuple[type[</span>
<span class="w"> </span>            - If a field does not have a type annotation.
<span class="w"> </span>            - If a field on base class was overridden by a non-annotated attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    from ..fields import FieldInfo, ModelPrivateAttr, PrivateAttr</span>
<span class="gi">+</span>
<span class="gi">+    all_ignored_types = ignored_types + default_ignored_types()</span>
<span class="gi">+</span>
<span class="gi">+    private_attributes: dict[str, ModelPrivateAttr] = {}</span>
<span class="gi">+    raw_annotations = namespace.get(&#39;__annotations__&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;__root__&#39; in raw_annotations or &#39;__root__&#39; in namespace:</span>
<span class="gi">+        raise TypeError(&quot;To define root models, use `pydantic.RootModel` rather than a field called &#39;__root__&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    ignored_names: set[str] = set()</span>
<span class="gi">+    for var_name, value in list(namespace.items()):</span>
<span class="gi">+        if var_name == &#39;model_config&#39; or var_name == &#39;__pydantic_extra__&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif (</span>
<span class="gi">+            isinstance(value, type)</span>
<span class="gi">+            and value.__module__ == namespace[&#39;__module__&#39;]</span>
<span class="gi">+            and &#39;__qualname__&#39; in namespace</span>
<span class="gi">+            and value.__qualname__.startswith(namespace[&#39;__qualname__&#39;])</span>
<span class="gi">+        ):</span>
<span class="gi">+            # `value` is a nested type defined in this namespace; don&#39;t error</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif isinstance(value, all_ignored_types) or value.__class__.__module__ == &#39;functools&#39;:</span>
<span class="gi">+            ignored_names.add(var_name)</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif isinstance(value, ModelPrivateAttr):</span>
<span class="gi">+            if var_name.startswith(&#39;__&#39;):</span>
<span class="gi">+                raise NameError(</span>
<span class="gi">+                    &#39;Private attributes must not use dunder names;&#39;</span>
<span class="gi">+                    f&#39; use a single underscore prefix instead of {var_name!r}.&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            elif is_valid_field_name(var_name):</span>
<span class="gi">+                raise NameError(</span>
<span class="gi">+                    &#39;Private attributes must not use valid field names;&#39;</span>
<span class="gi">+                    f&#39; use sunder names, e.g. {&quot;_&quot; + var_name!r} instead of {var_name!r}.&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            private_attributes[var_name] = value</span>
<span class="gi">+            del namespace[var_name]</span>
<span class="gi">+        elif isinstance(value, FieldInfo) and not is_valid_field_name(var_name):</span>
<span class="gi">+            suggested_name = var_name.lstrip(&#39;_&#39;) or &#39;my_field&#39;  # don&#39;t suggest &#39;&#39; for all-underscore name</span>
<span class="gi">+            raise NameError(</span>
<span class="gi">+                f&#39;Fields must not use names with leading underscores;&#39;</span>
<span class="gi">+                f&#39; e.g., use {suggested_name!r} instead of {var_name!r}.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        elif var_name.startswith(&#39;__&#39;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif is_valid_privateattr_name(var_name):</span>
<span class="gi">+            if var_name not in raw_annotations or not is_classvar(raw_annotations[var_name]):</span>
<span class="gi">+                private_attributes[var_name] = PrivateAttr(default=value)</span>
<span class="gi">+                del namespace[var_name]</span>
<span class="gi">+        elif var_name in base_class_vars:</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif var_name not in raw_annotations:</span>
<span class="gi">+            if var_name in base_class_fields:</span>
<span class="gi">+                raise PydanticUserError(</span>
<span class="gi">+                    f&#39;Field {var_name!r} defined on a base class was overridden by a non-annotated attribute. &#39;</span>
<span class="gi">+                    f&#39;All field definitions, including overrides, require a type annotation.&#39;,</span>
<span class="gi">+                    code=&#39;model-field-overridden&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+            elif isinstance(value, FieldInfo):</span>
<span class="gi">+                raise PydanticUserError(</span>
<span class="gi">+                    f&#39;Field {var_name!r} requires a type annotation&#39;, code=&#39;model-field-missing-annotation&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise PydanticUserError(</span>
<span class="gi">+                    f&#39;A non-annotated attribute was detected: `{var_name} = {value!r}`. All model fields require a &#39;</span>
<span class="gi">+                    f&#39;type annotation; if `{var_name}` is not meant to be a field, you may be able to resolve this &#39;</span>
<span class="gi">+                    f&quot;error by annotating it as a `ClassVar` or updating `model_config[&#39;ignored_types&#39;]`.&quot;,</span>
<span class="gi">+                    code=&#39;model-field-missing-annotation&#39;,</span>
<span class="gi">+                )</span>

<span class="gd">-def set_model_fields(cls: type[BaseModel], bases: tuple[type[Any], ...],</span>
<span class="gd">-    config_wrapper: ConfigWrapper, types_namespace: dict[str, Any]) -&gt;None:</span>
<span class="gi">+    for ann_name, ann_type in raw_annotations.items():</span>
<span class="gi">+        if (</span>
<span class="gi">+            is_valid_privateattr_name(ann_name)</span>
<span class="gi">+            and ann_name not in private_attributes</span>
<span class="gi">+            and ann_name not in ignored_names</span>
<span class="gi">+            and not is_classvar(ann_type)</span>
<span class="gi">+            and ann_type not in all_ignored_types</span>
<span class="gi">+            and getattr(ann_type, &#39;__module__&#39;, None) != &#39;functools&#39;</span>
<span class="gi">+        ):</span>
<span class="gi">+            if is_annotated(ann_type):</span>
<span class="gi">+                _, *metadata = typing_extensions.get_args(ann_type)</span>
<span class="gi">+                private_attr = next((v for v in metadata if isinstance(v, ModelPrivateAttr)), None)</span>
<span class="gi">+                if private_attr is not None:</span>
<span class="gi">+                    private_attributes[ann_name] = private_attr</span>
<span class="gi">+                    continue</span>
<span class="gi">+            private_attributes[ann_name] = PrivateAttr()</span>
<span class="gi">+</span>
<span class="gi">+    return private_attributes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_default_hash_func(cls: type[BaseModel], bases: tuple[type[Any], ...]) -&gt; None:</span>
<span class="gi">+    base_hash_func = get_attribute_from_bases(bases, &#39;__hash__&#39;)</span>
<span class="gi">+    new_hash_func = make_hash_func(cls)</span>
<span class="gi">+    if base_hash_func in {None, object.__hash__} or getattr(base_hash_func, &#39;__code__&#39;, None) == new_hash_func.__code__:</span>
<span class="gi">+        # If `__hash__` is some default, we generate a hash function.</span>
<span class="gi">+        # It will be `None` if not overridden from BaseModel.</span>
<span class="gi">+        # It may be `object.__hash__` if there is another</span>
<span class="gi">+        # parent class earlier in the bases which doesn&#39;t override `__hash__` (e.g. `typing.Generic`).</span>
<span class="gi">+        # It may be a value set by `set_default_hash_func` if `cls` is a subclass of another frozen model.</span>
<span class="gi">+        # In the last case we still need a new hash function to account for new `model_fields`.</span>
<span class="gi">+        cls.__hash__ = new_hash_func</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_hash_func(cls: type[BaseModel]) -&gt; Any:</span>
<span class="gi">+    getter = operator.itemgetter(*cls.model_fields.keys()) if cls.model_fields else lambda _: 0</span>
<span class="gi">+</span>
<span class="gi">+    def hash_func(self: Any) -&gt; int:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return hash(getter(self.__dict__))</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # In rare cases (such as when using the deprecated copy method), the __dict__ may not contain</span>
<span class="gi">+            # all model fields, which is how we can get here.</span>
<span class="gi">+            # getter(self.__dict__) is much faster than any &#39;safe&#39; method that accounts for missing keys,</span>
<span class="gi">+            # and wrapping it in a `try` doesn&#39;t slow things down much in the common case.</span>
<span class="gi">+            return hash(getter(SafeGetItemProxy(self.__dict__)))</span>
<span class="gi">+</span>
<span class="gi">+    return hash_func</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_model_fields(</span>
<span class="gi">+    cls: type[BaseModel], bases: tuple[type[Any], ...], config_wrapper: ConfigWrapper, types_namespace: dict[str, Any]</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Collect and set `cls.model_fields` and `cls.__class_vars__`.

<span class="w"> </span>    Args:
<span class="gu">@@ -270,13 +465,34 @@ def set_model_fields(cls: type[BaseModel], bases: tuple[type[Any], ...],</span>
<span class="w"> </span>        config_wrapper: The config wrapper instance.
<span class="w"> </span>        types_namespace: Optional extra namespace to look for types in.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def complete_model_class(cls: type[BaseModel], cls_name: str,</span>
<span class="gd">-    config_wrapper: ConfigWrapper, *, raise_errors: bool=True,</span>
<span class="gd">-    types_namespace: (dict[str, Any] | None), create_model_module: (str |</span>
<span class="gd">-    None)=None) -&gt;bool:</span>
<span class="gi">+    typevars_map = get_model_typevars_map(cls)</span>
<span class="gi">+    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)</span>
<span class="gi">+</span>
<span class="gi">+    cls.model_fields = fields</span>
<span class="gi">+    cls.__class_vars__.update(class_vars)</span>
<span class="gi">+</span>
<span class="gi">+    for k in class_vars:</span>
<span class="gi">+        # Class vars should not be private attributes</span>
<span class="gi">+        #     We remove them _here_ and not earlier because we rely on inspecting the class to determine its classvars,</span>
<span class="gi">+        #     but private attributes are determined by inspecting the namespace _prior_ to class creation.</span>
<span class="gi">+        #     In the case that a classvar with a leading-&#39;_&#39; is defined via a ForwardRef (e.g., when using</span>
<span class="gi">+        #     `__future__.annotations`), we want to remove the private attribute which was detected _before_ we knew it</span>
<span class="gi">+        #     evaluated to a classvar</span>
<span class="gi">+</span>
<span class="gi">+        value = cls.__private_attributes__.pop(k, None)</span>
<span class="gi">+        if value is not None and value.default is not PydanticUndefined:</span>
<span class="gi">+            setattr(cls, k, value.default)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def complete_model_class(</span>
<span class="gi">+    cls: type[BaseModel],</span>
<span class="gi">+    cls_name: str,</span>
<span class="gi">+    config_wrapper: ConfigWrapper,</span>
<span class="gi">+    *,</span>
<span class="gi">+    raise_errors: bool = True,</span>
<span class="gi">+    types_namespace: dict[str, Any] | None,</span>
<span class="gi">+    create_model_module: str | None = None,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Finish building a model class.

<span class="w"> </span>    This logic must be called after class has been created since validation functions must be bound
<span class="gu">@@ -297,12 +513,79 @@ def complete_model_class(cls: type[BaseModel], cls_name: str,</span>
<span class="w"> </span>        PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`
<span class="w"> </span>            and `raise_errors=True`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def set_deprecated_descriptors(cls: type[BaseModel]) -&gt;None:</span>
<span class="gi">+    typevars_map = get_model_typevars_map(cls)</span>
<span class="gi">+    gen_schema = GenerateSchema(</span>
<span class="gi">+        config_wrapper,</span>
<span class="gi">+        types_namespace,</span>
<span class="gi">+        typevars_map,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    handler = CallbackGetCoreSchemaHandler(</span>
<span class="gi">+        partial(gen_schema.generate_schema, from_dunder_get_core_schema=False),</span>
<span class="gi">+        gen_schema,</span>
<span class="gi">+        ref_mode=&#39;unpack&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if config_wrapper.defer_build and &#39;model&#39; in config_wrapper.experimental_defer_build_mode:</span>
<span class="gi">+        set_model_mocks(cls, cls_name)</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        schema = cls.__get_pydantic_core_schema__(cls, handler)</span>
<span class="gi">+    except PydanticUndefinedAnnotation as e:</span>
<span class="gi">+        if raise_errors:</span>
<span class="gi">+            raise</span>
<span class="gi">+        set_model_mocks(cls, cls_name, f&#39;`{e.name}`&#39;)</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    core_config = config_wrapper.core_config(cls)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        schema = gen_schema.clean_schema(schema)</span>
<span class="gi">+    except gen_schema.CollectedInvalid:</span>
<span class="gi">+        set_model_mocks(cls, cls_name)</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # debug(schema)</span>
<span class="gi">+    cls.__pydantic_core_schema__ = schema</span>
<span class="gi">+</span>
<span class="gi">+    cls.__pydantic_validator__ = create_schema_validator(</span>
<span class="gi">+        schema,</span>
<span class="gi">+        cls,</span>
<span class="gi">+        create_model_module or cls.__module__,</span>
<span class="gi">+        cls.__qualname__,</span>
<span class="gi">+        &#39;create_model&#39; if create_model_module else &#39;BaseModel&#39;,</span>
<span class="gi">+        core_config,</span>
<span class="gi">+        config_wrapper.plugin_settings,</span>
<span class="gi">+    )</span>
<span class="gi">+    cls.__pydantic_serializer__ = SchemaSerializer(schema, core_config)</span>
<span class="gi">+    cls.__pydantic_complete__ = True</span>
<span class="gi">+</span>
<span class="gi">+    # set __signature__ attr only for model class, but not for its instances</span>
<span class="gi">+    cls.__signature__ = ClassAttribute(</span>
<span class="gi">+        &#39;__signature__&#39;,</span>
<span class="gi">+        generate_pydantic_signature(init=cls.__init__, fields=cls.model_fields, config_wrapper=config_wrapper),</span>
<span class="gi">+    )</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_deprecated_descriptors(cls: type[BaseModel]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set data descriptors on the class for deprecated fields.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for field, field_info in cls.model_fields.items():</span>
<span class="gi">+        if (msg := field_info.deprecation_message) is not None:</span>
<span class="gi">+            desc = _DeprecatedFieldDescriptor(msg)</span>
<span class="gi">+            desc.__set_name__(cls, field)</span>
<span class="gi">+            setattr(cls, field, desc)</span>
<span class="gi">+</span>
<span class="gi">+    for field, computed_field_info in cls.model_computed_fields.items():</span>
<span class="gi">+        if (</span>
<span class="gi">+            (msg := computed_field_info.deprecation_message) is not None</span>
<span class="gi">+            # Avoid having two warnings emitted:</span>
<span class="gi">+            and not hasattr(unwrap_wrapped_function(computed_field_info.wrapped_property), &#39;__deprecated__&#39;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            desc = _DeprecatedFieldDescriptor(msg, computed_field_info.wrapped_property)</span>
<span class="gi">+            desc.__set_name__(cls, field)</span>
<span class="gi">+            setattr(cls, field, desc)</span>


<span class="w"> </span>class _DeprecatedFieldDescriptor:
<span class="gu">@@ -313,26 +596,30 @@ class _DeprecatedFieldDescriptor:</span>
<span class="w"> </span>        wrapped_property: The property instance if the deprecated field is a computed field, or `None`.
<span class="w"> </span>        field_name: The name of the field being deprecated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    field_name: str

<span class="gd">-    def __init__(self, msg: str, wrapped_property: (property | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, msg: str, wrapped_property: property | None = None) -&gt; None:</span>
<span class="w"> </span>        self.msg = msg
<span class="w"> </span>        self.wrapped_property = wrapped_property

<span class="gd">-    def __set_name__(self, cls: type[BaseModel], name: str) -&gt;None:</span>
<span class="gi">+    def __set_name__(self, cls: type[BaseModel], name: str) -&gt; None:</span>
<span class="w"> </span>        self.field_name = name

<span class="gd">-    def __get__(self, obj: (BaseModel | None), obj_type: (type[BaseModel] |</span>
<span class="gd">-        None)=None) -&gt;Any:</span>
<span class="gi">+    def __get__(self, obj: BaseModel | None, obj_type: type[BaseModel] | None = None) -&gt; Any:</span>
<span class="w"> </span>        if obj is None:
<span class="w"> </span>            raise AttributeError(self.field_name)
<span class="gi">+</span>
<span class="w"> </span>        warnings.warn(self.msg, builtins.DeprecationWarning, stacklevel=2)
<span class="gi">+</span>
<span class="w"> </span>        if self.wrapped_property is not None:
<span class="w"> </span>            return self.wrapped_property.__get__(obj, obj_type)
<span class="w"> </span>        return obj.__dict__[self.field_name]

<span class="gd">-    def __set__(self, obj: Any, value: Any) -&gt;NoReturn:</span>
<span class="gi">+    # Defined to take precedence over the instance&#39;s dictionary</span>
<span class="gi">+    # Note that it will not be called when setting a value on a model instance</span>
<span class="gi">+    # as `BaseModel.__setattr__` is defined and takes priority.</span>
<span class="gi">+    def __set__(self, obj: Any, value: Any) -&gt; NoReturn:</span>
<span class="w"> </span>        raise AttributeError(self.field_name)


<span class="gu">@@ -355,23 +642,23 @@ class _PydanticWeakRef:</span>

<span class="w"> </span>    def __init__(self, obj: Any):
<span class="w"> </span>        if obj is None:
<span class="gi">+            # The object will be `None` upon deserialization if the serialized weakref</span>
<span class="gi">+            # had lost its underlying object.</span>
<span class="w"> </span>            self._wr = None
<span class="w"> </span>        else:
<span class="w"> </span>            self._wr = weakref.ref(obj)

<span class="gd">-    def __call__(self) -&gt;Any:</span>
<span class="gi">+    def __call__(self) -&gt; Any:</span>
<span class="w"> </span>        if self._wr is None:
<span class="w"> </span>            return None
<span class="w"> </span>        else:
<span class="w"> </span>            return self._wr()

<span class="gd">-    def __reduce__(self) -&gt;tuple[Callable, tuple[weakref.ReferenceType | None]</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def __reduce__(self) -&gt; tuple[Callable, tuple[weakref.ReferenceType | None]]:</span>
<span class="w"> </span>        return _PydanticWeakRef, (self(),)


<span class="gd">-def build_lenient_weakvaluedict(d: (dict[str, Any] | None)) -&gt;(dict[str,</span>
<span class="gd">-    Any] | None):</span>
<span class="gi">+def build_lenient_weakvaluedict(d: dict[str, Any] | None) -&gt; dict[str, Any] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Takes an input dictionary, and produces a new value that (invertibly) replaces the values with weakrefs.

<span class="w"> </span>    We can&#39;t just use a WeakValueDictionary because many types (including int, str, etc.) can&#39;t be stored as values
<span class="gu">@@ -379,10 +666,43 @@ def build_lenient_weakvaluedict(d: (dict[str, Any] | None)) -&gt;(dict[str,</span>

<span class="w"> </span>    The `unpack_lenient_weakvaluedict` function can be used to reverse this operation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def unpack_lenient_weakvaluedict(d: (dict[str, Any] | None)) -&gt;(dict[str,</span>
<span class="gd">-    Any] | None):</span>
<span class="gi">+    if d is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for k, v in d.items():</span>
<span class="gi">+        try:</span>
<span class="gi">+            proxy = _PydanticWeakRef(v)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            proxy = v</span>
<span class="gi">+        result[k] = proxy</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def unpack_lenient_weakvaluedict(d: dict[str, Any] | None) -&gt; dict[str, Any] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Inverts the transform performed by `build_lenient_weakvaluedict`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if d is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for k, v in d.items():</span>
<span class="gi">+        if isinstance(v, _PydanticWeakRef):</span>
<span class="gi">+            v = v()</span>
<span class="gi">+            if v is not None:</span>
<span class="gi">+                result[k] = v</span>
<span class="gi">+        else:</span>
<span class="gi">+            result[k] = v</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_ignored_types() -&gt; tuple[type[Any], ...]:</span>
<span class="gi">+    from ..fields import ComputedFieldInfo</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        FunctionType,</span>
<span class="gi">+        property,</span>
<span class="gi">+        classmethod,</span>
<span class="gi">+        staticmethod,</span>
<span class="gi">+        PydanticDescriptorProxy,</span>
<span class="gi">+        ComputedFieldInfo,</span>
<span class="gi">+        ValidateCallWrapper,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pydantic/_internal/_repr.py b/pydantic/_internal/_repr.py</span>
<span class="gh">index ad15026c1..83cb4cc7d 100644</span>
<span class="gd">--- a/pydantic/_internal/_repr.py</span>
<span class="gi">+++ b/pydantic/_internal/_repr.py</span>
<span class="gu">@@ -1,16 +1,20 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Tools to provide pretty/human-readable display of objects.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import types
<span class="w"> </span>import typing
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>import typing_extensions
<span class="gi">+</span>
<span class="w"> </span>from . import _typing_extra
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    ReprArgs: typing_extensions.TypeAlias = (</span>
<span class="gd">-        &#39;typing.Iterable[tuple[str | None, Any]]&#39;)</span>
<span class="gi">+    ReprArgs: typing_extensions.TypeAlias = &#39;typing.Iterable[tuple[str | None, Any]]&#39;</span>
<span class="w"> </span>    RichReprResult: typing_extensions.TypeAlias = (
<span class="w"> </span>        &#39;typing.Iterable[Any | tuple[Any] | tuple[str, Any] | tuple[str, Any, Any]]&#39;
<span class="gd">-        )</span>
<span class="gi">+    )</span>


<span class="w"> </span>class PlainRepr(str):
<span class="gu">@@ -18,14 +22,20 @@ class PlainRepr(str):</span>
<span class="w"> </span>    representation of something that is valid (or pseudo-valid) python.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self)


<span class="w"> </span>class Representation:
<span class="gd">-    __slots__ = tuple()</span>
<span class="gi">+    # Mixin to provide `__str__`, `__repr__`, and `__pretty__` and `__rich_repr__` methods.</span>
<span class="gi">+    # `__pretty__` is used by [devtools](https://python-devtools.helpmanual.io/).</span>
<span class="gi">+    # `__rich_repr__` is used by [rich](https://rich.readthedocs.io/en/stable/pretty.html).</span>
<span class="gi">+    # (this is not a docstring to avoid adding a docstring to classes which inherit from Representation)</span>
<span class="gi">+</span>
<span class="gi">+    # we don&#39;t want to use a type annotation here as it can break get_type_hints</span>
<span class="gi">+    __slots__ = tuple()  # type: typing.Collection[str]</span>

<span class="gd">-    def __repr_args__(self) -&gt;ReprArgs:</span>
<span class="gi">+    def __repr_args__(self) -&gt; ReprArgs:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.

<span class="w"> </span>        Can either return:
<span class="gu">@@ -38,16 +48,14 @@ class Representation:</span>
<span class="w"> </span>        attrs = ((s, getattr(self, s)) for s in attrs_names)
<span class="w"> </span>        return [(a, v) for a, v in attrs if v is not None]

<span class="gd">-    def __repr_name__(self) -&gt;str:</span>
<span class="gi">+    def __repr_name__(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Name of the instance&#39;s class, used in __repr__.&quot;&quot;&quot;
<span class="w"> </span>        return self.__class__.__name__

<span class="gd">-    def __repr_str__(self, join_str: str) -&gt;str:</span>
<span class="gd">-        return join_str.join(repr(v) if a is None else f&#39;{a}={v!r}&#39; for a,</span>
<span class="gd">-            v in self.__repr_args__())</span>
<span class="gi">+    def __repr_str__(self, join_str: str) -&gt; str:</span>
<span class="gi">+        return join_str.join(repr(v) if a is None else f&#39;{a}={v!r}&#39; for a, v in self.__repr_args__())</span>

<span class="gd">-    def __pretty__(self, fmt: typing.Callable[[Any], Any], **kwargs: Any</span>
<span class="gd">-        ) -&gt;typing.Generator[Any, None, None]:</span>
<span class="gi">+    def __pretty__(self, fmt: typing.Callable[[Any], Any], **kwargs: Any) -&gt; typing.Generator[Any, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.&quot;&quot;&quot;
<span class="w"> </span>        yield self.__repr_name__() + &#39;(&#39;
<span class="w"> </span>        yield 1
<span class="gu">@@ -60,7 +68,7 @@ class Representation:</span>
<span class="w"> </span>        yield -1
<span class="w"> </span>        yield &#39;)&#39;

<span class="gd">-    def __rich_repr__(self) -&gt;RichReprResult:</span>
<span class="gi">+    def __rich_repr__(self) -&gt; RichReprResult:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.&quot;&quot;&quot;
<span class="w"> </span>        for name, field_repr in self.__repr_args__():
<span class="w"> </span>            if name is None:
<span class="gu">@@ -68,16 +76,43 @@ class Representation:</span>
<span class="w"> </span>            else:
<span class="w"> </span>                yield name, field_repr

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.__repr_str__(&#39; &#39;)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&quot;{self.__repr_name__()}({self.__repr_str__(&#39;, &#39;)})&quot;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&#39;{self.__repr_name__()}({self.__repr_str__(&quot;, &quot;)})&#39;</span>


<span class="gd">-def display_as_type(obj: Any) -&gt;str:</span>
<span class="gi">+def display_as_type(obj: Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pretty representation of a type, should be as close as possible to the original type definition string.

<span class="w"> </span>    Takes some logic from `typing._type_repr`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(obj, types.FunctionType):</span>
<span class="gi">+        return obj.__name__</span>
<span class="gi">+    elif obj is ...:</span>
<span class="gi">+        return &#39;...&#39;</span>
<span class="gi">+    elif isinstance(obj, Representation):</span>
<span class="gi">+        return repr(obj)</span>
<span class="gi">+    elif isinstance(obj, typing_extensions.TypeAliasType):</span>
<span class="gi">+        return str(obj)</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(obj, (_typing_extra.typing_base, _typing_extra.WithArgsTypes, type)):</span>
<span class="gi">+        obj = obj.__class__</span>
<span class="gi">+</span>
<span class="gi">+    if _typing_extra.origin_is_union(typing_extensions.get_origin(obj)):</span>
<span class="gi">+        args = &#39;, &#39;.join(map(display_as_type, typing_extensions.get_args(obj)))</span>
<span class="gi">+        return f&#39;Union[{args}]&#39;</span>
<span class="gi">+    elif isinstance(obj, _typing_extra.WithArgsTypes):</span>
<span class="gi">+        if typing_extensions.get_origin(obj) == typing_extensions.Literal:</span>
<span class="gi">+            args = &#39;, &#39;.join(map(repr, typing_extensions.get_args(obj)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            args = &#39;, &#39;.join(map(display_as_type, typing_extensions.get_args(obj)))</span>
<span class="gi">+        try:</span>
<span class="gi">+            return f&#39;{obj.__qualname__}[{args}]&#39;</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return str(obj)  # handles TypeAliasType in 3.12</span>
<span class="gi">+    elif isinstance(obj, type):</span>
<span class="gi">+        return obj.__qualname__</span>
<span class="gi">+    else:</span>
<span class="gi">+        return repr(obj).replace(&#39;typing.&#39;, &#39;&#39;).replace(&#39;typing_extensions.&#39;, &#39;&#39;)</span>
<span class="gh">diff --git a/pydantic/_internal/_schema_generation_shared.py b/pydantic/_internal/_schema_generation_shared.py</span>
<span class="gh">index 34203092c..f35c665d2 100644</span>
<span class="gd">--- a/pydantic/_internal/_schema_generation_shared.py</span>
<span class="gi">+++ b/pydantic/_internal/_schema_generation_shared.py</span>
<span class="gu">@@ -1,15 +1,20 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Types and utility functions used by various other internal tools.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import core_schema
<span class="w"> </span>from typing_extensions import Literal
<span class="gi">+</span>
<span class="w"> </span>from ..annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ..json_schema import GenerateJsonSchema, JsonSchemaValue
<span class="w"> </span>    from ._core_utils import CoreSchemaOrField
<span class="w"> </span>    from ._generate_schema import GenerateSchema
<span class="gd">-    GetJsonSchemaFunction = Callable[[CoreSchemaOrField,</span>
<span class="gd">-        GetJsonSchemaHandler], JsonSchemaValue]</span>
<span class="gi">+</span>
<span class="gi">+    GetJsonSchemaFunction = Callable[[CoreSchemaOrField, GetJsonSchemaHandler], JsonSchemaValue]</span>
<span class="w"> </span>    HandlerOverride = Callable[[CoreSchemaOrField], JsonSchemaValue]


<span class="gu">@@ -23,17 +28,15 @@ class GenerateJsonSchemaHandler(GetJsonSchemaHandler):</span>
<span class="w"> </span>    See `GetJsonSchemaHandler` for the handler API.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, generate_json_schema: GenerateJsonSchema,</span>
<span class="gd">-        handler_override: (HandlerOverride | None)) -&gt;None:</span>
<span class="gi">+    def __init__(self, generate_json_schema: GenerateJsonSchema, handler_override: HandlerOverride | None) -&gt; None:</span>
<span class="w"> </span>        self.generate_json_schema = generate_json_schema
<span class="w"> </span>        self.handler = handler_override or generate_json_schema.generate_inner
<span class="w"> </span>        self.mode = generate_json_schema.mode

<span class="gd">-    def __call__(self, core_schema: CoreSchemaOrField, /) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __call__(self, core_schema: CoreSchemaOrField, /) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        return self.handler(core_schema)

<span class="gd">-    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resolves `$ref` in the json schema.

<span class="w"> </span>        This returns the input json schema if there is no `$ref` in json schema.
<span class="gu">@@ -47,7 +50,16 @@ class GenerateJsonSchemaHandler(GetJsonSchemaHandler):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            LookupError: If it can&#39;t find the definition for `$ref`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;$ref&#39; not in maybe_ref_json_schema:</span>
<span class="gi">+            return maybe_ref_json_schema</span>
<span class="gi">+        ref = maybe_ref_json_schema[&#39;$ref&#39;]</span>
<span class="gi">+        json_schema = self.generate_json_schema.get_schema_from_definitions(ref)</span>
<span class="gi">+        if json_schema is None:</span>
<span class="gi">+            raise LookupError(</span>
<span class="gi">+                f&#39;Could not find a ref for {ref}.&#39;</span>
<span class="gi">+                &#39; Maybe you tried to call resolve_ref_schema from within a recursive model?&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        return json_schema</span>


<span class="w"> </span>class CallbackGetCoreSchemaHandler(GetCoreSchemaHandler):
<span class="gu">@@ -57,14 +69,17 @@ class CallbackGetCoreSchemaHandler(GetCoreSchemaHandler):</span>
<span class="w"> </span>    See `GetCoreSchemaHandler` for the handler API.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, handler: Callable[[Any], core_schema.CoreSchema],</span>
<span class="gd">-        generate_schema: GenerateSchema, ref_mode: Literal[&#39;to-def&#39;,</span>
<span class="gd">-        &#39;unpack&#39;]=&#39;to-def&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        handler: Callable[[Any], core_schema.CoreSchema],</span>
<span class="gi">+        generate_schema: GenerateSchema,</span>
<span class="gi">+        ref_mode: Literal[&#39;to-def&#39;, &#39;unpack&#39;] = &#39;to-def&#39;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._handler = handler
<span class="w"> </span>        self._generate_schema = generate_schema
<span class="w"> </span>        self._ref_mode = ref_mode

<span class="gd">-    def __call__(self, source_type: Any, /) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __call__(self, source_type: Any, /) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        schema = self._handler(source_type)
<span class="w"> </span>        ref = schema.get(&#39;ref&#39;)
<span class="w"> </span>        if self._ref_mode == &#39;to-def&#39;:
<span class="gu">@@ -72,11 +87,20 @@ class CallbackGetCoreSchemaHandler(GetCoreSchemaHandler):</span>
<span class="w"> </span>                self._generate_schema.defs.definitions[ref] = schema
<span class="w"> </span>                return core_schema.definition_reference_schema(ref)
<span class="w"> </span>            return schema
<span class="gd">-        else:</span>
<span class="gi">+        else:  # ref_mode = &#39;unpack</span>
<span class="w"> </span>            return self.resolve_ref_schema(schema)

<span class="gd">-    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema</span>
<span class="gd">-        ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def _get_types_namespace(self) -&gt; dict[str, Any] | None:</span>
<span class="gi">+        return self._generate_schema._types_namespace</span>
<span class="gi">+</span>
<span class="gi">+    def generate_schema(self, source_type: Any, /) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return self._generate_schema.generate_schema(source_type)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def field_name(self) -&gt; str | None:</span>
<span class="gi">+        return self._generate_schema.field_name_stack.get()</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resolves reference in the core schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -88,4 +112,14 @@ class CallbackGetCoreSchemaHandler(GetCoreSchemaHandler):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            LookupError: If it can&#39;t find the definition for reference.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if maybe_ref_schema[&#39;type&#39;] == &#39;definition-ref&#39;:</span>
<span class="gi">+            ref = maybe_ref_schema[&#39;schema_ref&#39;]</span>
<span class="gi">+            if ref not in self._generate_schema.defs.definitions:</span>
<span class="gi">+                raise LookupError(</span>
<span class="gi">+                    f&#39;Could not find a ref for {ref}.&#39;</span>
<span class="gi">+                    &#39; Maybe you tried to call resolve_ref_schema from within a recursive model?&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            return self._generate_schema.defs.definitions[ref]</span>
<span class="gi">+        elif maybe_ref_schema[&#39;type&#39;] == &#39;definitions&#39;:</span>
<span class="gi">+            return self.resolve_ref_schema(maybe_ref_schema[&#39;schema&#39;])</span>
<span class="gi">+        return maybe_ref_schema</span>
<span class="gh">diff --git a/pydantic/_internal/_signature.py b/pydantic/_internal/_signature.py</span>
<span class="gh">index f5663caa3..816a1651b 100644</span>
<span class="gd">--- a/pydantic/_internal/_signature.py</span>
<span class="gi">+++ b/pydantic/_internal/_signature.py</span>
<span class="gu">@@ -1,15 +1,19 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>from inspect import Parameter, Signature, signature
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import PydanticUndefined
<span class="gi">+</span>
<span class="w"> </span>from ._config import ConfigWrapper
<span class="w"> </span>from ._utils import is_valid_identifier
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ..fields import FieldInfo


<span class="gd">-def _field_name_for_signature(field_name: str, field_info: FieldInfo) -&gt;str:</span>
<span class="gi">+def _field_name_for_signature(field_name: str, field_info: FieldInfo) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract the correct name to use for the field when generating a signature.

<span class="w"> </span>    Assuming the field has a valid alias, this will return the alias. Otherwise, it will return the field name.
<span class="gu">@@ -22,10 +26,15 @@ def _field_name_for_signature(field_name: str, field_info: FieldInfo) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The correct name to use when generating a signature.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _alias_if_valid(x: Any) -&gt; str | None:</span>
<span class="gi">+        &quot;&quot;&quot;Return the alias if it is a valid alias and identifier, else None.&quot;&quot;&quot;</span>
<span class="gi">+        return x if isinstance(x, str) and is_valid_identifier(x) else None</span>
<span class="gi">+</span>
<span class="gi">+    return _alias_if_valid(field_info.alias) or _alias_if_valid(field_info.validation_alias) or field_name</span>


<span class="gd">-def _process_param_defaults(param: Parameter) -&gt;Parameter:</span>
<span class="gi">+def _process_param_defaults(param: Parameter) -&gt; Parameter:</span>
<span class="w"> </span>    &quot;&quot;&quot;Modify the signature for a parameter in a dataclass where the default value is a FieldInfo instance.

<span class="w"> </span>    Args:
<span class="gu">@@ -34,18 +43,108 @@ def _process_param_defaults(param: Parameter) -&gt;Parameter:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Parameter: The custom processed parameter
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+    param_default = param.default</span>
<span class="gi">+    if isinstance(param_default, FieldInfo):</span>
<span class="gi">+        annotation = param.annotation</span>
<span class="gi">+        # Replace the annotation if appropriate</span>
<span class="gi">+        # inspect does &quot;clever&quot; things to show annotations as strings because we have</span>
<span class="gi">+        # `from __future__ import annotations` in main, we don&#39;t want that</span>
<span class="gi">+        if annotation == &#39;Any&#39;:</span>
<span class="gi">+            annotation = Any</span>
<span class="gi">+</span>
<span class="gi">+        # Replace the field default</span>
<span class="gi">+        default = param_default.default</span>
<span class="gi">+        if default is PydanticUndefined:</span>
<span class="gi">+            if param_default.default_factory is PydanticUndefined:</span>
<span class="gi">+                default = Signature.empty</span>
<span class="gi">+            else:</span>
<span class="gi">+                # this is used by dataclasses to indicate a factory exists:</span>
<span class="gi">+                default = dataclasses._HAS_DEFAULT_FACTORY  # type: ignore</span>
<span class="gi">+        return param.replace(</span>
<span class="gi">+            annotation=annotation, name=_field_name_for_signature(param.name, param_default), default=default</span>
<span class="gi">+        )</span>
<span class="gi">+    return param</span>


<span class="gd">-def _generate_signature_parameters(init: Callable[..., None], fields: dict[</span>
<span class="gd">-    str, FieldInfo], config_wrapper: ConfigWrapper) -&gt;dict[str, Parameter]:</span>
<span class="gi">+def _generate_signature_parameters(  # noqa: C901 (ignore complexity, could use a refactor)</span>
<span class="gi">+    init: Callable[..., None],</span>
<span class="gi">+    fields: dict[str, FieldInfo],</span>
<span class="gi">+    config_wrapper: ConfigWrapper,</span>
<span class="gi">+) -&gt; dict[str, Parameter]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a mapping of parameter names to Parameter objects for a pydantic BaseModel or dataclass.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from itertools import islice</span>
<span class="gi">+</span>
<span class="gi">+    present_params = signature(init).parameters.values()</span>
<span class="gi">+    merged_params: dict[str, Parameter] = {}</span>
<span class="gi">+    var_kw = None</span>
<span class="gi">+    use_var_kw = False</span>
<span class="gi">+</span>
<span class="gi">+    for param in islice(present_params, 1, None):  # skip self arg</span>
<span class="gi">+        # inspect does &quot;clever&quot; things to show annotations as strings because we have</span>
<span class="gi">+        # `from __future__ import annotations` in main, we don&#39;t want that</span>
<span class="gi">+        if fields.get(param.name):</span>
<span class="gi">+            # exclude params with init=False</span>
<span class="gi">+            if getattr(fields[param.name], &#39;init&#39;, True) is False:</span>
<span class="gi">+                continue</span>
<span class="gi">+            param = param.replace(name=_field_name_for_signature(param.name, fields[param.name]))</span>
<span class="gi">+        if param.annotation == &#39;Any&#39;:</span>
<span class="gi">+            param = param.replace(annotation=Any)</span>
<span class="gi">+        if param.kind is param.VAR_KEYWORD:</span>
<span class="gi">+            var_kw = param</span>
<span class="gi">+            continue</span>
<span class="gi">+        merged_params[param.name] = param</span>

<span class="gi">+    if var_kw:  # if custom init has no var_kw, fields which are not declared in it cannot be passed through</span>
<span class="gi">+        allow_names = config_wrapper.populate_by_name</span>
<span class="gi">+        for field_name, field in fields.items():</span>
<span class="gi">+            # when alias is a str it should be used for signature generation</span>
<span class="gi">+            param_name = _field_name_for_signature(field_name, field)</span>

<span class="gd">-def generate_pydantic_signature(init: Callable[..., None], fields: dict[str,</span>
<span class="gd">-    FieldInfo], config_wrapper: ConfigWrapper, is_dataclass: bool=False</span>
<span class="gd">-    ) -&gt;Signature:</span>
<span class="gi">+            if field_name in merged_params or param_name in merged_params:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not is_valid_identifier(param_name):</span>
<span class="gi">+                if allow_names:</span>
<span class="gi">+                    param_name = field_name</span>
<span class="gi">+                else:</span>
<span class="gi">+                    use_var_kw = True</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            kwargs = {} if field.is_required() else {&#39;default&#39;: field.get_default(call_default_factory=False)}</span>
<span class="gi">+            merged_params[param_name] = Parameter(</span>
<span class="gi">+                param_name, Parameter.KEYWORD_ONLY, annotation=field.rebuild_annotation(), **kwargs</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    if config_wrapper.extra == &#39;allow&#39;:</span>
<span class="gi">+        use_var_kw = True</span>
<span class="gi">+</span>
<span class="gi">+    if var_kw and use_var_kw:</span>
<span class="gi">+        # Make sure the parameter for extra kwargs</span>
<span class="gi">+        # does not have the same name as a field</span>
<span class="gi">+        default_model_signature = [</span>
<span class="gi">+            (&#39;self&#39;, Parameter.POSITIONAL_ONLY),</span>
<span class="gi">+            (&#39;data&#39;, Parameter.VAR_KEYWORD),</span>
<span class="gi">+        ]</span>
<span class="gi">+        if [(p.name, p.kind) for p in present_params] == default_model_signature:</span>
<span class="gi">+            # if this is the standard model signature, use extra_data as the extra args name</span>
<span class="gi">+            var_kw_name = &#39;extra_data&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            # else start from var_kw</span>
<span class="gi">+            var_kw_name = var_kw.name</span>
<span class="gi">+</span>
<span class="gi">+        # generate a name that&#39;s definitely unique</span>
<span class="gi">+        while var_kw_name in fields:</span>
<span class="gi">+            var_kw_name += &#39;_&#39;</span>
<span class="gi">+        merged_params[var_kw_name] = var_kw.replace(name=var_kw_name)</span>
<span class="gi">+</span>
<span class="gi">+    return merged_params</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate_pydantic_signature(</span>
<span class="gi">+    init: Callable[..., None], fields: dict[str, FieldInfo], config_wrapper: ConfigWrapper, is_dataclass: bool = False</span>
<span class="gi">+) -&gt; Signature:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate signature for a pydantic BaseModel or dataclass.

<span class="w"> </span>    Args:
<span class="gu">@@ -57,4 +156,9 @@ def generate_pydantic_signature(init: Callable[..., None], fields: dict[str,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The dataclass/BaseModel subclass signature.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    merged_params = _generate_signature_parameters(init, fields, config_wrapper)</span>
<span class="gi">+</span>
<span class="gi">+    if is_dataclass:</span>
<span class="gi">+        merged_params = {k: _process_param_defaults(v) for k, v in merged_params.items()}</span>
<span class="gi">+</span>
<span class="gi">+    return Signature(parameters=list(merged_params.values()), return_annotation=None)</span>
<span class="gh">diff --git a/pydantic/_internal/_std_types_schema.py b/pydantic/_internal/_std_types_schema.py</span>
<span class="gh">index 9dc4c792a..9f8b95890 100644</span>
<span class="gd">--- a/pydantic/_internal/_std_types_schema.py</span>
<span class="gi">+++ b/pydantic/_internal/_std_types_schema.py</span>
<span class="gu">@@ -2,7 +2,9 @@</span>

<span class="w"> </span>Import of this module is deferred since it contains imports of many standard library modules.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import collections.abc
<span class="w"> </span>import dataclasses
<span class="gu">@@ -15,49 +17,128 @@ from functools import partial</span>
<span class="w"> </span>from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
<span class="w"> </span>from operator import attrgetter
<span class="w"> </span>from typing import Any, Callable, Iterable, Literal, Tuple, TypeVar
<span class="gi">+</span>
<span class="w"> </span>import typing_extensions
<span class="gd">-from pydantic_core import CoreSchema, MultiHostUrl, PydanticCustomError, PydanticOmit, Url, core_schema</span>
<span class="gi">+from pydantic_core import (</span>
<span class="gi">+    CoreSchema,</span>
<span class="gi">+    MultiHostUrl,</span>
<span class="gi">+    PydanticCustomError,</span>
<span class="gi">+    PydanticOmit,</span>
<span class="gi">+    Url,</span>
<span class="gi">+    core_schema,</span>
<span class="gi">+)</span>
<span class="w"> </span>from typing_extensions import get_args, get_origin
<span class="gi">+</span>
<span class="w"> </span>from pydantic.errors import PydanticSchemaGenerationError
<span class="w"> </span>from pydantic.fields import FieldInfo
<span class="w"> </span>from pydantic.types import Strict
<span class="gi">+</span>
<span class="w"> </span>from ..config import ConfigDict
<span class="w"> </span>from ..json_schema import JsonSchemaValue
<span class="w"> </span>from . import _known_annotated_metadata, _typing_extra, _validators
<span class="w"> </span>from ._core_utils import get_type_ref
<span class="w"> </span>from ._internal_dataclass import slots_true
<span class="w"> </span>from ._schema_generation_shared import GetCoreSchemaHandler, GetJsonSchemaHandler
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from ._generate_schema import GenerateSchema
<span class="gd">-    StdSchemaFunction = Callable[[GenerateSchema, type[Any]], core_schema.</span>
<span class="gd">-        CoreSchema]</span>
<span class="gi">+</span>
<span class="gi">+    StdSchemaFunction = Callable[[GenerateSchema, type[Any]], core_schema.CoreSchema]</span>


<span class="w"> </span>@dataclasses.dataclass(**slots_true)
<span class="w"> </span>class SchemaTransformer:
<span class="w"> </span>    get_core_schema: Callable[[Any, GetCoreSchemaHandler], CoreSchema]
<span class="gd">-    get_json_schema: Callable[[CoreSchema, GetJsonSchemaHandler],</span>
<span class="gd">-        JsonSchemaValue]</span>
<span class="gi">+    get_json_schema: Callable[[CoreSchema, GetJsonSchemaHandler], JsonSchemaValue]</span>

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:</span>
<span class="w"> </span>        return self.get_core_schema(source_type, handler)

<span class="gd">-    def __get_pydantic_json_schema__(self, schema: CoreSchema, handler:</span>
<span class="gd">-        GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(self, schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        return self.get_json_schema(schema, handler)


<span class="gi">+def get_enum_core_schema(enum_type: type[Enum], config: ConfigDict) -&gt; CoreSchema:</span>
<span class="gi">+    cases: list[Any] = list(enum_type.__members__.values())</span>
<span class="gi">+</span>
<span class="gi">+    enum_ref = get_type_ref(enum_type)</span>
<span class="gi">+    description = None if not enum_type.__doc__ else inspect.cleandoc(enum_type.__doc__)</span>
<span class="gi">+    if description == &#39;An enumeration.&#39;:  # This is the default value provided by enum.EnumMeta.__new__; don&#39;t use it</span>
<span class="gi">+        description = None</span>
<span class="gi">+    js_updates = {&#39;title&#39;: enum_type.__name__, &#39;description&#39;: description}</span>
<span class="gi">+    js_updates = {k: v for k, v in js_updates.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+    sub_type: Literal[&#39;str&#39;, &#39;int&#39;, &#39;float&#39;] | None = None</span>
<span class="gi">+    if issubclass(enum_type, int):</span>
<span class="gi">+        sub_type = &#39;int&#39;</span>
<span class="gi">+        value_ser_type: core_schema.SerSchema = core_schema.simple_ser_schema(&#39;int&#39;)</span>
<span class="gi">+    elif issubclass(enum_type, str):</span>
<span class="gi">+        # this handles `StrEnum` (3.11 only), and also `Foobar(str, Enum)`</span>
<span class="gi">+        sub_type = &#39;str&#39;</span>
<span class="gi">+        value_ser_type = core_schema.simple_ser_schema(&#39;str&#39;)</span>
<span class="gi">+    elif issubclass(enum_type, float):</span>
<span class="gi">+        sub_type = &#39;float&#39;</span>
<span class="gi">+        value_ser_type = core_schema.simple_ser_schema(&#39;float&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # TODO this is an ugly hack, how do we trigger an Any schema for serialization?</span>
<span class="gi">+        value_ser_type = core_schema.plain_serializer_function_ser_schema(lambda x: x)</span>
<span class="gi">+</span>
<span class="gi">+    if cases:</span>
<span class="gi">+</span>
<span class="gi">+        def get_json_schema(schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue:</span>
<span class="gi">+            json_schema = handler(schema)</span>
<span class="gi">+            original_schema = handler.resolve_ref_schema(json_schema)</span>
<span class="gi">+            original_schema.update(js_updates)</span>
<span class="gi">+            return json_schema</span>
<span class="gi">+</span>
<span class="gi">+        # we don&#39;t want to add the missing to the schema if it&#39;s the default one</span>
<span class="gi">+        default_missing = getattr(enum_type._missing_, &#39;__func__&#39;, None) == Enum._missing_.__func__  # type: ignore</span>
<span class="gi">+        enum_schema = core_schema.enum_schema(</span>
<span class="gi">+            enum_type,</span>
<span class="gi">+            cases,</span>
<span class="gi">+            sub_type=sub_type,</span>
<span class="gi">+            missing=None if default_missing else enum_type._missing_,</span>
<span class="gi">+            ref=enum_ref,</span>
<span class="gi">+            metadata={&#39;pydantic_js_functions&#39;: [get_json_schema]},</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if config.get(&#39;use_enum_values&#39;, False):</span>
<span class="gi">+            enum_schema = core_schema.no_info_after_validator_function(</span>
<span class="gi">+                attrgetter(&#39;value&#39;), enum_schema, serialization=value_ser_type</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return enum_schema</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def get_json_schema_no_cases(_, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue:</span>
<span class="gi">+            json_schema = handler(core_schema.enum_schema(enum_type, cases, sub_type=sub_type, ref=enum_ref))</span>
<span class="gi">+            original_schema = handler.resolve_ref_schema(json_schema)</span>
<span class="gi">+            original_schema.update(js_updates)</span>
<span class="gi">+            return json_schema</span>
<span class="gi">+</span>
<span class="gi">+        # Use an isinstance check for enums with no cases.</span>
<span class="gi">+        # The most important use case for this is creating TypeVar bounds for generics that should</span>
<span class="gi">+        # be restricted to enums. This is more consistent than it might seem at first, since you can only</span>
<span class="gi">+        # subclass enum.Enum (or subclasses of enum.Enum) if all parent classes have no cases.</span>
<span class="gi">+        # We use the get_json_schema function when an Enum subclass has been declared with no cases</span>
<span class="gi">+        # so that we can still generate a valid json schema.</span>
<span class="gi">+        return core_schema.is_instance_schema(</span>
<span class="gi">+            enum_type,</span>
<span class="gi">+            metadata={&#39;pydantic_js_functions&#39;: [get_json_schema_no_cases]},</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@dataclasses.dataclass(**slots_true)
<span class="w"> </span>class InnerSchemaValidator:
<span class="w"> </span>    &quot;&quot;&quot;Use a fixed CoreSchema, avoiding interference from outward annotations.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    core_schema: CoreSchema
<span class="w"> </span>    js_schema: JsonSchemaValue | None = None
<span class="w"> </span>    js_core_schema: CoreSchema | None = None
<span class="w"> </span>    js_schema_update: JsonSchemaValue | None = None

<span class="gd">-    def __get_pydantic_json_schema__(self, _schema: CoreSchema, handler:</span>
<span class="gd">-        GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(self, _schema: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        if self.js_schema is not None:
<span class="w"> </span>            return self.js_schema
<span class="w"> </span>        js_schema = handler(self.js_core_schema or self.core_schema)
<span class="gu">@@ -65,11 +146,160 @@ class InnerSchemaValidator:</span>
<span class="w"> </span>            js_schema.update(self.js_schema_update)
<span class="w"> </span>        return js_schema

<span class="gd">-    def __get_pydantic_core_schema__(self, _source_type: Any, _handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, _source_type: Any, _handler: GetCoreSchemaHandler) -&gt; CoreSchema:</span>
<span class="w"> </span>        return self.core_schema


<span class="gi">+def decimal_prepare_pydantic_annotations(</span>
<span class="gi">+    source: Any, annotations: Iterable[Any], config: ConfigDict</span>
<span class="gi">+) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+    if source is not decimal.Decimal:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)</span>
<span class="gi">+</span>
<span class="gi">+    config_allow_inf_nan = config.get(&#39;allow_inf_nan&#39;)</span>
<span class="gi">+    if config_allow_inf_nan is not None:</span>
<span class="gi">+        metadata.setdefault(&#39;allow_inf_nan&#39;, config_allow_inf_nan)</span>
<span class="gi">+</span>
<span class="gi">+    _known_annotated_metadata.check_metadata(</span>
<span class="gi">+        metadata, {*_known_annotated_metadata.FLOAT_CONSTRAINTS, &#39;max_digits&#39;, &#39;decimal_places&#39;}, decimal.Decimal</span>
<span class="gi">+    )</span>
<span class="gi">+    return source, [InnerSchemaValidator(core_schema.decimal_schema(**metadata)), *remaining_annotations]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def datetime_prepare_pydantic_annotations(</span>
<span class="gi">+    source_type: Any, annotations: Iterable[Any], _config: ConfigDict</span>
<span class="gi">+) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+    import datetime</span>
<span class="gi">+</span>
<span class="gi">+    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)</span>
<span class="gi">+    if source_type is datetime.date:</span>
<span class="gi">+        sv = InnerSchemaValidator(core_schema.date_schema(**metadata))</span>
<span class="gi">+    elif source_type is datetime.datetime:</span>
<span class="gi">+        sv = InnerSchemaValidator(core_schema.datetime_schema(**metadata))</span>
<span class="gi">+    elif source_type is datetime.time:</span>
<span class="gi">+        sv = InnerSchemaValidator(core_schema.time_schema(**metadata))</span>
<span class="gi">+    elif source_type is datetime.timedelta:</span>
<span class="gi">+        sv = InnerSchemaValidator(core_schema.timedelta_schema(**metadata))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+    # check now that we know the source type is correct</span>
<span class="gi">+    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.DATE_TIME_CONSTRAINTS, source_type)</span>
<span class="gi">+    return (source_type, [sv, *remaining_annotations])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def uuid_prepare_pydantic_annotations(</span>
<span class="gi">+    source_type: Any, annotations: Iterable[Any], _config: ConfigDict</span>
<span class="gi">+) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+    # UUIDs have no constraints - they are fixed length, constructing a UUID instance checks the length</span>
<span class="gi">+</span>
<span class="gi">+    from uuid import UUID</span>
<span class="gi">+</span>
<span class="gi">+    if source_type is not UUID:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    return (source_type, [InnerSchemaValidator(core_schema.uuid_schema()), *annotations])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def path_schema_prepare_pydantic_annotations(</span>
<span class="gi">+    source_type: Any, annotations: Iterable[Any], _config: ConfigDict</span>
<span class="gi">+) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+    import pathlib</span>
<span class="gi">+</span>
<span class="gi">+    if source_type not in {</span>
<span class="gi">+        os.PathLike,</span>
<span class="gi">+        pathlib.Path,</span>
<span class="gi">+        pathlib.PurePath,</span>
<span class="gi">+        pathlib.PosixPath,</span>
<span class="gi">+        pathlib.PurePosixPath,</span>
<span class="gi">+        pathlib.PureWindowsPath,</span>
<span class="gi">+    }:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)</span>
<span class="gi">+    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, source_type)</span>
<span class="gi">+</span>
<span class="gi">+    construct_path = pathlib.PurePath if source_type is os.PathLike else source_type</span>
<span class="gi">+</span>
<span class="gi">+    def path_validator(input_value: str) -&gt; os.PathLike[Any]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return construct_path(input_value)</span>
<span class="gi">+        except TypeError as e:</span>
<span class="gi">+            raise PydanticCustomError(&#39;path_type&#39;, &#39;Input is not a valid path&#39;) from e</span>
<span class="gi">+</span>
<span class="gi">+    constrained_str_schema = core_schema.str_schema(**metadata)</span>
<span class="gi">+</span>
<span class="gi">+    instance_schema = core_schema.json_or_python_schema(</span>
<span class="gi">+        json_schema=core_schema.no_info_after_validator_function(path_validator, constrained_str_schema),</span>
<span class="gi">+        python_schema=core_schema.is_instance_schema(source_type),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    strict: bool | None = None</span>
<span class="gi">+    for annotation in annotations:</span>
<span class="gi">+        if isinstance(annotation, Strict):</span>
<span class="gi">+            strict = annotation.strict</span>
<span class="gi">+</span>
<span class="gi">+    schema = core_schema.lax_or_strict_schema(</span>
<span class="gi">+        lax_schema=core_schema.union_schema(</span>
<span class="gi">+            [</span>
<span class="gi">+                instance_schema,</span>
<span class="gi">+                core_schema.no_info_after_validator_function(path_validator, constrained_str_schema),</span>
<span class="gi">+            ],</span>
<span class="gi">+            custom_error_type=&#39;path_type&#39;,</span>
<span class="gi">+            custom_error_message=&#39;Input is not a valid path&#39;,</span>
<span class="gi">+            strict=True,</span>
<span class="gi">+        ),</span>
<span class="gi">+        strict_schema=instance_schema,</span>
<span class="gi">+        serialization=core_schema.to_string_ser_schema(),</span>
<span class="gi">+        strict=strict,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        source_type,</span>
<span class="gi">+        [</span>
<span class="gi">+            InnerSchemaValidator(schema, js_core_schema=constrained_str_schema, js_schema_update={&#39;format&#39;: &#39;path&#39;}),</span>
<span class="gi">+            *remaining_annotations,</span>
<span class="gi">+        ],</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def dequeue_validator(</span>
<span class="gi">+    input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler, maxlen: None | int</span>
<span class="gi">+) -&gt; collections.deque[Any]:</span>
<span class="gi">+    if isinstance(input_value, collections.deque):</span>
<span class="gi">+        maxlens = [v for v in (input_value.maxlen, maxlen) if v is not None]</span>
<span class="gi">+        if maxlens:</span>
<span class="gi">+            maxlen = min(maxlens)</span>
<span class="gi">+        return collections.deque(handler(input_value), maxlen=maxlen)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return collections.deque(handler(input_value), maxlen=maxlen)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def serialize_sequence_via_list(</span>
<span class="gi">+    v: Any, handler: core_schema.SerializerFunctionWrapHandler, info: core_schema.SerializationInfo</span>
<span class="gi">+) -&gt; Any:</span>
<span class="gi">+    items: list[Any] = []</span>
<span class="gi">+</span>
<span class="gi">+    mapped_origin = SEQUENCE_ORIGIN_MAP.get(type(v), None)</span>
<span class="gi">+    if mapped_origin is None:</span>
<span class="gi">+        # we shouldn&#39;t hit this branch, should probably add a serialization error or something</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    for index, item in enumerate(v):</span>
<span class="gi">+        try:</span>
<span class="gi">+            v = handler(item, index)</span>
<span class="gi">+        except PydanticOmit:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            items.append(v)</span>
<span class="gi">+</span>
<span class="gi">+    if info.mode_is_json():</span>
<span class="gi">+        return items</span>
<span class="gi">+    else:</span>
<span class="gi">+        return mapped_origin(items)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@dataclasses.dataclass(**slots_true)
<span class="w"> </span>class SequenceValidator:
<span class="w"> </span>    mapped_origin: type[Any]
<span class="gu">@@ -79,71 +309,201 @@ class SequenceValidator:</span>
<span class="w"> </span>    strict: bool | None = None
<span class="w"> </span>    fail_fast: bool | None = None

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:</span>
<span class="w"> </span>        if self.item_source_type is Any:
<span class="w"> </span>            items_schema = None
<span class="w"> </span>        else:
<span class="w"> </span>            items_schema = handler.generate_schema(self.item_source_type)
<span class="gd">-        metadata = {&#39;min_length&#39;: self.min_length, &#39;max_length&#39;: self.</span>
<span class="gd">-            max_length, &#39;strict&#39;: self.strict, &#39;fail_fast&#39;: self.fail_fast}</span>
<span class="gi">+</span>
<span class="gi">+        metadata = {</span>
<span class="gi">+            &#39;min_length&#39;: self.min_length,</span>
<span class="gi">+            &#39;max_length&#39;: self.max_length,</span>
<span class="gi">+            &#39;strict&#39;: self.strict,</span>
<span class="gi">+            &#39;fail_fast&#39;: self.fail_fast,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>        if self.mapped_origin in (list, set, frozenset):
<span class="w"> </span>            if self.mapped_origin is list:
<span class="gd">-                constrained_schema = core_schema.list_schema(items_schema,</span>
<span class="gd">-                    **metadata)</span>
<span class="gi">+                constrained_schema = core_schema.list_schema(items_schema, **metadata)</span>
<span class="w"> </span>            elif self.mapped_origin is set:
<span class="gd">-                constrained_schema = core_schema.set_schema(items_schema,</span>
<span class="gd">-                    **metadata)</span>
<span class="gi">+                constrained_schema = core_schema.set_schema(items_schema, **metadata)</span>
<span class="w"> </span>            else:
<span class="gd">-                assert self.mapped_origin is frozenset</span>
<span class="gd">-                constrained_schema = core_schema.frozenset_schema(items_schema,</span>
<span class="gd">-                    **metadata)</span>
<span class="gi">+                assert self.mapped_origin is frozenset  # safety check in case we forget to add a case</span>
<span class="gi">+                constrained_schema = core_schema.frozenset_schema(items_schema, **metadata)</span>
<span class="gi">+</span>
<span class="w"> </span>            schema = constrained_schema
<span class="w"> </span>        else:
<span class="gd">-            assert self.mapped_origin in (collections.deque, collections.</span>
<span class="gd">-                Counter)</span>
<span class="gi">+            # safety check in case we forget to add a case</span>
<span class="gi">+            assert self.mapped_origin in (collections.deque, collections.Counter)</span>
<span class="gi">+</span>
<span class="w"> </span>            if self.mapped_origin is collections.deque:
<span class="gd">-                coerce_instance_wrap = partial(core_schema.</span>
<span class="gd">-                    no_info_wrap_validator_function, partial(</span>
<span class="gd">-                    dequeue_validator, maxlen=metadata.get(&#39;max_length&#39;, None))</span>
<span class="gd">-                    )</span>
<span class="gi">+                # if we have a MaxLen annotation might as well set that as the default maxlen on the deque</span>
<span class="gi">+                # this lets us re-use existing metadata annotations to let users set the maxlen on a dequeue</span>
<span class="gi">+                # that e.g. comes from JSON</span>
<span class="gi">+                coerce_instance_wrap = partial(</span>
<span class="gi">+                    core_schema.no_info_wrap_validator_function,</span>
<span class="gi">+                    partial(dequeue_validator, maxlen=metadata.get(&#39;max_length&#39;, None)),</span>
<span class="gi">+                )</span>
<span class="w"> </span>            else:
<span class="gd">-                coerce_instance_wrap = partial(core_schema.</span>
<span class="gd">-                    no_info_after_validator_function, self.mapped_origin)</span>
<span class="gi">+                coerce_instance_wrap = partial(core_schema.no_info_after_validator_function, self.mapped_origin)</span>
<span class="gi">+</span>
<span class="gi">+            # we have to use a lax list schema here, because we need to validate the deque&#39;s</span>
<span class="gi">+            # items via a list schema, but it&#39;s ok if the deque itself is not a list (same for Counter)</span>
<span class="w"> </span>            metadata_with_strict_override = {**metadata, &#39;strict&#39;: False}
<span class="gd">-            constrained_schema = core_schema.list_schema(items_schema, **</span>
<span class="gd">-                metadata_with_strict_override)</span>
<span class="gd">-            check_instance = core_schema.json_or_python_schema(json_schema=</span>
<span class="gd">-                core_schema.list_schema(), python_schema=core_schema.</span>
<span class="gd">-                is_instance_schema(self.mapped_origin))</span>
<span class="gi">+            constrained_schema = core_schema.list_schema(items_schema, **metadata_with_strict_override)</span>
<span class="gi">+</span>
<span class="gi">+            check_instance = core_schema.json_or_python_schema(</span>
<span class="gi">+                json_schema=core_schema.list_schema(),</span>
<span class="gi">+                python_schema=core_schema.is_instance_schema(self.mapped_origin),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>            serialization = core_schema.wrap_serializer_function_ser_schema(
<span class="gd">-                serialize_sequence_via_list, schema=items_schema or</span>
<span class="gd">-                core_schema.any_schema(), info_arg=True)</span>
<span class="gd">-            strict = core_schema.chain_schema([check_instance,</span>
<span class="gd">-                coerce_instance_wrap(constrained_schema)])</span>
<span class="gi">+                serialize_sequence_via_list, schema=items_schema or core_schema.any_schema(), info_arg=True</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            strict = core_schema.chain_schema([check_instance, coerce_instance_wrap(constrained_schema)])</span>
<span class="gi">+</span>
<span class="w"> </span>            if metadata.get(&#39;strict&#39;, False):
<span class="w"> </span>                schema = strict
<span class="w"> </span>            else:
<span class="w"> </span>                lax = coerce_instance_wrap(constrained_schema)
<span class="gd">-                schema = core_schema.lax_or_strict_schema(lax_schema=lax,</span>
<span class="gd">-                    strict_schema=strict)</span>
<span class="gi">+                schema = core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict)</span>
<span class="w"> </span>            schema[&#39;serialization&#39;] = serialization
<span class="gi">+</span>
<span class="w"> </span>        return schema


<span class="gd">-SEQUENCE_ORIGIN_MAP: dict[Any, Any] = {typing.Deque: collections.deque,</span>
<span class="gd">-    collections.deque: collections.deque, list: list, typing.List: list,</span>
<span class="gd">-    set: set, typing.AbstractSet: set, typing.Set: set, frozenset:</span>
<span class="gd">-    frozenset, typing.FrozenSet: frozenset, typing.Sequence: list, typing.</span>
<span class="gd">-    MutableSequence: list, typing.MutableSet: set, collections.abc.</span>
<span class="gd">-    MutableSet: set, collections.abc.Set: frozenset}</span>
<span class="gd">-MAPPING_ORIGIN_MAP: dict[Any, Any] = {typing.DefaultDict: collections.</span>
<span class="gd">-    defaultdict, collections.defaultdict: collections.defaultdict,</span>
<span class="gd">-    collections.OrderedDict: collections.OrderedDict, typing_extensions.</span>
<span class="gd">-    OrderedDict: collections.OrderedDict, dict: dict, typing.Dict: dict,</span>
<span class="gd">-    collections.Counter: collections.Counter, typing.Counter: collections.</span>
<span class="gd">-    Counter, typing.Mapping: dict, typing.MutableMapping: dict, collections</span>
<span class="gd">-    .abc.MutableMapping: dict, collections.abc.Mapping: dict}</span>
<span class="gi">+SEQUENCE_ORIGIN_MAP: dict[Any, Any] = {</span>
<span class="gi">+    typing.Deque: collections.deque,</span>
<span class="gi">+    collections.deque: collections.deque,</span>
<span class="gi">+    list: list,</span>
<span class="gi">+    typing.List: list,</span>
<span class="gi">+    set: set,</span>
<span class="gi">+    typing.AbstractSet: set,</span>
<span class="gi">+    typing.Set: set,</span>
<span class="gi">+    frozenset: frozenset,</span>
<span class="gi">+    typing.FrozenSet: frozenset,</span>
<span class="gi">+    typing.Sequence: list,</span>
<span class="gi">+    typing.MutableSequence: list,</span>
<span class="gi">+    typing.MutableSet: set,</span>
<span class="gi">+    # this doesn&#39;t handle subclasses of these</span>
<span class="gi">+    # parametrized typing.Set creates one of these</span>
<span class="gi">+    collections.abc.MutableSet: set,</span>
<span class="gi">+    collections.abc.Set: frozenset,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def identity(s: CoreSchema) -&gt; CoreSchema:</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sequence_like_prepare_pydantic_annotations(</span>
<span class="gi">+    source_type: Any, annotations: Iterable[Any], _config: ConfigDict</span>
<span class="gi">+) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+    origin: Any = get_origin(source_type)</span>
<span class="gi">+</span>
<span class="gi">+    mapped_origin = SEQUENCE_ORIGIN_MAP.get(origin, None) if origin else SEQUENCE_ORIGIN_MAP.get(source_type, None)</span>
<span class="gi">+    if mapped_origin is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    args = get_args(source_type)</span>
<span class="gi">+</span>
<span class="gi">+    if not args:</span>
<span class="gi">+        args = typing.cast(Tuple[Any], (Any,))</span>
<span class="gi">+    elif len(args) != 1:</span>
<span class="gi">+        raise ValueError(&#39;Expected sequence to have exactly 1 generic parameter&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    item_source_type = args[0]</span>
<span class="gi">+</span>
<span class="gi">+    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)</span>
<span class="gi">+    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.SEQUENCE_CONSTRAINTS, source_type)</span>
<span class="gi">+</span>
<span class="gi">+    return (source_type, [SequenceValidator(mapped_origin, item_source_type, **metadata), *remaining_annotations])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MAPPING_ORIGIN_MAP: dict[Any, Any] = {</span>
<span class="gi">+    typing.DefaultDict: collections.defaultdict,</span>
<span class="gi">+    collections.defaultdict: collections.defaultdict,</span>
<span class="gi">+    collections.OrderedDict: collections.OrderedDict,</span>
<span class="gi">+    typing_extensions.OrderedDict: collections.OrderedDict,</span>
<span class="gi">+    dict: dict,</span>
<span class="gi">+    typing.Dict: dict,</span>
<span class="gi">+    collections.Counter: collections.Counter,</span>
<span class="gi">+    typing.Counter: collections.Counter,</span>
<span class="gi">+    # this doesn&#39;t handle subclasses of these</span>
<span class="gi">+    typing.Mapping: dict,</span>
<span class="gi">+    typing.MutableMapping: dict,</span>
<span class="gi">+    # parametrized typing.{Mutable}Mapping creates one of these</span>
<span class="gi">+    collections.abc.MutableMapping: dict,</span>
<span class="gi">+    collections.abc.Mapping: dict,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def defaultdict_validator(</span>
<span class="gi">+    input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler, default_default_factory: Callable[[], Any]</span>
<span class="gi">+) -&gt; collections.defaultdict[Any, Any]:</span>
<span class="gi">+    if isinstance(input_value, collections.defaultdict):</span>
<span class="gi">+        default_factory = input_value.default_factory</span>
<span class="gi">+        return collections.defaultdict(default_factory, handler(input_value))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return collections.defaultdict(default_default_factory, handler(input_value))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_defaultdict_default_default_factory(values_source_type: Any) -&gt; Callable[[], Any]:</span>
<span class="gi">+    def infer_default() -&gt; Callable[[], Any]:</span>
<span class="gi">+        allowed_default_types: dict[Any, Any] = {</span>
<span class="gi">+            typing.Tuple: tuple,</span>
<span class="gi">+            tuple: tuple,</span>
<span class="gi">+            collections.abc.Sequence: tuple,</span>
<span class="gi">+            collections.abc.MutableSequence: list,</span>
<span class="gi">+            typing.List: list,</span>
<span class="gi">+            list: list,</span>
<span class="gi">+            typing.Sequence: list,</span>
<span class="gi">+            typing.Set: set,</span>
<span class="gi">+            set: set,</span>
<span class="gi">+            typing.MutableSet: set,</span>
<span class="gi">+            collections.abc.MutableSet: set,</span>
<span class="gi">+            collections.abc.Set: frozenset,</span>
<span class="gi">+            typing.MutableMapping: dict,</span>
<span class="gi">+            typing.Mapping: dict,</span>
<span class="gi">+            collections.abc.Mapping: dict,</span>
<span class="gi">+            collections.abc.MutableMapping: dict,</span>
<span class="gi">+            float: float,</span>
<span class="gi">+            int: int,</span>
<span class="gi">+            str: str,</span>
<span class="gi">+            bool: bool,</span>
<span class="gi">+        }</span>
<span class="gi">+        values_type_origin = get_origin(values_source_type) or values_source_type</span>
<span class="gi">+        instructions = &#39;set using `DefaultDict[..., Annotated[..., Field(default_factory=...)]]`&#39;</span>
<span class="gi">+        if isinstance(values_type_origin, TypeVar):</span>
<span class="gi">+</span>
<span class="gi">+            def type_var_default_factory() -&gt; None:</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    &#39;Generic defaultdict cannot be used without a concrete value type or an&#39;</span>
<span class="gi">+                    &#39; explicit default factory, &#39; + instructions</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            return type_var_default_factory</span>
<span class="gi">+        elif values_type_origin not in allowed_default_types:</span>
<span class="gi">+            # a somewhat subjective set of types that have reasonable default values</span>
<span class="gi">+            allowed_msg = &#39;, &#39;.join([t.__name__ for t in set(allowed_default_types.values())])</span>
<span class="gi">+            raise PydanticSchemaGenerationError(</span>
<span class="gi">+                f&#39;Unable to infer a default factory for keys of type {values_source_type}.&#39;</span>
<span class="gi">+                f&#39; Only {allowed_msg} are supported, other types require an explicit default factory&#39;</span>
<span class="gi">+                &#39; &#39; + instructions</span>
<span class="gi">+            )</span>
<span class="gi">+        return allowed_default_types[values_type_origin]</span>
<span class="gi">+</span>
<span class="gi">+    # Assume Annotated[..., Field(...)]</span>
<span class="gi">+    if _typing_extra.is_annotated(values_source_type):</span>
<span class="gi">+        field_info = next((v for v in get_args(values_source_type) if isinstance(v, FieldInfo)), None)</span>
<span class="gi">+    else:</span>
<span class="gi">+        field_info = None</span>
<span class="gi">+    if field_info and field_info.default_factory:</span>
<span class="gi">+        default_default_factory = field_info.default_factory</span>
<span class="gi">+    else:</span>
<span class="gi">+        default_default_factory = infer_default()</span>
<span class="gi">+    return default_default_factory</span>


<span class="w"> </span>@dataclasses.dataclass(**slots_true)
<span class="gu">@@ -155,8 +515,10 @@ class MappingValidator:</span>
<span class="w"> </span>    max_length: int | None = None
<span class="w"> </span>    strict: bool = False

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;CoreSchema:</span>
<span class="gi">+    def serialize_mapping_via_dict(self, v: Any, handler: core_schema.SerializerFunctionWrapHandler) -&gt; Any:</span>
<span class="gi">+        return handler(v)</span>
<span class="gi">+</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:</span>
<span class="w"> </span>        if self.keys_source_type is Any:
<span class="w"> </span>            keys_schema = None
<span class="w"> </span>        else:
<span class="gu">@@ -165,49 +527,196 @@ class MappingValidator:</span>
<span class="w"> </span>            values_schema = None
<span class="w"> </span>        else:
<span class="w"> </span>            values_schema = handler.generate_schema(self.values_source_type)
<span class="gd">-        metadata = {&#39;min_length&#39;: self.min_length, &#39;max_length&#39;: self.</span>
<span class="gd">-            max_length, &#39;strict&#39;: self.strict}</span>
<span class="gi">+</span>
<span class="gi">+        metadata = {&#39;min_length&#39;: self.min_length, &#39;max_length&#39;: self.max_length, &#39;strict&#39;: self.strict}</span>
<span class="gi">+</span>
<span class="w"> </span>        if self.mapped_origin is dict:
<span class="gd">-            schema = core_schema.dict_schema(keys_schema, values_schema, **</span>
<span class="gd">-                metadata)</span>
<span class="gi">+            schema = core_schema.dict_schema(keys_schema, values_schema, **metadata)</span>
<span class="w"> </span>        else:
<span class="gd">-            constrained_schema = core_schema.dict_schema(keys_schema,</span>
<span class="gd">-                values_schema, **metadata)</span>
<span class="gd">-            check_instance = core_schema.json_or_python_schema(json_schema=</span>
<span class="gd">-                core_schema.dict_schema(), python_schema=core_schema.</span>
<span class="gd">-                is_instance_schema(self.mapped_origin))</span>
<span class="gi">+            constrained_schema = core_schema.dict_schema(keys_schema, values_schema, **metadata)</span>
<span class="gi">+            check_instance = core_schema.json_or_python_schema(</span>
<span class="gi">+                json_schema=core_schema.dict_schema(),</span>
<span class="gi">+                python_schema=core_schema.is_instance_schema(self.mapped_origin),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>            if self.mapped_origin is collections.defaultdict:
<span class="gd">-                default_default_factory = (</span>
<span class="gd">-                    get_defaultdict_default_default_factory(self.</span>
<span class="gd">-                    values_source_type))</span>
<span class="gd">-                coerce_instance_wrap = partial(core_schema.</span>
<span class="gd">-                    no_info_wrap_validator_function, partial(</span>
<span class="gd">-                    defaultdict_validator, default_default_factory=</span>
<span class="gd">-                    default_default_factory))</span>
<span class="gi">+                default_default_factory = get_defaultdict_default_default_factory(self.values_source_type)</span>
<span class="gi">+                coerce_instance_wrap = partial(</span>
<span class="gi">+                    core_schema.no_info_wrap_validator_function,</span>
<span class="gi">+                    partial(defaultdict_validator, default_default_factory=default_default_factory),</span>
<span class="gi">+                )</span>
<span class="w"> </span>            else:
<span class="gd">-                coerce_instance_wrap = partial(core_schema.</span>
<span class="gd">-                    no_info_after_validator_function, self.mapped_origin)</span>
<span class="gi">+                coerce_instance_wrap = partial(core_schema.no_info_after_validator_function, self.mapped_origin)</span>
<span class="gi">+</span>
<span class="w"> </span>            serialization = core_schema.wrap_serializer_function_ser_schema(
<span class="gd">-                self.serialize_mapping_via_dict, schema=core_schema.</span>
<span class="gd">-                dict_schema(keys_schema or core_schema.any_schema(), </span>
<span class="gd">-                values_schema or core_schema.any_schema()), info_arg=False)</span>
<span class="gd">-            strict = core_schema.chain_schema([check_instance,</span>
<span class="gd">-                coerce_instance_wrap(constrained_schema)])</span>
<span class="gi">+                self.serialize_mapping_via_dict,</span>
<span class="gi">+                schema=core_schema.dict_schema(</span>
<span class="gi">+                    keys_schema or core_schema.any_schema(), values_schema or core_schema.any_schema()</span>
<span class="gi">+                ),</span>
<span class="gi">+                info_arg=False,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            strict = core_schema.chain_schema([check_instance, coerce_instance_wrap(constrained_schema)])</span>
<span class="gi">+</span>
<span class="w"> </span>            if metadata.get(&#39;strict&#39;, False):
<span class="w"> </span>                schema = strict
<span class="w"> </span>            else:
<span class="w"> </span>                lax = coerce_instance_wrap(constrained_schema)
<span class="gd">-                schema = core_schema.lax_or_strict_schema(lax_schema=lax,</span>
<span class="gd">-                    strict_schema=strict)</span>
<span class="gi">+                schema = core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict)</span>
<span class="w"> </span>                schema[&#39;serialization&#39;] = serialization
<span class="gi">+</span>
<span class="w"> </span>        return schema


<span class="gd">-PREPARE_METHODS: tuple[Callable[[Any, Iterable[Any], ConfigDict], tuple[Any,</span>
<span class="gd">-    list[Any]] | None], ...] = (decimal_prepare_pydantic_annotations,</span>
<span class="gi">+def mapping_like_prepare_pydantic_annotations(</span>
<span class="gi">+    source_type: Any, annotations: Iterable[Any], _config: ConfigDict</span>
<span class="gi">+) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+    origin: Any = get_origin(source_type)</span>
<span class="gi">+</span>
<span class="gi">+    mapped_origin = MAPPING_ORIGIN_MAP.get(origin, None) if origin else MAPPING_ORIGIN_MAP.get(source_type, None)</span>
<span class="gi">+    if mapped_origin is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    args = get_args(source_type)</span>
<span class="gi">+</span>
<span class="gi">+    if not args:</span>
<span class="gi">+        args = typing.cast(Tuple[Any, Any], (Any, Any))</span>
<span class="gi">+    elif mapped_origin is collections.Counter:</span>
<span class="gi">+        # a single generic</span>
<span class="gi">+        if len(args) != 1:</span>
<span class="gi">+            raise ValueError(&#39;Expected Counter to have exactly 1 generic parameter&#39;)</span>
<span class="gi">+        args = (args[0], int)  # keys are always an int</span>
<span class="gi">+    elif len(args) != 2:</span>
<span class="gi">+        raise ValueError(&#39;Expected mapping to have exactly 2 generic parameters&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    keys_source_type, values_source_type = args</span>
<span class="gi">+</span>
<span class="gi">+    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)</span>
<span class="gi">+    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.SEQUENCE_CONSTRAINTS, source_type)</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        source_type,</span>
<span class="gi">+        [</span>
<span class="gi">+            MappingValidator(mapped_origin, keys_source_type, values_source_type, **metadata),</span>
<span class="gi">+            *remaining_annotations,</span>
<span class="gi">+        ],</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_prepare_pydantic_annotations(</span>
<span class="gi">+    source_type: Any, annotations: Iterable[Any], _config: ConfigDict</span>
<span class="gi">+) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+    def make_strict_ip_schema(tp: type[Any]) -&gt; CoreSchema:</span>
<span class="gi">+        return core_schema.json_or_python_schema(</span>
<span class="gi">+            json_schema=core_schema.no_info_after_validator_function(tp, core_schema.str_schema()),</span>
<span class="gi">+            python_schema=core_schema.is_instance_schema(tp),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if source_type is IPv4Address:</span>
<span class="gi">+        return source_type, [</span>
<span class="gi">+            SchemaTransformer(</span>
<span class="gi">+                lambda _1, _2: core_schema.lax_or_strict_schema(</span>
<span class="gi">+                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_address_validator),</span>
<span class="gi">+                    strict_schema=make_strict_ip_schema(IPv4Address),</span>
<span class="gi">+                    serialization=core_schema.to_string_ser_schema(),</span>
<span class="gi">+                ),</span>
<span class="gi">+                lambda _1, _2: {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv4&#39;},</span>
<span class="gi">+            ),</span>
<span class="gi">+            *annotations,</span>
<span class="gi">+        ]</span>
<span class="gi">+    if source_type is IPv4Network:</span>
<span class="gi">+        return source_type, [</span>
<span class="gi">+            SchemaTransformer(</span>
<span class="gi">+                lambda _1, _2: core_schema.lax_or_strict_schema(</span>
<span class="gi">+                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_network_validator),</span>
<span class="gi">+                    strict_schema=make_strict_ip_schema(IPv4Network),</span>
<span class="gi">+                    serialization=core_schema.to_string_ser_schema(),</span>
<span class="gi">+                ),</span>
<span class="gi">+                lambda _1, _2: {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv4network&#39;},</span>
<span class="gi">+            ),</span>
<span class="gi">+            *annotations,</span>
<span class="gi">+        ]</span>
<span class="gi">+    if source_type is IPv4Interface:</span>
<span class="gi">+        return source_type, [</span>
<span class="gi">+            SchemaTransformer(</span>
<span class="gi">+                lambda _1, _2: core_schema.lax_or_strict_schema(</span>
<span class="gi">+                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_interface_validator),</span>
<span class="gi">+                    strict_schema=make_strict_ip_schema(IPv4Interface),</span>
<span class="gi">+                    serialization=core_schema.to_string_ser_schema(),</span>
<span class="gi">+                ),</span>
<span class="gi">+                lambda _1, _2: {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv4interface&#39;},</span>
<span class="gi">+            ),</span>
<span class="gi">+            *annotations,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    if source_type is IPv6Address:</span>
<span class="gi">+        return source_type, [</span>
<span class="gi">+            SchemaTransformer(</span>
<span class="gi">+                lambda _1, _2: core_schema.lax_or_strict_schema(</span>
<span class="gi">+                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_address_validator),</span>
<span class="gi">+                    strict_schema=make_strict_ip_schema(IPv6Address),</span>
<span class="gi">+                    serialization=core_schema.to_string_ser_schema(),</span>
<span class="gi">+                ),</span>
<span class="gi">+                lambda _1, _2: {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv6&#39;},</span>
<span class="gi">+            ),</span>
<span class="gi">+            *annotations,</span>
<span class="gi">+        ]</span>
<span class="gi">+    if source_type is IPv6Network:</span>
<span class="gi">+        return source_type, [</span>
<span class="gi">+            SchemaTransformer(</span>
<span class="gi">+                lambda _1, _2: core_schema.lax_or_strict_schema(</span>
<span class="gi">+                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_network_validator),</span>
<span class="gi">+                    strict_schema=make_strict_ip_schema(IPv6Network),</span>
<span class="gi">+                    serialization=core_schema.to_string_ser_schema(),</span>
<span class="gi">+                ),</span>
<span class="gi">+                lambda _1, _2: {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv6network&#39;},</span>
<span class="gi">+            ),</span>
<span class="gi">+            *annotations,</span>
<span class="gi">+        ]</span>
<span class="gi">+    if source_type is IPv6Interface:</span>
<span class="gi">+        return source_type, [</span>
<span class="gi">+            SchemaTransformer(</span>
<span class="gi">+                lambda _1, _2: core_schema.lax_or_strict_schema(</span>
<span class="gi">+                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_interface_validator),</span>
<span class="gi">+                    strict_schema=make_strict_ip_schema(IPv6Interface),</span>
<span class="gi">+                    serialization=core_schema.to_string_ser_schema(),</span>
<span class="gi">+                ),</span>
<span class="gi">+                lambda _1, _2: {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv6interface&#39;},</span>
<span class="gi">+            ),</span>
<span class="gi">+            *annotations,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def url_prepare_pydantic_annotations(</span>
<span class="gi">+    source_type: Any, annotations: Iterable[Any], _config: ConfigDict</span>
<span class="gi">+) -&gt; tuple[Any, list[Any]] | None:</span>
<span class="gi">+    if source_type is Url:</span>
<span class="gi">+        return source_type, [</span>
<span class="gi">+            SchemaTransformer(</span>
<span class="gi">+                lambda _1, _2: core_schema.url_schema(),</span>
<span class="gi">+                lambda cs, handler: handler(cs),</span>
<span class="gi">+            ),</span>
<span class="gi">+            *annotations,</span>
<span class="gi">+        ]</span>
<span class="gi">+    if source_type is MultiHostUrl:</span>
<span class="gi">+        return source_type, [</span>
<span class="gi">+            SchemaTransformer(</span>
<span class="gi">+                lambda _1, _2: core_schema.multi_host_url_schema(),</span>
<span class="gi">+                lambda cs, handler: handler(cs),</span>
<span class="gi">+            ),</span>
<span class="gi">+            *annotations,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+PREPARE_METHODS: tuple[Callable[[Any, Iterable[Any], ConfigDict], tuple[Any, list[Any]] | None], ...] = (</span>
<span class="gi">+    decimal_prepare_pydantic_annotations,</span>
<span class="w"> </span>    sequence_like_prepare_pydantic_annotations,
<span class="w"> </span>    datetime_prepare_pydantic_annotations,
<span class="w"> </span>    uuid_prepare_pydantic_annotations,
<span class="w"> </span>    path_schema_prepare_pydantic_annotations,
<span class="w"> </span>    mapping_like_prepare_pydantic_annotations,
<span class="gd">-    ip_prepare_pydantic_annotations, url_prepare_pydantic_annotations)</span>
<span class="gi">+    ip_prepare_pydantic_annotations,</span>
<span class="gi">+    url_prepare_pydantic_annotations,</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/pydantic/_internal/_typing_extra.py b/pydantic/_internal/_typing_extra.py</span>
<span class="gh">index 1caf85c1b..71be20b37 100644</span>
<span class="gd">--- a/pydantic/_internal/_typing_extra.py</span>
<span class="gi">+++ b/pydantic/_internal/_typing_extra.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python&#39;s typing module.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="gu">@@ -10,75 +12,165 @@ from collections.abc import Callable</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from types import GetSetDescriptorType
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Final
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, deprecated, get_args, get_origin
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ._dataclasses import StandardDataclass
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    from typing import _TypingBase</span>
<span class="gi">+    from typing import _TypingBase  # type: ignore[attr-defined]</span>
<span class="w"> </span>except ImportError:
<span class="gd">-    from typing import _Final as _TypingBase</span>
<span class="gi">+    from typing import _Final as _TypingBase  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="w"> </span>typing_base = _TypingBase
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 9):
<span class="gi">+    # python &lt; 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)</span>
<span class="w"> </span>    TypingGenericAlias = ()
<span class="w"> </span>else:
<span class="gd">-    from typing import GenericAlias as TypingGenericAlias</span>
<span class="gi">+    from typing import GenericAlias as TypingGenericAlias  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 11):
<span class="w"> </span>    from typing_extensions import NotRequired, Required
<span class="w"> </span>else:
<span class="gd">-    from typing import NotRequired, Required</span>
<span class="gi">+    from typing import NotRequired, Required  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 10):
<span class="gd">-    WithArgsTypes = TypingGenericAlias,</span>
<span class="gi">+</span>
<span class="gi">+    def origin_is_union(tp: type[Any] | None) -&gt; bool:</span>
<span class="gi">+        return tp is typing.Union</span>
<span class="gi">+</span>
<span class="gi">+    WithArgsTypes = (TypingGenericAlias,)</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gd">-    WithArgsTypes = typing._GenericAlias, types.GenericAlias, types.UnionType</span>
<span class="gi">+</span>
<span class="gi">+    def origin_is_union(tp: type[Any] | None) -&gt; bool:</span>
<span class="gi">+        return tp is typing.Union or tp is types.UnionType</span>
<span class="gi">+</span>
<span class="gi">+    WithArgsTypes = typing._GenericAlias, types.GenericAlias, types.UnionType  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 10):
<span class="w"> </span>    NoneType = type(None)
<span class="w"> </span>    EllipsisType = type(Ellipsis)
<span class="w"> </span>else:
<span class="w"> </span>    from types import NoneType as NoneType
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>LITERAL_TYPES: set[Any] = {Literal}
<span class="w"> </span>if hasattr(typing, &#39;Literal&#39;):
<span class="gd">-    LITERAL_TYPES.add(typing.Literal)</span>
<span class="gd">-DEPRECATED_TYPES: tuple[Any, ...] = (deprecated,) if isinstance(deprecated,</span>
<span class="gd">-    type) else ()</span>
<span class="gi">+    LITERAL_TYPES.add(typing.Literal)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+# Check if `deprecated` is a type to prevent errors when using typing_extensions &lt; 4.9.0</span>
<span class="gi">+DEPRECATED_TYPES: tuple[Any, ...] = (deprecated,) if isinstance(deprecated, type) else ()</span>
<span class="w"> </span>if hasattr(warnings, &#39;deprecated&#39;):
<span class="gd">-    DEPRECATED_TYPES = *DEPRECATED_TYPES, warnings.deprecated</span>
<span class="gd">-NONE_TYPES: tuple[Any, ...] = (None, NoneType, *(tp[None] for tp in</span>
<span class="gd">-    LITERAL_TYPES))</span>
<span class="gd">-TypeVarType = Any</span>
<span class="gi">+    DEPRECATED_TYPES = (*DEPRECATED_TYPES, warnings.deprecated)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+NONE_TYPES: tuple[Any, ...] = (None, NoneType, *(tp[None] for tp in LITERAL_TYPES))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+TypeVarType = Any  # since mypy doesn&#39;t allow the use of TypeVar as a type</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_none_type(type_: Any) -&gt; bool:</span>
<span class="gi">+    return type_ in NONE_TYPES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_callable_type(type_: type[Any]) -&gt; bool:</span>
<span class="gi">+    return type_ is Callable or get_origin(type_) is Callable</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_literal_type(type_: type[Any]) -&gt; bool:</span>
<span class="gi">+    return Literal is not None and get_origin(type_) in LITERAL_TYPES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_deprecated_instance(instance: Any) -&gt; TypeGuard[deprecated]:</span>
<span class="gi">+    return isinstance(instance, DEPRECATED_TYPES)</span>
<span class="gi">+</span>

<span class="gi">+def literal_values(type_: type[Any]) -&gt; tuple[Any, ...]:</span>
<span class="gi">+    return get_args(type_)</span>

<span class="gd">-def all_literal_values(type_: type[Any]) -&gt;list[Any]:</span>
<span class="gi">+</span>
<span class="gi">+def all_literal_values(type_: type[Any]) -&gt; list[Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;This method is used to retrieve all Literal values as
<span class="w"> </span>    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)
<span class="w"> </span>    e.g. `Literal[Literal[Literal[1, 2, 3], &quot;foo&quot;], 5, None]`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_literal_type(type_):</span>
<span class="gi">+        return [type_]</span>
<span class="gi">+</span>
<span class="gi">+    values = literal_values(type_)</span>
<span class="gi">+    return list(x for value in values for x in all_literal_values(value))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_annotated(ann_type: Any) -&gt; bool:</span>
<span class="gi">+    return get_origin(ann_type) is Annotated</span>
<span class="gi">+</span>

<span class="gi">+def annotated_type(type_: Any) -&gt; Any | None:</span>
<span class="gi">+    return get_args(type_)[0] if is_annotated(type_) else None</span>

<span class="gd">-def is_namedtuple(type_: type[Any]) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def is_namedtuple(type_: type[Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a given class is a named tuple.
<span class="w"> </span>    It can be either a `typing.NamedTuple` or `collections.namedtuple`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ._utils import lenient_issubclass</span>
<span class="gi">+</span>
<span class="gi">+    return lenient_issubclass(type_, tuple) and hasattr(type_, &#39;_fields&#39;)</span>


<span class="w"> </span>test_new_type = typing.NewType(&#39;test_new_type&#39;, str)


<span class="gd">-def is_new_type(type_: type[Any]) -&gt;bool:</span>
<span class="gi">+def is_new_type(type_: type[Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check whether type_ was created using typing.NewType.

<span class="w"> </span>    Can&#39;t use isinstance because it fails &lt;3.10.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(type_, test_new_type.__class__) and hasattr(type_, &#39;__supertype__&#39;)  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_classvar(v: type[Any] | None) -&gt; bool:</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return False</span>

<span class="gi">+    return v.__class__ == typing.ClassVar.__class__ and getattr(v, &#39;_name&#39;, None) == &#39;ClassVar&#39;</span>

<span class="gd">-def _check_finalvar(v: (type[Any] | None)) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def is_classvar(ann_type: type[Any]) -&gt; bool:</span>
<span class="gi">+    if _check_classvar(ann_type) or _check_classvar(get_origin(ann_type)):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # this is an ugly workaround for class vars that contain forward references and are therefore themselves</span>
<span class="gi">+    # forward references, see #3679</span>
<span class="gi">+    if ann_type.__class__ == typing.ForwardRef and re.match(</span>
<span class="gi">+        r&#39;(\w+\.)?ClassVar\[&#39;,</span>
<span class="gi">+        ann_type.__forward_arg__,  # type: ignore</span>
<span class="gi">+    ):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_finalvar(v: type[Any] | None) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a given type is a `typing.Final` type.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return v.__class__ == Final.__class__ and (sys.version_info &lt; (3, 8) or getattr(v, &#39;_name&#39;, None) == &#39;Final&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_finalvar(ann_type: Any) -&gt; bool:</span>
<span class="gi">+    return _check_finalvar(ann_type) or _check_finalvar(get_origin(ann_type))</span>


<span class="gd">-def parent_frame_namespace(*, parent_depth: int=2) -&gt;(dict[str, Any] | None):</span>
<span class="gi">+def parent_frame_namespace(*, parent_depth: int = 2) -&gt; dict[str, Any] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;We allow use of items in parent namespace to get around the issue with `get_type_hints` only looking in the
<span class="w"> </span>    global module namespace. See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -&gt; Scope
<span class="w"> </span>    and suggestion at the end of the next comment by @gvanrossum.
<span class="gu">@@ -90,49 +182,153 @@ def parent_frame_namespace(*, parent_depth: int=2) -&gt;(dict[str, Any] | None):</span>
<span class="w"> </span>    dict of exactly what&#39;s in scope. Using `f_back` would work sometimes but would be very wrong and confusing in many
<span class="w"> </span>    other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_cls_type_hints_lenient(obj: Any, globalns: (dict[str, Any] | None)=None</span>
<span class="gd">-    ) -&gt;dict[str, Any]:</span>
<span class="gi">+    frame = sys._getframe(parent_depth)</span>
<span class="gi">+    # if f_back is None, it&#39;s the global module namespace and we don&#39;t need to include it here</span>
<span class="gi">+    if frame.f_back is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        return frame.f_locals</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add_module_globals(obj: Any, globalns: dict[str, Any] | None = None) -&gt; dict[str, Any]:</span>
<span class="gi">+    module_name = getattr(obj, &#39;__module__&#39;, None)</span>
<span class="gi">+    if module_name:</span>
<span class="gi">+        try:</span>
<span class="gi">+            module_globalns = sys.modules[module_name].__dict__</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if globalns:</span>
<span class="gi">+                return {**module_globalns, **globalns}</span>
<span class="gi">+            else:</span>
<span class="gi">+                # copy module globals to make sure it can&#39;t be updated later</span>
<span class="gi">+                return module_globalns.copy()</span>
<span class="gi">+</span>
<span class="gi">+    return globalns or {}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_cls_types_namespace(cls: type[Any], parent_namespace: dict[str, Any] | None = None) -&gt; dict[str, Any]:</span>
<span class="gi">+    ns = add_module_globals(cls, parent_namespace)</span>
<span class="gi">+    ns[cls.__name__] = cls</span>
<span class="gi">+    return ns</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_cls_type_hints_lenient(obj: Any, globalns: dict[str, Any] | None = None) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Collect annotations from a class, including those from parent classes.

<span class="w"> </span>    Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hints = {}</span>
<span class="gi">+    for base in reversed(obj.__mro__):</span>
<span class="gi">+        ann = base.__dict__.get(&#39;__annotations__&#39;)</span>
<span class="gi">+        localns = dict(vars(base))</span>
<span class="gi">+        if ann is not None and ann is not GetSetDescriptorType:</span>
<span class="gi">+            for name, value in ann.items():</span>
<span class="gi">+                hints[name] = eval_type_lenient(value, globalns, localns)</span>
<span class="gi">+    return hints</span>


<span class="gd">-def eval_type_lenient(value: Any, globalns: (dict[str, Any] | None)=None,</span>
<span class="gd">-    localns: (dict[str, Any] | None)=None) -&gt;Any:</span>
<span class="gi">+def eval_type_lenient(value: Any, globalns: dict[str, Any] | None = None, localns: dict[str, Any] | None = None) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Behaves like typing._eval_type, except it won&#39;t raise an error if a forward reference can&#39;t be resolved.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def eval_type_backport(value: Any, globalns: (dict[str, Any] | None)=None,</span>
<span class="gd">-    localns: (dict[str, Any] | None)=None, type_params: (tuple[Any] | None)</span>
<span class="gd">-    =None) -&gt;Any:</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        value = NoneType</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        value = _make_forward_ref(value, is_argument=False, is_class=True)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return eval_type_backport(value, globalns, localns)</span>
<span class="gi">+    except NameError:</span>
<span class="gi">+        # the point of this function is to be tolerant to this case</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def eval_type_backport(</span>
<span class="gi">+    value: Any,</span>
<span class="gi">+    globalns: dict[str, Any] | None = None,</span>
<span class="gi">+    localns: dict[str, Any] | None = None,</span>
<span class="gi">+    type_params: tuple[Any] | None = None,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Like `typing._eval_type`, but falls back to the `eval_type_backport` package if it&#39;s
<span class="w"> </span>    installed to let older Python versions use newer typing features.
<span class="w"> </span>    Specifically, this transforms `X | Y` into `typing.Union[X, Y]`
<span class="w"> </span>    and `list[X]` into `typing.List[X]` etc. (for all the types made generic in PEP 585)
<span class="w"> </span>    if the original syntax is not supported in the current Python version.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_function_type_hints(function: Callable[..., Any], *, include_keys:</span>
<span class="gd">-    (set[str] | None)=None, types_namespace: (dict[str, Any] | None)=None</span>
<span class="gd">-    ) -&gt;dict[str, Any]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        if sys.version_info &gt;= (3, 13):</span>
<span class="gi">+            return typing._eval_type(  # type: ignore</span>
<span class="gi">+                value, globalns, localns, type_params=type_params</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return typing._eval_type(  # type: ignore</span>
<span class="gi">+                value, globalns, localns</span>
<span class="gi">+            )</span>
<span class="gi">+    except TypeError as e:</span>
<span class="gi">+        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):</span>
<span class="gi">+            raise</span>
<span class="gi">+        try:</span>
<span class="gi">+            from eval_type_backport import eval_type_backport</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&#39;You have a type annotation {value.__forward_arg__!r} &#39;</span>
<span class="gi">+                f&#39;which makes use of newer typing features than are supported in your version of Python. &#39;</span>
<span class="gi">+                f&#39;To handle this error, you should either remove the use of new syntax &#39;</span>
<span class="gi">+                f&#39;or install the `eval_type_backport` package.&#39;</span>
<span class="gi">+            ) from e</span>
<span class="gi">+</span>
<span class="gi">+        return eval_type_backport(value, globalns, localns, try_default=False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_backport_fixable_error(e: TypeError) -&gt; bool:</span>
<span class="gi">+    msg = str(e)</span>
<span class="gi">+    return msg.startswith(&#39;unsupported operand type(s) for |: &#39;) or &quot;&#39; object is not subscriptable&quot; in msg</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_function_type_hints(</span>
<span class="gi">+    function: Callable[..., Any], *, include_keys: set[str] | None = None, types_namespace: dict[str, Any] | None = None</span>
<span class="gi">+) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Like `typing.get_type_hints`, but doesn&#39;t convert `X` to `Optional[X]` if the default value is `None`, also
<span class="w"> </span>    copes with `partial`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(function, partial):</span>
<span class="gi">+            annotations = function.func.__annotations__</span>
<span class="gi">+        else:</span>
<span class="gi">+            annotations = function.__annotations__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        type_hints = get_type_hints(function)</span>
<span class="gi">+        if isinstance(function, type):</span>
<span class="gi">+            # `type[...]` is a callable, which returns an instance of itself.</span>
<span class="gi">+            # At some point, we might even look into the return type of `__new__`</span>
<span class="gi">+            # if it returns something else.</span>
<span class="gi">+            type_hints.setdefault(&#39;return&#39;, function)</span>
<span class="gi">+        return type_hints</span>
<span class="gi">+</span>
<span class="gi">+    globalns = add_module_globals(function)</span>
<span class="gi">+    type_hints = {}</span>
<span class="gi">+    type_params: tuple[Any] = getattr(function, &#39;__type_params__&#39;, ())  # type: ignore</span>
<span class="gi">+    for name, value in annotations.items():</span>
<span class="gi">+        if include_keys is not None and name not in include_keys:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            value = NoneType</span>
<span class="gi">+        elif isinstance(value, str):</span>
<span class="gi">+            value = _make_forward_ref(value)</span>
<span class="gi">+</span>
<span class="gi">+        type_hints[name] = eval_type_backport(value, globalns, types_namespace, type_params)</span>
<span class="gi">+</span>
<span class="gi">+    return type_hints</span>


<span class="w"> </span>if sys.version_info &lt; (3, 9, 8) or (3, 10) &lt;= sys.version_info &lt; (3, 10, 1):

<span class="gd">-    def _make_forward_ref(arg: Any, is_argument: bool=True, *, is_class:</span>
<span class="gd">-        bool=False) -&gt;typing.ForwardRef:</span>
<span class="gi">+    def _make_forward_ref(</span>
<span class="gi">+        arg: Any,</span>
<span class="gi">+        is_argument: bool = True,</span>
<span class="gi">+        *,</span>
<span class="gi">+        is_class: bool = False,</span>
<span class="gi">+    ) -&gt; typing.ForwardRef:</span>
<span class="w"> </span>        &quot;&quot;&quot;Wrapper for ForwardRef that accounts for the `is_class` argument missing in older versions.
<span class="w"> </span>        The `module` argument is omitted as it breaks &lt;3.9.8, =3.10.0 and isn&#39;t used in the calls below.

<span class="gu">@@ -144,11 +340,15 @@ if sys.version_info &lt; (3, 9, 8) or (3, 10) &lt;= sys.version_info &lt; (3, 10, 1):</span>

<span class="w"> </span>        Implemented as EAFP with memory.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return typing.ForwardRef(arg, is_argument)</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    _make_forward_ref = typing.ForwardRef
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):
<span class="w"> </span>    get_type_hints = typing.get_type_hints
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    For older versions of python, we have a custom implementation of `get_type_hints` which is a close as possible to
<span class="gu">@@ -156,9 +356,12 @@ else:</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @typing.no_type_check
<span class="gd">-    def get_type_hints(obj: Any, globalns: (dict[str, Any] | None)=None,</span>
<span class="gd">-        localns: (dict[str, Any] | None)=None, include_extras: bool=False</span>
<span class="gd">-        ) -&gt;dict[str, Any]:</span>
<span class="gi">+    def get_type_hints(  # noqa: C901</span>
<span class="gi">+        obj: Any,</span>
<span class="gi">+        globalns: dict[str, Any] | None = None,</span>
<span class="gi">+        localns: dict[str, Any] | None = None,</span>
<span class="gi">+        include_extras: bool = False,</span>
<span class="gi">+    ) -&gt; dict[str, Any]:  # pragma: no cover</span>
<span class="w"> </span>        &quot;&quot;&quot;Taken verbatim from python 3.10.8 unchanged, except:
<span class="w"> </span>        * type annotations of the function definition above.
<span class="w"> </span>        * prefixing `typing.` where appropriate
<span class="gu">@@ -200,10 +403,106 @@ else:</span>
<span class="w"> </span>        - If two dict arguments are passed, they specify globals and
<span class="w"> </span>          locals, respectively.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if getattr(obj, &#39;__no_type_check__&#39;, None):</span>
<span class="gi">+            return {}</span>
<span class="gi">+        # Classes require a special treatment.</span>
<span class="gi">+        if isinstance(obj, type):</span>
<span class="gi">+            hints = {}</span>
<span class="gi">+            for base in reversed(obj.__mro__):</span>
<span class="gi">+                if globalns is None:</span>
<span class="gi">+                    base_globals = getattr(sys.modules.get(base.__module__, None), &#39;__dict__&#39;, {})</span>
<span class="gi">+                else:</span>
<span class="gi">+                    base_globals = globalns</span>
<span class="gi">+                ann = base.__dict__.get(&#39;__annotations__&#39;, {})</span>
<span class="gi">+                if isinstance(ann, types.GetSetDescriptorType):</span>
<span class="gi">+                    ann = {}</span>
<span class="gi">+                base_locals = dict(vars(base)) if localns is None else localns</span>
<span class="gi">+                if localns is None and globalns is None:</span>
<span class="gi">+                    # This is surprising, but required.  Before Python 3.10,</span>
<span class="gi">+                    # get_type_hints only evaluated the globalns of</span>
<span class="gi">+                    # a class.  To maintain backwards compatibility, we reverse</span>
<span class="gi">+                    # the globalns and localns order so that eval() looks into</span>
<span class="gi">+                    # *base_globals* first rather than *base_locals*.</span>
<span class="gi">+                    # This only affects ForwardRefs.</span>
<span class="gi">+                    base_globals, base_locals = base_locals, base_globals</span>
<span class="gi">+                for name, value in ann.items():</span>
<span class="gi">+                    if value is None:</span>
<span class="gi">+                        value = type(None)</span>
<span class="gi">+                    if isinstance(value, str):</span>
<span class="gi">+                        value = _make_forward_ref(value, is_argument=False, is_class=True)</span>
<span class="gi">+</span>
<span class="gi">+                    value = eval_type_backport(value, base_globals, base_locals)</span>
<span class="gi">+                    hints[name] = value</span>
<span class="gi">+            if not include_extras and hasattr(typing, &#39;_strip_annotations&#39;):</span>
<span class="gi">+                return {</span>
<span class="gi">+                    k: typing._strip_annotations(t)  # type: ignore</span>
<span class="gi">+                    for k, t in hints.items()</span>
<span class="gi">+                }</span>
<span class="gi">+            else:</span>
<span class="gi">+                return hints</span>
<span class="gi">+</span>
<span class="gi">+        if globalns is None:</span>
<span class="gi">+            if isinstance(obj, types.ModuleType):</span>
<span class="gi">+                globalns = obj.__dict__</span>
<span class="gi">+            else:</span>
<span class="gi">+                nsobj = obj</span>
<span class="gi">+                # Find globalns for the unwrapped object.</span>
<span class="gi">+                while hasattr(nsobj, &#39;__wrapped__&#39;):</span>
<span class="gi">+                    nsobj = nsobj.__wrapped__</span>
<span class="gi">+                globalns = getattr(nsobj, &#39;__globals__&#39;, {})</span>
<span class="gi">+            if localns is None:</span>
<span class="gi">+                localns = globalns</span>
<span class="gi">+        elif localns is None:</span>
<span class="gi">+            localns = globalns</span>
<span class="gi">+        hints = getattr(obj, &#39;__annotations__&#39;, None)</span>
<span class="gi">+        if hints is None:</span>
<span class="gi">+            # Return empty annotations for something that _could_ have them.</span>
<span class="gi">+            if isinstance(obj, typing._allowed_types):  # type: ignore</span>
<span class="gi">+                return {}</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(f&#39;{obj!r} is not a module, class, method, &#39; &#39;or function.&#39;)</span>
<span class="gi">+        defaults = typing._get_defaults(obj)  # type: ignore</span>
<span class="gi">+        hints = dict(hints)</span>
<span class="gi">+        for name, value in hints.items():</span>
<span class="gi">+            if value is None:</span>
<span class="gi">+                value = type(None)</span>
<span class="gi">+            if isinstance(value, str):</span>
<span class="gi">+                # class-level forward refs were handled above, this must be either</span>
<span class="gi">+                # a module-level annotation or a function argument annotation</span>
<span class="gi">+</span>
<span class="gi">+                value = _make_forward_ref(</span>
<span class="gi">+                    value,</span>
<span class="gi">+                    is_argument=not isinstance(obj, types.ModuleType),</span>
<span class="gi">+                    is_class=False,</span>
<span class="gi">+                )</span>
<span class="gi">+            value = eval_type_backport(value, globalns, localns)</span>
<span class="gi">+            if name in defaults and defaults[name] is None:</span>
<span class="gi">+                value = typing.Optional[value]</span>
<span class="gi">+            hints[name] = value</span>
<span class="gi">+        return hints if include_extras else {k: typing._strip_annotations(t) for k, t in hints.items()}  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_dataclass(_cls: type[Any]) -&gt; TypeGuard[type[StandardDataclass]]:</span>
<span class="gi">+    # The dataclasses.is_dataclass function doesn&#39;t seem to provide TypeGuard functionality,</span>
<span class="gi">+    # so I created this convenience function</span>
<span class="gi">+    return dataclasses.is_dataclass(_cls)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def origin_is_type_alias_type(origin: Any) -&gt; TypeGuard[TypeAliasType]:</span>
<span class="gi">+    return isinstance(origin, TypeAliasType)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):

<span class="gi">+    def is_generic_alias(type_: type[Any]) -&gt; bool:</span>
<span class="gi">+        return isinstance(type_, (types.GenericAlias, typing._GenericAlias))  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    def is_generic_alias(type_: type[Any]) -&gt; bool:</span>
<span class="gi">+        return isinstance(type_, typing._GenericAlias)  # type: ignore</span>
<span class="gi">+</span>

<span class="gd">-def is_self_type(tp: Any) -&gt;bool:</span>
<span class="gi">+def is_self_type(tp: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a given class is a Self type (from `typing` or `typing_extensions`)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(tp, typing_base) and getattr(tp, &#39;_name&#39;, None) == &#39;Self&#39;</span>
<span class="gh">diff --git a/pydantic/_internal/_utils.py b/pydantic/_internal/_utils.py</span>
<span class="gh">index 5353dcfc4..de19243ae 100644</span>
<span class="gd">--- a/pydantic/_internal/_utils.py</span>
<span class="gi">+++ b/pydantic/_internal/_utils.py</span>
<span class="gu">@@ -2,7 +2,9 @@</span>

<span class="w"> </span>This should be reduced as much as possible with functions only used in one place, moved to that place.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import keyword
<span class="w"> </span>import typing
<span class="gu">@@ -12,84 +14,168 @@ from copy import deepcopy</span>
<span class="w"> </span>from itertools import zip_longest
<span class="w"> </span>from types import BuiltinFunctionType, CodeType, FunctionType, GeneratorType, LambdaType, ModuleType
<span class="w"> </span>from typing import Any, Mapping, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import TypeAlias, TypeGuard
<span class="gi">+</span>
<span class="w"> </span>from . import _repr, _typing_extra
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-    MappingIntStrAny: TypeAlias = (</span>
<span class="gd">-        &#39;typing.Mapping[int, Any] | typing.Mapping[str, Any]&#39;)</span>
<span class="gd">-    AbstractSetIntStr: TypeAlias = (</span>
<span class="gd">-        &#39;typing.AbstractSet[int] | typing.AbstractSet[str]&#39;)</span>
<span class="gi">+    MappingIntStrAny: TypeAlias = &#39;typing.Mapping[int, Any] | typing.Mapping[str, Any]&#39;</span>
<span class="gi">+    AbstractSetIntStr: TypeAlias = &#39;typing.AbstractSet[int] | typing.AbstractSet[str]&#39;</span>
<span class="w"> </span>    from ..main import BaseModel
<span class="gd">-IMMUTABLE_NON_COLLECTIONS_TYPES: set[type[Any]] = {int, float, complex, str,</span>
<span class="gd">-    bool, bytes, type, _typing_extra.NoneType, FunctionType,</span>
<span class="gd">-    BuiltinFunctionType, LambdaType, weakref.ref, CodeType, ModuleType,</span>
<span class="gd">-    NotImplemented.__class__, Ellipsis.__class__}</span>
<span class="gd">-BUILTIN_COLLECTIONS: set[type[Any]] = {list, set, tuple, frozenset, dict,</span>
<span class="gd">-    OrderedDict, defaultdict, deque}</span>


<span class="gd">-def is_model_class(cls: Any) -&gt;TypeGuard[type[BaseModel]]:</span>
<span class="gi">+# these are types that are returned unchanged by deepcopy</span>
<span class="gi">+IMMUTABLE_NON_COLLECTIONS_TYPES: set[type[Any]] = {</span>
<span class="gi">+    int,</span>
<span class="gi">+    float,</span>
<span class="gi">+    complex,</span>
<span class="gi">+    str,</span>
<span class="gi">+    bool,</span>
<span class="gi">+    bytes,</span>
<span class="gi">+    type,</span>
<span class="gi">+    _typing_extra.NoneType,</span>
<span class="gi">+    FunctionType,</span>
<span class="gi">+    BuiltinFunctionType,</span>
<span class="gi">+    LambdaType,</span>
<span class="gi">+    weakref.ref,</span>
<span class="gi">+    CodeType,</span>
<span class="gi">+    # note: including ModuleType will differ from behaviour of deepcopy by not producing error.</span>
<span class="gi">+    # It might be not a good idea in general, but considering that this function used only internally</span>
<span class="gi">+    # against default values of fields, this will allow to actually have a field with module as default value</span>
<span class="gi">+    ModuleType,</span>
<span class="gi">+    NotImplemented.__class__,</span>
<span class="gi">+    Ellipsis.__class__,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# these are types that if empty, might be copied with simple copy() instead of deepcopy()</span>
<span class="gi">+BUILTIN_COLLECTIONS: set[type[Any]] = {</span>
<span class="gi">+    list,</span>
<span class="gi">+    set,</span>
<span class="gi">+    tuple,</span>
<span class="gi">+    frozenset,</span>
<span class="gi">+    dict,</span>
<span class="gi">+    OrderedDict,</span>
<span class="gi">+    defaultdict,</span>
<span class="gi">+    deque,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sequence_like(v: Any) -&gt; bool:</span>
<span class="gi">+    return isinstance(v, (list, tuple, set, frozenset, GeneratorType, deque))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lenient_isinstance(o: Any, class_or_tuple: type[Any] | tuple[type[Any], ...] | None) -&gt; bool:  # pragma: no cover</span>
<span class="gi">+    try:</span>
<span class="gi">+        return isinstance(o, class_or_tuple)  # type: ignore[arg-type]</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lenient_issubclass(cls: Any, class_or_tuple: Any) -&gt; bool:  # pragma: no cover</span>
<span class="gi">+    try:</span>
<span class="gi">+        return isinstance(cls, type) and issubclass(cls, class_or_tuple)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        if isinstance(cls, _typing_extra.WithArgsTypes):</span>
<span class="gi">+            return False</span>
<span class="gi">+        raise  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_model_class(cls: Any) -&gt; TypeGuard[type[BaseModel]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns true if cls is a _proper_ subclass of BaseModel, and provides proper type-checking,
<span class="w"> </span>    unlike raw calls to lenient_issubclass.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    return lenient_issubclass(cls, BaseModel) and cls is not BaseModel</span>


<span class="gd">-def is_valid_identifier(identifier: str) -&gt;bool:</span>
<span class="gi">+def is_valid_identifier(identifier: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks that a string is a valid identifier and not a Python keyword.
<span class="w"> </span>    :param identifier: The identifier to test.
<span class="w"> </span>    :return: True if the identifier is valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return identifier.isidentifier() and not keyword.iskeyword(identifier)</span>


<span class="w"> </span>KeyType = TypeVar(&#39;KeyType&#39;)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def deep_update(mapping: dict[KeyType, Any], *updating_mappings: dict[KeyType, Any]) -&gt; dict[KeyType, Any]:</span>
<span class="gi">+    updated_mapping = mapping.copy()</span>
<span class="gi">+    for updating_mapping in updating_mappings:</span>
<span class="gi">+        for k, v in updating_mapping.items():</span>
<span class="gi">+            if k in updated_mapping and isinstance(updated_mapping[k], dict) and isinstance(v, dict):</span>
<span class="gi">+                updated_mapping[k] = deep_update(updated_mapping[k], v)</span>
<span class="gi">+            else:</span>
<span class="gi">+                updated_mapping[k] = v</span>
<span class="gi">+    return updated_mapping</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def update_not_none(mapping: dict[Any, Any], **update: Any) -&gt; None:</span>
<span class="gi">+    mapping.update({k: v for k, v in update.items() if v is not None})</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)


<span class="gd">-def unique_list(input_list: (list[T] | tuple[T, ...]), *, name_factory:</span>
<span class="gd">-    typing.Callable[[T], str]=str) -&gt;list[T]:</span>
<span class="gi">+def unique_list(</span>
<span class="gi">+    input_list: list[T] | tuple[T, ...],</span>
<span class="gi">+    *,</span>
<span class="gi">+    name_factory: typing.Callable[[T], str] = str,</span>
<span class="gi">+) -&gt; list[T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a list unique while maintaining order.
<span class="w"> </span>    We update the list if another one with the same name is set
<span class="w"> </span>    (e.g. model validator overridden in subclass).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result: list[T] = []</span>
<span class="gi">+    result_names: list[str] = []</span>
<span class="gi">+    for v in input_list:</span>
<span class="gi">+        v_name = name_factory(v)</span>
<span class="gi">+        if v_name not in result_names:</span>
<span class="gi">+            result_names.append(v_name)</span>
<span class="gi">+            result.append(v)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result[result_names.index(v_name)] = v</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class ValueItems(_repr.Representation):
<span class="w"> </span>    &quot;&quot;&quot;Class for more convenient calculation of excluded or included fields on values.&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_items&#39;, &#39;_type&#39;</span>

<span class="gd">-    def __init__(self, value: Any, items: (AbstractSetIntStr |</span>
<span class="gd">-        MappingIntStrAny)) -&gt;None:</span>
<span class="gi">+    __slots__ = (&#39;_items&#39;, &#39;_type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, value: Any, items: AbstractSetIntStr | MappingIntStrAny) -&gt; None:</span>
<span class="w"> </span>        items = self._coerce_items(items)
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(value, (list, tuple)):
<span class="gd">-            items = self._normalize_indexes(items, len(value))</span>
<span class="gd">-        self._items: MappingIntStrAny = items</span>
<span class="gi">+            items = self._normalize_indexes(items, len(value))  # type: ignore</span>

<span class="gd">-    def is_excluded(self, item: Any) -&gt;bool:</span>
<span class="gi">+        self._items: MappingIntStrAny = items  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def is_excluded(self, item: Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if item is fully excluded.

<span class="w"> </span>        :param item: key or index of a value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.is_true(self._items.get(item))</span>

<span class="gd">-    def is_included(self, item: Any) -&gt;bool:</span>
<span class="gi">+    def is_included(self, item: Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if value is contained in self._items.

<span class="w"> </span>        :param item: key or index of value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return item in self._items</span>

<span class="gd">-    def for_element(self, e: (int | str)) -&gt;(AbstractSetIntStr |</span>
<span class="gd">-        MappingIntStrAny | None):</span>
<span class="gi">+    def for_element(self, e: int | str) -&gt; AbstractSetIntStr | MappingIntStrAny | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;:param e: key or index of element on value
<span class="w"> </span>        :return: raw values for element if self._items is dict and contain needed element
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        item = self._items.get(e)  # type: ignore</span>
<span class="gi">+        return item if not self.is_true(item) else None</span>

<span class="gd">-    def _normalize_indexes(self, items: MappingIntStrAny, v_length: int</span>
<span class="gd">-        ) -&gt;dict[int | str, Any]:</span>
<span class="gi">+    def _normalize_indexes(self, items: MappingIntStrAny, v_length: int) -&gt; dict[int | str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;:param items: dict or set of indexes which will be normalized
<span class="w"> </span>        :param v_length: length of sequence indexes of which will be

<span class="gu">@@ -98,10 +184,36 @@ class ValueItems(_repr.Representation):</span>
<span class="w"> </span>        &gt;&gt;&gt; self._normalize_indexes({&#39;__all__&#39;: True}, 4)
<span class="w"> </span>        {0: True, 1: True, 2: True, 3: True}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        normalized_items: dict[int | str, Any] = {}</span>
<span class="gi">+        all_items = None</span>
<span class="gi">+        for i, v in items.items():</span>
<span class="gi">+            if not (isinstance(v, typing.Mapping) or isinstance(v, typing.AbstractSet) or self.is_true(v)):</span>
<span class="gi">+                raise TypeError(f&#39;Unexpected type of exclude value for index &quot;{i}&quot; {v.__class__}&#39;)</span>
<span class="gi">+            if i == &#39;__all__&#39;:</span>
<span class="gi">+                all_items = self._coerce_value(v)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(i, int):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &#39;Excluding fields from a sequence of sub-models or dicts must be performed index-wise: &#39;</span>
<span class="gi">+                    &#39;expected integer keys or keyword &quot;__all__&quot;&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            normalized_i = v_length + i if i &lt; 0 else i</span>
<span class="gi">+            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))</span>
<span class="gi">+</span>
<span class="gi">+        if not all_items:</span>
<span class="gi">+            return normalized_items</span>
<span class="gi">+        if self.is_true(all_items):</span>
<span class="gi">+            for i in range(v_length):</span>
<span class="gi">+                normalized_items.setdefault(i, ...)</span>
<span class="gi">+            return normalized_items</span>
<span class="gi">+        for i in range(v_length):</span>
<span class="gi">+            normalized_item = normalized_items.setdefault(i, {})</span>
<span class="gi">+            if not self.is_true(normalized_item):</span>
<span class="gi">+                normalized_items[i] = self.merge(all_items, normalized_item)</span>
<span class="gi">+        return normalized_items</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def merge(cls, base: Any, override: Any, intersect: bool=False) -&gt;Any:</span>
<span class="gi">+    def merge(cls, base: Any, override: Any, intersect: bool = False) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Merge a `base` item with an `override` item.

<span class="w"> </span>        Both `base` and `override` are converted to dictionaries if possible.
<span class="gu">@@ -115,45 +227,101 @@ class ValueItems(_repr.Representation):</span>
<span class="w"> </span>        set to `False` (default) and on the intersection of keys if
<span class="w"> </span>        `intersect` is set to `True`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        override = cls._coerce_value(override)</span>
<span class="gi">+        base = cls._coerce_value(base)</span>
<span class="gi">+        if override is None:</span>
<span class="gi">+            return base</span>
<span class="gi">+        if cls.is_true(base) or base is None:</span>
<span class="gi">+            return override</span>
<span class="gi">+        if cls.is_true(override):</span>
<span class="gi">+            return base if intersect else override</span>
<span class="gi">+</span>
<span class="gi">+        # intersection or union of keys while preserving ordering:</span>
<span class="gi">+        if intersect:</span>
<span class="gi">+            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]</span>
<span class="gi">+        else:</span>
<span class="gi">+            merge_keys = list(base) + [k for k in override if k not in base]</span>
<span class="gi">+</span>
<span class="gi">+        merged: dict[int | str, Any] = {}</span>
<span class="gi">+        for k in merge_keys:</span>
<span class="gi">+            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)</span>
<span class="gi">+            if merged_item is not None:</span>
<span class="gi">+                merged[k] = merged_item</span>
<span class="gi">+</span>
<span class="gi">+        return merged</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _coerce_items(items: AbstractSetIntStr | MappingIntStrAny) -&gt; MappingIntStrAny:</span>
<span class="gi">+        if isinstance(items, typing.Mapping):</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif isinstance(items, typing.AbstractSet):</span>
<span class="gi">+            items = dict.fromkeys(items, ...)  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            class_name = getattr(items, &#39;__class__&#39;, &#39;???&#39;)</span>
<span class="gi">+            raise TypeError(f&#39;Unexpected type of exclude value {class_name}&#39;)</span>
<span class="gi">+        return items  # type: ignore</span>

<span class="gd">-    def __repr_args__(self) -&gt;_repr.ReprArgs:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _coerce_value(cls, value: Any) -&gt; Any:</span>
<span class="gi">+        if value is None or cls.is_true(value):</span>
<span class="gi">+            return value</span>
<span class="gi">+        return cls._coerce_items(value)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def is_true(v: Any) -&gt; bool:</span>
<span class="gi">+        return v is True or v is ...</span>
<span class="gi">+</span>
<span class="gi">+    def __repr_args__(self) -&gt; _repr.ReprArgs:</span>
<span class="w"> </span>        return [(None, self._items)]


<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="gd">-else:</span>

<span class="gi">+    def ClassAttribute(name: str, value: T) -&gt; T: ...</span>
<span class="gi">+</span>
<span class="gi">+else:</span>

<span class="w"> </span>    class ClassAttribute:
<span class="w"> </span>        &quot;&quot;&quot;Hide class attribute from its instances.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        __slots__ = &#39;name&#39;, &#39;value&#39;

<span class="gd">-        def __init__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+        def __init__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>            self.name = name
<span class="w"> </span>            self.value = value

<span class="gd">-        def __get__(self, instance: Any, owner: type[Any]) -&gt;None:</span>
<span class="gi">+        def __get__(self, instance: Any, owner: type[Any]) -&gt; None:</span>
<span class="w"> </span>            if instance is None:
<span class="w"> </span>                return self.value
<span class="gd">-            raise AttributeError(</span>
<span class="gd">-                f&#39;{self.name!r} attribute of {owner.__name__!r} is class-only&#39;)</span>
<span class="gi">+            raise AttributeError(f&#39;{self.name!r} attribute of {owner.__name__!r} is class-only&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>Obj = TypeVar(&#39;Obj&#39;)


<span class="gd">-def smart_deepcopy(obj: Obj) -&gt;Obj:</span>
<span class="gi">+def smart_deepcopy(obj: Obj) -&gt; Obj:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return type as is for immutable built-in types
<span class="w"> </span>    Use obj.copy() for built-in empty collections
<span class="w"> </span>    Use copy.deepcopy() for non-empty collections and unknown objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    obj_type = obj.__class__</span>
<span class="gi">+    if obj_type in IMMUTABLE_NON_COLLECTIONS_TYPES:</span>
<span class="gi">+        return obj  # fastest case: obj is immutable and not collection therefore will not be copied anyway</span>
<span class="gi">+    try:</span>
<span class="gi">+        if not obj and obj_type in BUILTIN_COLLECTIONS:</span>
<span class="gi">+            # faster way for empty collections, no need to copy its members</span>
<span class="gi">+            return obj if obj_type is tuple else obj.copy()  # tuple doesn&#39;t have copy method  # type: ignore</span>
<span class="gi">+    except (TypeError, ValueError, RuntimeError):</span>
<span class="gi">+        # do we really dare to catch ALL errors? Seems a bit risky</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return deepcopy(obj)  # slowest way when we actually might need a deepcopy</span>


<span class="w"> </span>_SENTINEL = object()


<span class="gd">-def all_identical(left: typing.Iterable[Any], right: typing.Iterable[Any]</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def all_identical(left: typing.Iterable[Any], right: typing.Iterable[Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check that the items of `left` are the same objects as those in `right`.

<span class="w"> </span>    &gt;&gt;&gt; a, b = object(), object()
<span class="gu">@@ -162,7 +330,10 @@ def all_identical(left: typing.Iterable[Any], right: typing.Iterable[Any]</span>
<span class="w"> </span>    &gt;&gt;&gt; all_identical([a, b, [a]], [a, b, [a]])  # new list object, while &quot;equal&quot; is not &quot;identical&quot;
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for left_item, right_item in zip_longest(left, right, fillvalue=_SENTINEL):</span>
<span class="gi">+        if left_item is not right_item:</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>@dataclasses.dataclass(frozen=True)
<span class="gu">@@ -171,12 +342,21 @@ class SafeGetItemProxy:</span>

<span class="w"> </span>    This makes is safe to use in `operator.itemgetter` when some keys may be missing
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;wrapped&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    # Define __slots__manually for performances</span>
<span class="gi">+    # @dataclasses.dataclass() only support slots=True in python&gt;=3.10</span>
<span class="gi">+    __slots__ = (&#39;wrapped&#39;,)</span>
<span class="gi">+</span>
<span class="w"> </span>    wrapped: Mapping[str, Any]

<span class="gd">-    def __getitem__(self, key: str, /) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, key: str, /) -&gt; Any:</span>
<span class="w"> </span>        return self.wrapped.get(key, _SENTINEL)
<span class="gi">+</span>
<span class="gi">+    # required to pass the object to operator.itemgetter() instances due to a quirk of typeshed</span>
<span class="gi">+    # https://github.com/python/mypy/issues/13713</span>
<span class="gi">+    # https://github.com/python/typeshed/pull/8785</span>
<span class="gi">+    # Since this is typing-only, hide it in a typing.TYPE_CHECKING block</span>
<span class="w"> </span>    if typing.TYPE_CHECKING:

<span class="gd">-        def __contains__(self, key: str, /) -&gt;bool:</span>
<span class="gi">+        def __contains__(self, key: str, /) -&gt; bool:</span>
<span class="w"> </span>            return self.wrapped.__contains__(key)
<span class="gh">diff --git a/pydantic/_internal/_validate_call.py b/pydantic/_internal/_validate_call.py</span>
<span class="gh">index 0c9c2fbee..3fae2d10e 100644</span>
<span class="gd">--- a/pydantic/_internal/_validate_call.py</span>
<span class="gi">+++ b/pydantic/_internal/_validate_call.py</span>
<span class="gu">@@ -1,8 +1,11 @@</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import inspect
<span class="w"> </span>from functools import partial
<span class="w"> </span>from typing import Any, Awaitable, Callable
<span class="gi">+</span>
<span class="w"> </span>import pydantic_core
<span class="gi">+</span>
<span class="w"> </span>from ..config import ConfigDict
<span class="w"> </span>from ..plugin._schema_validator import create_schema_validator
<span class="w"> </span>from . import _generate_schema, _typing_extra
<span class="gu">@@ -11,11 +14,22 @@ from ._config import ConfigWrapper</span>

<span class="w"> </span>class ValidateCallWrapper:
<span class="w"> </span>    &quot;&quot;&quot;This is a wrapper around a function that validates the arguments passed to it, and optionally the return value.&quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;__pydantic_validator__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;,</span>
<span class="gd">-        &#39;__annotations__&#39;, &#39;__dict__&#39;)</span>

<span class="gd">-    def __init__(self, function: Callable[..., Any], config: (ConfigDict |</span>
<span class="gd">-        None), validate_return: bool, namespace: (dict[str, Any] | None)):</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;__pydantic_validator__&#39;,</span>
<span class="gi">+        &#39;__name__&#39;,</span>
<span class="gi">+        &#39;__qualname__&#39;,</span>
<span class="gi">+        &#39;__annotations__&#39;,</span>
<span class="gi">+        &#39;__dict__&#39;,  # required for __module__</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        function: Callable[..., Any],</span>
<span class="gi">+        config: ConfigDict | None,</span>
<span class="gi">+        validate_return: bool,</span>
<span class="gi">+        namespace: dict[str, Any] | None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if isinstance(function, partial):
<span class="w"> </span>            func = function.func
<span class="w"> </span>            schema_type = func
<span class="gu">@@ -27,41 +41,59 @@ class ValidateCallWrapper:</span>
<span class="w"> </span>            self.__name__ = function.__name__
<span class="w"> </span>            self.__qualname__ = function.__qualname__
<span class="w"> </span>            self.__module__ = function.__module__
<span class="gi">+</span>
<span class="w"> </span>        global_ns = _typing_extra.add_module_globals(function, None)
<span class="gi">+        # TODO: this is a bit of a hack, we should probably have a better way to handle this</span>
<span class="gi">+        # specifically, we shouldn&#39;t be pumping the namespace full of type_params</span>
<span class="gi">+        # when we take namespace and type_params arguments in eval_type_backport</span>
<span class="w"> </span>        type_params = getattr(schema_type, &#39;__type_params__&#39;, ())
<span class="gd">-        namespace = {**{param.__name__: param for param in type_params}, **</span>
<span class="gd">-            global_ns or {}, **namespace or {}}</span>
<span class="gi">+        namespace = {</span>
<span class="gi">+            **{param.__name__: param for param in type_params},</span>
<span class="gi">+            **(global_ns or {}),</span>
<span class="gi">+            **(namespace or {}),</span>
<span class="gi">+        }</span>
<span class="w"> </span>        config_wrapper = ConfigWrapper(config)
<span class="w"> </span>        gen_schema = _generate_schema.GenerateSchema(config_wrapper, namespace)
<span class="w"> </span>        schema = gen_schema.clean_schema(gen_schema.generate_schema(function))
<span class="w"> </span>        core_config = config_wrapper.core_config(self)
<span class="gd">-        self.__pydantic_validator__ = create_schema_validator(schema,</span>
<span class="gd">-            schema_type, self.__module__, self.__qualname__,</span>
<span class="gd">-            &#39;validate_call&#39;, core_config, config_wrapper.plugin_settings)</span>
<span class="gi">+</span>
<span class="gi">+        self.__pydantic_validator__ = create_schema_validator(</span>
<span class="gi">+            schema,</span>
<span class="gi">+            schema_type,</span>
<span class="gi">+            self.__module__,</span>
<span class="gi">+            self.__qualname__,</span>
<span class="gi">+            &#39;validate_call&#39;,</span>
<span class="gi">+            core_config,</span>
<span class="gi">+            config_wrapper.plugin_settings,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        if validate_return:
<span class="w"> </span>            signature = inspect.signature(function)
<span class="gd">-            return_type = (signature.return_annotation if signature.</span>
<span class="gd">-                return_annotation is not signature.empty else Any)</span>
<span class="gd">-            gen_schema = _generate_schema.GenerateSchema(config_wrapper,</span>
<span class="gd">-                namespace)</span>
<span class="gd">-            schema = gen_schema.clean_schema(gen_schema.generate_schema(</span>
<span class="gd">-                return_type))</span>
<span class="gd">-            validator = create_schema_validator(schema, schema_type, self.</span>
<span class="gd">-                __module__, self.__qualname__, &#39;validate_call&#39;, core_config,</span>
<span class="gd">-                config_wrapper.plugin_settings)</span>
<span class="gi">+            return_type = signature.return_annotation if signature.return_annotation is not signature.empty else Any</span>
<span class="gi">+            gen_schema = _generate_schema.GenerateSchema(config_wrapper, namespace)</span>
<span class="gi">+            schema = gen_schema.clean_schema(gen_schema.generate_schema(return_type))</span>
<span class="gi">+            validator = create_schema_validator(</span>
<span class="gi">+                schema,</span>
<span class="gi">+                schema_type,</span>
<span class="gi">+                self.__module__,</span>
<span class="gi">+                self.__qualname__,</span>
<span class="gi">+                &#39;validate_call&#39;,</span>
<span class="gi">+                core_config,</span>
<span class="gi">+                config_wrapper.plugin_settings,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            if inspect.iscoroutinefunction(function):

<span class="gd">-                async def return_val_wrapper(aw: Awaitable[Any]) -&gt;None:</span>
<span class="gi">+                async def return_val_wrapper(aw: Awaitable[Any]) -&gt; None:</span>
<span class="w"> </span>                    return validator.validate_python(await aw)
<span class="gi">+</span>
<span class="w"> </span>                self.__return_pydantic_validator__ = return_val_wrapper
<span class="w"> </span>            else:
<span class="w"> </span>                self.__return_pydantic_validator__ = validator.validate_python
<span class="w"> </span>        else:
<span class="w"> </span>            self.__return_pydantic_validator__ = None

<span class="gd">-    def __call__(self, *args: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gd">-        res = self.__pydantic_validator__.validate_python(pydantic_core.</span>
<span class="gd">-            ArgsKwargs(args, kwargs))</span>
<span class="gi">+    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+        res = self.__pydantic_validator__.validate_python(pydantic_core.ArgsKwargs(args, kwargs))</span>
<span class="w"> </span>        if self.__return_pydantic_validator__:
<span class="w"> </span>            return self.__return_pydantic_validator__(res)
<span class="w"> </span>        return res
<span class="gh">diff --git a/pydantic/_internal/_validators.py b/pydantic/_internal/_validators.py</span>
<span class="gh">index 2f7d67f47..870b536e3 100644</span>
<span class="gd">--- a/pydantic/_internal/_validators.py</span>
<span class="gi">+++ b/pydantic/_internal/_validators.py</span>
<span class="gu">@@ -2,23 +2,71 @@</span>

<span class="w"> </span>Import of this module is deferred since it contains imports of many standard library modules.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>import re
<span class="w"> </span>import typing
<span class="w"> </span>from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
<span class="w"> </span>from typing import Any, Callable
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import PydanticCustomError, core_schema
<span class="w"> </span>from pydantic_core._pydantic_core import PydanticKnownError


<span class="gd">-def sequence_validator(input_value: typing.Sequence[Any], /, validator:</span>
<span class="gd">-    core_schema.ValidatorFunctionWrapHandler) -&gt;typing.Sequence[Any]:</span>
<span class="gi">+def sequence_validator(</span>
<span class="gi">+    input_value: typing.Sequence[Any],</span>
<span class="gi">+    /,</span>
<span class="gi">+    validator: core_schema.ValidatorFunctionWrapHandler,</span>
<span class="gi">+) -&gt; typing.Sequence[Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Validator for `Sequence` types, isinstance(v, Sequence) has already been called.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value_type = type(input_value)</span>
<span class="gi">+</span>
<span class="gi">+    # We don&#39;t accept any plain string as a sequence</span>
<span class="gi">+    # Relevant issue: https://github.com/pydantic/pydantic/issues/5595</span>
<span class="gi">+    if issubclass(value_type, (str, bytes)):</span>
<span class="gi">+        raise PydanticCustomError(</span>
<span class="gi">+            &#39;sequence_str&#39;,</span>
<span class="gi">+            &quot;&#39;{type_name}&#39; instances are not allowed as a Sequence value&quot;,</span>
<span class="gi">+            {&#39;type_name&#39;: value_type.__name__},</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: refactor sequence validation to validate with either a list or a tuple</span>
<span class="gi">+    # schema, depending on the type of the value.</span>
<span class="gi">+    # Additionally, we should be able to remove one of either this validator or the</span>
<span class="gi">+    # SequenceValidator in _std_types_schema.py (preferably this one, while porting over some logic).</span>
<span class="gi">+    # Effectively, a refactor for sequence validation is needed.</span>
<span class="gi">+    if value_type is tuple:</span>
<span class="gi">+        input_value = list(input_value)</span>
<span class="gi">+</span>
<span class="gi">+    v_list = validator(input_value)</span>
<span class="gi">+</span>
<span class="gi">+    # the rest of the logic is just re-creating the original type from `v_list`</span>
<span class="gi">+    if value_type is list:</span>
<span class="gi">+        return v_list</span>
<span class="gi">+    elif issubclass(value_type, range):</span>
<span class="gi">+        # return the list as we probably can&#39;t re-create the range</span>
<span class="gi">+        return v_list</span>
<span class="gi">+    elif value_type is tuple:</span>
<span class="gi">+        return tuple(v_list)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # best guess at how to re-create the original type, more custom construction logic might be required</span>
<span class="gi">+        return value_type(v_list)  # type: ignore[call-arg]</span>


<span class="gd">-def _import_string_logic(dotted_path: str) -&gt;Any:</span>
<span class="gi">+def import_string(value: Any) -&gt; Any:</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _import_string_logic(value)</span>
<span class="gi">+        except ImportError as e:</span>
<span class="gi">+            raise PydanticCustomError(&#39;import_error&#39;, &#39;Invalid python path: {error}&#39;, {&#39;error&#39;: str(e)}) from e</span>
<span class="gi">+    else:</span>
<span class="gi">+        # otherwise we just return the value and let the next validator do the rest of the work</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _import_string_logic(dotted_path: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Inspired by uvicorn — dotted paths should include a colon before the final item if that item is not a module.
<span class="w"> </span>    (This is necessary to distinguish between a submodule and an attribute when there is a conflict.).

<span class="gu">@@ -36,37 +84,225 @@ def _import_string_logic(dotted_path: str) -&gt;Any:</span>
<span class="w"> </span>    * the substring of `dotted_path` before the colon is not a valid module in the environment (e.g., &#39;123:Mapping&#39;)
<span class="w"> </span>    * the substring of `dotted_path` after the colon is not an attribute of the module (e.g., &#39;collections:abc123&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from importlib import import_module</span>
<span class="gi">+</span>
<span class="gi">+    components = dotted_path.strip().split(&#39;:&#39;)</span>
<span class="gi">+    if len(components) &gt; 2:</span>
<span class="gi">+        raise ImportError(f&quot;Import strings should have at most one &#39;:&#39;; received {dotted_path!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    module_path = components[0]</span>
<span class="gi">+    if not module_path:</span>
<span class="gi">+        raise ImportError(f&#39;Import strings should have a nonempty module name; received {dotted_path!r}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = import_module(module_path)</span>
<span class="gi">+    except ModuleNotFoundError as e:</span>
<span class="gi">+        if &#39;.&#39; in module_path:</span>
<span class="gi">+            # Check if it would be valid if the final item was separated from its module with a `:`</span>
<span class="gi">+            maybe_module_path, maybe_attribute = dotted_path.strip().rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+            try:</span>
<span class="gi">+                return _import_string_logic(f&#39;{maybe_module_path}:{maybe_attribute}&#39;)</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            raise ImportError(f&#39;No module named {module_path!r}&#39;) from e</span>
<span class="gi">+        raise e</span>
<span class="gi">+</span>
<span class="gi">+    if len(components) &gt; 1:</span>
<span class="gi">+        attribute = components[1]</span>
<span class="gi">+        try:</span>
<span class="gi">+            return getattr(module, attribute)</span>
<span class="gi">+        except AttributeError as e:</span>
<span class="gi">+            raise ImportError(f&#39;cannot import name {attribute!r} from {module_path!r}&#39;) from e</span>
<span class="gi">+    else:</span>
<span class="gi">+        return module</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pattern_either_validator(input_value: Any, /) -&gt; typing.Pattern[Any]:</span>
<span class="gi">+    if isinstance(input_value, typing.Pattern):</span>
<span class="gi">+        return input_value</span>
<span class="gi">+    elif isinstance(input_value, (str, bytes)):</span>
<span class="gi">+        # todo strict mode</span>
<span class="gi">+        return compile_pattern(input_value)  # type: ignore</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise PydanticCustomError(&#39;pattern_type&#39;, &#39;Input should be a valid pattern&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pattern_str_validator(input_value: Any, /) -&gt; typing.Pattern[str]:</span>
<span class="gi">+    if isinstance(input_value, typing.Pattern):</span>
<span class="gi">+        if isinstance(input_value.pattern, str):</span>
<span class="gi">+            return input_value</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticCustomError(&#39;pattern_str_type&#39;, &#39;Input should be a string pattern&#39;)</span>
<span class="gi">+    elif isinstance(input_value, str):</span>
<span class="gi">+        return compile_pattern(input_value)</span>
<span class="gi">+    elif isinstance(input_value, bytes):</span>
<span class="gi">+        raise PydanticCustomError(&#39;pattern_str_type&#39;, &#39;Input should be a string pattern&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise PydanticCustomError(&#39;pattern_type&#39;, &#39;Input should be a valid pattern&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pattern_bytes_validator(input_value: Any, /) -&gt; typing.Pattern[bytes]:</span>
<span class="gi">+    if isinstance(input_value, typing.Pattern):</span>
<span class="gi">+        if isinstance(input_value.pattern, bytes):</span>
<span class="gi">+            return input_value</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticCustomError(&#39;pattern_bytes_type&#39;, &#39;Input should be a bytes pattern&#39;)</span>
<span class="gi">+    elif isinstance(input_value, bytes):</span>
<span class="gi">+        return compile_pattern(input_value)</span>
<span class="gi">+    elif isinstance(input_value, str):</span>
<span class="gi">+        raise PydanticCustomError(&#39;pattern_bytes_type&#39;, &#39;Input should be a bytes pattern&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise PydanticCustomError(&#39;pattern_type&#39;, &#39;Input should be a valid pattern&#39;)</span>


<span class="w"> </span>PatternType = typing.TypeVar(&#39;PatternType&#39;, str, bytes)


<span class="gd">-def ip_v4_network_validator(input_value: Any, /) -&gt;IPv4Network:</span>
<span class="gi">+def compile_pattern(pattern: PatternType) -&gt; typing.Pattern[PatternType]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return re.compile(pattern)</span>
<span class="gi">+    except re.error:</span>
<span class="gi">+        raise PydanticCustomError(&#39;pattern_regex&#39;, &#39;Input should be a valid regular expression&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_v4_address_validator(input_value: Any, /) -&gt; IPv4Address:</span>
<span class="gi">+    if isinstance(input_value, IPv4Address):</span>
<span class="gi">+        return input_value</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv4Address(input_value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(&#39;ip_v4_address&#39;, &#39;Input is not a valid IPv4 address&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_v6_address_validator(input_value: Any, /) -&gt; IPv6Address:</span>
<span class="gi">+    if isinstance(input_value, IPv6Address):</span>
<span class="gi">+        return input_value</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv6Address(input_value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(&#39;ip_v6_address&#39;, &#39;Input is not a valid IPv6 address&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_v4_network_validator(input_value: Any, /) -&gt; IPv4Network:</span>
<span class="w"> </span>    &quot;&quot;&quot;Assume IPv4Network initialised with a default `strict` argument.

<span class="w"> </span>    See more:
<span class="w"> </span>    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(input_value, IPv4Network):</span>
<span class="gi">+        return input_value</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv4Network(input_value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(&#39;ip_v4_network&#39;, &#39;Input is not a valid IPv4 network&#39;)</span>


<span class="gd">-def ip_v6_network_validator(input_value: Any, /) -&gt;IPv6Network:</span>
<span class="gi">+def ip_v6_network_validator(input_value: Any, /) -&gt; IPv6Network:</span>
<span class="w"> </span>    &quot;&quot;&quot;Assume IPv6Network initialised with a default `strict` argument.

<span class="w"> </span>    See more:
<span class="w"> </span>    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(input_value, IPv6Network):</span>
<span class="gi">+        return input_value</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv6Network(input_value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(&#39;ip_v6_network&#39;, &#39;Input is not a valid IPv6 network&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_v4_interface_validator(input_value: Any, /) -&gt; IPv4Interface:</span>
<span class="gi">+    if isinstance(input_value, IPv4Interface):</span>
<span class="gi">+        return input_value</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv4Interface(input_value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(&#39;ip_v4_interface&#39;, &#39;Input is not a valid IPv4 interface&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_v6_interface_validator(input_value: Any, /) -&gt; IPv6Interface:</span>
<span class="gi">+    if isinstance(input_value, IPv6Interface):</span>
<span class="gi">+        return input_value</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv6Interface(input_value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(&#39;ip_v6_interface&#39;, &#39;Input is not a valid IPv6 interface&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def greater_than_validator(x: Any, gt: Any) -&gt; Any:</span>
<span class="gi">+    if not (x &gt; gt):</span>
<span class="gi">+        raise PydanticKnownError(&#39;greater_than&#39;, {&#39;gt&#39;: gt})</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def greater_than_or_equal_validator(x: Any, ge: Any) -&gt; Any:</span>
<span class="gi">+    if not (x &gt;= ge):</span>
<span class="gi">+        raise PydanticKnownError(&#39;greater_than_equal&#39;, {&#39;ge&#39;: ge})</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def less_than_validator(x: Any, lt: Any) -&gt; Any:</span>
<span class="gi">+    if not (x &lt; lt):</span>
<span class="gi">+        raise PydanticKnownError(&#39;less_than&#39;, {&#39;lt&#39;: lt})</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def less_than_or_equal_validator(x: Any, le: Any) -&gt; Any:</span>
<span class="gi">+    if not (x &lt;= le):</span>
<span class="gi">+        raise PydanticKnownError(&#39;less_than_equal&#39;, {&#39;le&#39;: le})</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def multiple_of_validator(x: Any, multiple_of: Any) -&gt; Any:</span>
<span class="gi">+    if not (x % multiple_of == 0):</span>
<span class="gi">+        raise PydanticKnownError(&#39;multiple_of&#39;, {&#39;multiple_of&#39;: multiple_of})</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def min_length_validator(x: Any, min_length: Any) -&gt; Any:</span>
<span class="gi">+    if not (len(x) &gt;= min_length):</span>
<span class="gi">+        raise PydanticKnownError(</span>
<span class="gi">+            &#39;too_short&#39;,</span>
<span class="gi">+            {&#39;field_type&#39;: &#39;Value&#39;, &#39;min_length&#39;: min_length, &#39;actual_length&#39;: len(x)},</span>
<span class="gi">+        )</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def max_length_validator(x: Any, max_length: Any) -&gt; Any:</span>
<span class="gi">+    if len(x) &gt; max_length:</span>
<span class="gi">+        raise PydanticKnownError(</span>
<span class="gi">+            &#39;too_long&#39;,</span>
<span class="gi">+            {&#39;field_type&#39;: &#39;Value&#39;, &#39;max_length&#39;: max_length, &#39;actual_length&#39;: len(x)},</span>
<span class="gi">+        )</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def forbid_inf_nan_check(x: Any) -&gt; Any:</span>
<span class="gi">+    if not math.isfinite(x):</span>
<span class="gi">+        raise PydanticKnownError(&#39;finite_number&#39;)</span>
<span class="gi">+    return x</span>


<span class="gd">-_CONSTRAINT_TO_VALIDATOR_MAP: dict[str, Callable] = {&#39;gt&#39;:</span>
<span class="gd">-    greater_than_validator, &#39;ge&#39;: greater_than_or_equal_validator, &#39;lt&#39;:</span>
<span class="gd">-    less_than_validator, &#39;le&#39;: less_than_or_equal_validator, &#39;multiple_of&#39;:</span>
<span class="gd">-    multiple_of_validator, &#39;min_length&#39;: min_length_validator, &#39;max_length&#39;:</span>
<span class="gd">-    max_length_validator}</span>
<span class="gi">+_CONSTRAINT_TO_VALIDATOR_MAP: dict[str, Callable] = {</span>
<span class="gi">+    &#39;gt&#39;: greater_than_validator,</span>
<span class="gi">+    &#39;ge&#39;: greater_than_or_equal_validator,</span>
<span class="gi">+    &#39;lt&#39;: less_than_validator,</span>
<span class="gi">+    &#39;le&#39;: less_than_or_equal_validator,</span>
<span class="gi">+    &#39;multiple_of&#39;: multiple_of_validator,</span>
<span class="gi">+    &#39;min_length&#39;: min_length_validator,</span>
<span class="gi">+    &#39;max_length&#39;: max_length_validator,</span>
<span class="gi">+}</span>


<span class="gd">-def get_constraint_validator(constraint: str) -&gt;Callable:</span>
<span class="gi">+def get_constraint_validator(constraint: str) -&gt; Callable:</span>
<span class="w"> </span>    &quot;&quot;&quot;Fetch the validator function for the given constraint.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _CONSTRAINT_TO_VALIDATOR_MAP[constraint]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        raise TypeError(f&#39;Unknown constraint {constraint}&#39;)</span>
<span class="gh">diff --git a/pydantic/_migration.py b/pydantic/_migration.py</span>
<span class="gh">index ef115aae8..c8478a624 100644</span>
<span class="gd">--- a/pydantic/_migration.py</span>
<span class="gi">+++ b/pydantic/_migration.py</span>
<span class="gu">@@ -1,48 +1,71 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import Any, Callable, Dict
<span class="gi">+</span>
<span class="w"> </span>from .version import version_short
<span class="gd">-MOVED_IN_V2 = {&#39;pydantic.utils:version_info&#39;:</span>
<span class="gd">-    &#39;pydantic.version:version_info&#39;,</span>
<span class="gi">+</span>
<span class="gi">+MOVED_IN_V2 = {</span>
<span class="gi">+    &#39;pydantic.utils:version_info&#39;: &#39;pydantic.version:version_info&#39;,</span>
<span class="w"> </span>    &#39;pydantic.error_wrappers:ValidationError&#39;: &#39;pydantic:ValidationError&#39;,
<span class="w"> </span>    &#39;pydantic.utils:to_camel&#39;: &#39;pydantic.alias_generators:to_pascal&#39;,
<span class="w"> </span>    &#39;pydantic.utils:to_lower_camel&#39;: &#39;pydantic.alias_generators:to_camel&#39;,
<span class="w"> </span>    &#39;pydantic:PyObject&#39;: &#39;pydantic.types:ImportString&#39;,
<span class="w"> </span>    &#39;pydantic.types:PyObject&#39;: &#39;pydantic.types:ImportString&#39;,
<span class="gd">-    &#39;pydantic.generics:GenericModel&#39;: &#39;pydantic.BaseModel&#39;}</span>
<span class="gd">-DEPRECATED_MOVED_IN_V2 = {&#39;pydantic.tools:schema_of&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.tools:schema_of&#39;, &#39;pydantic.tools:parse_obj_as&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.tools:parse_obj_as&#39;,</span>
<span class="gd">-    &#39;pydantic.tools:schema_json_of&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.tools:schema_json_of&#39;,</span>
<span class="gd">-    &#39;pydantic.json:pydantic_encoder&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.json:pydantic_encoder&#39;,</span>
<span class="gd">-    &#39;pydantic:validate_arguments&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.decorator:validate_arguments&#39;,</span>
<span class="gd">-    &#39;pydantic.json:custom_pydantic_encoder&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.json:custom_pydantic_encoder&#39;,</span>
<span class="gd">-    &#39;pydantic.json:timedelta_isoformat&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.json:timedelta_isoformat&#39;,</span>
<span class="gd">-    &#39;pydantic.decorator:validate_arguments&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.decorator:validate_arguments&#39;,</span>
<span class="gd">-    &#39;pydantic.class_validators:validator&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.class_validators:validator&#39;,</span>
<span class="gd">-    &#39;pydantic.class_validators:root_validator&#39;:</span>
<span class="gd">-    &#39;pydantic.deprecated.class_validators:root_validator&#39;,</span>
<span class="gi">+    &#39;pydantic.generics:GenericModel&#39;: &#39;pydantic.BaseModel&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+DEPRECATED_MOVED_IN_V2 = {</span>
<span class="gi">+    &#39;pydantic.tools:schema_of&#39;: &#39;pydantic.deprecated.tools:schema_of&#39;,</span>
<span class="gi">+    &#39;pydantic.tools:parse_obj_as&#39;: &#39;pydantic.deprecated.tools:parse_obj_as&#39;,</span>
<span class="gi">+    &#39;pydantic.tools:schema_json_of&#39;: &#39;pydantic.deprecated.tools:schema_json_of&#39;,</span>
<span class="gi">+    &#39;pydantic.json:pydantic_encoder&#39;: &#39;pydantic.deprecated.json:pydantic_encoder&#39;,</span>
<span class="gi">+    &#39;pydantic:validate_arguments&#39;: &#39;pydantic.deprecated.decorator:validate_arguments&#39;,</span>
<span class="gi">+    &#39;pydantic.json:custom_pydantic_encoder&#39;: &#39;pydantic.deprecated.json:custom_pydantic_encoder&#39;,</span>
<span class="gi">+    &#39;pydantic.json:timedelta_isoformat&#39;: &#39;pydantic.deprecated.json:timedelta_isoformat&#39;,</span>
<span class="gi">+    &#39;pydantic.decorator:validate_arguments&#39;: &#39;pydantic.deprecated.decorator:validate_arguments&#39;,</span>
<span class="gi">+    &#39;pydantic.class_validators:validator&#39;: &#39;pydantic.deprecated.class_validators:validator&#39;,</span>
<span class="gi">+    &#39;pydantic.class_validators:root_validator&#39;: &#39;pydantic.deprecated.class_validators:root_validator&#39;,</span>
<span class="w"> </span>    &#39;pydantic.config:BaseConfig&#39;: &#39;pydantic.deprecated.config:BaseConfig&#39;,
<span class="gd">-    &#39;pydantic.config:Extra&#39;: &#39;pydantic.deprecated.config:Extra&#39;}</span>
<span class="gd">-REDIRECT_TO_V1 = {f&#39;pydantic.utils:{obj}&#39;: f&#39;pydantic.v1.utils:{obj}&#39; for</span>
<span class="gd">-    obj in (&#39;deep_update&#39;, &#39;GetterDict&#39;, &#39;lenient_issubclass&#39;,</span>
<span class="gd">-    &#39;lenient_isinstance&#39;, &#39;is_valid_field&#39;, &#39;update_not_none&#39;,</span>
<span class="gd">-    &#39;import_string&#39;, &#39;Representation&#39;, &#39;ROOT_KEY&#39;, &#39;smart_deepcopy&#39;,</span>
<span class="gd">-    &#39;sequence_like&#39;)}</span>
<span class="gd">-REMOVED_IN_V2 = {&#39;pydantic:ConstrainedBytes&#39;, &#39;pydantic:ConstrainedDate&#39;,</span>
<span class="gd">-    &#39;pydantic:ConstrainedDecimal&#39;, &#39;pydantic:ConstrainedFloat&#39;,</span>
<span class="gd">-    &#39;pydantic:ConstrainedFrozenSet&#39;, &#39;pydantic:ConstrainedInt&#39;,</span>
<span class="gd">-    &#39;pydantic:ConstrainedList&#39;, &#39;pydantic:ConstrainedSet&#39;,</span>
<span class="gd">-    &#39;pydantic:ConstrainedStr&#39;, &#39;pydantic:JsonWrapper&#39;, &#39;pydantic:NoneBytes&#39;,</span>
<span class="gd">-    &#39;pydantic:NoneStr&#39;, &#39;pydantic:NoneStrBytes&#39;, &#39;pydantic:Protocol&#39;,</span>
<span class="gd">-    &#39;pydantic:Required&#39;, &#39;pydantic:StrBytes&#39;, &#39;pydantic:compiled&#39;,</span>
<span class="gd">-    &#39;pydantic.config:get_config&#39;, &#39;pydantic.config:inherit_config&#39;,</span>
<span class="gi">+    &#39;pydantic.config:Extra&#39;: &#39;pydantic.deprecated.config:Extra&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+REDIRECT_TO_V1 = {</span>
<span class="gi">+    f&#39;pydantic.utils:{obj}&#39;: f&#39;pydantic.v1.utils:{obj}&#39;</span>
<span class="gi">+    for obj in (</span>
<span class="gi">+        &#39;deep_update&#39;,</span>
<span class="gi">+        &#39;GetterDict&#39;,</span>
<span class="gi">+        &#39;lenient_issubclass&#39;,</span>
<span class="gi">+        &#39;lenient_isinstance&#39;,</span>
<span class="gi">+        &#39;is_valid_field&#39;,</span>
<span class="gi">+        &#39;update_not_none&#39;,</span>
<span class="gi">+        &#39;import_string&#39;,</span>
<span class="gi">+        &#39;Representation&#39;,</span>
<span class="gi">+        &#39;ROOT_KEY&#39;,</span>
<span class="gi">+        &#39;smart_deepcopy&#39;,</span>
<span class="gi">+        &#39;sequence_like&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+REMOVED_IN_V2 = {</span>
<span class="gi">+    &#39;pydantic:ConstrainedBytes&#39;,</span>
<span class="gi">+    &#39;pydantic:ConstrainedDate&#39;,</span>
<span class="gi">+    &#39;pydantic:ConstrainedDecimal&#39;,</span>
<span class="gi">+    &#39;pydantic:ConstrainedFloat&#39;,</span>
<span class="gi">+    &#39;pydantic:ConstrainedFrozenSet&#39;,</span>
<span class="gi">+    &#39;pydantic:ConstrainedInt&#39;,</span>
<span class="gi">+    &#39;pydantic:ConstrainedList&#39;,</span>
<span class="gi">+    &#39;pydantic:ConstrainedSet&#39;,</span>
<span class="gi">+    &#39;pydantic:ConstrainedStr&#39;,</span>
<span class="gi">+    &#39;pydantic:JsonWrapper&#39;,</span>
<span class="gi">+    &#39;pydantic:NoneBytes&#39;,</span>
<span class="gi">+    &#39;pydantic:NoneStr&#39;,</span>
<span class="gi">+    &#39;pydantic:NoneStrBytes&#39;,</span>
<span class="gi">+    &#39;pydantic:Protocol&#39;,</span>
<span class="gi">+    &#39;pydantic:Required&#39;,</span>
<span class="gi">+    &#39;pydantic:StrBytes&#39;,</span>
<span class="gi">+    &#39;pydantic:compiled&#39;,</span>
<span class="gi">+    &#39;pydantic.config:get_config&#39;,</span>
<span class="gi">+    &#39;pydantic.config:inherit_config&#39;,</span>
<span class="w"> </span>    &#39;pydantic.config:prepare_config&#39;,
<span class="w"> </span>    &#39;pydantic:create_model_from_namedtuple&#39;,
<span class="w"> </span>    &#39;pydantic:create_model_from_typeddict&#39;,
<span class="gu">@@ -56,107 +79,174 @@ REMOVED_IN_V2 = {&#39;pydantic:ConstrainedBytes&#39;, &#39;pydantic:ConstrainedDate&#39;,</span>
<span class="w"> </span>    &#39;pydantic.error_wrappers:ErrorWrapper&#39;,
<span class="w"> </span>    &#39;pydantic.errors:AnyStrMaxLengthError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:AnyStrMinLengthError&#39;,
<span class="gd">-    &#39;pydantic.errors:ArbitraryTypeError&#39;, &#39;pydantic.errors:BoolError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:BytesError&#39;, &#39;pydantic.errors:CallableError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:ClassError&#39;, &#39;pydantic.errors:ColorError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:ConfigError&#39;, &#39;pydantic.errors:DataclassTypeError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:DateError&#39;, &#39;pydantic.errors:DateNotInTheFutureError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:ArbitraryTypeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:BoolError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:BytesError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:CallableError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:ClassError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:ColorError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:ConfigError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:DataclassTypeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:DateError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:DateNotInTheFutureError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:DateNotInThePastError&#39;,
<span class="gd">-    &#39;pydantic.errors:DateTimeError&#39;, &#39;pydantic.errors:DecimalError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:DateTimeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:DecimalError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:DecimalIsNotFiniteError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:DecimalMaxDigitsError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:DecimalMaxPlacesError&#39;,
<span class="gd">-    &#39;pydantic.errors:DecimalWholeDigitsError&#39;, &#39;pydantic.errors:DictError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:DurationError&#39;, &#39;pydantic.errors:EmailError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:EnumError&#39;, &#39;pydantic.errors:EnumMemberError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:ExtraError&#39;, &#39;pydantic.errors:FloatError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:DecimalWholeDigitsError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:DictError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:DurationError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:EmailError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:EnumError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:EnumMemberError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:ExtraError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:FloatError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:FrozenSetError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:FrozenSetMaxLengthError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:FrozenSetMinLengthError&#39;,
<span class="gd">-    &#39;pydantic.errors:HashableError&#39;, &#39;pydantic.errors:IPv4AddressError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:HashableError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:IPv4AddressError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:IPv4InterfaceError&#39;,
<span class="gd">-    &#39;pydantic.errors:IPv4NetworkError&#39;, &#39;pydantic.errors:IPv6AddressError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:IPv4NetworkError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:IPv6AddressError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:IPv6InterfaceError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:IPv6NetworkError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:IPvAnyAddressError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:IPvAnyInterfaceError&#39;,
<span class="gd">-    &#39;pydantic.errors:IPvAnyNetworkError&#39;, &#39;pydantic.errors:IntEnumError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:IntegerError&#39;, &#39;pydantic.errors:InvalidByteSize&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:IPvAnyNetworkError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:IntEnumError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:IntegerError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:InvalidByteSize&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:InvalidByteSizeUnit&#39;,
<span class="w"> </span>    &#39;pydantic.errors:InvalidDiscriminator&#39;,
<span class="gd">-    &#39;pydantic.errors:InvalidLengthForBrand&#39;, &#39;pydantic.errors:JsonError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:JsonTypeError&#39;, &#39;pydantic.errors:ListError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:InvalidLengthForBrand&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:JsonError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:JsonTypeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:ListError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:ListMaxLengthError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:ListMinLengthError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:ListUniqueItemsError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:LuhnValidationError&#39;,
<span class="gd">-    &#39;pydantic.errors:MissingDiscriminator&#39;, &#39;pydantic.errors:MissingError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:MissingDiscriminator&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:MissingError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:NoneIsAllowedError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:NoneIsNotAllowedError&#39;,
<span class="gd">-    &#39;pydantic.errors:NotDigitError&#39;, &#39;pydantic.errors:NotNoneError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:NumberNotGeError&#39;, &#39;pydantic.errors:NumberNotGtError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:NumberNotLeError&#39;, &#39;pydantic.errors:NumberNotLtError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:NumberNotMultipleError&#39;, &#39;pydantic.errors:PathError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:NotDigitError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:NotNoneError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:NumberNotGeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:NumberNotGtError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:NumberNotLeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:NumberNotLtError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:NumberNotMultipleError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:PathError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:PathNotADirectoryError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:PathNotAFileError&#39;,
<span class="gd">-    &#39;pydantic.errors:PathNotExistsError&#39;, &#39;pydantic.errors:PatternError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:PyObjectError&#39;, &#39;pydantic.errors:PydanticTypeError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:PydanticValueError&#39;, &#39;pydantic.errors:SequenceError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:SetError&#39;, &#39;pydantic.errors:SetMaxLengthError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:SetMinLengthError&#39;, &#39;pydantic.errors:StrError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:StrRegexError&#39;, &#39;pydantic.errors:StrictBoolError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:SubclassError&#39;, &#39;pydantic.errors:TimeError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:TupleError&#39;, &#39;pydantic.errors:TupleLengthError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:UUIDError&#39;, &#39;pydantic.errors:UUIDVersionError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:UrlError&#39;, &#39;pydantic.errors:UrlExtraError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:UrlHostError&#39;, &#39;pydantic.errors:UrlHostTldError&#39;,</span>
<span class="gd">-    &#39;pydantic.errors:UrlPortError&#39;, &#39;pydantic.errors:UrlSchemeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:PathNotExistsError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:PatternError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:PyObjectError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:PydanticTypeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:PydanticValueError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:SequenceError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:SetError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:SetMaxLengthError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:SetMinLengthError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:StrError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:StrRegexError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:StrictBoolError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:SubclassError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:TimeError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:TupleError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:TupleLengthError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:UUIDError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:UUIDVersionError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:UrlError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:UrlExtraError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:UrlHostError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:UrlHostTldError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:UrlPortError&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:UrlSchemeError&#39;,</span>
<span class="w"> </span>    &#39;pydantic.errors:UrlSchemePermittedError&#39;,
<span class="w"> </span>    &#39;pydantic.errors:UrlUserInfoError&#39;,
<span class="gd">-    &#39;pydantic.errors:WrongConstantError&#39;, &#39;pydantic.main:validate_model&#39;,</span>
<span class="gd">-    &#39;pydantic.networks:stricturl&#39;, &#39;pydantic:parse_file_as&#39;,</span>
<span class="gd">-    &#39;pydantic:parse_raw_as&#39;, &#39;pydantic:stricturl&#39;,</span>
<span class="gd">-    &#39;pydantic.tools:parse_file_as&#39;, &#39;pydantic.tools:parse_raw_as&#39;,</span>
<span class="gd">-    &#39;pydantic.types:ConstrainedBytes&#39;, &#39;pydantic.types:ConstrainedDate&#39;,</span>
<span class="gd">-    &#39;pydantic.types:ConstrainedDecimal&#39;, &#39;pydantic.types:ConstrainedFloat&#39;,</span>
<span class="gd">-    &#39;pydantic.types:ConstrainedFrozenSet&#39;, &#39;pydantic.types:ConstrainedInt&#39;,</span>
<span class="gd">-    &#39;pydantic.types:ConstrainedList&#39;, &#39;pydantic.types:ConstrainedSet&#39;,</span>
<span class="gd">-    &#39;pydantic.types:ConstrainedStr&#39;, &#39;pydantic.types:JsonWrapper&#39;,</span>
<span class="gd">-    &#39;pydantic.types:NoneBytes&#39;, &#39;pydantic.types:NoneStr&#39;,</span>
<span class="gd">-    &#39;pydantic.types:NoneStrBytes&#39;, &#39;pydantic.types:StrBytes&#39;,</span>
<span class="gi">+    &#39;pydantic.errors:WrongConstantError&#39;,</span>
<span class="gi">+    &#39;pydantic.main:validate_model&#39;,</span>
<span class="gi">+    &#39;pydantic.networks:stricturl&#39;,</span>
<span class="gi">+    &#39;pydantic:parse_file_as&#39;,</span>
<span class="gi">+    &#39;pydantic:parse_raw_as&#39;,</span>
<span class="gi">+    &#39;pydantic:stricturl&#39;,</span>
<span class="gi">+    &#39;pydantic.tools:parse_file_as&#39;,</span>
<span class="gi">+    &#39;pydantic.tools:parse_raw_as&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedBytes&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedDate&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedDecimal&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedFloat&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedFrozenSet&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedInt&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedList&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedSet&#39;,</span>
<span class="gi">+    &#39;pydantic.types:ConstrainedStr&#39;,</span>
<span class="gi">+    &#39;pydantic.types:JsonWrapper&#39;,</span>
<span class="gi">+    &#39;pydantic.types:NoneBytes&#39;,</span>
<span class="gi">+    &#39;pydantic.types:NoneStr&#39;,</span>
<span class="gi">+    &#39;pydantic.types:NoneStrBytes&#39;,</span>
<span class="gi">+    &#39;pydantic.types:StrBytes&#39;,</span>
<span class="w"> </span>    &#39;pydantic.typing:evaluate_forwardref&#39;,
<span class="gd">-    &#39;pydantic.typing:AbstractSetIntStr&#39;, &#39;pydantic.typing:AnyCallable&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:AnyClassMethod&#39;, &#39;pydantic.typing:CallableGenerator&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:DictAny&#39;, &#39;pydantic.typing:DictIntStrAny&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:DictStrAny&#39;, &#39;pydantic.typing:IntStr&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:ListStr&#39;, &#39;pydantic.typing:MappingIntStrAny&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:NoArgAnyCallable&#39;, &#39;pydantic.typing:NoneType&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:ReprArgs&#39;, &#39;pydantic.typing:SetStr&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:StrPath&#39;, &#39;pydantic.typing:TupleGenerator&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:WithArgsTypes&#39;, &#39;pydantic.typing:all_literal_values&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:display_as_type&#39;, &#39;pydantic.typing:get_all_type_hints&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:get_args&#39;, &#39;pydantic.typing:get_origin&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:get_sub_types&#39;, &#39;pydantic.typing:is_callable_type&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:is_classvar&#39;, &#39;pydantic.typing:is_finalvar&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:is_literal_type&#39;, &#39;pydantic.typing:is_namedtuple&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:is_new_type&#39;, &#39;pydantic.typing:is_none_type&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:is_typeddict&#39;, &#39;pydantic.typing:is_typeddict_special&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:is_union&#39;, &#39;pydantic.typing:new_type_supertype&#39;,</span>
<span class="gd">-    &#39;pydantic.typing:resolve_annotations&#39;, &#39;pydantic.typing:typing_base&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:AbstractSetIntStr&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:AnyCallable&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:AnyClassMethod&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:CallableGenerator&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:DictAny&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:DictIntStrAny&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:DictStrAny&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:IntStr&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:ListStr&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:MappingIntStrAny&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:NoArgAnyCallable&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:NoneType&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:ReprArgs&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:SetStr&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:StrPath&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:TupleGenerator&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:WithArgsTypes&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:all_literal_values&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:display_as_type&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:get_all_type_hints&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:get_args&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:get_origin&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:get_sub_types&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_callable_type&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_classvar&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_finalvar&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_literal_type&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_namedtuple&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_new_type&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_none_type&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_typeddict&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_typeddict_special&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:is_union&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:new_type_supertype&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:resolve_annotations&#39;,</span>
<span class="gi">+    &#39;pydantic.typing:typing_base&#39;,</span>
<span class="w"> </span>    &#39;pydantic.typing:update_field_forward_refs&#39;,
<span class="w"> </span>    &#39;pydantic.typing:update_model_forward_refs&#39;,
<span class="gd">-    &#39;pydantic.utils:ClassAttribute&#39;, &#39;pydantic.utils:DUNDER_ATTRIBUTES&#39;,</span>
<span class="gd">-    &#39;pydantic.utils:PyObjectStr&#39;, &#39;pydantic.utils:ValueItems&#39;,</span>
<span class="gi">+    &#39;pydantic.utils:ClassAttribute&#39;,</span>
<span class="gi">+    &#39;pydantic.utils:DUNDER_ATTRIBUTES&#39;,</span>
<span class="gi">+    &#39;pydantic.utils:PyObjectStr&#39;,</span>
<span class="gi">+    &#39;pydantic.utils:ValueItems&#39;,</span>
<span class="w"> </span>    &#39;pydantic.utils:almost_equal_floats&#39;,
<span class="w"> </span>    &#39;pydantic.utils:get_discriminator_alias_and_values&#39;,
<span class="w"> </span>    &#39;pydantic.utils:get_model&#39;,
<span class="w"> </span>    &#39;pydantic.utils:get_unique_discriminator_alias&#39;,
<span class="gd">-    &#39;pydantic.utils:in_ipython&#39;, &#39;pydantic.utils:is_valid_identifier&#39;,</span>
<span class="gd">-    &#39;pydantic.utils:path_type&#39;, &#39;pydantic.utils:validate_field_name&#39;,</span>
<span class="gd">-    &#39;pydantic:validate_model&#39;}</span>
<span class="gi">+    &#39;pydantic.utils:in_ipython&#39;,</span>
<span class="gi">+    &#39;pydantic.utils:is_valid_identifier&#39;,</span>
<span class="gi">+    &#39;pydantic.utils:path_type&#39;,</span>
<span class="gi">+    &#39;pydantic.utils:validate_field_name&#39;,</span>
<span class="gi">+    &#39;pydantic:validate_model&#39;,</span>
<span class="gi">+}</span>


<span class="gd">-def getattr_migration(module: str) -&gt;Callable[[str], Any]:</span>
<span class="gi">+def getattr_migration(module: str) -&gt; Callable[[str], Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Implement PEP 562 for objects that were either moved or removed on the migration
<span class="w"> </span>    to V2.

<span class="gu">@@ -166,4 +256,53 @@ def getattr_migration(module: str) -&gt;Callable[[str], Any]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A callable that will raise an error if the object is not found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This avoids circular import with errors.py.</span>
<span class="gi">+    from .errors import PydanticImportError</span>
<span class="gi">+</span>
<span class="gi">+    def wrapper(name: str) -&gt; object:</span>
<span class="gi">+        &quot;&quot;&quot;Raise an error if the object is not found, or warn if it was moved.</span>
<span class="gi">+</span>
<span class="gi">+        In case it was moved, it still returns the object.</span>
<span class="gi">+</span>
<span class="gi">+        Args:</span>
<span class="gi">+            name: The object name.</span>
<span class="gi">+</span>
<span class="gi">+        Returns:</span>
<span class="gi">+            The object.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if name == &#39;__path__&#39;:</span>
<span class="gi">+            raise AttributeError(f&#39;module {module!r} has no attribute {name!r}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        import warnings</span>
<span class="gi">+</span>
<span class="gi">+        from ._internal._validators import import_string</span>
<span class="gi">+</span>
<span class="gi">+        import_path = f&#39;{module}:{name}&#39;</span>
<span class="gi">+        if import_path in MOVED_IN_V2.keys():</span>
<span class="gi">+            new_location = MOVED_IN_V2[import_path]</span>
<span class="gi">+            warnings.warn(f&#39;`{import_path}` has been moved to `{new_location}`.&#39;)</span>
<span class="gi">+            return import_string(MOVED_IN_V2[import_path])</span>
<span class="gi">+        if import_path in DEPRECATED_MOVED_IN_V2:</span>
<span class="gi">+            # skip the warning here because a deprecation warning will be raised elsewhere</span>
<span class="gi">+            return import_string(DEPRECATED_MOVED_IN_V2[import_path])</span>
<span class="gi">+        if import_path in REDIRECT_TO_V1:</span>
<span class="gi">+            new_location = REDIRECT_TO_V1[import_path]</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&#39;`{import_path}` has been removed. We are importing from `{new_location}` instead.&#39;</span>
<span class="gi">+                &#39;See the migration guide for more details: https://docs.pydantic.dev/latest/migration/&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+            return import_string(REDIRECT_TO_V1[import_path])</span>
<span class="gi">+        if import_path == &#39;pydantic:BaseSettings&#39;:</span>
<span class="gi">+            raise PydanticImportError(</span>
<span class="gi">+                &#39;`BaseSettings` has been moved to the `pydantic-settings` package. &#39;</span>
<span class="gi">+                f&#39;See https://docs.pydantic.dev/{version_short()}/migration/#basesettings-has-moved-to-pydantic-settings &#39;</span>
<span class="gi">+                &#39;for more details.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        if import_path in REMOVED_IN_V2:</span>
<span class="gi">+            raise PydanticImportError(f&#39;`{import_path}` has been removed in V2.&#39;)</span>
<span class="gi">+        globals: Dict[str, Any] = sys.modules[module].__dict__</span>
<span class="gi">+        if name in globals:</span>
<span class="gi">+            return globals[name]</span>
<span class="gi">+        raise AttributeError(f&#39;module {module!r} has no attribute {name!r}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/pydantic/alias_generators.py b/pydantic/alias_generators.py</span>
<span class="gh">index c68d768b2..0b7653f58 100644</span>
<span class="gd">--- a/pydantic/alias_generators.py</span>
<span class="gi">+++ b/pydantic/alias_generators.py</span>
<span class="gu">@@ -1,9 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Alias generators for converting between different capitalization conventions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="gd">-__all__ = &#39;to_pascal&#39;, &#39;to_camel&#39;, &#39;to_snake&#39;</span>

<span class="gi">+__all__ = (&#39;to_pascal&#39;, &#39;to_camel&#39;, &#39;to_snake&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# TODO: in V3, change the argument names to be more descriptive</span>
<span class="gi">+# Generally, don&#39;t only convert from snake_case, or name the functions</span>
<span class="gi">+# more specifically like snake_to_camel.</span>

<span class="gd">-def to_pascal(snake: str) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def to_pascal(snake: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a snake_case string to PascalCase.

<span class="w"> </span>    Args:
<span class="gu">@@ -12,10 +18,11 @@ def to_pascal(snake: str) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The PascalCase string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    camel = snake.title()</span>
<span class="gi">+    return re.sub(&#39;([0-9A-Za-z])_(?=[0-9A-Z])&#39;, lambda m: m.group(1), camel)</span>


<span class="gd">-def to_camel(snake: str) -&gt;str:</span>
<span class="gi">+def to_camel(snake: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a snake_case string to camelCase.

<span class="w"> </span>    Args:
<span class="gu">@@ -24,10 +31,16 @@ def to_camel(snake: str) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The converted camelCase string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If the string is already in camelCase and does not contain a digit followed</span>
<span class="gi">+    # by a lowercase letter, return it as it is</span>
<span class="gi">+    if re.match(&#39;^[a-z]+[A-Za-z0-9]*$&#39;, snake) and not re.search(r&#39;\d[a-z]&#39;, snake):</span>
<span class="gi">+        return snake</span>
<span class="gi">+</span>
<span class="gi">+    camel = to_pascal(snake)</span>
<span class="gi">+    return re.sub(&#39;(^_*[A-Z])&#39;, lambda m: m.group(1).lower(), camel)</span>


<span class="gd">-def to_snake(camel: str) -&gt;str:</span>
<span class="gi">+def to_snake(camel: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a PascalCase, camelCase, or kebab-case string to snake_case.

<span class="w"> </span>    Args:
<span class="gu">@@ -36,4 +49,14 @@ def to_snake(camel: str) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The converted string in snake_case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Handle the sequence of uppercase letters followed by a lowercase letter</span>
<span class="gi">+    snake = re.sub(r&#39;([A-Z]+)([A-Z][a-z])&#39;, lambda m: f&#39;{m.group(1)}_{m.group(2)}&#39;, camel)</span>
<span class="gi">+    # Insert an underscore between a lowercase letter and an uppercase letter</span>
<span class="gi">+    snake = re.sub(r&#39;([a-z])([A-Z])&#39;, lambda m: f&#39;{m.group(1)}_{m.group(2)}&#39;, snake)</span>
<span class="gi">+    # Insert an underscore between a digit and an uppercase letter</span>
<span class="gi">+    snake = re.sub(r&#39;([0-9])([A-Z])&#39;, lambda m: f&#39;{m.group(1)}_{m.group(2)}&#39;, snake)</span>
<span class="gi">+    # Insert an underscore between a lowercase letter and a digit</span>
<span class="gi">+    snake = re.sub(r&#39;([a-z])([0-9])&#39;, lambda m: f&#39;{m.group(1)}_{m.group(2)}&#39;, snake)</span>
<span class="gi">+    # Replace hyphens with underscores to handle kebab-case</span>
<span class="gi">+    snake = snake.replace(&#39;-&#39;, &#39;_&#39;)</span>
<span class="gi">+    return snake.lower()</span>
<span class="gh">diff --git a/pydantic/aliases.py b/pydantic/aliases.py</span>
<span class="gh">index a6947b0cd..441fee162 100644</span>
<span class="gd">--- a/pydantic/aliases.py</span>
<span class="gi">+++ b/pydantic/aliases.py</span>
<span class="gu">@@ -1,10 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Support for alias configurations.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>from typing import Any, Callable, Literal
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import PydanticUndefined
<span class="gi">+</span>
<span class="w"> </span>from ._internal import _internal_dataclass
<span class="gd">-__all__ = &#39;AliasGenerator&#39;, &#39;AliasPath&#39;, &#39;AliasChoices&#39;</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;AliasGenerator&#39;, &#39;AliasPath&#39;, &#39;AliasChoices&#39;)</span>


<span class="w"> </span>@dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -16,26 +21,36 @@ class AliasPath:</span>
<span class="w"> </span>    Attributes:
<span class="w"> </span>        path: A list of string or integer aliases.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    path: list[int | str]

<span class="gd">-    def __init__(self, first_arg: str, *args: (str | int)) -&gt;None:</span>
<span class="gi">+    def __init__(self, first_arg: str, *args: str | int) -&gt; None:</span>
<span class="w"> </span>        self.path = [first_arg] + list(args)

<span class="gd">-    def convert_to_aliases(self) -&gt;list[str | int]:</span>
<span class="gi">+    def convert_to_aliases(self) -&gt; list[str | int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts arguments to a list of string or integer aliases.

<span class="w"> </span>        Returns:
<span class="w"> </span>            The list of aliases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.path</span>

<span class="gd">-    def search_dict_for_path(self, d: dict) -&gt;Any:</span>
<span class="gi">+    def search_dict_for_path(self, d: dict) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Searches a dictionary for the path specified by the alias.

<span class="w"> </span>        Returns:
<span class="w"> </span>            The value at the specified path, or `PydanticUndefined` if the path is not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        v = d</span>
<span class="gi">+        for k in self.path:</span>
<span class="gi">+            if isinstance(v, str):</span>
<span class="gi">+                # disallow indexing into a str, like for AliasPath(&#39;x&#39;, 0) and x=&#39;abc&#39;</span>
<span class="gi">+                return PydanticUndefined</span>
<span class="gi">+            try:</span>
<span class="gi">+                v = v[k]</span>
<span class="gi">+            except (KeyError, IndexError, TypeError):</span>
<span class="gi">+                return PydanticUndefined</span>
<span class="gi">+        return v</span>


<span class="w"> </span>@dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -47,19 +62,25 @@ class AliasChoices:</span>
<span class="w"> </span>    Attributes:
<span class="w"> </span>        choices: A list containing a string or `AliasPath`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    choices: list[str | AliasPath]

<span class="gd">-    def __init__(self, first_choice: (str | AliasPath), *choices: (str |</span>
<span class="gd">-        AliasPath)) -&gt;None:</span>
<span class="gi">+    def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -&gt; None:</span>
<span class="w"> </span>        self.choices = [first_choice] + list(choices)

<span class="gd">-    def convert_to_aliases(self) -&gt;list[list[str | int]]:</span>
<span class="gi">+    def convert_to_aliases(self) -&gt; list[list[str | int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts arguments to a list of lists containing string or integer aliases.

<span class="w"> </span>        Returns:
<span class="w"> </span>            The list of aliases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        aliases: list[list[str | int]] = []</span>
<span class="gi">+        for c in self.choices:</span>
<span class="gi">+            if isinstance(c, AliasPath):</span>
<span class="gi">+                aliases.append(c.convert_to_aliases())</span>
<span class="gi">+            else:</span>
<span class="gi">+                aliases.append([c])</span>
<span class="gi">+        return aliases</span>


<span class="w"> </span>@dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -73,27 +94,39 @@ class AliasGenerator:</span>
<span class="w"> </span>        validation_alias: A callable that takes a field name and returns a validation alias for it.
<span class="w"> </span>        serialization_alias: A callable that takes a field name and returns a serialization alias for it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    alias: Callable[[str], str] | None = None
<span class="gd">-    validation_alias: Callable[[str], str | AliasPath | AliasChoices</span>
<span class="gd">-        ] | None = None</span>
<span class="gi">+    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None</span>
<span class="w"> </span>    serialization_alias: Callable[[str], str] | None = None

<span class="gd">-    def _generate_alias(self, alias_kind: Literal[&#39;alias&#39;,</span>
<span class="gd">-        &#39;validation_alias&#39;, &#39;serialization_alias&#39;], allowed_types: tuple[</span>
<span class="gd">-        type[str] | type[AliasPath] | type[AliasChoices], ...], field_name: str</span>
<span class="gd">-        ) -&gt;(str | AliasPath | AliasChoices | None):</span>
<span class="gi">+    def _generate_alias(</span>
<span class="gi">+        self,</span>
<span class="gi">+        alias_kind: Literal[&#39;alias&#39;, &#39;validation_alias&#39;, &#39;serialization_alias&#39;],</span>
<span class="gi">+        allowed_types: tuple[type[str] | type[AliasPath] | type[AliasChoices], ...],</span>
<span class="gi">+        field_name: str,</span>
<span class="gi">+    ) -&gt; str | AliasPath | AliasChoices | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate an alias of the specified kind. Returns None if the alias generator is None.

<span class="w"> </span>        Raises:
<span class="w"> </span>            TypeError: If the alias generator produces an invalid type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def generate_aliases(self, field_name: str) -&gt;tuple[str | None, str |</span>
<span class="gd">-        AliasPath | AliasChoices | None, str | None]:</span>
<span class="gi">+        alias = None</span>
<span class="gi">+        if alias_generator := getattr(self, alias_kind):</span>
<span class="gi">+            alias = alias_generator(field_name)</span>
<span class="gi">+            if alias and not isinstance(alias, allowed_types):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&#39;Invalid `{alias_kind}` type. `{alias_kind}` generator must produce one of `{allowed_types}`&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+        return alias</span>
<span class="gi">+</span>
<span class="gi">+    def generate_aliases(self, field_name: str) -&gt; tuple[str | None, str | AliasPath | AliasChoices | None, str | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate `alias`, `validation_alias`, and `serialization_alias` for a field.

<span class="w"> </span>        Returns:
<span class="w"> </span>            A tuple of three aliases - validation, alias, and serialization.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        alias = self._generate_alias(&#39;alias&#39;, (str,), field_name)</span>
<span class="gi">+        validation_alias = self._generate_alias(&#39;validation_alias&#39;, (str, AliasChoices, AliasPath), field_name)</span>
<span class="gi">+        serialization_alias = self._generate_alias(&#39;serialization_alias&#39;, (str,), field_name)</span>
<span class="gi">+</span>
<span class="gi">+        return alias, validation_alias, serialization_alias  # type: ignore</span>
<span class="gh">diff --git a/pydantic/annotated_handlers.py b/pydantic/annotated_handlers.py</span>
<span class="gh">index 92a4df504..ac3d21391 100644</span>
<span class="gd">--- a/pydantic/annotated_handlers.py</span>
<span class="gi">+++ b/pydantic/annotated_handlers.py</span>
<span class="gu">@@ -1,12 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Type annotations to use with `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import core_schema
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .json_schema import JsonSchemaMode, JsonSchemaValue
<span class="gd">-    CoreSchemaOrField = Union[core_schema.CoreSchema, core_schema.</span>
<span class="gd">-        ModelField, core_schema.DataclassField, core_schema.TypedDictField,</span>
<span class="gd">-        core_schema.ComputedField]</span>
<span class="gi">+</span>
<span class="gi">+    CoreSchemaOrField = Union[</span>
<span class="gi">+        core_schema.CoreSchema,</span>
<span class="gi">+        core_schema.ModelField,</span>
<span class="gi">+        core_schema.DataclassField,</span>
<span class="gi">+        core_schema.TypedDictField,</span>
<span class="gi">+        core_schema.ComputedField,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;GetJsonSchemaHandler&#39;, &#39;GetCoreSchemaHandler&#39;


<span class="gu">@@ -16,9 +26,10 @@ class GetJsonSchemaHandler:</span>
<span class="w"> </span>    Attributes:
<span class="w"> </span>        mode: Json schema mode, can be `validation` or `serialization`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    mode: JsonSchemaMode

<span class="gd">-    def __call__(self, core_schema: CoreSchemaOrField, /) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __call__(self, core_schema: CoreSchemaOrField, /) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call the inner handler and get the JsonSchemaValue it returns.
<span class="w"> </span>        This will call the next JSON schema modifying function up until it calls
<span class="w"> </span>        into `pydantic.json_schema.GenerateJsonSchema`, which will raise a
<span class="gu">@@ -34,8 +45,7 @@ class GetJsonSchemaHandler:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        raise NotImplementedError

<span class="gd">-    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue, /</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue, /) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the real schema for a `{&quot;$ref&quot;: ...}` schema.
<span class="w"> </span>        If the schema given is not a `$ref` schema, it will be returned as is.
<span class="w"> </span>        This means you don&#39;t have to check before calling this function.
<span class="gu">@@ -49,13 +59,13 @@ class GetJsonSchemaHandler:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            JsonSchemaValue: A JsonSchemaValue that has no `$ref`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class GetCoreSchemaHandler:
<span class="w"> </span>    &quot;&quot;&quot;Handler to call into the next CoreSchema schema generation function.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, source_type: Any, /) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __call__(self, source_type: Any, /) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call the inner handler and get the CoreSchema it returns.
<span class="w"> </span>        This will call the next CoreSchema modifying function up until it calls
<span class="w"> </span>        into Pydantic&#39;s internal schema generation machinery, which will raise a
<span class="gu">@@ -70,7 +80,7 @@ class GetCoreSchemaHandler:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        raise NotImplementedError

<span class="gd">-    def generate_schema(self, source_type: Any, /) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def generate_schema(self, source_type: Any, /) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a schema unrelated to the current context.
<span class="w"> </span>        Use this function if e.g. you are handling schema generation for a sequence
<span class="w"> </span>        and want to generate a schema for its items.
<span class="gu">@@ -83,10 +93,9 @@ class GetCoreSchemaHandler:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            CoreSchema: The `pydantic-core` CoreSchema generated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /</span>
<span class="gd">-        ) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the real schema for a `definition-ref` schema.
<span class="w"> </span>        If the schema given is not a `definition-ref` schema, it will be returned as is.
<span class="w"> </span>        This means you don&#39;t have to check before calling this function.
<span class="gu">@@ -100,13 +109,13 @@ class GetCoreSchemaHandler:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A concrete `CoreSchema`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @property
<span class="gd">-    def field_name(self) -&gt;(str | None):</span>
<span class="gi">+    def field_name(self) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the name of the closest field to this validator.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def _get_types_namespace(self) -&gt;(dict[str, Any] | None):</span>
<span class="gi">+    def _get_types_namespace(self) -&gt; dict[str, Any] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Internal method used during type resolution for serializer annotations.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gh">diff --git a/pydantic/class_validators.py b/pydantic/class_validators.py</span>
<span class="gh">index dcb5f3bac..9977150c9 100644</span>
<span class="gd">--- a/pydantic/class_validators.py</span>
<span class="gi">+++ b/pydantic/class_validators.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;`class_validators` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/color.py b/pydantic/color.py</span>
<span class="gh">index dae7ca3d2..c702fc634 100644</span>
<span class="gd">--- a/pydantic/color.py</span>
<span class="gi">+++ b/pydantic/color.py</span>
<span class="gu">@@ -11,24 +11,28 @@ Warning: Deprecated</span>
<span class="w"> </span>    See [`pydantic-extra-types.Color`](../usage/types/extra_types/color_types.md)
<span class="w"> </span>    for more information.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>import re
<span class="w"> </span>from colorsys import hls_to_rgb, rgb_to_hls
<span class="w"> </span>from typing import Any, Callable, Optional, Tuple, Type, Union, cast
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import CoreSchema, PydanticCustomError, core_schema
<span class="w"> </span>from typing_extensions import deprecated
<span class="gi">+</span>
<span class="w"> </span>from ._internal import _repr
<span class="w"> </span>from ._internal._schema_generation_shared import GetJsonSchemaHandler as _GetJsonSchemaHandler
<span class="w"> </span>from .json_schema import JsonSchemaValue
<span class="w"> </span>from .warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>ColorTuple = Union[Tuple[int, int, int], Tuple[int, int, int, float]]
<span class="w"> </span>ColorType = Union[ColorTuple, str]
<span class="gd">-HslColorTuple = Union[Tuple[float, float, float], Tuple[float, float, float,</span>
<span class="gd">-    float]]</span>
<span class="gi">+HslColorTuple = Union[Tuple[float, float, float], Tuple[float, float, float, float]]</span>


<span class="w"> </span>class RGBA:
<span class="w"> </span>    &quot;&quot;&quot;Internal use only as a representation of a color.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = &#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;alpha&#39;, &#39;_tuple&#39;

<span class="w"> </span>    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):
<span class="gu">@@ -36,45 +40,46 @@ class RGBA:</span>
<span class="w"> </span>        self.g = g
<span class="w"> </span>        self.b = b
<span class="w"> </span>        self.alpha = alpha
<span class="gd">-        self._tuple: Tuple[float, float, float, Optional[float]] = (r, g, b,</span>
<span class="gd">-            alpha)</span>

<span class="gd">-    def __getitem__(self, item: Any) -&gt;Any:</span>
<span class="gi">+        self._tuple: Tuple[float, float, float, Optional[float]] = (r, g, b, alpha)</span>
<span class="gi">+</span>
<span class="gi">+    def __getitem__(self, item: Any) -&gt; Any:</span>
<span class="w"> </span>        return self._tuple[item]


<span class="gd">-_r_255 = &#39;(\\d{1,3}(?:\\.\\d+)?)&#39;</span>
<span class="gd">-_r_comma = &#39;\\s*,\\s*&#39;</span>
<span class="gd">-_r_alpha = &#39;(\\d(?:\\.\\d+)?|\\.\\d+|\\d{1,2}%)&#39;</span>
<span class="gd">-_r_h = &#39;(-?\\d+(?:\\.\\d+)?|-?\\.\\d+)(deg|rad|turn)?&#39;</span>
<span class="gd">-_r_sl = &#39;(\\d{1,3}(?:\\.\\d+)?)%&#39;</span>
<span class="gd">-r_hex_short = &#39;\\s*(?:#|0x)?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?\\s*&#39;</span>
<span class="gd">-r_hex_long = (</span>
<span class="gd">-    &#39;\\s*(?:#|0x)?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?\\s*&#39;)</span>
<span class="gd">-r_rgb = (</span>
<span class="gd">-    f&#39;\\s*rgba?\\(\\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}(?:{_r_comma}{_r_alpha})?\\s*\\)\\s*&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-r_hsl = (</span>
<span class="gd">-    f&#39;\\s*hsla?\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}(?:{_r_comma}{_r_alpha})?\\s*\\)\\s*&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-r_rgb_v4_style = (</span>
<span class="gd">-    f&#39;\\s*rgba?\\(\\s*{_r_255}\\s+{_r_255}\\s+{_r_255}(?:\\s*/\\s*{_r_alpha})?\\s*\\)\\s*&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-r_hsl_v4_style = (</span>
<span class="gd">-    f&#39;\\s*hsla?\\(\\s*{_r_h}\\s+{_r_sl}\\s+{_r_sl}(?:\\s*/\\s*{_r_alpha})?\\s*\\)\\s*&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+# these are not compiled here to avoid import slowdown, they&#39;ll be compiled the first time they&#39;re used, then cached</span>
<span class="gi">+_r_255 = r&#39;(\d{1,3}(?:\.\d+)?)&#39;</span>
<span class="gi">+_r_comma = r&#39;\s*,\s*&#39;</span>
<span class="gi">+_r_alpha = r&#39;(\d(?:\.\d+)?|\.\d+|\d{1,2}%)&#39;</span>
<span class="gi">+_r_h = r&#39;(-?\d+(?:\.\d+)?|-?\.\d+)(deg|rad|turn)?&#39;</span>
<span class="gi">+_r_sl = r&#39;(\d{1,3}(?:\.\d+)?)%&#39;</span>
<span class="gi">+r_hex_short = r&#39;\s*(?:#|0x)?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?\s*&#39;</span>
<span class="gi">+r_hex_long = r&#39;\s*(?:#|0x)?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?\s*&#39;</span>
<span class="gi">+# CSS3 RGB examples: rgb(0, 0, 0), rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 50%)</span>
<span class="gi">+r_rgb = rf&#39;\s*rgba?\(\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}(?:{_r_comma}{_r_alpha})?\s*\)\s*&#39;</span>
<span class="gi">+# CSS3 HSL examples: hsl(270, 60%, 50%), hsla(270, 60%, 50%, 0.5), hsla(270, 60%, 50%, 50%)</span>
<span class="gi">+r_hsl = rf&#39;\s*hsla?\(\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}(?:{_r_comma}{_r_alpha})?\s*\)\s*&#39;</span>
<span class="gi">+# CSS4 RGB examples: rgb(0 0 0), rgb(0 0 0 / 0.5), rgb(0 0 0 / 50%), rgba(0 0 0 / 50%)</span>
<span class="gi">+r_rgb_v4_style = rf&#39;\s*rgba?\(\s*{_r_255}\s+{_r_255}\s+{_r_255}(?:\s*/\s*{_r_alpha})?\s*\)\s*&#39;</span>
<span class="gi">+# CSS4 HSL examples: hsl(270 60% 50%), hsl(270 60% 50% / 0.5), hsl(270 60% 50% / 50%), hsla(270 60% 50% / 50%)</span>
<span class="gi">+r_hsl_v4_style = rf&#39;\s*hsla?\(\s*{_r_h}\s+{_r_sl}\s+{_r_sl}(?:\s*/\s*{_r_alpha})?\s*\)\s*&#39;</span>
<span class="gi">+</span>
<span class="gi">+# colors where the two hex characters are the same, if all colors match this the short version of hex colors can be used</span>
<span class="w"> </span>repeat_colors = {int(c * 2, 16) for c in &#39;0123456789abcdef&#39;}
<span class="w"> </span>rads = 2 * math.pi


<span class="w"> </span>@deprecated(
<span class="gd">-    &#39;The `Color` class is deprecated, use `pydantic_extra_types` instead. See https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/.&#39;</span>
<span class="gd">-    , category=PydanticDeprecatedSince20)</span>
<span class="gi">+    &#39;The `Color` class is deprecated, use `pydantic_extra_types` instead. &#39;</span>
<span class="gi">+    &#39;See https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/.&#39;,</span>
<span class="gi">+    category=PydanticDeprecatedSince20,</span>
<span class="gi">+)</span>
<span class="w"> </span>class Color(_repr.Representation):
<span class="w"> </span>    &quot;&quot;&quot;Represents a color.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = &#39;_original&#39;, &#39;_rgba&#39;

<span class="gd">-    def __init__(self, value: ColorType) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: ColorType) -&gt; None:</span>
<span class="w"> </span>        self._rgba: RGBA
<span class="w"> </span>        self._original: ColorType
<span class="w"> </span>        if isinstance(value, (tuple, list)):
<span class="gu">@@ -85,23 +90,26 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>            self._rgba = value._rgba
<span class="w"> </span>            value = value._original
<span class="w"> </span>        else:
<span class="gd">-            raise PydanticCustomError(&#39;color_error&#39;,</span>
<span class="gd">-                &#39;value is not a valid color: value must be a tuple, list or string&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise PydanticCustomError(</span>
<span class="gi">+                &#39;color_error&#39;, &#39;value is not a valid color: value must be a tuple, list or string&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # if we&#39;ve got here value must be a valid color</span>
<span class="w"> </span>        self._original = value

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_json_schema__(cls, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: _GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        cls, core_schema: core_schema.CoreSchema, handler: _GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        field_schema = {}
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;color&#39;)
<span class="w"> </span>        return field_schema

<span class="gd">-    def original(self) -&gt;ColorType:</span>
<span class="gi">+    def original(self) -&gt; ColorType:</span>
<span class="w"> </span>        &quot;&quot;&quot;Original value passed to `Color`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._original</span>

<span class="gd">-    def as_named(self, *, fallback: bool=False) -&gt;str:</span>
<span class="gi">+    def as_named(self, *, fallback: bool = False) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,
<span class="w"> </span>        otherwise returns the hexadecimal representation of the color or raises `ValueError`.

<span class="gu">@@ -115,9 +123,19 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            ValueError: When no named color is found and fallback is `False`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._rgba.alpha is None:</span>
<span class="gi">+            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())</span>
<span class="gi">+            try:</span>
<span class="gi">+                return COLORS_BY_VALUE[rgb]</span>
<span class="gi">+            except KeyError as e:</span>
<span class="gi">+                if fallback:</span>
<span class="gi">+                    return self.as_hex()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(&#39;no named color found, use fallback=True, as_hex() or as_rgb()&#39;) from e</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.as_hex()</span>

<span class="gd">-    def as_hex(self) -&gt;str:</span>
<span class="gi">+    def as_hex(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the hexadecimal representation of the color.

<span class="w"> </span>        Hex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string
<span class="gu">@@ -126,13 +144,26 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The hexadecimal representation of the color.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        values = [float_to_255(c) for c in self._rgba[:3]]</span>
<span class="gi">+        if self._rgba.alpha is not None:</span>
<span class="gi">+            values.append(float_to_255(self._rgba.alpha))</span>
<span class="gi">+</span>
<span class="gi">+        as_hex = &#39;&#39;.join(f&#39;{v:02x}&#39; for v in values)</span>
<span class="gi">+        if all(c in repeat_colors for c in values):</span>
<span class="gi">+            as_hex = &#39;&#39;.join(as_hex[c] for c in range(0, len(as_hex), 2))</span>
<span class="gi">+        return &#39;#&#39; + as_hex</span>

<span class="gd">-    def as_rgb(self) -&gt;str:</span>
<span class="gi">+    def as_rgb(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Color as an `rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;)` or `rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;)` string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._rgba.alpha is None:</span>
<span class="gi">+            return f&#39;rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (</span>
<span class="gi">+                f&#39;rgba({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)}, &#39;</span>
<span class="gi">+                f&#39;{round(self._alpha_float(), 2)})&#39;</span>
<span class="gi">+            )</span>

<span class="gd">-    def as_rgb_tuple(self, *, alpha: Optional[bool]=None) -&gt;ColorTuple:</span>
<span class="gi">+    def as_rgb_tuple(self, *, alpha: Optional[bool] = None) -&gt; ColorTuple:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the color as an RGB or RGBA tuple.

<span class="w"> </span>        Args:
<span class="gu">@@ -146,13 +177,28 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>            A tuple that contains the values of the red, green, and blue channels in the range 0 to 255.
<span class="w"> </span>                If alpha is included, it is in the range 0 to 1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        r, g, b = (float_to_255(c) for c in self._rgba[:3])</span>
<span class="gi">+        if alpha is None:</span>
<span class="gi">+            if self._rgba.alpha is None:</span>
<span class="gi">+                return r, g, b</span>
<span class="gi">+            else:</span>
<span class="gi">+                return r, g, b, self._alpha_float()</span>
<span class="gi">+        elif alpha:</span>
<span class="gi">+            return r, g, b, self._alpha_float()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # alpha is False</span>
<span class="gi">+            return r, g, b</span>

<span class="gd">-    def as_hsl(self) -&gt;str:</span>
<span class="gi">+    def as_hsl(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Color as an `hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;)` or `hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;, &lt;a&gt;)` string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._rgba.alpha is None:</span>
<span class="gi">+            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore</span>
<span class="gi">+            return f&#39;hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            h, s, li, a = self.as_hsl_tuple(alpha=True)  # type: ignore</span>
<span class="gi">+            return f&#39;hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%}, {round(a, 2)})&#39;</span>

<span class="gd">-    def as_hsl_tuple(self, *, alpha: Optional[bool]=None) -&gt;HslColorTuple:</span>
<span class="gi">+    def as_hsl_tuple(self, *, alpha: Optional[bool] = None) -&gt; HslColorTuple:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the color as an HSL or HSLA tuple.

<span class="w"> </span>        Args:
<span class="gu">@@ -169,30 +215,47 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>        Note:
<span class="w"> </span>            This is HSL as used in HTML and most other places, not HLS as used in Python&#39;s `colorsys`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741</span>
<span class="gi">+        if alpha is None:</span>
<span class="gi">+            if self._rgba.alpha is None:</span>
<span class="gi">+                return h, s, l</span>
<span class="gi">+            else:</span>
<span class="gi">+                return h, s, l, self._alpha_float()</span>
<span class="gi">+        if alpha:</span>
<span class="gi">+            return h, s, l, self._alpha_float()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # alpha is False</span>
<span class="gi">+            return h, s, l</span>
<span class="gi">+</span>
<span class="gi">+    def _alpha_float(self) -&gt; float:</span>
<span class="gi">+        return 1 if self._rgba.alpha is None else self._rgba.alpha</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def __get_pydantic_core_schema__(</span>
<span class="gi">+        cls, source: Type[Any], handler: Callable[[Any], CoreSchema]</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.with_info_plain_validator_function(</span>
<span class="gi">+            cls._validate, serialization=core_schema.to_string_ser_schema()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, source: Type[Any], handler:</span>
<span class="gd">-        Callable[[Any], CoreSchema]) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        return core_schema.with_info_plain_validator_function(cls._validate,</span>
<span class="gd">-            serialization=core_schema.to_string_ser_schema())</span>
<span class="gi">+    def _validate(cls, __input_value: Any, _: Any) -&gt; &#39;Color&#39;:</span>
<span class="gi">+        return cls(__input_value)</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.as_named(fallback=True)

<span class="gd">-    def __repr_args__(self) -&gt;&#39;_repr.ReprArgs&#39;:</span>
<span class="gd">-        return [(None, self.as_named(fallback=True))] + [(&#39;rgb&#39;, self.</span>
<span class="gd">-            as_rgb_tuple())]</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;_repr.ReprArgs&#39;:</span>
<span class="gi">+        return [(None, self.as_named(fallback=True))] + [(&#39;rgb&#39;, self.as_rgb_tuple())]</span>

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, Color) and self.as_rgb_tuple(</span>
<span class="gd">-            ) == other.as_rgb_tuple()</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, Color) and self.as_rgb_tuple() == other.as_rgb_tuple()</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.as_rgb_tuple())


<span class="gd">-def parse_tuple(value: Tuple[Any, ...]) -&gt;RGBA:</span>
<span class="gi">+def parse_tuple(value: Tuple[Any, ...]) -&gt; RGBA:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a tuple or list to get RGBA values.

<span class="w"> </span>    Args:
<span class="gu">@@ -204,10 +267,17 @@ def parse_tuple(value: Tuple[Any, ...]) -&gt;RGBA:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticCustomError: If tuple is not valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(value) == 3:</span>
<span class="gi">+        r, g, b = (parse_color_value(v) for v in value)</span>
<span class="gi">+        return RGBA(r, g, b, None)</span>
<span class="gi">+    elif len(value) == 4:</span>
<span class="gi">+        r, g, b = (parse_color_value(v) for v in value[:3])</span>
<span class="gi">+        return RGBA(r, g, b, parse_float_alpha(value[3]))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise PydanticCustomError(&#39;color_error&#39;, &#39;value is not a valid color: tuples must have length 3 or 4&#39;)</span>


<span class="gd">-def parse_str(value: str) -&gt;RGBA:</span>
<span class="gi">+def parse_str(value: str) -&gt; RGBA:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a string representing a color to an RGBA tuple.

<span class="w"> </span>    Possible formats for the input string include:
<span class="gu">@@ -227,11 +297,46 @@ def parse_str(value: str) -&gt;RGBA:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        ValueError: If the input string cannot be parsed to an RGBA tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value_lower = value.lower()</span>
<span class="gi">+    try:</span>
<span class="gi">+        r, g, b = COLORS_BY_NAME[value_lower]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        return ints_to_rgba(r, g, b, None)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.fullmatch(r_hex_short, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        *rgb, a = m.groups()</span>
<span class="gi">+        r, g, b = (int(v * 2, 16) for v in rgb)</span>
<span class="gi">+        if a:</span>
<span class="gi">+            alpha: Optional[float] = int(a * 2, 16) / 255</span>
<span class="gi">+        else:</span>
<span class="gi">+            alpha = None</span>
<span class="gi">+        return ints_to_rgba(r, g, b, alpha)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.fullmatch(r_hex_long, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        *rgb, a = m.groups()</span>
<span class="gi">+        r, g, b = (int(v, 16) for v in rgb)</span>
<span class="gi">+        if a:</span>
<span class="gi">+            alpha = int(a, 16) / 255</span>
<span class="gi">+        else:</span>
<span class="gi">+            alpha = None</span>
<span class="gi">+        return ints_to_rgba(r, g, b, alpha)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.fullmatch(r_rgb, value_lower) or re.fullmatch(r_rgb_v4_style, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        return ints_to_rgba(*m.groups())  # type: ignore</span>

<span class="gi">+    m = re.fullmatch(r_hsl, value_lower) or re.fullmatch(r_hsl_v4_style, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        return parse_hsl(*m.groups())  # type: ignore</span>

<span class="gd">-def ints_to_rgba(r: Union[int, str], g: Union[int, str], b: Union[int, str],</span>
<span class="gd">-    alpha: Optional[float]=None) -&gt;RGBA:</span>
<span class="gi">+    raise PydanticCustomError(&#39;color_error&#39;, &#39;value is not a valid color: string not recognised as a valid color&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ints_to_rgba(r: Union[int, str], g: Union[int, str], b: Union[int, str], alpha: Optional[float] = None) -&gt; RGBA:</span>
<span class="w"> </span>    &quot;&quot;&quot;Converts integer or string values for RGB color and an optional alpha value to an `RGBA` object.

<span class="w"> </span>    Args:
<span class="gu">@@ -243,10 +348,10 @@ def ints_to_rgba(r: Union[int, str], g: Union[int, str], b: Union[int, str],</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        An instance of the `RGBA` class with the corresponding color and alpha values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))</span>


<span class="gd">-def parse_color_value(value: Union[int, str], max_val: int=255) -&gt;float:</span>
<span class="gi">+def parse_color_value(value: Union[int, str], max_val: int = 255) -&gt; float:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse the color value provided and return a number between 0 and 1.

<span class="w"> </span>    Args:
<span class="gu">@@ -259,10 +364,21 @@ def parse_color_value(value: Union[int, str], max_val: int=255) -&gt;float:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A number between 0 and 1.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_float_alpha(value: Union[None, str, float, int]) -&gt;Optional[float]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        color = float(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(&#39;color_error&#39;, &#39;value is not a valid color: color values must be a valid number&#39;)</span>
<span class="gi">+    if 0 &lt;= color &lt;= max_val:</span>
<span class="gi">+        return color / max_val</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise PydanticCustomError(</span>
<span class="gi">+            &#39;color_error&#39;,</span>
<span class="gi">+            &#39;value is not a valid color: color values must be in the range 0 to {max_val}&#39;,</span>
<span class="gi">+            {&#39;max_val&#39;: max_val},</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_float_alpha(value: Union[None, str, float, int]) -&gt; Optional[float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse an alpha value checking it&#39;s a valid float in the range 0 to 1.

<span class="w"> </span>    Args:
<span class="gu">@@ -274,11 +390,25 @@ def parse_float_alpha(value: Union[None, str, float, int]) -&gt;Optional[float]:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticCustomError: If the input value cannot be successfully parsed as a float in the expected range.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(value, str) and value.endswith(&#39;%&#39;):</span>
<span class="gi">+            alpha = float(value[:-1]) / 100</span>
<span class="gi">+        else:</span>
<span class="gi">+            alpha = float(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(&#39;color_error&#39;, &#39;value is not a valid color: alpha values must be a valid float&#39;)</span>

<span class="gi">+    if math.isclose(alpha, 1):</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif 0 &lt;= alpha &lt;= 1:</span>
<span class="gi">+        return alpha</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise PydanticCustomError(&#39;color_error&#39;, &#39;value is not a valid color: alpha values must be in the range 0 to 1&#39;)</span>

<span class="gd">-def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[</span>
<span class="gd">-    float]=None) -&gt;RGBA:</span>
<span class="gi">+</span>
<span class="gi">+def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[float] = None) -&gt; RGBA:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse raw hue, saturation, lightness, and alpha values and convert to RGBA.

<span class="w"> </span>    Args:
<span class="gu">@@ -291,10 +421,22 @@ def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        An instance of `RGBA`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)</span>
<span class="gi">+</span>
<span class="gi">+    h_value = float(h)</span>
<span class="gi">+    if h_units in {None, &#39;deg&#39;}:</span>
<span class="gi">+        h_value = h_value % 360 / 360</span>
<span class="gi">+    elif h_units == &#39;rad&#39;:</span>
<span class="gi">+        h_value = h_value % rads / rads</span>
<span class="gi">+    else:</span>
<span class="gi">+        # turns</span>
<span class="gi">+        h_value = h_value % 1</span>

<span class="gi">+    r, g, b = hls_to_rgb(h_value, l_value, s_value)</span>
<span class="gi">+    return RGBA(r, g, b, parse_float_alpha(alpha))</span>

<span class="gd">-def float_to_255(c: float) -&gt;int:</span>
<span class="gi">+</span>
<span class="gi">+def float_to_255(c: float) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Converts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive).

<span class="w"> </span>    Args:
<span class="gu">@@ -306,69 +448,157 @@ def float_to_255(c: float) -&gt;int:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        ValueError: If the given float value is outside the acceptable range of 0 to 1 (inclusive).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-COLORS_BY_NAME = {&#39;aliceblue&#39;: (240, 248, 255), &#39;antiquewhite&#39;: (250, 235, </span>
<span class="gd">-    215), &#39;aqua&#39;: (0, 255, 255), &#39;aquamarine&#39;: (127, 255, 212), &#39;azure&#39;: (</span>
<span class="gd">-    240, 255, 255), &#39;beige&#39;: (245, 245, 220), &#39;bisque&#39;: (255, 228, 196),</span>
<span class="gd">-    &#39;black&#39;: (0, 0, 0), &#39;blanchedalmond&#39;: (255, 235, 205), &#39;blue&#39;: (0, 0, </span>
<span class="gd">-    255), &#39;blueviolet&#39;: (138, 43, 226), &#39;brown&#39;: (165, 42, 42), &#39;burlywood&#39;:</span>
<span class="gd">-    (222, 184, 135), &#39;cadetblue&#39;: (95, 158, 160), &#39;chartreuse&#39;: (127, 255, </span>
<span class="gd">-    0), &#39;chocolate&#39;: (210, 105, 30), &#39;coral&#39;: (255, 127, 80),</span>
<span class="gd">-    &#39;cornflowerblue&#39;: (100, 149, 237), &#39;cornsilk&#39;: (255, 248, 220),</span>
<span class="gd">-    &#39;crimson&#39;: (220, 20, 60), &#39;cyan&#39;: (0, 255, 255), &#39;darkblue&#39;: (0, 0, 139</span>
<span class="gd">-    ), &#39;darkcyan&#39;: (0, 139, 139), &#39;darkgoldenrod&#39;: (184, 134, 11),</span>
<span class="gd">-    &#39;darkgray&#39;: (169, 169, 169), &#39;darkgreen&#39;: (0, 100, 0), &#39;darkgrey&#39;: (169,</span>
<span class="gd">-    169, 169), &#39;darkkhaki&#39;: (189, 183, 107), &#39;darkmagenta&#39;: (139, 0, 139),</span>
<span class="gd">-    &#39;darkolivegreen&#39;: (85, 107, 47), &#39;darkorange&#39;: (255, 140, 0),</span>
<span class="gd">-    &#39;darkorchid&#39;: (153, 50, 204), &#39;darkred&#39;: (139, 0, 0), &#39;darksalmon&#39;: (</span>
<span class="gd">-    233, 150, 122), &#39;darkseagreen&#39;: (143, 188, 143), &#39;darkslateblue&#39;: (72, </span>
<span class="gd">-    61, 139), &#39;darkslategray&#39;: (47, 79, 79), &#39;darkslategrey&#39;: (47, 79, 79),</span>
<span class="gd">-    &#39;darkturquoise&#39;: (0, 206, 209), &#39;darkviolet&#39;: (148, 0, 211), &#39;deeppink&#39;:</span>
<span class="gd">-    (255, 20, 147), &#39;deepskyblue&#39;: (0, 191, 255), &#39;dimgray&#39;: (105, 105, 105</span>
<span class="gd">-    ), &#39;dimgrey&#39;: (105, 105, 105), &#39;dodgerblue&#39;: (30, 144, 255),</span>
<span class="gd">-    &#39;firebrick&#39;: (178, 34, 34), &#39;floralwhite&#39;: (255, 250, 240),</span>
<span class="gd">-    &#39;forestgreen&#39;: (34, 139, 34), &#39;fuchsia&#39;: (255, 0, 255), &#39;gainsboro&#39;: (</span>
<span class="gd">-    220, 220, 220), &#39;ghostwhite&#39;: (248, 248, 255), &#39;gold&#39;: (255, 215, 0),</span>
<span class="gd">-    &#39;goldenrod&#39;: (218, 165, 32), &#39;gray&#39;: (128, 128, 128), &#39;green&#39;: (0, 128,</span>
<span class="gd">-    0), &#39;greenyellow&#39;: (173, 255, 47), &#39;grey&#39;: (128, 128, 128), &#39;honeydew&#39;:</span>
<span class="gd">-    (240, 255, 240), &#39;hotpink&#39;: (255, 105, 180), &#39;indianred&#39;: (205, 92, 92),</span>
<span class="gd">-    &#39;indigo&#39;: (75, 0, 130), &#39;ivory&#39;: (255, 255, 240), &#39;khaki&#39;: (240, 230, </span>
<span class="gd">-    140), &#39;lavender&#39;: (230, 230, 250), &#39;lavenderblush&#39;: (255, 240, 245),</span>
<span class="gd">-    &#39;lawngreen&#39;: (124, 252, 0), &#39;lemonchiffon&#39;: (255, 250, 205),</span>
<span class="gd">-    &#39;lightblue&#39;: (173, 216, 230), &#39;lightcoral&#39;: (240, 128, 128),</span>
<span class="gd">-    &#39;lightcyan&#39;: (224, 255, 255), &#39;lightgoldenrodyellow&#39;: (250, 250, 210),</span>
<span class="gd">-    &#39;lightgray&#39;: (211, 211, 211), &#39;lightgreen&#39;: (144, 238, 144),</span>
<span class="gd">-    &#39;lightgrey&#39;: (211, 211, 211), &#39;lightpink&#39;: (255, 182, 193),</span>
<span class="gd">-    &#39;lightsalmon&#39;: (255, 160, 122), &#39;lightseagreen&#39;: (32, 178, 170),</span>
<span class="gd">-    &#39;lightskyblue&#39;: (135, 206, 250), &#39;lightslategray&#39;: (119, 136, 153),</span>
<span class="gd">-    &#39;lightslategrey&#39;: (119, 136, 153), &#39;lightsteelblue&#39;: (176, 196, 222),</span>
<span class="gd">-    &#39;lightyellow&#39;: (255, 255, 224), &#39;lime&#39;: (0, 255, 0), &#39;limegreen&#39;: (50, </span>
<span class="gd">-    205, 50), &#39;linen&#39;: (250, 240, 230), &#39;magenta&#39;: (255, 0, 255), &#39;maroon&#39;:</span>
<span class="gd">-    (128, 0, 0), &#39;mediumaquamarine&#39;: (102, 205, 170), &#39;mediumblue&#39;: (0, 0, </span>
<span class="gd">-    205), &#39;mediumorchid&#39;: (186, 85, 211), &#39;mediumpurple&#39;: (147, 112, 219),</span>
<span class="gd">-    &#39;mediumseagreen&#39;: (60, 179, 113), &#39;mediumslateblue&#39;: (123, 104, 238),</span>
<span class="gd">-    &#39;mediumspringgreen&#39;: (0, 250, 154), &#39;mediumturquoise&#39;: (72, 209, 204),</span>
<span class="gd">-    &#39;mediumvioletred&#39;: (199, 21, 133), &#39;midnightblue&#39;: (25, 25, 112),</span>
<span class="gd">-    &#39;mintcream&#39;: (245, 255, 250), &#39;mistyrose&#39;: (255, 228, 225), &#39;moccasin&#39;:</span>
<span class="gd">-    (255, 228, 181), &#39;navajowhite&#39;: (255, 222, 173), &#39;navy&#39;: (0, 0, 128),</span>
<span class="gd">-    &#39;oldlace&#39;: (253, 245, 230), &#39;olive&#39;: (128, 128, 0), &#39;olivedrab&#39;: (107, </span>
<span class="gd">-    142, 35), &#39;orange&#39;: (255, 165, 0), &#39;orangered&#39;: (255, 69, 0), &#39;orchid&#39;:</span>
<span class="gd">-    (218, 112, 214), &#39;palegoldenrod&#39;: (238, 232, 170), &#39;palegreen&#39;: (152, </span>
<span class="gd">-    251, 152), &#39;paleturquoise&#39;: (175, 238, 238), &#39;palevioletred&#39;: (219, 112,</span>
<span class="gd">-    147), &#39;papayawhip&#39;: (255, 239, 213), &#39;peachpuff&#39;: (255, 218, 185),</span>
<span class="gd">-    &#39;peru&#39;: (205, 133, 63), &#39;pink&#39;: (255, 192, 203), &#39;plum&#39;: (221, 160, 221</span>
<span class="gd">-    ), &#39;powderblue&#39;: (176, 224, 230), &#39;purple&#39;: (128, 0, 128), &#39;red&#39;: (255,</span>
<span class="gd">-    0, 0), &#39;rosybrown&#39;: (188, 143, 143), &#39;royalblue&#39;: (65, 105, 225),</span>
<span class="gd">-    &#39;saddlebrown&#39;: (139, 69, 19), &#39;salmon&#39;: (250, 128, 114), &#39;sandybrown&#39;:</span>
<span class="gd">-    (244, 164, 96), &#39;seagreen&#39;: (46, 139, 87), &#39;seashell&#39;: (255, 245, 238),</span>
<span class="gd">-    &#39;sienna&#39;: (160, 82, 45), &#39;silver&#39;: (192, 192, 192), &#39;skyblue&#39;: (135, </span>
<span class="gd">-    206, 235), &#39;slateblue&#39;: (106, 90, 205), &#39;slategray&#39;: (112, 128, 144),</span>
<span class="gd">-    &#39;slategrey&#39;: (112, 128, 144), &#39;snow&#39;: (255, 250, 250), &#39;springgreen&#39;: (</span>
<span class="gd">-    0, 255, 127), &#39;steelblue&#39;: (70, 130, 180), &#39;tan&#39;: (210, 180, 140),</span>
<span class="gd">-    &#39;teal&#39;: (0, 128, 128), &#39;thistle&#39;: (216, 191, 216), &#39;tomato&#39;: (255, 99, </span>
<span class="gd">-    71), &#39;turquoise&#39;: (64, 224, 208), &#39;violet&#39;: (238, 130, 238), &#39;wheat&#39;: (</span>
<span class="gd">-    245, 222, 179), &#39;white&#39;: (255, 255, 255), &#39;whitesmoke&#39;: (245, 245, 245),</span>
<span class="gd">-    &#39;yellow&#39;: (255, 255, 0), &#39;yellowgreen&#39;: (154, 205, 50)}</span>
<span class="gi">+    return int(round(c * 255))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+COLORS_BY_NAME = {</span>
<span class="gi">+    &#39;aliceblue&#39;: (240, 248, 255),</span>
<span class="gi">+    &#39;antiquewhite&#39;: (250, 235, 215),</span>
<span class="gi">+    &#39;aqua&#39;: (0, 255, 255),</span>
<span class="gi">+    &#39;aquamarine&#39;: (127, 255, 212),</span>
<span class="gi">+    &#39;azure&#39;: (240, 255, 255),</span>
<span class="gi">+    &#39;beige&#39;: (245, 245, 220),</span>
<span class="gi">+    &#39;bisque&#39;: (255, 228, 196),</span>
<span class="gi">+    &#39;black&#39;: (0, 0, 0),</span>
<span class="gi">+    &#39;blanchedalmond&#39;: (255, 235, 205),</span>
<span class="gi">+    &#39;blue&#39;: (0, 0, 255),</span>
<span class="gi">+    &#39;blueviolet&#39;: (138, 43, 226),</span>
<span class="gi">+    &#39;brown&#39;: (165, 42, 42),</span>
<span class="gi">+    &#39;burlywood&#39;: (222, 184, 135),</span>
<span class="gi">+    &#39;cadetblue&#39;: (95, 158, 160),</span>
<span class="gi">+    &#39;chartreuse&#39;: (127, 255, 0),</span>
<span class="gi">+    &#39;chocolate&#39;: (210, 105, 30),</span>
<span class="gi">+    &#39;coral&#39;: (255, 127, 80),</span>
<span class="gi">+    &#39;cornflowerblue&#39;: (100, 149, 237),</span>
<span class="gi">+    &#39;cornsilk&#39;: (255, 248, 220),</span>
<span class="gi">+    &#39;crimson&#39;: (220, 20, 60),</span>
<span class="gi">+    &#39;cyan&#39;: (0, 255, 255),</span>
<span class="gi">+    &#39;darkblue&#39;: (0, 0, 139),</span>
<span class="gi">+    &#39;darkcyan&#39;: (0, 139, 139),</span>
<span class="gi">+    &#39;darkgoldenrod&#39;: (184, 134, 11),</span>
<span class="gi">+    &#39;darkgray&#39;: (169, 169, 169),</span>
<span class="gi">+    &#39;darkgreen&#39;: (0, 100, 0),</span>
<span class="gi">+    &#39;darkgrey&#39;: (169, 169, 169),</span>
<span class="gi">+    &#39;darkkhaki&#39;: (189, 183, 107),</span>
<span class="gi">+    &#39;darkmagenta&#39;: (139, 0, 139),</span>
<span class="gi">+    &#39;darkolivegreen&#39;: (85, 107, 47),</span>
<span class="gi">+    &#39;darkorange&#39;: (255, 140, 0),</span>
<span class="gi">+    &#39;darkorchid&#39;: (153, 50, 204),</span>
<span class="gi">+    &#39;darkred&#39;: (139, 0, 0),</span>
<span class="gi">+    &#39;darksalmon&#39;: (233, 150, 122),</span>
<span class="gi">+    &#39;darkseagreen&#39;: (143, 188, 143),</span>
<span class="gi">+    &#39;darkslateblue&#39;: (72, 61, 139),</span>
<span class="gi">+    &#39;darkslategray&#39;: (47, 79, 79),</span>
<span class="gi">+    &#39;darkslategrey&#39;: (47, 79, 79),</span>
<span class="gi">+    &#39;darkturquoise&#39;: (0, 206, 209),</span>
<span class="gi">+    &#39;darkviolet&#39;: (148, 0, 211),</span>
<span class="gi">+    &#39;deeppink&#39;: (255, 20, 147),</span>
<span class="gi">+    &#39;deepskyblue&#39;: (0, 191, 255),</span>
<span class="gi">+    &#39;dimgray&#39;: (105, 105, 105),</span>
<span class="gi">+    &#39;dimgrey&#39;: (105, 105, 105),</span>
<span class="gi">+    &#39;dodgerblue&#39;: (30, 144, 255),</span>
<span class="gi">+    &#39;firebrick&#39;: (178, 34, 34),</span>
<span class="gi">+    &#39;floralwhite&#39;: (255, 250, 240),</span>
<span class="gi">+    &#39;forestgreen&#39;: (34, 139, 34),</span>
<span class="gi">+    &#39;fuchsia&#39;: (255, 0, 255),</span>
<span class="gi">+    &#39;gainsboro&#39;: (220, 220, 220),</span>
<span class="gi">+    &#39;ghostwhite&#39;: (248, 248, 255),</span>
<span class="gi">+    &#39;gold&#39;: (255, 215, 0),</span>
<span class="gi">+    &#39;goldenrod&#39;: (218, 165, 32),</span>
<span class="gi">+    &#39;gray&#39;: (128, 128, 128),</span>
<span class="gi">+    &#39;green&#39;: (0, 128, 0),</span>
<span class="gi">+    &#39;greenyellow&#39;: (173, 255, 47),</span>
<span class="gi">+    &#39;grey&#39;: (128, 128, 128),</span>
<span class="gi">+    &#39;honeydew&#39;: (240, 255, 240),</span>
<span class="gi">+    &#39;hotpink&#39;: (255, 105, 180),</span>
<span class="gi">+    &#39;indianred&#39;: (205, 92, 92),</span>
<span class="gi">+    &#39;indigo&#39;: (75, 0, 130),</span>
<span class="gi">+    &#39;ivory&#39;: (255, 255, 240),</span>
<span class="gi">+    &#39;khaki&#39;: (240, 230, 140),</span>
<span class="gi">+    &#39;lavender&#39;: (230, 230, 250),</span>
<span class="gi">+    &#39;lavenderblush&#39;: (255, 240, 245),</span>
<span class="gi">+    &#39;lawngreen&#39;: (124, 252, 0),</span>
<span class="gi">+    &#39;lemonchiffon&#39;: (255, 250, 205),</span>
<span class="gi">+    &#39;lightblue&#39;: (173, 216, 230),</span>
<span class="gi">+    &#39;lightcoral&#39;: (240, 128, 128),</span>
<span class="gi">+    &#39;lightcyan&#39;: (224, 255, 255),</span>
<span class="gi">+    &#39;lightgoldenrodyellow&#39;: (250, 250, 210),</span>
<span class="gi">+    &#39;lightgray&#39;: (211, 211, 211),</span>
<span class="gi">+    &#39;lightgreen&#39;: (144, 238, 144),</span>
<span class="gi">+    &#39;lightgrey&#39;: (211, 211, 211),</span>
<span class="gi">+    &#39;lightpink&#39;: (255, 182, 193),</span>
<span class="gi">+    &#39;lightsalmon&#39;: (255, 160, 122),</span>
<span class="gi">+    &#39;lightseagreen&#39;: (32, 178, 170),</span>
<span class="gi">+    &#39;lightskyblue&#39;: (135, 206, 250),</span>
<span class="gi">+    &#39;lightslategray&#39;: (119, 136, 153),</span>
<span class="gi">+    &#39;lightslategrey&#39;: (119, 136, 153),</span>
<span class="gi">+    &#39;lightsteelblue&#39;: (176, 196, 222),</span>
<span class="gi">+    &#39;lightyellow&#39;: (255, 255, 224),</span>
<span class="gi">+    &#39;lime&#39;: (0, 255, 0),</span>
<span class="gi">+    &#39;limegreen&#39;: (50, 205, 50),</span>
<span class="gi">+    &#39;linen&#39;: (250, 240, 230),</span>
<span class="gi">+    &#39;magenta&#39;: (255, 0, 255),</span>
<span class="gi">+    &#39;maroon&#39;: (128, 0, 0),</span>
<span class="gi">+    &#39;mediumaquamarine&#39;: (102, 205, 170),</span>
<span class="gi">+    &#39;mediumblue&#39;: (0, 0, 205),</span>
<span class="gi">+    &#39;mediumorchid&#39;: (186, 85, 211),</span>
<span class="gi">+    &#39;mediumpurple&#39;: (147, 112, 219),</span>
<span class="gi">+    &#39;mediumseagreen&#39;: (60, 179, 113),</span>
<span class="gi">+    &#39;mediumslateblue&#39;: (123, 104, 238),</span>
<span class="gi">+    &#39;mediumspringgreen&#39;: (0, 250, 154),</span>
<span class="gi">+    &#39;mediumturquoise&#39;: (72, 209, 204),</span>
<span class="gi">+    &#39;mediumvioletred&#39;: (199, 21, 133),</span>
<span class="gi">+    &#39;midnightblue&#39;: (25, 25, 112),</span>
<span class="gi">+    &#39;mintcream&#39;: (245, 255, 250),</span>
<span class="gi">+    &#39;mistyrose&#39;: (255, 228, 225),</span>
<span class="gi">+    &#39;moccasin&#39;: (255, 228, 181),</span>
<span class="gi">+    &#39;navajowhite&#39;: (255, 222, 173),</span>
<span class="gi">+    &#39;navy&#39;: (0, 0, 128),</span>
<span class="gi">+    &#39;oldlace&#39;: (253, 245, 230),</span>
<span class="gi">+    &#39;olive&#39;: (128, 128, 0),</span>
<span class="gi">+    &#39;olivedrab&#39;: (107, 142, 35),</span>
<span class="gi">+    &#39;orange&#39;: (255, 165, 0),</span>
<span class="gi">+    &#39;orangered&#39;: (255, 69, 0),</span>
<span class="gi">+    &#39;orchid&#39;: (218, 112, 214),</span>
<span class="gi">+    &#39;palegoldenrod&#39;: (238, 232, 170),</span>
<span class="gi">+    &#39;palegreen&#39;: (152, 251, 152),</span>
<span class="gi">+    &#39;paleturquoise&#39;: (175, 238, 238),</span>
<span class="gi">+    &#39;palevioletred&#39;: (219, 112, 147),</span>
<span class="gi">+    &#39;papayawhip&#39;: (255, 239, 213),</span>
<span class="gi">+    &#39;peachpuff&#39;: (255, 218, 185),</span>
<span class="gi">+    &#39;peru&#39;: (205, 133, 63),</span>
<span class="gi">+    &#39;pink&#39;: (255, 192, 203),</span>
<span class="gi">+    &#39;plum&#39;: (221, 160, 221),</span>
<span class="gi">+    &#39;powderblue&#39;: (176, 224, 230),</span>
<span class="gi">+    &#39;purple&#39;: (128, 0, 128),</span>
<span class="gi">+    &#39;red&#39;: (255, 0, 0),</span>
<span class="gi">+    &#39;rosybrown&#39;: (188, 143, 143),</span>
<span class="gi">+    &#39;royalblue&#39;: (65, 105, 225),</span>
<span class="gi">+    &#39;saddlebrown&#39;: (139, 69, 19),</span>
<span class="gi">+    &#39;salmon&#39;: (250, 128, 114),</span>
<span class="gi">+    &#39;sandybrown&#39;: (244, 164, 96),</span>
<span class="gi">+    &#39;seagreen&#39;: (46, 139, 87),</span>
<span class="gi">+    &#39;seashell&#39;: (255, 245, 238),</span>
<span class="gi">+    &#39;sienna&#39;: (160, 82, 45),</span>
<span class="gi">+    &#39;silver&#39;: (192, 192, 192),</span>
<span class="gi">+    &#39;skyblue&#39;: (135, 206, 235),</span>
<span class="gi">+    &#39;slateblue&#39;: (106, 90, 205),</span>
<span class="gi">+    &#39;slategray&#39;: (112, 128, 144),</span>
<span class="gi">+    &#39;slategrey&#39;: (112, 128, 144),</span>
<span class="gi">+    &#39;snow&#39;: (255, 250, 250),</span>
<span class="gi">+    &#39;springgreen&#39;: (0, 255, 127),</span>
<span class="gi">+    &#39;steelblue&#39;: (70, 130, 180),</span>
<span class="gi">+    &#39;tan&#39;: (210, 180, 140),</span>
<span class="gi">+    &#39;teal&#39;: (0, 128, 128),</span>
<span class="gi">+    &#39;thistle&#39;: (216, 191, 216),</span>
<span class="gi">+    &#39;tomato&#39;: (255, 99, 71),</span>
<span class="gi">+    &#39;turquoise&#39;: (64, 224, 208),</span>
<span class="gi">+    &#39;violet&#39;: (238, 130, 238),</span>
<span class="gi">+    &#39;wheat&#39;: (245, 222, 179),</span>
<span class="gi">+    &#39;white&#39;: (255, 255, 255),</span>
<span class="gi">+    &#39;whitesmoke&#39;: (245, 245, 245),</span>
<span class="gi">+    &#39;yellow&#39;: (255, 255, 0),</span>
<span class="gi">+    &#39;yellowgreen&#39;: (154, 205, 50),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>COLORS_BY_VALUE = {v: k for k, v in COLORS_BY_NAME.items()}
<span class="gh">diff --git a/pydantic/config.py b/pydantic/config.py</span>
<span class="gh">index 24abaf45f..87ab416fb 100644</span>
<span class="gd">--- a/pydantic/config.py</span>
<span class="gi">+++ b/pydantic/config.py</span>
<span class="gu">@@ -1,42 +1,62 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Configuration for Pydantic models.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Dict, List, Type, TypeVar, Union
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Literal, TypeAlias, TypedDict
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="w"> </span>from .aliases import AliasGenerator
<span class="w"> </span>from .errors import PydanticUserError
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ._internal._generate_schema import GenerateSchema as _GenerateSchema
<span class="w"> </span>    from .fields import ComputedFieldInfo, FieldInfo
<span class="gd">-__all__ = &#39;ConfigDict&#39;, &#39;with_config&#39;</span>
<span class="gd">-JsonValue: TypeAlias = Union[int, float, str, bool, None, List[&#39;JsonValue&#39;],</span>
<span class="gd">-    &#39;JsonDict&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;ConfigDict&#39;, &#39;with_config&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+JsonValue: TypeAlias = Union[int, float, str, bool, None, List[&#39;JsonValue&#39;], &#39;JsonDict&#39;]</span>
<span class="w"> </span>JsonDict: TypeAlias = Dict[str, JsonValue]
<span class="gi">+</span>
<span class="w"> </span>JsonEncoder = Callable[[Any], Any]
<span class="gd">-JsonSchemaExtraCallable: TypeAlias = Union[Callable[[JsonDict], None],</span>
<span class="gd">-    Callable[[JsonDict, Type[Any]], None]]</span>
<span class="gi">+</span>
<span class="gi">+JsonSchemaExtraCallable: TypeAlias = Union[</span>
<span class="gi">+    Callable[[JsonDict], None],</span>
<span class="gi">+    Callable[[JsonDict, Type[Any]], None],</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>ExtraValues = Literal[&#39;allow&#39;, &#39;ignore&#39;, &#39;forbid&#39;]


<span class="gd">-class ConfigDict(TypedDict, total=(False)):</span>
<span class="gi">+class ConfigDict(TypedDict, total=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;A TypedDict for configuring Pydantic behaviour.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    title: str | None
<span class="w"> </span>    &quot;&quot;&quot;The title for the generated JSON schema, defaults to the model&#39;s name&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    model_title_generator: Callable[[type], str] | None
<span class="w"> </span>    &quot;&quot;&quot;A callable that takes a model class and returns the title for it. Defaults to `None`.&quot;&quot;&quot;
<span class="gd">-    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str</span>
<span class="gd">-        ] | None</span>
<span class="gi">+</span>
<span class="gi">+    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None</span>
<span class="w"> </span>    &quot;&quot;&quot;A callable that takes a field&#39;s name and info and returns title for it. Defaults to `None`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    str_to_lower: bool
<span class="w"> </span>    &quot;&quot;&quot;Whether to convert all characters to lowercase for str types. Defaults to `False`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    str_to_upper: bool
<span class="w"> </span>    &quot;&quot;&quot;Whether to convert all characters to uppercase for str types. Defaults to `False`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    str_strip_whitespace: bool
<span class="w"> </span>    &quot;&quot;&quot;Whether to strip leading and trailing whitespace for str types.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    str_min_length: int
<span class="w"> </span>    &quot;&quot;&quot;The minimum length for str types. Defaults to `None`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    str_max_length: int | None
<span class="w"> </span>    &quot;&quot;&quot;The maximum length for str types. Defaults to `None`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    extra: ExtraValues | None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether to ignore, allow, or forbid extra attributes during model initialization. Defaults to `&#39;ignore&#39;`.
<span class="gu">@@ -107,6 +127,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    frozen: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether models are faux-immutable, i.e. whether `__setattr__` is allowed, and also generates
<span class="gu">@@ -116,6 +137,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    Note:
<span class="w"> </span>        On V1, the inverse of this setting was called `allow_mutation`, and was `True` by default.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    populate_by_name: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether an aliased field may be populated by its name as given by the model
<span class="gu">@@ -148,6 +170,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    2. The model is populated by the alias `&#39;full_name&#39;`.
<span class="w"> </span>    3. The model is populated by the field name `&#39;name&#39;`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    use_enum_values: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether to populate models with the `value` property of enums, rather than the raw enum.
<span class="gu">@@ -187,6 +210,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    #&gt; {&#39;some_enum&#39;: &#39;bar&#39;, &#39;another_enum&#39;: &#39;baz&#39;}
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    validate_assignment: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether to validate the data when the model is changed. Defaults to `False`.
<span class="gu">@@ -238,6 +262,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    2. The validation happens when the model is created.
<span class="w"> </span>    3. The validation _also_ happens when the data is changed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    arbitrary_types_allowed: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether arbitrary types are allowed for field types. Defaults to `False`.
<span class="gu">@@ -292,12 +317,15 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    #&gt; &lt;class &#39;__main__.Pet&#39;&gt;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    from_attributes: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether to build models and look up discriminators of tagged unions using python object attributes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    loc_by_alias: bool
<span class="w"> </span>    &quot;&quot;&quot;Whether to use the actual key provided in the data (e.g. alias) for error `loc`s rather than the field&#39;s name. Defaults to `True`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    alias_generator: Callable[[str], str] | AliasGenerator | None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A callable that takes a field name and returns an alias for it
<span class="gu">@@ -356,16 +384,20 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        Pydantic offers three built-in alias generators: [`to_pascal`][pydantic.alias_generators.to_pascal],
<span class="w"> </span>        [`to_camel`][pydantic.alias_generators.to_camel], and [`to_snake`][pydantic.alias_generators.to_snake].
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ignored_types: tuple[type, ...]
<span class="w"> </span>    &quot;&quot;&quot;A tuple of types that may occur as values of class attributes without annotations. This is
<span class="w"> </span>    typically used for custom descriptors (classes that behave like `property`). If an attribute is set on a
<span class="w"> </span>    class without an annotation and has a type that is not in this tuple (or otherwise recognized by
<span class="w"> </span>    _pydantic_), an error will be raised. Defaults to `()`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    allow_inf_nan: bool
<span class="w"> </span>    &quot;&quot;&quot;Whether to allow infinity (`+inf` an `-inf`) and NaN values to float fields. Defaults to `True`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None
<span class="w"> </span>    &quot;&quot;&quot;A dict or callable to provide extra JSON schema properties. Defaults to `None`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    json_encoders: dict[type[object], JsonEncoder] | None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A `dict` of custom JSON encoders for specific types. Defaults to `None`.
<span class="gu">@@ -375,6 +407,8 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        We originally planned to remove it in v2 but didn&#39;t have a 1:1 replacement so we are keeping it for now.
<span class="w"> </span>        It is still deprecated and will likely be removed in the future.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # new in V2</span>
<span class="w"> </span>    strict: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    _(new in V2)_ If `True`, strict validation is applied to all fields on the model.
<span class="gu">@@ -401,6 +435,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    See the [Conversion Table](../concepts/conversion_table.md) for more details on how Pydantic converts data in both
<span class="w"> </span>    strict and lax modes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    # whether instances of models and dataclasses (including subclass instances) should re-validate, default &#39;never&#39;</span>
<span class="w"> </span>    revalidate_instances: Literal[&#39;always&#39;, &#39;never&#39;, &#39;subclass-instances&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    When and how to revalidate models and dataclasses during validation. Accepts the string
<span class="gu">@@ -527,6 +562,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    2. This is not revalidated, since `my_user` is not a subclass of `User`.
<span class="w"> </span>    3. Using `&#39;never&#39;` we would have gotten `user=SubUser(hobbies=[&#39;scuba diving&#39;], sins=[&#39;lying&#39;])`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ser_json_timedelta: Literal[&#39;iso8601&#39;, &#39;float&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The format of JSON serialized timedeltas. Accepts the string values of `&#39;iso8601&#39;` and
<span class="gu">@@ -535,6 +571,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    - `&#39;iso8601&#39;` will serialize timedeltas to ISO 8601 durations.
<span class="w"> </span>    - `&#39;float&#39;` will serialize timedeltas to the total number of seconds.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ser_json_bytes: Literal[&#39;utf8&#39;, &#39;base64&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The encoding of JSON serialized bytes. Accepts the string values of `&#39;utf8&#39;` and `&#39;base64&#39;`.
<span class="gu">@@ -543,6 +580,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    - `&#39;utf8&#39;` will serialize bytes to UTF-8 strings.
<span class="w"> </span>    - `&#39;base64&#39;` will serialize bytes to URL safe base64 strings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ser_json_inf_nan: Literal[&#39;null&#39;, &#39;constants&#39;, &#39;strings&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The encoding of JSON serialized infinity and NaN float values. Defaults to `&#39;null&#39;`.
<span class="gu">@@ -551,10 +589,14 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    - `&#39;constants&#39;` will serialize infinity and NaN values as `Infinity` and `NaN`.
<span class="w"> </span>    - `&#39;strings&#39;` will serialize infinity as string `&quot;Infinity&quot;` and NaN as string `&quot;NaN&quot;`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # whether to validate default values during validation, default False</span>
<span class="w"> </span>    validate_default: bool
<span class="w"> </span>    &quot;&quot;&quot;Whether to validate default values during validation. Defaults to `False`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    validate_return: bool
<span class="w"> </span>    &quot;&quot;&quot;whether to validate the return value from call validators. Defaults to `False`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    protected_namespaces: tuple[str, ...]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A `tuple` of strings that prevent model to have field which conflict with them.
<span class="gu">@@ -630,6 +672,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    hide_input_in_errors: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether to hide inputs when printing errors. Defaults to `False`.
<span class="gu">@@ -673,6 +716,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    defer_build: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.
<span class="gu">@@ -690,6 +734,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        models in order for `defer_build=True` to take effect. This additional (experimental) parameter is required for
<span class="w"> </span>        the deferred building due to FastAPI relying on `TypeAdapter`s.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    experimental_defer_build_mode: tuple[Literal[&#39;model&#39;, &#39;type_adapter&#39;], ...]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Controls when [`defer_build`][pydantic.config.ConfigDict.defer_build] is applicable. Defaults to `(&#39;model&#39;,)`.
<span class="gu">@@ -704,11 +749,13 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        The `experimental_defer_build_mode` parameter is named with an underscore to suggest this is an experimental feature. It may
<span class="w"> </span>        be removed or changed in the future in a minor release.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    plugin_settings: dict[str, object] | None
<span class="w"> </span>    &quot;&quot;&quot;A `dict` of settings for plugins. Defaults to `None`.

<span class="w"> </span>    See [Pydantic Plugins](../concepts/plugins.md) for details.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    schema_generator: type[_GenerateSchema] | None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A custom core schema generator class to use when generating JSON schemas.
<span class="gu">@@ -718,6 +765,7 @@ class ConfigDict(TypedDict, total=(False)):</span>

<span class="w"> </span>    See [#6737](https://github.com/pydantic/pydantic/pull/6737) for details.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    json_schema_serialization_defaults_required: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether fields with default values should be marked as required in the serialization schema. Defaults to `False`.
<span class="gu">@@ -756,6 +804,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    json_schema_mode_override: Literal[&#39;validation&#39;, &#39;serialization&#39;, None]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    If not `None`, the specified mode will be used to generate the JSON schema regardless of what `mode` was passed to
<span class="gu">@@ -810,6 +859,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    coerce_numbers_to_str: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    If `True`, enables automatic coercion of any `Number` type to `str` in &quot;lax&quot; (non-strict) mode. Defaults to `False`.
<span class="gu">@@ -847,6 +897,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    #&gt; &quot;42.13&quot;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    regex_engine: Literal[&#39;rust-regex&#39;, &#39;python-re&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The regex engine to be used for pattern validation.
<span class="gu">@@ -883,6 +934,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    validation_error_cause: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    If `True`, Python exceptions that were part of a validation failure will be shown as an exception group as a cause. Can be useful for debugging. Defaults to `False`.
<span class="gu">@@ -893,8 +945,9 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>    Note:
<span class="w"> </span>        The structure of validation errors are likely to change in future Pydantic versions. Pydantic offers no guarantees about their structure. Should be used for visual traceback debugging only.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    use_attribute_docstrings: bool
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Whether docstrings of attributes (bare string literals immediately following the attribute declaration)
<span class="w"> </span>    should be used for field descriptions. Defaults to `False`.

<span class="gu">@@ -908,14 +961,14 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        model_config = ConfigDict(use_attribute_docstrings=True)

<span class="w"> </span>        x: str
<span class="gd">-        &quot;&quot;\&quot;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>        Example of an attribute docstring
<span class="gd">-        &quot;&quot;\&quot;</span>
<span class="gi">+        &quot;&quot;&quot;</span>

<span class="w"> </span>        y: int = Field(description=&quot;Description in Field&quot;)
<span class="gd">-        &quot;&quot;\&quot;</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>        Description in Field overrides attribute docstring
<span class="gd">-        &quot;&quot;\&quot;</span>
<span class="gi">+        &quot;&quot;&quot;</span>


<span class="w"> </span>    print(Model.model_fields[&quot;x&quot;].description)
<span class="gu">@@ -929,7 +982,8 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>        Due to current limitations, attribute docstrings detection may not work as expected when using `TypedDict`
<span class="w"> </span>        (in particular when multiple `TypedDict` classes have the same name in the same source file). The behavior
<span class="w"> </span>        can be different depending on the Python version used.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    cache_strings: bool | Literal[&#39;all&#39;, &#39;keys&#39;, &#39;none&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether to cache strings to avoid constructing new Python objects. Defaults to True.
<span class="gu">@@ -953,7 +1007,7 @@ class ConfigDict(TypedDict, total=(False)):</span>
<span class="w"> </span>_TypeT = TypeVar(&#39;_TypeT&#39;, bound=type)


<span class="gd">-def with_config(config: ConfigDict) -&gt;Callable[[_TypeT], _TypeT]:</span>
<span class="gi">+def with_config(config: ConfigDict) -&gt; Callable[[_TypeT], _TypeT]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/config/#configuration-with-dataclass-from-the-standard-library-or-typeddict

<span class="w"> </span>    A convenience decorator to set a [Pydantic configuration](config.md) on a `TypedDict` or a `dataclass` from the standard library.
<span class="gu">@@ -978,7 +1032,22 @@ def with_config(config: ConfigDict) -&gt;Callable[[_TypeT], _TypeT]:</span>
<span class="w"> </span>        #&gt; {&#39;x&#39;: &#39;abc&#39;}
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def inner(class_: _TypeT, /) -&gt; _TypeT:</span>
<span class="gi">+        # Ideally, we would check for `class_` to either be a `TypedDict` or a stdlib dataclass.</span>
<span class="gi">+        # However, the `@with_config` decorator can be applied *after* `@dataclass`. To avoid</span>
<span class="gi">+        # common mistakes, we at least check for `class_` to not be a Pydantic model.</span>
<span class="gi">+        from ._internal._utils import is_model_class</span>
<span class="gi">+</span>
<span class="gi">+        if is_model_class(class_):</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;Cannot use `with_config` on {class_.__name__} as it is a Pydantic model&#39;,</span>
<span class="gi">+                code=&#39;with-config-on-model&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+        class_.__pydantic_config__ = config</span>
<span class="gi">+        return class_</span>
<span class="gi">+</span>
<span class="gi">+    return inner</span>


<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/dataclasses.py b/pydantic/dataclasses.py</span>
<span class="gh">index cb2e2160b..acfd3d520 100644</span>
<span class="gd">--- a/pydantic/dataclasses.py</span>
<span class="gi">+++ b/pydantic/dataclasses.py</span>
<span class="gu">@@ -1,30 +1,112 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Provide an enhanced dataclass that performs validation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Generic, NoReturn, TypeVar, overload
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Literal, TypeGuard, dataclass_transform
<span class="gi">+</span>
<span class="w"> </span>from ._internal import _config, _decorators, _typing_extra
<span class="w"> </span>from ._internal import _dataclasses as _pydantic_dataclasses
<span class="w"> </span>from ._migration import getattr_migration
<span class="w"> </span>from .config import ConfigDict
<span class="w"> </span>from .errors import PydanticUserError
<span class="w"> </span>from .fields import Field, FieldInfo, PrivateAttr
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from ._internal._dataclasses import PydanticDataclass
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;dataclass&#39;, &#39;rebuild_dataclass&#39;
<span class="gi">+</span>
<span class="w"> </span>_T = TypeVar(&#39;_T&#39;)
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):

<span class="gi">+    @dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr))</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def dataclass(</span>
<span class="gi">+        *,</span>
<span class="gi">+        init: Literal[False] = False,</span>
<span class="gi">+        repr: bool = True,</span>
<span class="gi">+        eq: bool = True,</span>
<span class="gi">+        order: bool = False,</span>
<span class="gi">+        unsafe_hash: bool = False,</span>
<span class="gi">+        frozen: bool = False,</span>
<span class="gi">+        config: ConfigDict | type[object] | None = None,</span>
<span class="gi">+        validate_on_init: bool | None = None,</span>
<span class="gi">+        kw_only: bool = ...,</span>
<span class="gi">+        slots: bool = ...,</span>
<span class="gi">+    ) -&gt; Callable[[type[_T]], type[PydanticDataclass]]:  # type: ignore</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr))</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def dataclass(</span>
<span class="gi">+        _cls: type[_T],  # type: ignore</span>
<span class="gi">+        *,</span>
<span class="gi">+        init: Literal[False] = False,</span>
<span class="gi">+        repr: bool = True,</span>
<span class="gi">+        eq: bool = True,</span>
<span class="gi">+        order: bool = False,</span>
<span class="gi">+        unsafe_hash: bool = False,</span>
<span class="gi">+        frozen: bool = False,</span>
<span class="gi">+        config: ConfigDict | type[object] | None = None,</span>
<span class="gi">+        validate_on_init: bool | None = None,</span>
<span class="gi">+        kw_only: bool = ...,</span>
<span class="gi">+        slots: bool = ...,</span>
<span class="gi">+    ) -&gt; type[PydanticDataclass]: ...</span>
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    @dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr))</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def dataclass(</span>
<span class="gi">+        *,</span>
<span class="gi">+        init: Literal[False] = False,</span>
<span class="gi">+        repr: bool = True,</span>
<span class="gi">+        eq: bool = True,</span>
<span class="gi">+        order: bool = False,</span>
<span class="gi">+        unsafe_hash: bool = False,</span>
<span class="gi">+        frozen: bool = False,</span>
<span class="gi">+        config: ConfigDict | type[object] | None = None,</span>
<span class="gi">+        validate_on_init: bool | None = None,</span>
<span class="gi">+    ) -&gt; Callable[[type[_T]], type[PydanticDataclass]]:  # type: ignore</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr))</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def dataclass(</span>
<span class="gi">+        _cls: type[_T],  # type: ignore</span>
<span class="gi">+        *,</span>
<span class="gi">+        init: Literal[False] = False,</span>
<span class="gi">+        repr: bool = True,</span>
<span class="gi">+        eq: bool = True,</span>
<span class="gi">+        order: bool = False,</span>
<span class="gi">+        unsafe_hash: bool = False,</span>
<span class="gi">+        frozen: bool = False,</span>
<span class="gi">+        config: ConfigDict | type[object] | None = None,</span>
<span class="gi">+        validate_on_init: bool | None = None,</span>
<span class="gi">+    ) -&gt; type[PydanticDataclass]: ...</span>
<span class="gi">+</span>

<span class="w"> </span>@dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr))
<span class="gd">-def dataclass(_cls: (type[_T] | None)=None, *, init: Literal[False]=False,</span>
<span class="gd">-    repr: bool=True, eq: bool=True, order: bool=False, unsafe_hash: bool=</span>
<span class="gd">-    False, frozen: bool=False, config: (ConfigDict | type[object] | None)=</span>
<span class="gd">-    None, validate_on_init: (bool | None)=None, kw_only: bool=False, slots:</span>
<span class="gd">-    bool=False) -&gt;(Callable[[type[_T]], type[PydanticDataclass]] | type[</span>
<span class="gd">-    PydanticDataclass]):</span>
<span class="gi">+def dataclass(  # noqa: C901</span>
<span class="gi">+    _cls: type[_T] | None = None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    init: Literal[False] = False,</span>
<span class="gi">+    repr: bool = True,</span>
<span class="gi">+    eq: bool = True,</span>
<span class="gi">+    order: bool = False,</span>
<span class="gi">+    unsafe_hash: bool = False,</span>
<span class="gi">+    frozen: bool = False,</span>
<span class="gi">+    config: ConfigDict | type[object] | None = None,</span>
<span class="gi">+    validate_on_init: bool | None = None,</span>
<span class="gi">+    kw_only: bool = False,</span>
<span class="gi">+    slots: bool = False,</span>
<span class="gi">+) -&gt; Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/dataclasses/

<span class="w"> </span>    A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`,
<span class="gu">@@ -56,24 +138,150 @@ def dataclass(_cls: (type[_T] | None)=None, *, init: Literal[False]=False,</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert init is False, &#39;pydantic.dataclasses.dataclass only supports init=False&#39;</span>
<span class="gi">+    assert validate_on_init is not False, &#39;validate_on_init=False is no longer supported&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if sys.version_info &gt;= (3, 10):</span>
<span class="gi">+        kwargs = dict(kw_only=kw_only, slots=slots)</span>
<span class="gi">+    else:</span>
<span class="gi">+        kwargs = {}</span>
<span class="gi">+</span>
<span class="gi">+    def make_pydantic_fields_compatible(cls: type[Any]) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Make sure that stdlib `dataclasses` understands `Field` kwargs like `kw_only`</span>
<span class="gi">+        To do that, we simply change</span>
<span class="gi">+          `x: int = pydantic.Field(..., kw_only=True)`</span>
<span class="gi">+        into</span>
<span class="gi">+          `x: int = dataclasses.field(default=pydantic.Field(..., kw_only=True), kw_only=True)`</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        for annotation_cls in cls.__mro__:</span>
<span class="gi">+            # In Python &lt; 3.9, `__annotations__` might not be present if there are no fields.</span>
<span class="gi">+            # we therefore need to use `getattr` to avoid an `AttributeError`.</span>
<span class="gi">+            annotations = getattr(annotation_cls, &#39;__annotations__&#39;, [])</span>
<span class="gi">+            for field_name in annotations:</span>
<span class="gi">+                field_value = getattr(cls, field_name, None)</span>
<span class="gi">+                # Process only if this is an instance of `FieldInfo`.</span>
<span class="gi">+                if not isinstance(field_value, FieldInfo):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # Initialize arguments for the standard `dataclasses.field`.</span>
<span class="gi">+                field_args: dict = {&#39;default&#39;: field_value}</span>
<span class="gi">+</span>
<span class="gi">+                # Handle `kw_only` for Python 3.10+</span>
<span class="gi">+                if sys.version_info &gt;= (3, 10) and field_value.kw_only:</span>
<span class="gi">+                    field_args[&#39;kw_only&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+                # Set `repr` attribute if it&#39;s explicitly specified to be not `True`.</span>
<span class="gi">+                if field_value.repr is not True:</span>
<span class="gi">+                    field_args[&#39;repr&#39;] = field_value.repr</span>
<span class="gi">+</span>
<span class="gi">+                setattr(cls, field_name, dataclasses.field(**field_args))</span>
<span class="gi">+                # In Python 3.8, dataclasses checks cls.__dict__[&#39;__annotations__&#39;] for annotations,</span>
<span class="gi">+                # so we must make sure it&#39;s initialized before we add to it.</span>
<span class="gi">+                if cls.__dict__.get(&#39;__annotations__&#39;) is None:</span>
<span class="gi">+                    cls.__annotations__ = {}</span>
<span class="gi">+                cls.__annotations__[field_name] = annotations[field_name]</span>
<span class="gi">+</span>
<span class="gi">+    def create_dataclass(cls: type[Any]) -&gt; type[PydanticDataclass]:</span>
<span class="gi">+        &quot;&quot;&quot;Create a Pydantic dataclass from a regular dataclass.</span>
<span class="gi">+</span>
<span class="gi">+        Args:</span>
<span class="gi">+            cls: The class to create the Pydantic dataclass from.</span>
<span class="gi">+</span>
<span class="gi">+        Returns:</span>
<span class="gi">+            A Pydantic dataclass.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        from ._internal._utils import is_model_class</span>
<span class="gi">+</span>
<span class="gi">+        if is_model_class(cls):</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;Cannot create a Pydantic dataclass from {cls.__name__} as it is already a Pydantic model&#39;,</span>
<span class="gi">+                code=&#39;dataclass-on-model&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        original_cls = cls</span>
<span class="gi">+</span>
<span class="gi">+        config_dict = config</span>
<span class="gi">+        if config_dict is None:</span>
<span class="gi">+            # if not explicitly provided, read from the type</span>
<span class="gi">+            cls_config = getattr(cls, &#39;__pydantic_config__&#39;, None)</span>
<span class="gi">+            if cls_config is not None:</span>
<span class="gi">+                config_dict = cls_config</span>
<span class="gi">+        config_wrapper = _config.ConfigWrapper(config_dict)</span>
<span class="gi">+        decorators = _decorators.DecoratorInfos.build(cls)</span>
<span class="gi">+</span>
<span class="gi">+        # Keep track of the original __doc__ so that we can restore it after applying the dataclasses decorator</span>
<span class="gi">+        # Otherwise, classes with no __doc__ will have their signature added into the JSON schema description,</span>
<span class="gi">+        # since dataclasses.dataclass will set this as the __doc__</span>
<span class="gi">+        original_doc = cls.__doc__</span>
<span class="gi">+</span>
<span class="gi">+        if _pydantic_dataclasses.is_builtin_dataclass(cls):</span>
<span class="gi">+            # Don&#39;t preserve the docstring for vanilla dataclasses, as it may include the signature</span>
<span class="gi">+            # This matches v1 behavior, and there was an explicit test for it</span>
<span class="gi">+            original_doc = None</span>
<span class="gi">+</span>
<span class="gi">+            # We don&#39;t want to add validation to the existing std lib dataclass, so we will subclass it</span>
<span class="gi">+            #   If the class is generic, we need to make sure the subclass also inherits from Generic</span>
<span class="gi">+            #   with all the same parameters.</span>
<span class="gi">+            bases = (cls,)</span>
<span class="gi">+            if issubclass(cls, Generic):</span>
<span class="gi">+                generic_base = Generic[cls.__parameters__]  # type: ignore</span>
<span class="gi">+                bases = bases + (generic_base,)</span>
<span class="gi">+            cls = types.new_class(cls.__name__, bases)</span>
<span class="gi">+</span>
<span class="gi">+        make_pydantic_fields_compatible(cls)</span>
<span class="gi">+</span>
<span class="gi">+        cls = dataclasses.dataclass(  # type: ignore[call-overload]</span>
<span class="gi">+            cls,</span>
<span class="gi">+            # the value of init here doesn&#39;t affect anything except that it makes it easier to generate a signature</span>
<span class="gi">+            init=True,</span>
<span class="gi">+            repr=repr,</span>
<span class="gi">+            eq=eq,</span>
<span class="gi">+            order=order,</span>
<span class="gi">+            unsafe_hash=unsafe_hash,</span>
<span class="gi">+            frozen=frozen,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        cls.__pydantic_decorators__ = decorators  # type: ignore</span>
<span class="gi">+        cls.__doc__ = original_doc</span>
<span class="gi">+        cls.__module__ = original_cls.__module__</span>
<span class="gi">+        cls.__qualname__ = original_cls.__qualname__</span>
<span class="gi">+        pydantic_complete = _pydantic_dataclasses.complete_dataclass(</span>
<span class="gi">+            cls, config_wrapper, raise_errors=False, types_namespace=None</span>
<span class="gi">+        )</span>
<span class="gi">+        cls.__pydantic_complete__ = pydantic_complete  # type: ignore</span>
<span class="gi">+        return cls</span>
<span class="gi">+</span>
<span class="gi">+    if _cls is None:</span>
<span class="gi">+        return create_dataclass</span>
<span class="gi">+</span>
<span class="gi">+    return create_dataclass(_cls)</span>


<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gi">+</span>
<span class="w"> </span>if (3, 8) &lt;= sys.version_info &lt; (3, 11):
<span class="gi">+    # Monkeypatch dataclasses.InitVar so that typing doesn&#39;t error if it occurs as a type when evaluating type hints</span>
<span class="gi">+    # Starting in 3.11, typing.get_type_hints will not raise an error if the retrieved type hints are not callable.</span>

<span class="gd">-    def _call_initvar(*args: Any, **kwargs: Any) -&gt;NoReturn:</span>
<span class="gi">+    def _call_initvar(*args: Any, **kwargs: Any) -&gt; NoReturn:</span>
<span class="w"> </span>        &quot;&quot;&quot;This function does nothing but raise an error that is as similar as possible to what you&#39;d get
<span class="w"> </span>        if you were to try calling `InitVar[int]()` without this monkeypatch. The whole purpose is just
<span class="w"> </span>        to ensure typing._type_check does not error if the type hint evaluates to `InitVar[&lt;parameter&gt;]`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise TypeError(&quot;&#39;InitVar&#39; object is not callable&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    dataclasses.InitVar.__call__ = _call_initvar


<span class="gd">-def rebuild_dataclass(cls: type[PydanticDataclass], *, force: bool=False,</span>
<span class="gd">-    raise_errors: bool=True, _parent_namespace_depth: int=2,</span>
<span class="gd">-    _types_namespace: (dict[str, Any] | None)=None) -&gt;(bool | None):</span>
<span class="gi">+def rebuild_dataclass(</span>
<span class="gi">+    cls: type[PydanticDataclass],</span>
<span class="gi">+    *,</span>
<span class="gi">+    force: bool = False,</span>
<span class="gi">+    raise_errors: bool = True,</span>
<span class="gi">+    _parent_namespace_depth: int = 2,</span>
<span class="gi">+    _types_namespace: dict[str, Any] | None = None,</span>
<span class="gi">+) -&gt; bool | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to rebuild the pydantic-core schema for the dataclass.

<span class="w"> </span>    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
<span class="gu">@@ -92,11 +300,30 @@ def rebuild_dataclass(cls: type[PydanticDataclass], *, force: bool=False,</span>
<span class="w"> </span>        Returns `None` if the schema is already &quot;complete&quot; and rebuilding was not required.
<span class="w"> </span>        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not force and cls.__pydantic_complete__:</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        if _types_namespace is not None:</span>
<span class="gi">+            types_namespace: dict[str, Any] | None = _types_namespace.copy()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if _parent_namespace_depth &gt; 0:</span>
<span class="gi">+                frame_parent_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth) or {}</span>
<span class="gi">+                # Note: we may need to add something similar to cls.__pydantic_parent_namespace__ from BaseModel</span>
<span class="gi">+                #   here when implementing handling of recursive generics. See BaseModel.model_rebuild for reference.</span>
<span class="gi">+                types_namespace = frame_parent_ns</span>
<span class="gi">+            else:</span>
<span class="gi">+                types_namespace = {}</span>
<span class="gi">+</span>
<span class="gi">+            types_namespace = _typing_extra.get_cls_types_namespace(cls, types_namespace)</span>
<span class="gi">+        return _pydantic_dataclasses.complete_dataclass(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            _config.ConfigWrapper(cls.__pydantic_config__, check=False),</span>
<span class="gi">+            raise_errors=raise_errors,</span>
<span class="gi">+            types_namespace=types_namespace,</span>
<span class="gi">+        )</span>


<span class="gd">-def is_pydantic_dataclass(class_: type[Any], /) -&gt;TypeGuard[type[</span>
<span class="gd">-    PydanticDataclass]]:</span>
<span class="gi">+def is_pydantic_dataclass(class_: type[Any], /) -&gt; TypeGuard[type[PydanticDataclass]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Whether a class is a pydantic dataclass.

<span class="w"> </span>    Args:
<span class="gu">@@ -105,4 +332,7 @@ def is_pydantic_dataclass(class_: type[Any], /) -&gt;TypeGuard[type[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `True` if the class is a pydantic dataclass, `False` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return &#39;__pydantic_validator__&#39; in class_.__dict__ and dataclasses.is_dataclass(class_)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/pydantic/datetime_parse.py b/pydantic/datetime_parse.py</span>
<span class="gh">index c562404a1..53d52649e 100644</span>
<span class="gd">--- a/pydantic/datetime_parse.py</span>
<span class="gi">+++ b/pydantic/datetime_parse.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `datetime_parse` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/decorator.py b/pydantic/decorator.py</span>
<span class="gh">index 789184be3..0d97560c1 100644</span>
<span class="gd">--- a/pydantic/decorator.py</span>
<span class="gi">+++ b/pydantic/decorator.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `decorator` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/deprecated/class_validators.py b/pydantic/deprecated/class_validators.py</span>
<span class="gh">index 5ece7422d..aae33628d 100644</span>
<span class="gd">--- a/pydantic/deprecated/class_validators.py</span>
<span class="gi">+++ b/pydantic/deprecated/class_validators.py</span>
<span class="gu">@@ -1,84 +1,93 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Old `@validator` and `@root_validator` function validators from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>from functools import partial, partialmethod
<span class="w"> </span>from types import FunctionType
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, TypeVar, Union, overload
<span class="w"> </span>from warnings import warn
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Literal, Protocol, TypeAlias, deprecated
<span class="gi">+</span>
<span class="w"> </span>from .._internal import _decorators, _decorators_v1
<span class="w"> </span>from ..errors import PydanticUserError
<span class="w"> </span>from ..warnings import PydanticDeprecatedSince20
<span class="gd">-_ALLOW_REUSE_WARNING_MESSAGE = (</span>
<span class="gd">-    &#39;`allow_reuse` is deprecated and will be ignored; it should no longer be necessary&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-if TYPE_CHECKING:</span>

<span class="gi">+_ALLOW_REUSE_WARNING_MESSAGE = &#39;`allow_reuse` is deprecated and will be ignored; it should no longer be necessary&#39;</span>

<span class="gd">-    class _OnlyValueValidatorClsMethod(Protocol):</span>

<span class="gd">-        def __call__(self, __cls: Any, __value: Any) -&gt;Any:</span>
<span class="gd">-            ...</span>
<span class="gi">+if TYPE_CHECKING:</span>

<span class="gi">+    class _OnlyValueValidatorClsMethod(Protocol):</span>
<span class="gi">+        def __call__(self, __cls: Any, __value: Any) -&gt; Any: ...</span>

<span class="w"> </span>    class _V1ValidatorWithValuesClsMethod(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, __cls: Any, __value: Any, values: dict[str, Any]</span>
<span class="gd">-            ) -&gt;Any:</span>
<span class="gd">-            ...</span>
<span class="gd">-</span>
<span class="gi">+        def __call__(self, __cls: Any, __value: Any, values: dict[str, Any]) -&gt; Any: ...</span>

<span class="w"> </span>    class _V1ValidatorWithValuesKwOnlyClsMethod(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, __cls: Any, __value: Any, *, values: dict[str, Any]</span>
<span class="gd">-            ) -&gt;Any:</span>
<span class="gd">-            ...</span>
<span class="gd">-</span>
<span class="gi">+        def __call__(self, __cls: Any, __value: Any, *, values: dict[str, Any]) -&gt; Any: ...</span>

<span class="w"> </span>    class _V1ValidatorWithKwargsClsMethod(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, __cls: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gd">-            ...</span>
<span class="gd">-</span>
<span class="gi">+        def __call__(self, __cls: Any, **kwargs: Any) -&gt; Any: ...</span>

<span class="w"> </span>    class _V1ValidatorWithValuesAndKwargsClsMethod(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, __cls: Any, values: dict[str, Any], **kwargs: Any</span>
<span class="gd">-            ) -&gt;Any:</span>
<span class="gd">-            ...</span>
<span class="gd">-</span>
<span class="gi">+        def __call__(self, __cls: Any, values: dict[str, Any], **kwargs: Any) -&gt; Any: ...</span>

<span class="w"> </span>    class _V1RootValidatorClsMethod(Protocol):
<span class="gi">+        def __call__(</span>
<span class="gi">+            self, __cls: Any, __values: _decorators_v1.RootValidatorValues</span>
<span class="gi">+        ) -&gt; _decorators_v1.RootValidatorValues: ...</span>

<span class="gd">-        def __call__(self, __cls: Any, __values: _decorators_v1.</span>
<span class="gd">-            RootValidatorValues) -&gt;_decorators_v1.RootValidatorValues:</span>
<span class="gd">-            ...</span>
<span class="gd">-    V1Validator = Union[_OnlyValueValidatorClsMethod,</span>
<span class="gi">+    V1Validator = Union[</span>
<span class="gi">+        _OnlyValueValidatorClsMethod,</span>
<span class="w"> </span>        _V1ValidatorWithValuesClsMethod,
<span class="w"> </span>        _V1ValidatorWithValuesKwOnlyClsMethod,
<span class="w"> </span>        _V1ValidatorWithKwargsClsMethod,
<span class="gd">-        _V1ValidatorWithValuesAndKwargsClsMethod, _decorators_v1.</span>
<span class="gd">-        V1ValidatorWithValues, _decorators_v1.V1ValidatorWithValuesKwOnly,</span>
<span class="gd">-        _decorators_v1.V1ValidatorWithKwargs, _decorators_v1.</span>
<span class="gd">-        V1ValidatorWithValuesAndKwargs]</span>
<span class="gd">-    V1RootValidator = Union[_V1RootValidatorClsMethod, _decorators_v1.</span>
<span class="gd">-        V1RootValidatorFunction]</span>
<span class="gd">-    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any],</span>
<span class="gd">-        staticmethod[Any, Any], partialmethod[Any]]</span>
<span class="gd">-    _V1ValidatorType = TypeVar(&#39;_V1ValidatorType&#39;, V1Validator,</span>
<span class="gd">-        _PartialClsOrStaticMethod)</span>
<span class="gd">-    _V1RootValidatorFunctionType = TypeVar(&#39;_V1RootValidatorFunctionType&#39;,</span>
<span class="gd">-        _decorators_v1.V1RootValidatorFunction, _V1RootValidatorClsMethod,</span>
<span class="gd">-        _PartialClsOrStaticMethod)</span>
<span class="gi">+        _V1ValidatorWithValuesAndKwargsClsMethod,</span>
<span class="gi">+        _decorators_v1.V1ValidatorWithValues,</span>
<span class="gi">+        _decorators_v1.V1ValidatorWithValuesKwOnly,</span>
<span class="gi">+        _decorators_v1.V1ValidatorWithKwargs,</span>
<span class="gi">+        _decorators_v1.V1ValidatorWithValuesAndKwargs,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    V1RootValidator = Union[</span>
<span class="gi">+        _V1RootValidatorClsMethod,</span>
<span class="gi">+        _decorators_v1.V1RootValidatorFunction,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any]]</span>
<span class="gi">+</span>
<span class="gi">+    # Allow both a V1 (assumed pre=False) or V2 (assumed mode=&#39;after&#39;) validator</span>
<span class="gi">+    # We lie to type checkers and say we return the same thing we get</span>
<span class="gi">+    # but in reality we return a proxy object that _mostly_ behaves like the wrapped thing</span>
<span class="gi">+    _V1ValidatorType = TypeVar(&#39;_V1ValidatorType&#39;, V1Validator, _PartialClsOrStaticMethod)</span>
<span class="gi">+    _V1RootValidatorFunctionType = TypeVar(</span>
<span class="gi">+        &#39;_V1RootValidatorFunctionType&#39;,</span>
<span class="gi">+        _decorators_v1.V1RootValidatorFunction,</span>
<span class="gi">+        _V1RootValidatorClsMethod,</span>
<span class="gi">+        _PartialClsOrStaticMethod,</span>
<span class="gi">+    )</span>
<span class="w"> </span>else:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20


<span class="w"> </span>@deprecated(
<span class="gd">-    &#39;Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details&#39;</span>
<span class="gd">-    , category=None)</span>
<span class="gd">-def validator(__field: str, *fields: str, pre: bool=False, each_item: bool=</span>
<span class="gd">-    False, always: bool=False, check_fields: (bool | None)=None,</span>
<span class="gd">-    allow_reuse: bool=False) -&gt;Callable[[_V1ValidatorType], _V1ValidatorType]:</span>
<span class="gi">+    &#39;Pydantic V1 style `@validator` validators are deprecated.&#39;</span>
<span class="gi">+    &#39; You should migrate to Pydantic V2 style `@field_validator` validators,&#39;</span>
<span class="gi">+    &#39; see the migration guide for more details&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def validator(</span>
<span class="gi">+    __field: str,</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    pre: bool = False,</span>
<span class="gi">+    each_item: bool = False,</span>
<span class="gi">+    always: bool = False,</span>
<span class="gi">+    check_fields: bool | None = None,</span>
<span class="gi">+    allow_reuse: bool = False,</span>
<span class="gi">+) -&gt; Callable[[_V1ValidatorType], _V1ValidatorType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorate methods on the class indicating that they should be used to validate fields.

<span class="w"> </span>    Args:
<span class="gu">@@ -100,14 +109,104 @@ def validator(__field: str, *fields: str, pre: bool=False, each_item: bool=</span>
<span class="w"> </span>        Callable: A decorator that can be used to decorate a
<span class="w"> </span>            function to be used as a validator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warn(</span>
<span class="gi">+        &#39;Pydantic V1 style `@validator` validators are deprecated.&#39;</span>
<span class="gi">+        &#39; You should migrate to Pydantic V2 style `@field_validator` validators,&#39;</span>
<span class="gi">+        &#39; see the migration guide for more details&#39;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if allow_reuse is True:  # pragma: no cover</span>
<span class="gi">+        warn(_ALLOW_REUSE_WARNING_MESSAGE, DeprecationWarning)</span>
<span class="gi">+    fields = tuple((__field, *fields))</span>
<span class="gi">+    if isinstance(fields[0], FunctionType):</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            &#39;`@validator` should be used with fields and keyword arguments, not bare. &#39;</span>
<span class="gi">+            &quot;E.g. usage should be `@validator(&#39;&lt;field_name&gt;&#39;, ...)`&quot;,</span>
<span class="gi">+            code=&#39;validator-no-fields&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+    elif not all(isinstance(field, str) for field in fields):</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            &#39;`@validator` fields should be passed as separate string args. &#39;</span>
<span class="gi">+            &quot;E.g. usage should be `@validator(&#39;&lt;field_name_1&gt;&#39;, &#39;&lt;field_name_2&gt;&#39;, ...)`&quot;,</span>
<span class="gi">+            code=&#39;validator-invalid-fields&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    mode: Literal[&#39;before&#39;, &#39;after&#39;] = &#39;before&#39; if pre is True else &#39;after&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def dec(f: Any) -&gt; _decorators.PydanticDescriptorProxy[Any]:</span>
<span class="gi">+        if _decorators.is_instance_method_from_sig(f):</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;`@validator` cannot be applied to instance methods&#39;, code=&#39;validator-instance-method&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        # auto apply the @classmethod decorator</span>
<span class="gi">+        f = _decorators.ensure_classmethod_based_on_signature(f)</span>
<span class="gi">+        wrap = _decorators_v1.make_generic_v1_field_validator</span>
<span class="gi">+        validator_wrapper_info = _decorators.ValidatorDecoratorInfo(</span>
<span class="gi">+            fields=fields,</span>
<span class="gi">+            mode=mode,</span>
<span class="gi">+            each_item=each_item,</span>
<span class="gi">+            always=always,</span>
<span class="gi">+            check_fields=check_fields,</span>
<span class="gi">+        )</span>
<span class="gi">+        return _decorators.PydanticDescriptorProxy(f, validator_wrapper_info, shim=wrap)</span>
<span class="gi">+</span>
<span class="gi">+    return dec  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def root_validator(</span>
<span class="gi">+    *,</span>
<span class="gi">+    # if you don&#39;t specify `pre` the default is `pre=False`</span>
<span class="gi">+    # which means you need to specify `skip_on_failure=True`</span>
<span class="gi">+    skip_on_failure: Literal[True],</span>
<span class="gi">+    allow_reuse: bool = ...,</span>
<span class="gi">+) -&gt; Callable[</span>
<span class="gi">+    [_V1RootValidatorFunctionType],</span>
<span class="gi">+    _V1RootValidatorFunctionType,</span>
<span class="gi">+]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def root_validator(</span>
<span class="gi">+    *,</span>
<span class="gi">+    # if you specify `pre=True` then you don&#39;t need to specify</span>
<span class="gi">+    # `skip_on_failure`, in fact it is not allowed as an argument!</span>
<span class="gi">+    pre: Literal[True],</span>
<span class="gi">+    allow_reuse: bool = ...,</span>
<span class="gi">+) -&gt; Callable[</span>
<span class="gi">+    [_V1RootValidatorFunctionType],</span>
<span class="gi">+    _V1RootValidatorFunctionType,</span>
<span class="gi">+]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def root_validator(</span>
<span class="gi">+    *,</span>
<span class="gi">+    # if you explicitly specify `pre=False` then you</span>
<span class="gi">+    # MUST specify `skip_on_failure=True`</span>
<span class="gi">+    pre: Literal[False],</span>
<span class="gi">+    skip_on_failure: Literal[True],</span>
<span class="gi">+    allow_reuse: bool = ...,</span>
<span class="gi">+) -&gt; Callable[</span>
<span class="gi">+    [_V1RootValidatorFunctionType],</span>
<span class="gi">+    _V1RootValidatorFunctionType,</span>
<span class="gi">+]: ...</span>


<span class="w"> </span>@deprecated(
<span class="gd">-    &#39;Pydantic V1 style `@root_validator` validators are deprecated. You should migrate to Pydantic V2 style `@model_validator` validators, see the migration guide for more details&#39;</span>
<span class="gd">-    , category=None)</span>
<span class="gd">-def root_validator(*__args, pre: bool=False, skip_on_failure: bool=False,</span>
<span class="gd">-    allow_reuse: bool=False) -&gt;Any:</span>
<span class="gi">+    &#39;Pydantic V1 style `@root_validator` validators are deprecated.&#39;</span>
<span class="gi">+    &#39; You should migrate to Pydantic V2 style `@model_validator` validators,&#39;</span>
<span class="gi">+    &#39; see the migration guide for more details&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def root_validator(</span>
<span class="gi">+    *__args,</span>
<span class="gi">+    pre: bool = False,</span>
<span class="gi">+    skip_on_failure: bool = False,</span>
<span class="gi">+    allow_reuse: bool = False,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorate methods on a model indicating that they should be used to validate (and perhaps
<span class="w"> </span>    modify) data either before or after standard model parsing/validation is performed.

<span class="gu">@@ -122,4 +221,36 @@ def root_validator(*__args, pre: bool=False, skip_on_failure: bool=False,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Any: A decorator that can be used to decorate a function to be used as a root_validator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warn(</span>
<span class="gi">+        &#39;Pydantic V1 style `@root_validator` validators are deprecated.&#39;</span>
<span class="gi">+        &#39; You should migrate to Pydantic V2 style `@model_validator` validators,&#39;</span>
<span class="gi">+        &#39; see the migration guide for more details&#39;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if __args:</span>
<span class="gi">+        # Ensure a nice error is raised if someone attempts to use the bare decorator</span>
<span class="gi">+        return root_validator()(*__args)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    if allow_reuse is True:  # pragma: no cover</span>
<span class="gi">+        warn(_ALLOW_REUSE_WARNING_MESSAGE, DeprecationWarning)</span>
<span class="gi">+    mode: Literal[&#39;before&#39;, &#39;after&#39;] = &#39;before&#39; if pre is True else &#39;after&#39;</span>
<span class="gi">+    if pre is False and skip_on_failure is not True:</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            &#39;If you use `@root_validator` with pre=False (the default) you MUST specify `skip_on_failure=True`.&#39;</span>
<span class="gi">+            &#39; Note that `@root_validator` is deprecated and should be replaced with `@model_validator`.&#39;,</span>
<span class="gi">+            code=&#39;root-validator-pre-skip&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    wrap = partial(_decorators_v1.make_v1_generic_root_validator, pre=pre)</span>
<span class="gi">+</span>
<span class="gi">+    def dec(f: Callable[..., Any] | classmethod[Any, Any, Any] | staticmethod[Any, Any]) -&gt; Any:</span>
<span class="gi">+        if _decorators.is_instance_method_from_sig(f):</span>
<span class="gi">+            raise TypeError(&#39;`@root_validator` cannot be applied to instance methods&#39;)</span>
<span class="gi">+        # auto apply the @classmethod decorator</span>
<span class="gi">+        res = _decorators.ensure_classmethod_based_on_signature(f)</span>
<span class="gi">+        dec_info = _decorators.RootValidatorDecoratorInfo(mode=mode)</span>
<span class="gi">+        return _decorators.PydanticDescriptorProxy(res, dec_info, shim=wrap)</span>
<span class="gi">+</span>
<span class="gi">+    return dec</span>
<span class="gh">diff --git a/pydantic/deprecated/config.py b/pydantic/deprecated/config.py</span>
<span class="gh">index 32dda96fd..45400c658 100644</span>
<span class="gd">--- a/pydantic/deprecated/config.py</span>
<span class="gi">+++ b/pydantic/deprecated/config.py</span>
<span class="gu">@@ -1,29 +1,32 @@</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Literal, deprecated
<span class="gi">+</span>
<span class="w"> </span>from .._internal import _config
<span class="w"> </span>from ..warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>if not TYPE_CHECKING:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;BaseConfig&#39;, &#39;Extra&#39;


<span class="w"> </span>class _ConfigMetaclass(type):
<span class="gd">-</span>
<span class="gd">-    def __getattr__(self, item: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, item: str) -&gt; Any:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            obj = _config.config_defaults[item]
<span class="w"> </span>            warnings.warn(_config.DEPRECATION_MESSAGE, DeprecationWarning)
<span class="w"> </span>            return obj
<span class="w"> </span>        except KeyError as exc:
<span class="gd">-            raise AttributeError(</span>
<span class="gd">-                f&quot;type object &#39;{self.__name__}&#39; has no attribute {exc}&quot;</span>
<span class="gd">-                ) from exc</span>
<span class="gi">+            raise AttributeError(f&quot;type object &#39;{self.__name__}&#39; has no attribute {exc}&quot;) from exc</span>


<span class="gd">-@deprecated(&#39;BaseConfig is deprecated. Use the `pydantic.ConfigDict` instead.&#39;,</span>
<span class="gd">-    category=PydanticDeprecatedSince20)</span>
<span class="gi">+@deprecated(&#39;BaseConfig is deprecated. Use the `pydantic.ConfigDict` instead.&#39;, category=PydanticDeprecatedSince20)</span>
<span class="w"> </span>class BaseConfig(metaclass=_ConfigMetaclass):
<span class="w"> </span>    &quot;&quot;&quot;This class is only retained for backwards compatibility.

<span class="gu">@@ -31,7 +34,7 @@ class BaseConfig(metaclass=_ConfigMetaclass):</span>
<span class="w"> </span>        BaseConfig is deprecated. Use the [`pydantic.ConfigDict`][pydantic.ConfigDict] instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __getattr__(self, item: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, item: str) -&gt; Any:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            obj = super().__getattribute__(item)
<span class="w"> </span>            warnings.warn(_config.DEPRECATION_MESSAGE, DeprecationWarning)
<span class="gu">@@ -40,26 +43,29 @@ class BaseConfig(metaclass=_ConfigMetaclass):</span>
<span class="w"> </span>            try:
<span class="w"> </span>                return getattr(type(self), item)
<span class="w"> </span>            except AttributeError:
<span class="gi">+                # re-raising changes the displayed text to reflect that `self` is not a type</span>
<span class="w"> </span>                raise AttributeError(str(exc)) from exc

<span class="gd">-    def __init_subclass__(cls, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init_subclass__(cls, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        warnings.warn(_config.DEPRECATION_MESSAGE, DeprecationWarning)
<span class="w"> </span>        return super().__init_subclass__(**kwargs)


<span class="w"> </span>class _ExtraMeta(type):
<span class="gd">-</span>
<span class="gd">-    def __getattribute__(self, __name: str) -&gt;Any:</span>
<span class="gi">+    def __getattribute__(self, __name: str) -&gt; Any:</span>
<span class="gi">+        # The @deprecated decorator accesses other attributes, so we only emit a warning for the expected ones</span>
<span class="w"> </span>        if __name in {&#39;allow&#39;, &#39;ignore&#39;, &#39;forbid&#39;}:
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &quot;`pydantic.config.Extra` is deprecated, use literal values instead (e.g. `extra=&#39;allow&#39;`)&quot;</span>
<span class="gd">-                , DeprecationWarning, stacklevel=2)</span>
<span class="gi">+                &quot;`pydantic.config.Extra` is deprecated, use literal values instead (e.g. `extra=&#39;allow&#39;`)&quot;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        return super().__getattribute__(__name)


<span class="w"> </span>@deprecated(
<span class="gd">-    &quot;Extra is deprecated. Use literal values instead (e.g. `extra=&#39;allow&#39;`)&quot;,</span>
<span class="gd">-    category=PydanticDeprecatedSince20)</span>
<span class="gi">+    &quot;Extra is deprecated. Use literal values instead (e.g. `extra=&#39;allow&#39;`)&quot;, category=PydanticDeprecatedSince20</span>
<span class="gi">+)</span>
<span class="w"> </span>class Extra(metaclass=_ExtraMeta):
<span class="w"> </span>    allow: Literal[&#39;allow&#39;] = &#39;allow&#39;
<span class="w"> </span>    ignore: Literal[&#39;ignore&#39;] = &#39;ignore&#39;
<span class="gh">diff --git a/pydantic/deprecated/copy_internals.py b/pydantic/deprecated/copy_internals.py</span>
<span class="gh">index 6909df428..efe5de289 100644</span>
<span class="gd">--- a/pydantic/deprecated/copy_internals.py</span>
<span class="gi">+++ b/pydantic/deprecated/copy_internals.py</span>
<span class="gu">@@ -1,16 +1,224 @@</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import Any, Tuple
<span class="gi">+</span>
<span class="w"> </span>import typing_extensions
<span class="gd">-from .._internal import _model_construction, _typing_extra, _utils</span>
<span class="gi">+</span>
<span class="gi">+from .._internal import (</span>
<span class="gi">+    _model_construction,</span>
<span class="gi">+    _typing_extra,</span>
<span class="gi">+    _utils,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from .. import BaseModel
<span class="w"> </span>    from .._internal._utils import AbstractSetIntStr, MappingIntStrAny
<span class="gi">+</span>
<span class="w"> </span>    AnyClassMethod = classmethod[Any, Any, Any]
<span class="w"> </span>    TupleGenerator = typing.Generator[Tuple[str, Any], None, None]
<span class="w"> </span>    Model = typing.TypeVar(&#39;Model&#39;, bound=&#39;BaseModel&#39;)
<span class="gd">-    IncEx: typing_extensions.TypeAlias = (</span>
<span class="gd">-        &#39;set[int] | set[str] | dict[int, Any] | dict[str, Any] | None&#39;)</span>
<span class="gi">+    # should be `set[int] | set[str] | dict[int, IncEx] | dict[str, IncEx] | None`, but mypy can&#39;t cope</span>
<span class="gi">+    IncEx: typing_extensions.TypeAlias = &#39;set[int] | set[str] | dict[int, Any] | dict[str, Any] | None&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>_object_setattr = _model_construction.object_setattr
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _iter(</span>
<span class="gi">+    self: BaseModel,</span>
<span class="gi">+    to_dict: bool = False,</span>
<span class="gi">+    by_alias: bool = False,</span>
<span class="gi">+    include: AbstractSetIntStr | MappingIntStrAny | None = None,</span>
<span class="gi">+    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,</span>
<span class="gi">+    exclude_unset: bool = False,</span>
<span class="gi">+    exclude_defaults: bool = False,</span>
<span class="gi">+    exclude_none: bool = False,</span>
<span class="gi">+) -&gt; TupleGenerator:</span>
<span class="gi">+    # Merge field set excludes with explicit exclude parameter with explicit overriding field set options.</span>
<span class="gi">+    # The extra &quot;is not None&quot; guards are not logically necessary but optimizes performance for the simple case.</span>
<span class="gi">+    if exclude is not None:</span>
<span class="gi">+        exclude = _utils.ValueItems.merge(</span>
<span class="gi">+            {k: v.exclude for k, v in self.model_fields.items() if v.exclude is not None}, exclude</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if include is not None:</span>
<span class="gi">+        include = _utils.ValueItems.merge({k: True for k in self.model_fields}, include, intersect=True)</span>
<span class="gi">+</span>
<span class="gi">+    allowed_keys = _calculate_keys(self, include=include, exclude=exclude, exclude_unset=exclude_unset)  # type: ignore</span>
<span class="gi">+    if allowed_keys is None and not (to_dict or by_alias or exclude_unset or exclude_defaults or exclude_none):</span>
<span class="gi">+        # huge boost for plain _iter()</span>
<span class="gi">+        yield from self.__dict__.items()</span>
<span class="gi">+        if self.__pydantic_extra__:</span>
<span class="gi">+            yield from self.__pydantic_extra__.items()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    value_exclude = _utils.ValueItems(self, exclude) if exclude is not None else None</span>
<span class="gi">+    value_include = _utils.ValueItems(self, include) if include is not None else None</span>
<span class="gi">+</span>
<span class="gi">+    if self.__pydantic_extra__ is None:</span>
<span class="gi">+        items = self.__dict__.items()</span>
<span class="gi">+    else:</span>
<span class="gi">+        items = list(self.__dict__.items()) + list(self.__pydantic_extra__.items())</span>
<span class="gi">+</span>
<span class="gi">+    for field_key, v in items:</span>
<span class="gi">+        if (allowed_keys is not None and field_key not in allowed_keys) or (exclude_none and v is None):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if exclude_defaults:</span>
<span class="gi">+            try:</span>
<span class="gi">+                field = self.model_fields[field_key]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not field.is_required() and field.default == v:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+        if by_alias and field_key in self.model_fields:</span>
<span class="gi">+            dict_key = self.model_fields[field_key].alias or field_key</span>
<span class="gi">+        else:</span>
<span class="gi">+            dict_key = field_key</span>
<span class="gi">+</span>
<span class="gi">+        if to_dict or value_include or value_exclude:</span>
<span class="gi">+            v = _get_value(</span>
<span class="gi">+                type(self),</span>
<span class="gi">+                v,</span>
<span class="gi">+                to_dict=to_dict,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                include=value_include and value_include.for_element(field_key),</span>
<span class="gi">+                exclude=value_exclude and value_exclude.for_element(field_key),</span>
<span class="gi">+                exclude_unset=exclude_unset,</span>
<span class="gi">+                exclude_defaults=exclude_defaults,</span>
<span class="gi">+                exclude_none=exclude_none,</span>
<span class="gi">+            )</span>
<span class="gi">+        yield dict_key, v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _copy_and_set_values(</span>
<span class="gi">+    self: Model,</span>
<span class="gi">+    values: dict[str, Any],</span>
<span class="gi">+    fields_set: set[str],</span>
<span class="gi">+    extra: dict[str, Any] | None = None,</span>
<span class="gi">+    private: dict[str, Any] | None = None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    deep: bool,  # UP006</span>
<span class="gi">+) -&gt; Model:</span>
<span class="gi">+    if deep:</span>
<span class="gi">+        # chances of having empty dict here are quite low for using smart_deepcopy</span>
<span class="gi">+        values = deepcopy(values)</span>
<span class="gi">+        extra = deepcopy(extra)</span>
<span class="gi">+        private = deepcopy(private)</span>
<span class="gi">+</span>
<span class="gi">+    cls = self.__class__</span>
<span class="gi">+    m = cls.__new__(cls)</span>
<span class="gi">+    _object_setattr(m, &#39;__dict__&#39;, values)</span>
<span class="gi">+    _object_setattr(m, &#39;__pydantic_extra__&#39;, extra)</span>
<span class="gi">+    _object_setattr(m, &#39;__pydantic_fields_set__&#39;, fields_set)</span>
<span class="gi">+    _object_setattr(m, &#39;__pydantic_private__&#39;, private)</span>
<span class="gi">+</span>
<span class="gi">+    return m</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.no_type_check</span>
<span class="gi">+def _get_value(</span>
<span class="gi">+    cls: type[BaseModel],</span>
<span class="gi">+    v: Any,</span>
<span class="gi">+    to_dict: bool,</span>
<span class="gi">+    by_alias: bool,</span>
<span class="gi">+    include: AbstractSetIntStr | MappingIntStrAny | None,</span>
<span class="gi">+    exclude: AbstractSetIntStr | MappingIntStrAny | None,</span>
<span class="gi">+    exclude_unset: bool,</span>
<span class="gi">+    exclude_defaults: bool,</span>
<span class="gi">+    exclude_none: bool,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="gi">+    from .. import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(v, BaseModel):</span>
<span class="gi">+        if to_dict:</span>
<span class="gi">+            return v.model_dump(</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                exclude_unset=exclude_unset,</span>
<span class="gi">+                exclude_defaults=exclude_defaults,</span>
<span class="gi">+                include=include,  # type: ignore</span>
<span class="gi">+                exclude=exclude,  # type: ignore</span>
<span class="gi">+                exclude_none=exclude_none,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return v.copy(include=include, exclude=exclude)</span>
<span class="gi">+</span>
<span class="gi">+    value_exclude = _utils.ValueItems(v, exclude) if exclude else None</span>
<span class="gi">+    value_include = _utils.ValueItems(v, include) if include else None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(v, dict):</span>
<span class="gi">+        return {</span>
<span class="gi">+            k_: _get_value(</span>
<span class="gi">+                cls,</span>
<span class="gi">+                v_,</span>
<span class="gi">+                to_dict=to_dict,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                exclude_unset=exclude_unset,</span>
<span class="gi">+                exclude_defaults=exclude_defaults,</span>
<span class="gi">+                include=value_include and value_include.for_element(k_),</span>
<span class="gi">+                exclude=value_exclude and value_exclude.for_element(k_),</span>
<span class="gi">+                exclude_none=exclude_none,</span>
<span class="gi">+            )</span>
<span class="gi">+            for k_, v_ in v.items()</span>
<span class="gi">+            if (not value_exclude or not value_exclude.is_excluded(k_))</span>
<span class="gi">+            and (not value_include or value_include.is_included(k_))</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    elif _utils.sequence_like(v):</span>
<span class="gi">+        seq_args = (</span>
<span class="gi">+            _get_value(</span>
<span class="gi">+                cls,</span>
<span class="gi">+                v_,</span>
<span class="gi">+                to_dict=to_dict,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                exclude_unset=exclude_unset,</span>
<span class="gi">+                exclude_defaults=exclude_defaults,</span>
<span class="gi">+                include=value_include and value_include.for_element(i),</span>
<span class="gi">+                exclude=value_exclude and value_exclude.for_element(i),</span>
<span class="gi">+                exclude_none=exclude_none,</span>
<span class="gi">+            )</span>
<span class="gi">+            for i, v_ in enumerate(v)</span>
<span class="gi">+            if (not value_exclude or not value_exclude.is_excluded(i))</span>
<span class="gi">+            and (not value_include or value_include.is_included(i))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return v.__class__(*seq_args) if _typing_extra.is_namedtuple(v.__class__) else v.__class__(seq_args)</span>
<span class="gi">+</span>
<span class="gi">+    elif isinstance(v, Enum) and getattr(cls.model_config, &#39;use_enum_values&#39;, False):</span>
<span class="gi">+        return v.value</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _calculate_keys(</span>
<span class="gi">+    self: BaseModel,</span>
<span class="gi">+    include: MappingIntStrAny | None,</span>
<span class="gi">+    exclude: MappingIntStrAny | None,</span>
<span class="gi">+    exclude_unset: bool,</span>
<span class="gi">+    update: typing.Dict[str, Any] | None = None,  # noqa UP006</span>
<span class="gi">+) -&gt; typing.AbstractSet[str] | None:</span>
<span class="gi">+    if include is None and exclude is None and exclude_unset is False:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    keys: typing.AbstractSet[str]</span>
<span class="gi">+    if exclude_unset:</span>
<span class="gi">+        keys = self.__pydantic_fields_set__.copy()</span>
<span class="gi">+    else:</span>
<span class="gi">+        keys = set(self.__dict__.keys())</span>
<span class="gi">+        keys = keys | (self.__pydantic_extra__ or {}).keys()</span>
<span class="gi">+</span>
<span class="gi">+    if include is not None:</span>
<span class="gi">+        keys &amp;= include.keys()</span>
<span class="gi">+</span>
<span class="gi">+    if update:</span>
<span class="gi">+        keys -= update.keys()</span>
<span class="gi">+</span>
<span class="gi">+    if exclude:</span>
<span class="gi">+        keys -= {k for k, v in exclude.items() if _utils.ValueItems.is_true(v)}</span>
<span class="gi">+</span>
<span class="gi">+    return keys</span>
<span class="gh">diff --git a/pydantic/deprecated/decorator.py b/pydantic/deprecated/decorator.py</span>
<span class="gh">index 6be076d95..0c0ea7445 100644</span>
<span class="gd">--- a/pydantic/deprecated/decorator.py</span>
<span class="gi">+++ b/pydantic/deprecated/decorator.py</span>
<span class="gu">@@ -1,29 +1,69 @@</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from functools import wraps
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, overload
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import deprecated
<span class="gi">+</span>
<span class="w"> </span>from .._internal import _config, _typing_extra
<span class="w"> </span>from ..alias_generators import to_pascal
<span class="w"> </span>from ..errors import PydanticUserError
<span class="w"> </span>from ..functional_validators import field_validator
<span class="w"> </span>from ..main import BaseModel, create_model
<span class="w"> </span>from ..warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>if not TYPE_CHECKING:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20
<span class="gd">-__all__ = &#39;validate_arguments&#39;,</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;validate_arguments&#39;,)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    AnyCallable = Callable[..., Any]
<span class="gi">+</span>
<span class="w"> </span>    AnyCallableT = TypeVar(&#39;AnyCallableT&#39;, bound=AnyCallable)
<span class="w"> </span>    ConfigType = Union[None, Type[Any], Dict[str, Any]]


<span class="gi">+@overload</span>
<span class="gi">+def validate_arguments(</span>
<span class="gi">+    func: None = None, *, config: &#39;ConfigType&#39; = None</span>
<span class="gi">+) -&gt; Callable[[&#39;AnyCallableT&#39;], &#39;AnyCallableT&#39;]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def validate_arguments(func: &#39;AnyCallableT&#39;) -&gt; &#39;AnyCallableT&#39;: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@deprecated(
<span class="gd">-    &#39;The `validate_arguments` method is deprecated; use `validate_call` instead.&#39;</span>
<span class="gd">-    , category=None)</span>
<span class="gd">-def validate_arguments(func: Optional[&#39;AnyCallableT&#39;]=None, *, config:</span>
<span class="gd">-    &#39;ConfigType&#39;=None) -&gt;Any:</span>
<span class="gi">+    &#39;The `validate_arguments` method is deprecated; use `validate_call` instead.&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def validate_arguments(func: Optional[&#39;AnyCallableT&#39;] = None, *, config: &#39;ConfigType&#39; = None) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator to validate the arguments passed to a function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &#39;The `validate_arguments` method is deprecated; use `validate_call` instead.&#39;,</span>
<span class="gi">+        PydanticDeprecatedSince20,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def validate(_func: &#39;AnyCallable&#39;) -&gt; &#39;AnyCallable&#39;:</span>
<span class="gi">+        vd = ValidatedFunction(_func, config)</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(_func)</span>
<span class="gi">+        def wrapper_function(*args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+            return vd.call(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        wrapper_function.vd = vd  # type: ignore</span>
<span class="gi">+        wrapper_function.validate = vd.init_model_instance  # type: ignore</span>
<span class="gi">+        wrapper_function.raw_function = vd.raw_function  # type: ignore</span>
<span class="gi">+        wrapper_function.model = vd.model  # type: ignore</span>
<span class="gi">+        return wrapper_function</span>
<span class="gi">+</span>
<span class="gi">+    if func:</span>
<span class="gi">+        return validate(func)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return validate</span>


<span class="w"> </span>ALT_V_ARGS = &#39;v__args&#39;
<span class="gu">@@ -33,22 +73,25 @@ V_DUPLICATE_KWARGS = &#39;v__duplicate_kwargs&#39;</span>


<span class="w"> </span>class ValidatedFunction:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, function: &#39;AnyCallable&#39;, config: &#39;ConfigType&#39;):
<span class="w"> </span>        from inspect import Parameter, signature
<span class="gi">+</span>
<span class="w"> </span>        parameters: Mapping[str, Parameter] = signature(function).parameters
<span class="gd">-        if parameters.keys() &amp; {ALT_V_ARGS, ALT_V_KWARGS,</span>
<span class="gd">-            V_POSITIONAL_ONLY_NAME, V_DUPLICATE_KWARGS}:</span>
<span class="gi">+</span>
<span class="gi">+        if parameters.keys() &amp; {ALT_V_ARGS, ALT_V_KWARGS, V_POSITIONAL_ONLY_NAME, V_DUPLICATE_KWARGS}:</span>
<span class="w"> </span>            raise PydanticUserError(
<span class="gd">-                f&#39;&quot;{ALT_V_ARGS}&quot;, &quot;{ALT_V_KWARGS}&quot;, &quot;{V_POSITIONAL_ONLY_NAME}&quot; and &quot;{V_DUPLICATE_KWARGS}&quot; are not permitted as argument names when using the &quot;{validate_arguments.__name__}&quot; decorator&#39;</span>
<span class="gd">-                , code=None)</span>
<span class="gi">+                f&#39;&quot;{ALT_V_ARGS}&quot;, &quot;{ALT_V_KWARGS}&quot;, &quot;{V_POSITIONAL_ONLY_NAME}&quot; and &quot;{V_DUPLICATE_KWARGS}&quot; &#39;</span>
<span class="gi">+                f&#39;are not permitted as argument names when using the &quot;{validate_arguments.__name__}&quot; decorator&#39;,</span>
<span class="gi">+                code=None,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.raw_function = function
<span class="w"> </span>        self.arg_mapping: Dict[int, str] = {}
<span class="w"> </span>        self.positional_only_args: set[str] = set()
<span class="w"> </span>        self.v_args_name = &#39;args&#39;
<span class="w"> </span>        self.v_kwargs_name = &#39;kwargs&#39;
<span class="gd">-        type_hints = _typing_extra.get_type_hints(function, include_extras=True</span>
<span class="gd">-            )</span>
<span class="gi">+</span>
<span class="gi">+        type_hints = _typing_extra.get_type_hints(function, include_extras=True)</span>
<span class="w"> </span>        takes_args = False
<span class="w"> </span>        takes_kwargs = False
<span class="w"> </span>        fields: Dict[str, Tuple[Any, Any]] = {}
<span class="gu">@@ -57,6 +100,7 @@ class ValidatedFunction:</span>
<span class="w"> </span>                annotation = Any
<span class="w"> </span>            else:
<span class="w"> </span>                annotation = type_hints[name]
<span class="gi">+</span>
<span class="w"> </span>            default = ... if p.default is p.empty else p.default
<span class="w"> </span>            if p.kind == Parameter.POSITIONAL_ONLY:
<span class="w"> </span>                self.arg_mapping[i] = name
<span class="gu">@@ -78,12 +122,158 @@ class ValidatedFunction:</span>
<span class="w"> </span>                self.v_kwargs_name = name
<span class="w"> </span>                fields[name] = Dict[str, annotation], None
<span class="w"> </span>                takes_kwargs = True
<span class="gi">+</span>
<span class="gi">+        # these checks avoid a clash between &quot;args&quot; and a field with that name</span>
<span class="w"> </span>        if not takes_args and self.v_args_name in fields:
<span class="w"> </span>            self.v_args_name = ALT_V_ARGS
<span class="gi">+</span>
<span class="gi">+        # same with &quot;kwargs&quot;</span>
<span class="w"> </span>        if not takes_kwargs and self.v_kwargs_name in fields:
<span class="w"> </span>            self.v_kwargs_name = ALT_V_KWARGS
<span class="gi">+</span>
<span class="w"> </span>        if not takes_args:
<span class="gi">+            # we add the field so validation below can raise the correct exception</span>
<span class="w"> </span>            fields[self.v_args_name] = List[Any], None
<span class="gi">+</span>
<span class="w"> </span>        if not takes_kwargs:
<span class="gi">+            # same with kwargs</span>
<span class="w"> </span>            fields[self.v_kwargs_name] = Dict[Any, Any], None
<span class="gi">+</span>
<span class="w"> </span>        self.create_model(fields, takes_args, takes_kwargs, config)
<span class="gi">+</span>
<span class="gi">+    def init_model_instance(self, *args: Any, **kwargs: Any) -&gt; BaseModel:</span>
<span class="gi">+        values = self.build_values(args, kwargs)</span>
<span class="gi">+        return self.model(**values)</span>
<span class="gi">+</span>
<span class="gi">+    def call(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+        m = self.init_model_instance(*args, **kwargs)</span>
<span class="gi">+        return self.execute(m)</span>
<span class="gi">+</span>
<span class="gi">+    def build_values(self, args: Tuple[Any, ...], kwargs: Dict[str, Any]) -&gt; Dict[str, Any]:</span>
<span class="gi">+        values: Dict[str, Any] = {}</span>
<span class="gi">+        if args:</span>
<span class="gi">+            arg_iter = enumerate(args)</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    i, a = next(arg_iter)</span>
<span class="gi">+                except StopIteration:</span>
<span class="gi">+                    break</span>
<span class="gi">+                arg_name = self.arg_mapping.get(i)</span>
<span class="gi">+                if arg_name is not None:</span>
<span class="gi">+                    values[arg_name] = a</span>
<span class="gi">+                else:</span>
<span class="gi">+                    values[self.v_args_name] = [a] + [a for _, a in arg_iter]</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        var_kwargs: Dict[str, Any] = {}</span>
<span class="gi">+        wrong_positional_args = []</span>
<span class="gi">+        duplicate_kwargs = []</span>
<span class="gi">+        fields_alias = [</span>
<span class="gi">+            field.alias</span>
<span class="gi">+            for name, field in self.model.model_fields.items()</span>
<span class="gi">+            if name not in (self.v_args_name, self.v_kwargs_name)</span>
<span class="gi">+        ]</span>
<span class="gi">+        non_var_fields = set(self.model.model_fields) - {self.v_args_name, self.v_kwargs_name}</span>
<span class="gi">+        for k, v in kwargs.items():</span>
<span class="gi">+            if k in non_var_fields or k in fields_alias:</span>
<span class="gi">+                if k in self.positional_only_args:</span>
<span class="gi">+                    wrong_positional_args.append(k)</span>
<span class="gi">+                if k in values:</span>
<span class="gi">+                    duplicate_kwargs.append(k)</span>
<span class="gi">+                values[k] = v</span>
<span class="gi">+            else:</span>
<span class="gi">+                var_kwargs[k] = v</span>
<span class="gi">+</span>
<span class="gi">+        if var_kwargs:</span>
<span class="gi">+            values[self.v_kwargs_name] = var_kwargs</span>
<span class="gi">+        if wrong_positional_args:</span>
<span class="gi">+            values[V_POSITIONAL_ONLY_NAME] = wrong_positional_args</span>
<span class="gi">+        if duplicate_kwargs:</span>
<span class="gi">+            values[V_DUPLICATE_KWARGS] = duplicate_kwargs</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    def execute(self, m: BaseModel) -&gt; Any:</span>
<span class="gi">+        d = {k: v for k, v in m.__dict__.items() if k in m.__pydantic_fields_set__ or m.model_fields[k].default_factory}</span>
<span class="gi">+        var_kwargs = d.pop(self.v_kwargs_name, {})</span>
<span class="gi">+</span>
<span class="gi">+        if self.v_args_name in d:</span>
<span class="gi">+            args_: List[Any] = []</span>
<span class="gi">+            in_kwargs = False</span>
<span class="gi">+            kwargs = {}</span>
<span class="gi">+            for name, value in d.items():</span>
<span class="gi">+                if in_kwargs:</span>
<span class="gi">+                    kwargs[name] = value</span>
<span class="gi">+                elif name == self.v_args_name:</span>
<span class="gi">+                    args_ += value</span>
<span class="gi">+                    in_kwargs = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    args_.append(value)</span>
<span class="gi">+            return self.raw_function(*args_, **kwargs, **var_kwargs)</span>
<span class="gi">+        elif self.positional_only_args:</span>
<span class="gi">+            args_ = []</span>
<span class="gi">+            kwargs = {}</span>
<span class="gi">+            for name, value in d.items():</span>
<span class="gi">+                if name in self.positional_only_args:</span>
<span class="gi">+                    args_.append(value)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    kwargs[name] = value</span>
<span class="gi">+            return self.raw_function(*args_, **kwargs, **var_kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.raw_function(**d, **var_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def create_model(self, fields: Dict[str, Any], takes_args: bool, takes_kwargs: bool, config: &#39;ConfigType&#39;) -&gt; None:</span>
<span class="gi">+        pos_args = len(self.arg_mapping)</span>
<span class="gi">+</span>
<span class="gi">+        config_wrapper = _config.ConfigWrapper(config)</span>
<span class="gi">+</span>
<span class="gi">+        if config_wrapper.alias_generator:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;Setting the &quot;alias_generator&quot; property on custom Config for &#39;</span>
<span class="gi">+                &#39;@validate_arguments is not yet supported, please remove.&#39;,</span>
<span class="gi">+                code=None,</span>
<span class="gi">+            )</span>
<span class="gi">+        if config_wrapper.extra is None:</span>
<span class="gi">+            config_wrapper.config_dict[&#39;extra&#39;] = &#39;forbid&#39;</span>
<span class="gi">+</span>
<span class="gi">+        class DecoratorBaseModel(BaseModel):</span>
<span class="gi">+            @field_validator(self.v_args_name, check_fields=False)</span>
<span class="gi">+            @classmethod</span>
<span class="gi">+            def check_args(cls, v: Optional[List[Any]]) -&gt; Optional[List[Any]]:</span>
<span class="gi">+                if takes_args or v is None:</span>
<span class="gi">+                    return v</span>
<span class="gi">+</span>
<span class="gi">+                raise TypeError(f&#39;{pos_args} positional arguments expected but {pos_args + len(v)} given&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            @field_validator(self.v_kwargs_name, check_fields=False)</span>
<span class="gi">+            @classmethod</span>
<span class="gi">+            def check_kwargs(cls, v: Optional[Dict[str, Any]]) -&gt; Optional[Dict[str, Any]]:</span>
<span class="gi">+                if takes_kwargs or v is None:</span>
<span class="gi">+                    return v</span>
<span class="gi">+</span>
<span class="gi">+                plural = &#39;&#39; if len(v) == 1 else &#39;s&#39;</span>
<span class="gi">+                keys = &#39;, &#39;.join(map(repr, v.keys()))</span>
<span class="gi">+                raise TypeError(f&#39;unexpected keyword argument{plural}: {keys}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            @field_validator(V_POSITIONAL_ONLY_NAME, check_fields=False)</span>
<span class="gi">+            @classmethod</span>
<span class="gi">+            def check_positional_only(cls, v: Optional[List[str]]) -&gt; None:</span>
<span class="gi">+                if v is None:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                plural = &#39;&#39; if len(v) == 1 else &#39;s&#39;</span>
<span class="gi">+                keys = &#39;, &#39;.join(map(repr, v))</span>
<span class="gi">+                raise TypeError(f&#39;positional-only argument{plural} passed as keyword argument{plural}: {keys}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            @field_validator(V_DUPLICATE_KWARGS, check_fields=False)</span>
<span class="gi">+            @classmethod</span>
<span class="gi">+            def check_duplicate_kwargs(cls, v: Optional[List[str]]) -&gt; None:</span>
<span class="gi">+                if v is None:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                plural = &#39;&#39; if len(v) == 1 else &#39;s&#39;</span>
<span class="gi">+                keys = &#39;, &#39;.join(map(repr, v))</span>
<span class="gi">+                raise TypeError(f&#39;multiple values for argument{plural}: {keys}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            model_config = config_wrapper.config_dict</span>
<span class="gi">+</span>
<span class="gi">+        self.model = create_model(to_pascal(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)</span>
<span class="gh">diff --git a/pydantic/deprecated/json.py b/pydantic/deprecated/json.py</span>
<span class="gh">index 062beef97..9ba5256cf 100644</span>
<span class="gd">--- a/pydantic/deprecated/json.py</span>
<span class="gi">+++ b/pydantic/deprecated/json.py</span>
<span class="gu">@@ -9,17 +9,27 @@ from re import Pattern</span>
<span class="w"> </span>from types import GeneratorType
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Dict, Type, Union
<span class="w"> </span>from uuid import UUID
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import deprecated
<span class="gi">+</span>
<span class="w"> </span>from ..color import Color
<span class="w"> </span>from ..networks import NameEmail
<span class="w"> </span>from ..types import SecretBytes, SecretStr
<span class="w"> </span>from ..warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>if not TYPE_CHECKING:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;pydantic_encoder&#39;, &#39;custom_pydantic_encoder&#39;, &#39;timedelta_isoformat&#39;


<span class="gd">-def decimal_encoder(dec_value: Decimal) -&gt;Union[int, float]:</span>
<span class="gi">+def isoformat(o: Union[datetime.date, datetime.time]) -&gt; str:</span>
<span class="gi">+    return o.isoformat()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def decimal_encoder(dec_value: Decimal) -&gt; Union[int, float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Encodes a Decimal as int of there&#39;s no exponent, otherwise float.

<span class="w"> </span>    This is useful when we use ConstrainedDecimal to represent Numeric(x,0)
<span class="gu">@@ -33,20 +43,98 @@ def decimal_encoder(dec_value: Decimal) -&gt;Union[int, float]:</span>
<span class="w"> </span>    &gt;&gt;&gt; decimal_encoder(Decimal(&quot;1&quot;))
<span class="w"> </span>    1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exponent = dec_value.as_tuple().exponent</span>
<span class="gi">+    if isinstance(exponent, int) and exponent &gt;= 0:</span>
<span class="gi">+        return int(dec_value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return float(dec_value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {</span>
<span class="gi">+    bytes: lambda o: o.decode(),</span>
<span class="gi">+    Color: str,</span>
<span class="gi">+    datetime.date: isoformat,</span>
<span class="gi">+    datetime.datetime: isoformat,</span>
<span class="gi">+    datetime.time: isoformat,</span>
<span class="gi">+    datetime.timedelta: lambda td: td.total_seconds(),</span>
<span class="gi">+    Decimal: decimal_encoder,</span>
<span class="gi">+    Enum: lambda o: o.value,</span>
<span class="gi">+    frozenset: list,</span>
<span class="gi">+    deque: list,</span>
<span class="gi">+    GeneratorType: list,</span>
<span class="gi">+    IPv4Address: str,</span>
<span class="gi">+    IPv4Interface: str,</span>
<span class="gi">+    IPv4Network: str,</span>
<span class="gi">+    IPv6Address: str,</span>
<span class="gi">+    IPv6Interface: str,</span>
<span class="gi">+    IPv6Network: str,</span>
<span class="gi">+    NameEmail: str,</span>
<span class="gi">+    Path: str,</span>
<span class="gi">+    Pattern: lambda o: o.pattern,</span>
<span class="gi">+    SecretBytes: str,</span>
<span class="gi">+    SecretStr: str,</span>
<span class="gi">+    set: list,</span>
<span class="gi">+    UUID: str,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@deprecated(</span>
<span class="gi">+    &#39;`pydantic_encoder` is deprecated, use `pydantic_core.to_jsonable_python` instead.&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def pydantic_encoder(obj: Any) -&gt; Any:</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &#39;`pydantic_encoder` is deprecated, use `pydantic_core.to_jsonable_python` instead.&#39;,</span>
<span class="gi">+        category=PydanticDeprecatedSince20,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    from dataclasses import asdict, is_dataclass</span>
<span class="gi">+</span>
<span class="gi">+    from ..main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(obj, BaseModel):</span>
<span class="gi">+        return obj.model_dump()</span>
<span class="gi">+    elif is_dataclass(obj):</span>
<span class="gi">+        return asdict(obj)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    # Check the class type and its superclasses for a matching encoder</span>
<span class="gi">+    for base in obj.__class__.__mro__[:-1]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            encoder = ENCODERS_BY_TYPE[base]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        return encoder(obj)</span>
<span class="gi">+    else:  # We have exited the for loop without finding a suitable encoder</span>
<span class="gi">+        raise TypeError(f&quot;Object of type &#39;{obj.__class__.__name__}&#39; is not JSON serializable&quot;)</span>
<span class="gi">+</span>

<span class="gi">+# TODO: Add a suggested migration path once there is a way to use custom encoders</span>
<span class="gi">+@deprecated(</span>
<span class="gi">+    &#39;`custom_pydantic_encoder` is deprecated, use `BaseModel.model_dump` instead.&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def custom_pydantic_encoder(type_encoders: Dict[Any, Callable[[Type[Any]], Any]], obj: Any) -&gt; Any:</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &#39;`custom_pydantic_encoder` is deprecated, use `BaseModel.model_dump` instead.&#39;,</span>
<span class="gi">+        category=PydanticDeprecatedSince20,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    # Check the class type and its superclasses for a matching encoder</span>
<span class="gi">+    for base in obj.__class__.__mro__[:-1]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            encoder = type_encoders[base]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>

<span class="gd">-ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {bytes: lambda o:</span>
<span class="gd">-    o.decode(), Color: str, datetime.date: isoformat, datetime.datetime:</span>
<span class="gd">-    isoformat, datetime.time: isoformat, datetime.timedelta: lambda td: td.</span>
<span class="gd">-    total_seconds(), Decimal: decimal_encoder, Enum: lambda o: o.value,</span>
<span class="gd">-    frozenset: list, deque: list, GeneratorType: list, IPv4Address: str,</span>
<span class="gd">-    IPv4Interface: str, IPv4Network: str, IPv6Address: str, IPv6Interface:</span>
<span class="gd">-    str, IPv6Network: str, NameEmail: str, Path: str, Pattern: lambda o: o.</span>
<span class="gd">-    pattern, SecretBytes: str, SecretStr: str, set: list, UUID: str}</span>
<span class="gi">+        return encoder(obj)</span>
<span class="gi">+    else:  # We have exited the for loop without finding a suitable encoder</span>
<span class="gi">+        return pydantic_encoder(obj)</span>


<span class="w"> </span>@deprecated(&#39;`timedelta_isoformat` is deprecated.&#39;, category=None)
<span class="gd">-def timedelta_isoformat(td: datetime.timedelta) -&gt;str:</span>
<span class="gi">+def timedelta_isoformat(td: datetime.timedelta) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;ISO 8601 encoding for Python timedelta object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(&#39;`timedelta_isoformat` is deprecated.&#39;, category=PydanticDeprecatedSince20, stacklevel=2)</span>
<span class="gi">+    minutes, seconds = divmod(td.seconds, 60)</span>
<span class="gi">+    hours, minutes = divmod(minutes, 60)</span>
<span class="gi">+    return f&#39;{&quot;-&quot; if td.days &lt; 0 else &quot;&quot;}P{abs(td.days)}DT{hours:d}H{minutes:d}M{seconds:d}.{td.microseconds:06d}S&#39;</span>
<span class="gh">diff --git a/pydantic/deprecated/parse.py b/pydantic/deprecated/parse.py</span>
<span class="gh">index fe5986bb7..2a92e62b7 100644</span>
<span class="gd">--- a/pydantic/deprecated/parse.py</span>
<span class="gi">+++ b/pydantic/deprecated/parse.py</span>
<span class="gu">@@ -1,16 +1,80 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import pickle
<span class="w"> </span>import warnings
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import deprecated
<span class="gi">+</span>
<span class="w"> </span>from ..warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>if not TYPE_CHECKING:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20


<span class="w"> </span>class Protocol(str, Enum):
<span class="w"> </span>    json = &#39;json&#39;
<span class="w"> </span>    pickle = &#39;pickle&#39;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@deprecated(&#39;`load_str_bytes` is deprecated.&#39;, category=None)</span>
<span class="gi">+def load_str_bytes(</span>
<span class="gi">+    b: str | bytes,</span>
<span class="gi">+    *,</span>
<span class="gi">+    content_type: str | None = None,</span>
<span class="gi">+    encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+    proto: Protocol | None = None,</span>
<span class="gi">+    allow_pickle: bool = False,</span>
<span class="gi">+    json_loads: Callable[[str], Any] = json.loads,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="gi">+    warnings.warn(&#39;`load_str_bytes` is deprecated.&#39;, category=PydanticDeprecatedSince20, stacklevel=2)</span>
<span class="gi">+    if proto is None and content_type:</span>
<span class="gi">+        if content_type.endswith((&#39;json&#39;, &#39;javascript&#39;)):</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif allow_pickle and content_type.endswith(&#39;pickle&#39;):</span>
<span class="gi">+            proto = Protocol.pickle</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&#39;Unknown content-type: {content_type}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    proto = proto or Protocol.json</span>
<span class="gi">+</span>
<span class="gi">+    if proto == Protocol.json:</span>
<span class="gi">+        if isinstance(b, bytes):</span>
<span class="gi">+            b = b.decode(encoding)</span>
<span class="gi">+        return json_loads(b)  # type: ignore</span>
<span class="gi">+    elif proto == Protocol.pickle:</span>
<span class="gi">+        if not allow_pickle:</span>
<span class="gi">+            raise RuntimeError(&#39;Trying to decode with pickle with allow_pickle=False&#39;)</span>
<span class="gi">+        bb = b if isinstance(b, bytes) else b.encode()  # type: ignore</span>
<span class="gi">+        return pickle.loads(bb)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&#39;Unknown protocol: {proto}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@deprecated(&#39;`load_file` is deprecated.&#39;, category=None)</span>
<span class="gi">+def load_file(</span>
<span class="gi">+    path: str | Path,</span>
<span class="gi">+    *,</span>
<span class="gi">+    content_type: str | None = None,</span>
<span class="gi">+    encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+    proto: Protocol | None = None,</span>
<span class="gi">+    allow_pickle: bool = False,</span>
<span class="gi">+    json_loads: Callable[[str], Any] = json.loads,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="gi">+    warnings.warn(&#39;`load_file` is deprecated.&#39;, category=PydanticDeprecatedSince20, stacklevel=2)</span>
<span class="gi">+    path = Path(path)</span>
<span class="gi">+    b = path.read_bytes()</span>
<span class="gi">+    if content_type is None:</span>
<span class="gi">+        if path.suffix in (&#39;.js&#39;, &#39;.json&#39;):</span>
<span class="gi">+            proto = Protocol.json</span>
<span class="gi">+        elif path.suffix == &#39;.pkl&#39;:</span>
<span class="gi">+            proto = Protocol.pickle</span>
<span class="gi">+</span>
<span class="gi">+    return load_str_bytes(</span>
<span class="gi">+        b, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=json_loads</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pydantic/deprecated/tools.py b/pydantic/deprecated/tools.py</span>
<span class="gh">index 8bd382997..b04eae400 100644</span>
<span class="gd">--- a/pydantic/deprecated/tools.py</span>
<span class="gi">+++ b/pydantic/deprecated/tools.py</span>
<span class="gu">@@ -1,34 +1,103 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Type, TypeVar, Union
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import deprecated
<span class="gi">+</span>
<span class="w"> </span>from ..json_schema import DEFAULT_REF_TEMPLATE, GenerateJsonSchema
<span class="w"> </span>from ..type_adapter import TypeAdapter
<span class="w"> </span>from ..warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>if not TYPE_CHECKING:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;parse_obj_as&#39;, &#39;schema_of&#39;, &#39;schema_json_of&#39;
<span class="gi">+</span>
<span class="w"> </span>NameFactory = Union[str, Callable[[Type[Any]], str]]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)


<span class="w"> </span>@deprecated(
<span class="gd">-    &#39;`schema_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.&#39;</span>
<span class="gd">-    , category=None)</span>
<span class="gd">-def schema_of(type_: Any, *, title: (NameFactory | None)=None, by_alias:</span>
<span class="gd">-    bool=True, ref_template: str=DEFAULT_REF_TEMPLATE, schema_generator:</span>
<span class="gd">-    type[GenerateJsonSchema]=GenerateJsonSchema) -&gt;dict[str, Any]:</span>
<span class="gi">+    &#39;`parse_obj_as` is deprecated. Use `pydantic.TypeAdapter.validate_python` instead.&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def parse_obj_as(type_: type[T], obj: Any, type_name: NameFactory | None = None) -&gt; T:</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &#39;`parse_obj_as` is deprecated. Use `pydantic.TypeAdapter.validate_python` instead.&#39;,</span>
<span class="gi">+        category=PydanticDeprecatedSince20,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    if type_name is not None:  # pragma: no cover</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The type_name parameter is deprecated. parse_obj_as no longer creates temporary models&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+    return TypeAdapter(type_).validate_python(obj)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@deprecated(</span>
<span class="gi">+    &#39;`schema_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def schema_of(</span>
<span class="gi">+    type_: Any,</span>
<span class="gi">+    *,</span>
<span class="gi">+    title: NameFactory | None = None,</span>
<span class="gi">+    by_alias: bool = True,</span>
<span class="gi">+    ref_template: str = DEFAULT_REF_TEMPLATE,</span>
<span class="gi">+    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,</span>
<span class="gi">+) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a JSON schema (as dict) for the passed model or dynamically generated one.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &#39;`schema_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.&#39;,</span>
<span class="gi">+        category=PydanticDeprecatedSince20,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    res = TypeAdapter(type_).json_schema(</span>
<span class="gi">+        by_alias=by_alias,</span>
<span class="gi">+        schema_generator=schema_generator,</span>
<span class="gi">+        ref_template=ref_template,</span>
<span class="gi">+    )</span>
<span class="gi">+    if title is not None:</span>
<span class="gi">+        if isinstance(title, str):</span>
<span class="gi">+            res[&#39;title&#39;] = title</span>
<span class="gi">+        else:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &#39;Passing a callable for the `title` parameter is deprecated and no longer supported&#39;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="gi">+            res[&#39;title&#39;] = title(type_)</span>
<span class="gi">+    return res</span>


<span class="w"> </span>@deprecated(
<span class="gd">-    &#39;`schema_json_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.&#39;</span>
<span class="gd">-    , category=None)</span>
<span class="gd">-def schema_json_of(type_: Any, *, title: (NameFactory | None)=None,</span>
<span class="gd">-    by_alias: bool=True, ref_template: str=DEFAULT_REF_TEMPLATE,</span>
<span class="gd">-    schema_generator: type[GenerateJsonSchema]=GenerateJsonSchema, **</span>
<span class="gd">-    dumps_kwargs: Any) -&gt;str:</span>
<span class="gi">+    &#39;`schema_json_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def schema_json_of(</span>
<span class="gi">+    type_: Any,</span>
<span class="gi">+    *,</span>
<span class="gi">+    title: NameFactory | None = None,</span>
<span class="gi">+    by_alias: bool = True,</span>
<span class="gi">+    ref_template: str = DEFAULT_REF_TEMPLATE,</span>
<span class="gi">+    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,</span>
<span class="gi">+    **dumps_kwargs: Any,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a JSON schema (as JSON) for the passed model or dynamically generated one.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &#39;`schema_json_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.&#39;,</span>
<span class="gi">+        category=PydanticDeprecatedSince20,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    return json.dumps(</span>
<span class="gi">+        schema_of(type_, title=title, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator),</span>
<span class="gi">+        **dumps_kwargs,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pydantic/env_settings.py b/pydantic/env_settings.py</span>
<span class="gh">index b33516aa9..cd0b04e6a 100644</span>
<span class="gd">--- a/pydantic/env_settings.py</span>
<span class="gi">+++ b/pydantic/env_settings.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `env_settings` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/error_wrappers.py b/pydantic/error_wrappers.py</span>
<span class="gh">index 2d455f557..2985419ab 100644</span>
<span class="gd">--- a/pydantic/error_wrappers.py</span>
<span class="gi">+++ b/pydantic/error_wrappers.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `error_wrappers` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/errors.py b/pydantic/errors.py</span>
<span class="gh">index 3a0976c35..de2e512dd 100644</span>
<span class="gd">--- a/pydantic/errors.py</span>
<span class="gi">+++ b/pydantic/errors.py</span>
<span class="gu">@@ -1,34 +1,71 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Pydantic-specific errors.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Literal, Self
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="w"> </span>from .version import version_short
<span class="gd">-__all__ = (&#39;PydanticUserError&#39;, &#39;PydanticUndefinedAnnotation&#39;,</span>
<span class="gd">-    &#39;PydanticImportError&#39;, &#39;PydanticSchemaGenerationError&#39;,</span>
<span class="gd">-    &#39;PydanticInvalidForJsonSchema&#39;, &#39;PydanticErrorCodes&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &#39;PydanticUserError&#39;,</span>
<span class="gi">+    &#39;PydanticUndefinedAnnotation&#39;,</span>
<span class="gi">+    &#39;PydanticImportError&#39;,</span>
<span class="gi">+    &#39;PydanticSchemaGenerationError&#39;,</span>
<span class="gi">+    &#39;PydanticInvalidForJsonSchema&#39;,</span>
<span class="gi">+    &#39;PydanticErrorCodes&#39;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# We use this URL to allow for future flexibility about how we host the docs, while allowing for Pydantic</span>
<span class="gi">+# code in the while with &quot;old&quot; URLs to still work.</span>
<span class="gi">+# &#39;u&#39; refers to &quot;user errors&quot; - e.g. errors caused by developers using pydantic, as opposed to validation errors.</span>
<span class="w"> </span>DEV_ERROR_DOCS_URL = f&#39;https://errors.pydantic.dev/{version_short()}/u/&#39;
<span class="gd">-PydanticErrorCodes = Literal[&#39;class-not-fully-defined&#39;,</span>
<span class="gd">-    &#39;custom-json-schema&#39;, &#39;decorator-missing-field&#39;,</span>
<span class="gd">-    &#39;discriminator-no-field&#39;, &#39;discriminator-alias-type&#39;,</span>
<span class="gd">-    &#39;discriminator-needs-literal&#39;, &#39;discriminator-alias&#39;,</span>
<span class="gd">-    &#39;discriminator-validator&#39;, &#39;callable-discriminator-no-tag&#39;,</span>
<span class="gd">-    &#39;typed-dict-version&#39;, &#39;model-field-overridden&#39;,</span>
<span class="gd">-    &#39;model-field-missing-annotation&#39;, &#39;config-both&#39;, &#39;removed-kwargs&#39;,</span>
<span class="gd">-    &#39;invalid-for-json-schema&#39;, &#39;json-schema-already-used&#39;,</span>
<span class="gd">-    &#39;base-model-instantiated&#39;, &#39;undefined-annotation&#39;,</span>
<span class="gd">-    &#39;schema-for-unknown-type&#39;, &#39;import-error&#39;,</span>
<span class="gd">-    &#39;create-model-field-definitions&#39;, &#39;create-model-config-base&#39;,</span>
<span class="gd">-    &#39;validator-no-fields&#39;, &#39;validator-invalid-fields&#39;,</span>
<span class="gd">-    &#39;validator-instance-method&#39;, &#39;root-validator-pre-skip&#39;,</span>
<span class="gd">-    &#39;model-serializer-instance-method&#39;, &#39;validator-field-config-info&#39;,</span>
<span class="gd">-    &#39;validator-v1-signature&#39;, &#39;validator-signature&#39;,</span>
<span class="gd">-    &#39;field-serializer-signature&#39;, &#39;model-serializer-signature&#39;,</span>
<span class="gd">-    &#39;multiple-field-serializers&#39;, &#39;invalid_annotated_type&#39;,</span>
<span class="gd">-    &#39;type-adapter-config-unused&#39;, &#39;root-model-extra&#39;,</span>
<span class="gd">-    &#39;unevaluable-type-annotation&#39;, &#39;dataclass-init-false-extra-allow&#39;,</span>
<span class="gd">-    &#39;clashing-init-and-init-var&#39;, &#39;model-config-invalid-field-name&#39;,</span>
<span class="gd">-    &#39;with-config-on-model&#39;, &#39;dataclass-on-model&#39;]</span>
<span class="gi">+PydanticErrorCodes = Literal[</span>
<span class="gi">+    &#39;class-not-fully-defined&#39;,</span>
<span class="gi">+    &#39;custom-json-schema&#39;,</span>
<span class="gi">+    &#39;decorator-missing-field&#39;,</span>
<span class="gi">+    &#39;discriminator-no-field&#39;,</span>
<span class="gi">+    &#39;discriminator-alias-type&#39;,</span>
<span class="gi">+    &#39;discriminator-needs-literal&#39;,</span>
<span class="gi">+    &#39;discriminator-alias&#39;,</span>
<span class="gi">+    &#39;discriminator-validator&#39;,</span>
<span class="gi">+    &#39;callable-discriminator-no-tag&#39;,</span>
<span class="gi">+    &#39;typed-dict-version&#39;,</span>
<span class="gi">+    &#39;model-field-overridden&#39;,</span>
<span class="gi">+    &#39;model-field-missing-annotation&#39;,</span>
<span class="gi">+    &#39;config-both&#39;,</span>
<span class="gi">+    &#39;removed-kwargs&#39;,</span>
<span class="gi">+    &#39;invalid-for-json-schema&#39;,</span>
<span class="gi">+    &#39;json-schema-already-used&#39;,</span>
<span class="gi">+    &#39;base-model-instantiated&#39;,</span>
<span class="gi">+    &#39;undefined-annotation&#39;,</span>
<span class="gi">+    &#39;schema-for-unknown-type&#39;,</span>
<span class="gi">+    &#39;import-error&#39;,</span>
<span class="gi">+    &#39;create-model-field-definitions&#39;,</span>
<span class="gi">+    &#39;create-model-config-base&#39;,</span>
<span class="gi">+    &#39;validator-no-fields&#39;,</span>
<span class="gi">+    &#39;validator-invalid-fields&#39;,</span>
<span class="gi">+    &#39;validator-instance-method&#39;,</span>
<span class="gi">+    &#39;root-validator-pre-skip&#39;,</span>
<span class="gi">+    &#39;model-serializer-instance-method&#39;,</span>
<span class="gi">+    &#39;validator-field-config-info&#39;,</span>
<span class="gi">+    &#39;validator-v1-signature&#39;,</span>
<span class="gi">+    &#39;validator-signature&#39;,</span>
<span class="gi">+    &#39;field-serializer-signature&#39;,</span>
<span class="gi">+    &#39;model-serializer-signature&#39;,</span>
<span class="gi">+    &#39;multiple-field-serializers&#39;,</span>
<span class="gi">+    &#39;invalid_annotated_type&#39;,</span>
<span class="gi">+    &#39;type-adapter-config-unused&#39;,</span>
<span class="gi">+    &#39;root-model-extra&#39;,</span>
<span class="gi">+    &#39;unevaluable-type-annotation&#39;,</span>
<span class="gi">+    &#39;dataclass-init-false-extra-allow&#39;,</span>
<span class="gi">+    &#39;clashing-init-and-init-var&#39;,</span>
<span class="gi">+    &#39;model-config-invalid-field-name&#39;,</span>
<span class="gi">+    &#39;with-config-on-model&#39;,</span>
<span class="gi">+    &#39;dataclass-on-model&#39;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class PydanticErrorMixin:
<span class="gu">@@ -39,18 +76,15 @@ class PydanticErrorMixin:</span>
<span class="w"> </span>        code: An optional error code from PydanticErrorCodes enum.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, *, code: (PydanticErrorCodes | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, *, code: PydanticErrorCodes | None) -&gt; None:</span>
<span class="w"> </span>        self.message = message
<span class="w"> </span>        self.code = code

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        if self.code is None:
<span class="w"> </span>            return self.message
<span class="w"> </span>        else:
<span class="gd">-            return f&quot;&quot;&quot;{self.message}</span>
<span class="gd">-</span>
<span class="gd">-For further information visit {DEV_ERROR_DOCS_URL}{self.code}&quot;&quot;&quot;</span>
<span class="gi">+            return f&#39;{self.message}\n\nFor further information visit {DEV_ERROR_DOCS_URL}{self.code}&#39;</span>


<span class="w"> </span>class PydanticUserError(PydanticErrorMixin, TypeError):
<span class="gu">@@ -65,12 +99,12 @@ class PydanticUndefinedAnnotation(PydanticErrorMixin, NameError):</span>
<span class="w"> </span>        message: Description of the error.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str, message: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str, message: str) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        super().__init__(message=message, code=&#39;undefined-annotation&#39;)

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_name_error(cls, name_error: NameError) -&gt;Self:</span>
<span class="gi">+    def from_name_error(cls, name_error: NameError) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert a `NameError` to a `PydanticUndefinedAnnotation` error.

<span class="w"> </span>        Args:
<span class="gu">@@ -79,7 +113,11 @@ class PydanticUndefinedAnnotation(PydanticErrorMixin, NameError):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            Converted `PydanticUndefinedAnnotation` error.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            name = name_error.name  # type: ignore  # python &gt; 3.10</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            name = re.search(r&quot;.*&#39;(.+?)&#39;&quot;, str(name_error)).group(1)  # type: ignore[union-attr]</span>
<span class="gi">+        return cls(name=name, message=str(name_error))</span>


<span class="w"> </span>class PydanticImportError(PydanticErrorMixin, ImportError):
<span class="gu">@@ -89,7 +127,7 @@ class PydanticImportError(PydanticErrorMixin, ImportError):</span>
<span class="w"> </span>        message: Description of the error.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message, code=&#39;import-error&#39;)


<span class="gu">@@ -100,7 +138,7 @@ class PydanticSchemaGenerationError(PydanticUserError):</span>
<span class="w"> </span>        message: Description of the error.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message, code=&#39;schema-for-unknown-type&#39;)


<span class="gu">@@ -111,7 +149,7 @@ class PydanticInvalidForJsonSchema(PydanticUserError):</span>
<span class="w"> </span>        message: Description of the error.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message, code=&#39;invalid-for-json-schema&#39;)


<span class="gh">diff --git a/pydantic/experimental/pipeline.py b/pydantic/experimental/pipeline.py</span>
<span class="gh">index 253728a36..29da979e8 100644</span>
<span class="gd">--- a/pydantic/experimental/pipeline.py</span>
<span class="gi">+++ b/pydantic/experimental/pipeline.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Experimental pipeline API functionality. Be careful with this API, it&#39;s subject to change.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import operator
<span class="w"> </span>import re
<span class="gu">@@ -10,17 +12,24 @@ from dataclasses import dataclass</span>
<span class="w"> </span>from decimal import Decimal
<span class="w"> </span>from functools import cached_property, partial
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload
<span class="gi">+</span>
<span class="w"> </span>import annotated_types
<span class="w"> </span>from typing_extensions import Annotated
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic_core import core_schema as cs
<span class="gi">+</span>
<span class="w"> </span>    from pydantic import GetCoreSchemaHandler
<span class="gi">+</span>
<span class="w"> </span>from pydantic._internal._internal_dataclass import slots_true as _slots_true
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 10):
<span class="w"> </span>    EllipsisType = type(Ellipsis)
<span class="w"> </span>else:
<span class="w"> </span>    from types import EllipsisType
<span class="gi">+</span>
<span class="w"> </span>__all__ = [&#39;validate_as&#39;, &#39;validate_as_deferred&#39;, &#39;transform&#39;]
<span class="gi">+</span>
<span class="w"> </span>_slots_frozen = {**_slots_true, &#39;frozen&#39;: True}


<span class="gu">@@ -34,6 +43,10 @@ class _ValidateAs:</span>
<span class="w"> </span>class _ValidateAsDefer:
<span class="w"> </span>    func: Callable[[], type[Any]]

<span class="gi">+    @cached_property</span>
<span class="gi">+    def tp(self) -&gt; type[Any]:</span>
<span class="gi">+        return self.func()</span>
<span class="gi">+</span>

<span class="w"> </span>@dataclass(**_slots_frozen)
<span class="w"> </span>class _Transform:
<span class="gu">@@ -72,11 +85,24 @@ class _NotIn:</span>
<span class="w"> </span>    values: Container[Any]


<span class="gd">-_ConstraintAnnotation = Union[annotated_types.Le, annotated_types.Ge,</span>
<span class="gd">-    annotated_types.Lt, annotated_types.Gt, annotated_types.Len,</span>
<span class="gd">-    annotated_types.MultipleOf, annotated_types.Timezone, annotated_types.</span>
<span class="gd">-    Interval, annotated_types.Predicate, _Eq, _NotEq, _In, _NotIn, Pattern[str]</span>
<span class="gd">-    ]</span>
<span class="gi">+_ConstraintAnnotation = Union[</span>
<span class="gi">+    annotated_types.Le,</span>
<span class="gi">+    annotated_types.Ge,</span>
<span class="gi">+    annotated_types.Lt,</span>
<span class="gi">+    annotated_types.Gt,</span>
<span class="gi">+    annotated_types.Len,</span>
<span class="gi">+    annotated_types.MultipleOf,</span>
<span class="gi">+    annotated_types.Timezone,</span>
<span class="gi">+    annotated_types.Interval,</span>
<span class="gi">+    annotated_types.Predicate,</span>
<span class="gi">+    # common predicates not included in annotated_types</span>
<span class="gi">+    _Eq,</span>
<span class="gi">+    _NotEq,</span>
<span class="gi">+    _In,</span>
<span class="gi">+    _NotIn,</span>
<span class="gi">+    # regular expressions</span>
<span class="gi">+    Pattern[str],</span>
<span class="gi">+]</span>


<span class="w"> </span>@dataclass(**_slots_frozen)
<span class="gu">@@ -84,8 +110,8 @@ class _Constraint:</span>
<span class="w"> </span>    constraint: _ConstraintAnnotation


<span class="gd">-_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr,</span>
<span class="gd">-    _PipelineAnd, _Constraint]</span>
<span class="gi">+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]</span>
<span class="gi">+</span>
<span class="w"> </span>_InT = TypeVar(&#39;_InT&#39;)
<span class="w"> </span>_OutT = TypeVar(&#39;_OutT&#39;)
<span class="w"> </span>_NewOutT = TypeVar(&#39;_NewOutT&#39;)
<span class="gu">@@ -95,22 +121,35 @@ class _FieldTypeMarker:</span>
<span class="w"> </span>    pass


<span class="gi">+# TODO: ultimately, make this public, see https://github.com/pydantic/pydantic/pull/9459#discussion_r1628197626</span>
<span class="gi">+# Also, make this frozen eventually, but that doesn&#39;t work right now because of the generic base</span>
<span class="gi">+# Which attempts to modify __orig_base__ and such.</span>
<span class="gi">+# We could go with a manual freeze, but that seems overkill for now.</span>
<span class="w"> </span>@dataclass(**_slots_true)
<span class="w"> </span>class _Pipeline(Generic[_InT, _OutT]):
<span class="w"> </span>    &quot;&quot;&quot;Abstract representation of a chain of validation, transformation, and parsing steps.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _steps: tuple[_Step, ...]

<span class="gd">-    def transform(self, func: Callable[[_OutT], _NewOutT]) -&gt;_Pipeline[_InT,</span>
<span class="gd">-        _NewOutT]:</span>
<span class="gi">+    def transform(</span>
<span class="gi">+        self,</span>
<span class="gi">+        func: Callable[[_OutT], _NewOutT],</span>
<span class="gi">+    ) -&gt; _Pipeline[_InT, _NewOutT]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Transform the output of the previous step.

<span class="w"> </span>        If used as the first step in a pipeline, the type of the field is used.
<span class="w"> </span>        That is, the transformation is applied to after the value is parsed to the field&#39;s type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline[_InT, _NewOutT](self._steps + (_Transform(func),))</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def validate_as(self, tp: type[_NewOutT], *, strict: bool = ...) -&gt; _Pipeline[_InT, _NewOutT]: ...</span>

<span class="gd">-    def validate_as(self, tp: (type[_NewOutT] | EllipsisType), *, strict:</span>
<span class="gd">-        bool=False) -&gt;_Pipeline[_InT, Any]:</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def validate_as(self, tp: EllipsisType, *, strict: bool = ...) -&gt; _Pipeline[_InT, Any]:  # type: ignore</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def validate_as(self, tp: type[_NewOutT] | EllipsisType, *, strict: bool = False) -&gt; _Pipeline[_InT, Any]:  # type: ignore</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate / parse the input into a new type.

<span class="w"> </span>        If no type is provided, the type of the field is used.
<span class="gu">@@ -118,18 +157,70 @@ class _Pipeline(Generic[_InT, _OutT]):</span>
<span class="w"> </span>        Types are parsed in Pydantic&#39;s `lax` mode by default,
<span class="w"> </span>        but you can enable `strict` mode by passing `strict=True`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(tp, EllipsisType):</span>
<span class="gi">+            return _Pipeline[_InT, Any](self._steps + (_ValidateAs(_FieldTypeMarker, strict=strict),))</span>
<span class="gi">+        return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAs(tp, strict=strict),))</span>

<span class="gd">-    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]</span>
<span class="gd">-        ) -&gt;_Pipeline[_InT, _NewOutT]:</span>
<span class="gi">+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -&gt; _Pipeline[_InT, _NewOutT]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the input into a new type, deferring resolution of the type until the current class
<span class="w"> </span>        is fully defined.

<span class="w"> </span>        This is useful when you need to reference the class in it&#39;s own type annotations.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAsDefer(func),))</span>
<span class="gi">+</span>
<span class="gi">+    # constraints</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -&gt; _Pipeline[_InT, _NewOutGe]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -&gt; _Pipeline[_InT, _NewOutGt]: ...</span>

<span class="gd">-    def constrain(self, constraint: _ConstraintAnnotation) -&gt;Any:</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -&gt; _Pipeline[_InT, _NewOutLe]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -&gt; _Pipeline[_InT, _NewOutLt]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(</span>
<span class="gi">+        self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len</span>
<span class="gi">+    ) -&gt; _Pipeline[_InT, _NewOutLen]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(</span>
<span class="gi">+        self: _Pipeline[_InT, _NewOutT], constraint: annotated_types.MultipleOf</span>
<span class="gi">+    ) -&gt; _Pipeline[_InT, _NewOutT]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(</span>
<span class="gi">+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone</span>
<span class="gi">+    ) -&gt; _Pipeline[_InT, _NewOutDatetime]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -&gt; _Pipeline[_InT, _OutT]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(</span>
<span class="gi">+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval</span>
<span class="gi">+    ) -&gt; _Pipeline[_InT, _NewOutInterval]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -&gt; _Pipeline[_InT, _OutT]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -&gt; _Pipeline[_InT, _OutT]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -&gt; _Pipeline[_InT, _OutT]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -&gt; _Pipeline[_InT, _OutT]: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -&gt; _Pipeline[_InT, _NewOutT]: ...</span>
<span class="gi">+</span>
<span class="gi">+    def constrain(self, constraint: _ConstraintAnnotation) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to meet a certain condition.

<span class="w"> </span>        We support most conditions from `annotated_types`, as well as regular expressions.
<span class="gu">@@ -137,87 +228,128 @@ class _Pipeline(Generic[_InT, _OutT]):</span>
<span class="w"> </span>        Most of the time you&#39;ll be calling a shortcut method like `gt`, `lt`, `len`, etc
<span class="w"> </span>        so you don&#39;t need to call this directly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline[_InT, _OutT](self._steps + (_Constraint(constraint),))</span>

<span class="gd">-    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT</span>
<span class="gd">-        ], bool]) -&gt;_Pipeline[_InT, _NewOutT]:</span>
<span class="gi">+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -&gt; _Pipeline[_InT, _NewOutT]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to meet a certain predicate.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Predicate(func))</span>

<span class="gd">-    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -&gt;_Pipeline[</span>
<span class="gd">-        _InT, _NewOutGt]:</span>
<span class="gi">+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -&gt; _Pipeline[_InT, _NewOutGt]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be greater than a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Gt(gt))</span>

<span class="gd">-    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -&gt;_Pipeline[</span>
<span class="gd">-        _InT, _NewOutLt]:</span>
<span class="gi">+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -&gt; _Pipeline[_InT, _NewOutLt]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be less than a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Lt(lt))</span>

<span class="gd">-    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -&gt;_Pipeline[</span>
<span class="gd">-        _InT, _NewOutGe]:</span>
<span class="gi">+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -&gt; _Pipeline[_InT, _NewOutGe]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be greater than or equal to a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Ge(ge))</span>

<span class="gd">-    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -&gt;_Pipeline[</span>
<span class="gd">-        _InT, _NewOutLe]:</span>
<span class="gi">+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -&gt; _Pipeline[_InT, _NewOutLe]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be less than or equal to a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Le(le))</span>

<span class="gd">-    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: (int |</span>
<span class="gd">-        None)=None) -&gt;_Pipeline[_InT, _NewOutLen]:</span>
<span class="gi">+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -&gt; _Pipeline[_InT, _NewOutLen]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to have a certain length.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Len(min_len, max_len))</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -&gt; _Pipeline[_InT, _NewOutDiv]: ...</span>

<span class="gd">-    def multiple_of(self: _Pipeline[_InT, Any], multiple_of: Any) -&gt;_Pipeline[</span>
<span class="gd">-        _InT, Any]:</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def multiple_of(self: _Pipeline[_InT, _NewOutMod], multiple_of: _NewOutMod) -&gt; _Pipeline[_InT, _NewOutMod]: ...</span>
<span class="gi">+</span>
<span class="gi">+    def multiple_of(self: _Pipeline[_InT, Any], multiple_of: Any) -&gt; _Pipeline[_InT, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be a multiple of a certain number.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.MultipleOf(multiple_of))</span>

<span class="gd">-    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -&gt;_Pipeline[_InT, _OutT</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -&gt; _Pipeline[_InT, _OutT]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be equal to a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(_Eq(value))</span>

<span class="gd">-    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -&gt;_Pipeline[_InT,</span>
<span class="gd">-        _OutT]:</span>
<span class="gi">+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -&gt; _Pipeline[_InT, _OutT]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to not be equal to a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(_NotEq(value))</span>

<span class="gd">-    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]</span>
<span class="gd">-        ) -&gt;_Pipeline[_InT, _OutT]:</span>
<span class="gi">+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -&gt; _Pipeline[_InT, _OutT]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be in a certain set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(_In(values))</span>

<span class="gd">-    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]</span>
<span class="gd">-        ) -&gt;_Pipeline[_InT, _OutT]:</span>
<span class="gi">+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -&gt; _Pipeline[_InT, _OutT]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to not be in a certain set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(_NotIn(values))</span>
<span class="gi">+</span>
<span class="gi">+    # timezone methods</span>
<span class="gi">+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -&gt; _Pipeline[_InT, datetime.datetime]:</span>
<span class="gi">+        return self.constrain(annotated_types.Timezone(None))</span>
<span class="gi">+</span>
<span class="gi">+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -&gt; _Pipeline[_InT, datetime.datetime]:</span>
<span class="gi">+        return self.constrain(annotated_types.Timezone(...))</span>
<span class="gi">+</span>
<span class="gi">+    def datetime_tz(</span>
<span class="gi">+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo</span>
<span class="gi">+    ) -&gt; _Pipeline[_InT, datetime.datetime]:</span>
<span class="gi">+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore</span>

<span class="gd">-    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -&gt;_Pipeline[</span>
<span class="gd">-        _InT | _OtherIn, _OutT | _OtherOut]:</span>
<span class="gi">+    def datetime_with_tz(</span>
<span class="gi">+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None</span>
<span class="gi">+    ) -&gt; _Pipeline[_InT, datetime.datetime]:</span>
<span class="gi">+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))</span>
<span class="gi">+</span>
<span class="gi">+    # string methods</span>
<span class="gi">+    def str_lower(self: _Pipeline[_InT, str]) -&gt; _Pipeline[_InT, str]:</span>
<span class="gi">+        return self.transform(str.lower)</span>
<span class="gi">+</span>
<span class="gi">+    def str_upper(self: _Pipeline[_InT, str]) -&gt; _Pipeline[_InT, str]:</span>
<span class="gi">+        return self.transform(str.upper)</span>
<span class="gi">+</span>
<span class="gi">+    def str_title(self: _Pipeline[_InT, str]) -&gt; _Pipeline[_InT, str]:</span>
<span class="gi">+        return self.transform(str.title)</span>
<span class="gi">+</span>
<span class="gi">+    def str_strip(self: _Pipeline[_InT, str]) -&gt; _Pipeline[_InT, str]:</span>
<span class="gi">+        return self.transform(str.strip)</span>
<span class="gi">+</span>
<span class="gi">+    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -&gt; _Pipeline[_InT, str]:</span>
<span class="gi">+        return self.constrain(re.compile(pattern))</span>
<span class="gi">+</span>
<span class="gi">+    def str_contains(self: _Pipeline[_InT, str], substring: str) -&gt; _Pipeline[_InT, str]:</span>
<span class="gi">+        return self.predicate(lambda v: substring in v)</span>
<span class="gi">+</span>
<span class="gi">+    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -&gt; _Pipeline[_InT, str]:</span>
<span class="gi">+        return self.predicate(lambda v: v.startswith(prefix))</span>
<span class="gi">+</span>
<span class="gi">+    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -&gt; _Pipeline[_InT, str]:</span>
<span class="gi">+        return self.predicate(lambda v: v.endswith(suffix))</span>
<span class="gi">+</span>
<span class="gi">+    # operators</span>
<span class="gi">+    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -&gt; _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline((_PipelineOr(self, other),))</span>
<span class="gi">+</span>
<span class="w"> </span>    __or__ = otherwise

<span class="gd">-    def then(self, other: _Pipeline[_OutT, _OtherOut]) -&gt;_Pipeline[_InT,</span>
<span class="gd">-        _OtherOut]:</span>
<span class="gi">+    def then(self, other: _Pipeline[_OutT, _OtherOut]) -&gt; _Pipeline[_InT, _OtherOut]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Pipe the result of one validation chain into another.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline((_PipelineAnd(self, other),))</span>
<span class="gi">+</span>
<span class="w"> </span>    __and__ = then

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;cs.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; cs.CoreSchema:</span>
<span class="w"> </span>        from pydantic_core import core_schema as cs
<span class="gi">+</span>
<span class="w"> </span>        queue = deque(self._steps)
<span class="gi">+</span>
<span class="w"> </span>        s = None
<span class="gi">+</span>
<span class="w"> </span>        while queue:
<span class="w"> </span>            step = queue.popleft()
<span class="w"> </span>            s = _apply_step(step, s, handler, source_type)
<span class="gi">+</span>
<span class="w"> </span>        s = s or cs.any_schema()
<span class="w"> </span>        return s

<span class="gd">-    def __supports_type__(self, _: _OutT) -&gt;bool:</span>
<span class="gi">+    def __supports_type__(self, _: _OutT) -&gt; bool:</span>
<span class="w"> </span>        raise NotImplementedError


<span class="gu">@@ -226,21 +358,302 @@ validate_as_deferred = _Pipeline[Any, Any](()).validate_as_deferred</span>
<span class="w"> </span>transform = _Pipeline[Any, Any]((_ValidateAs(_FieldTypeMarker),)).transform


<span class="gd">-def _apply_constraint(s: (cs.CoreSchema | None), constraint:</span>
<span class="gd">-    _ConstraintAnnotation) -&gt;cs.CoreSchema:</span>
<span class="gd">-    &quot;&quot;&quot;Apply a single constraint to a schema.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def _check_func(</span>
<span class="gi">+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None</span>
<span class="gi">+) -&gt; cs.CoreSchema:</span>
<span class="gi">+    from pydantic_core import core_schema as cs</span>
<span class="gi">+</span>
<span class="gi">+    def handler(v: Any) -&gt; Any:</span>
<span class="gi">+        if func(v):</span>
<span class="gi">+            return v</span>
<span class="gi">+        raise ValueError(f&#39;Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if s is None:</span>
<span class="gi">+        return cs.no_info_plain_validator_function(handler)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return cs.no_info_after_validator_function(handler, s)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -&gt; cs.CoreSchema:</span>
<span class="gi">+    from pydantic_core import core_schema as cs</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(step, _ValidateAs):</span>
<span class="gi">+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)</span>
<span class="gi">+    elif isinstance(step, _ValidateAsDefer):</span>
<span class="gi">+        s = _apply_parse(s, step.tp, False, handler, source_type)</span>
<span class="gi">+    elif isinstance(step, _Transform):</span>
<span class="gi">+        s = _apply_transform(s, step.func, handler)</span>
<span class="gi">+    elif isinstance(step, _Constraint):</span>
<span class="gi">+        s = _apply_constraint(s, step.constraint)</span>
<span class="gi">+    elif isinstance(step, _PipelineOr):</span>
<span class="gi">+        s = cs.union_schema([handler(step.left), handler(step.right)])</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert isinstance(step, _PipelineAnd)</span>
<span class="gi">+        s = cs.chain_schema([handler(step.left), handler(step.right)])</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _apply_parse(</span>
<span class="gi">+    s: cs.CoreSchema | None,</span>
<span class="gi">+    tp: type[Any],</span>
<span class="gi">+    strict: bool,</span>
<span class="gi">+    handler: GetCoreSchemaHandler,</span>
<span class="gi">+    source_type: Any,</span>
<span class="gi">+) -&gt; cs.CoreSchema:</span>
<span class="gi">+    from pydantic_core import core_schema as cs</span>
<span class="gi">+</span>
<span class="gi">+    from pydantic import Strict</span>

<span class="gi">+    if tp is _FieldTypeMarker:</span>
<span class="gi">+        return handler(source_type)</span>

<span class="gd">-class _SupportsRange(annotated_types.SupportsLe, annotated_types.SupportsGe,</span>
<span class="gd">-    Protocol):</span>
<span class="gi">+    if strict:</span>
<span class="gi">+        tp = Annotated[tp, Strict()]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    if s and s[&#39;type&#39;] == &#39;any&#39;:</span>
<span class="gi">+        return handler(tp)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _apply_transform(</span>
<span class="gi">+    s: cs.CoreSchema | None, func: Callable[[Any], Any], handler: GetCoreSchemaHandler</span>
<span class="gi">+) -&gt; cs.CoreSchema:</span>
<span class="gi">+    from pydantic_core import core_schema as cs</span>
<span class="gi">+</span>
<span class="gi">+    if s is None:</span>
<span class="gi">+        return cs.no_info_plain_validator_function(func)</span>
<span class="gi">+</span>
<span class="gi">+    if s[&#39;type&#39;] == &#39;str&#39;:</span>
<span class="gi">+        if func is str.strip:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            s[&#39;strip_whitespace&#39;] = True</span>
<span class="gi">+            return s</span>
<span class="gi">+        elif func is str.lower:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            s[&#39;to_lower&#39;] = True</span>
<span class="gi">+            return s</span>
<span class="gi">+        elif func is str.upper:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            s[&#39;to_upper&#39;] = True</span>
<span class="gi">+            return s</span>
<span class="gi">+</span>
<span class="gi">+    return cs.no_info_after_validator_function(func, s)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _apply_constraint(  # noqa: C901</span>
<span class="gi">+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation</span>
<span class="gi">+) -&gt; cs.CoreSchema:</span>
<span class="gi">+    &quot;&quot;&quot;Apply a single constraint to a schema.&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(constraint, annotated_types.Gt):</span>
<span class="gi">+        gt = constraint.gt</span>
<span class="gi">+        if s and s[&#39;type&#39;] in {&#39;int&#39;, &#39;float&#39;, &#39;decimal&#39;}:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            if s[&#39;type&#39;] == &#39;int&#39; and isinstance(gt, int):</span>
<span class="gi">+                s[&#39;gt&#39;] = gt</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;float&#39; and isinstance(gt, float):</span>
<span class="gi">+                s[&#39;gt&#39;] = gt</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;decimal&#39; and isinstance(gt, Decimal):</span>
<span class="gi">+                s[&#39;gt&#39;] = gt</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def check_gt(v: Any) -&gt; bool:</span>
<span class="gi">+                return v &gt; gt</span>
<span class="gi">+</span>
<span class="gi">+            s = _check_func(check_gt, f&#39;&gt; {gt}&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Ge):</span>
<span class="gi">+        ge = constraint.ge</span>
<span class="gi">+        if s and s[&#39;type&#39;] in {&#39;int&#39;, &#39;float&#39;, &#39;decimal&#39;}:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            if s[&#39;type&#39;] == &#39;int&#39; and isinstance(ge, int):</span>
<span class="gi">+                s[&#39;ge&#39;] = ge</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;float&#39; and isinstance(ge, float):</span>
<span class="gi">+                s[&#39;ge&#39;] = ge</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;decimal&#39; and isinstance(ge, Decimal):</span>
<span class="gi">+                s[&#39;ge&#39;] = ge</span>
<span class="gi">+</span>
<span class="gi">+        def check_ge(v: Any) -&gt; bool:</span>
<span class="gi">+            return v &gt;= ge</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_ge, f&#39;&gt;= {ge}&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Lt):</span>
<span class="gi">+        lt = constraint.lt</span>
<span class="gi">+        if s and s[&#39;type&#39;] in {&#39;int&#39;, &#39;float&#39;, &#39;decimal&#39;}:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            if s[&#39;type&#39;] == &#39;int&#39; and isinstance(lt, int):</span>
<span class="gi">+                s[&#39;lt&#39;] = lt</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;float&#39; and isinstance(lt, float):</span>
<span class="gi">+                s[&#39;lt&#39;] = lt</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;decimal&#39; and isinstance(lt, Decimal):</span>
<span class="gi">+                s[&#39;lt&#39;] = lt</span>
<span class="gi">+</span>
<span class="gi">+        def check_lt(v: Any) -&gt; bool:</span>
<span class="gi">+            return v &lt; lt</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_lt, f&#39;&lt; {lt}&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Le):</span>
<span class="gi">+        le = constraint.le</span>
<span class="gi">+        if s and s[&#39;type&#39;] in {&#39;int&#39;, &#39;float&#39;, &#39;decimal&#39;}:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            if s[&#39;type&#39;] == &#39;int&#39; and isinstance(le, int):</span>
<span class="gi">+                s[&#39;le&#39;] = le</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;float&#39; and isinstance(le, float):</span>
<span class="gi">+                s[&#39;le&#39;] = le</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;decimal&#39; and isinstance(le, Decimal):</span>
<span class="gi">+                s[&#39;le&#39;] = le</span>
<span class="gi">+</span>
<span class="gi">+        def check_le(v: Any) -&gt; bool:</span>
<span class="gi">+            return v &lt;= le</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_le, f&#39;&lt;= {le}&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Len):</span>
<span class="gi">+        min_len = constraint.min_length</span>
<span class="gi">+        max_len = constraint.max_length</span>
<span class="gi">+</span>
<span class="gi">+        if s and s[&#39;type&#39;] in {&#39;str&#39;, &#39;list&#39;, &#39;tuple&#39;, &#39;set&#39;, &#39;frozenset&#39;, &#39;dict&#39;}:</span>
<span class="gi">+            assert (</span>
<span class="gi">+                s[&#39;type&#39;] == &#39;str&#39;</span>
<span class="gi">+                or s[&#39;type&#39;] == &#39;list&#39;</span>
<span class="gi">+                or s[&#39;type&#39;] == &#39;tuple&#39;</span>
<span class="gi">+                or s[&#39;type&#39;] == &#39;set&#39;</span>
<span class="gi">+                or s[&#39;type&#39;] == &#39;dict&#39;</span>
<span class="gi">+                or s[&#39;type&#39;] == &#39;frozenset&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            if min_len != 0:</span>
<span class="gi">+                s[&#39;min_length&#39;] = min_len</span>
<span class="gi">+            if max_len is not None:</span>
<span class="gi">+                s[&#39;max_length&#39;] = max_len</span>
<span class="gi">+</span>
<span class="gi">+        def check_len(v: Any) -&gt; bool:</span>
<span class="gi">+            if max_len is not None:</span>
<span class="gi">+                return (min_len &lt;= len(v)) and (len(v) &lt;= max_len)</span>
<span class="gi">+            return min_len &lt;= len(v)</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_len, f&#39;length &gt;= {min_len} and length &lt;= {max_len}&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.MultipleOf):</span>
<span class="gi">+        multiple_of = constraint.multiple_of</span>
<span class="gi">+        if s and s[&#39;type&#39;] in {&#39;int&#39;, &#39;float&#39;, &#39;decimal&#39;}:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            if s[&#39;type&#39;] == &#39;int&#39; and isinstance(multiple_of, int):</span>
<span class="gi">+                s[&#39;multiple_of&#39;] = multiple_of</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;float&#39; and isinstance(multiple_of, float):</span>
<span class="gi">+                s[&#39;multiple_of&#39;] = multiple_of</span>
<span class="gi">+            elif s[&#39;type&#39;] == &#39;decimal&#39; and isinstance(multiple_of, Decimal):</span>
<span class="gi">+                s[&#39;multiple_of&#39;] = multiple_of</span>
<span class="gi">+</span>
<span class="gi">+        def check_multiple_of(v: Any) -&gt; bool:</span>
<span class="gi">+            return v % multiple_of == 0</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_multiple_of, f&#39;% {multiple_of} == 0&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Timezone):</span>
<span class="gi">+        tz = constraint.tz</span>
<span class="gi">+</span>
<span class="gi">+        if tz is ...:</span>
<span class="gi">+            if s and s[&#39;type&#39;] == &#39;datetime&#39;:</span>
<span class="gi">+                s = s.copy()</span>
<span class="gi">+                s[&#39;tz_constraint&#39;] = &#39;aware&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                def check_tz_aware(v: object) -&gt; bool:</span>
<span class="gi">+                    assert isinstance(v, datetime.datetime)</span>
<span class="gi">+                    return v.tzinfo is not None</span>
<span class="gi">+</span>
<span class="gi">+                s = _check_func(check_tz_aware, &#39;timezone aware&#39;, s)</span>
<span class="gi">+        elif tz is None:</span>
<span class="gi">+            if s and s[&#39;type&#39;] == &#39;datetime&#39;:</span>
<span class="gi">+                s = s.copy()</span>
<span class="gi">+                s[&#39;tz_constraint&#39;] = &#39;naive&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                def check_tz_naive(v: object) -&gt; bool:</span>
<span class="gi">+                    assert isinstance(v, datetime.datetime)</span>
<span class="gi">+                    return v.tzinfo is None</span>
<span class="gi">+</span>
<span class="gi">+                s = _check_func(check_tz_naive, &#39;timezone naive&#39;, s)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(&#39;Constraining to a specific timezone is not yet supported&#39;)</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Interval):</span>
<span class="gi">+        if constraint.ge:</span>
<span class="gi">+            s = _apply_constraint(s, annotated_types.Ge(constraint.ge))</span>
<span class="gi">+        if constraint.gt:</span>
<span class="gi">+            s = _apply_constraint(s, annotated_types.Gt(constraint.gt))</span>
<span class="gi">+        if constraint.le:</span>
<span class="gi">+            s = _apply_constraint(s, annotated_types.Le(constraint.le))</span>
<span class="gi">+        if constraint.lt:</span>
<span class="gi">+            s = _apply_constraint(s, annotated_types.Lt(constraint.lt))</span>
<span class="gi">+        assert s is not None</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Predicate):</span>
<span class="gi">+        func = constraint.func</span>
<span class="gi">+</span>
<span class="gi">+        if func.__name__ == &#39;&lt;lambda&gt;&#39;:</span>
<span class="gi">+            # attempt to extract the source code for a lambda function</span>
<span class="gi">+            # to use as the function name in error messages</span>
<span class="gi">+            # TODO: is there a better way? should we just not do this?</span>
<span class="gi">+            import inspect</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                # remove &#39;)&#39; suffix, can use removesuffix once we drop 3.8</span>
<span class="gi">+                source = inspect.getsource(func).strip()</span>
<span class="gi">+                if source.endswith(&#39;)&#39;):</span>
<span class="gi">+                    source = source[:-1]</span>
<span class="gi">+                lambda_source_code = &#39;`&#39; + &#39;&#39;.join(&#39;&#39;.join(source.split(&#39;lambda &#39;)[1:]).split(&#39;:&#39;)[1:]).strip() + &#39;`&#39;</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # stringified annotations</span>
<span class="gi">+                lambda_source_code = &#39;lambda&#39;</span>
<span class="gi">+</span>
<span class="gi">+            s = _check_func(func, lambda_source_code, s)</span>
<span class="gi">+        else:</span>
<span class="gi">+            s = _check_func(func, func.__name__, s)</span>
<span class="gi">+    elif isinstance(constraint, _NotEq):</span>
<span class="gi">+        value = constraint.value</span>
<span class="gi">+</span>
<span class="gi">+        def check_not_eq(v: Any) -&gt; bool:</span>
<span class="gi">+            return operator.__ne__(v, value)</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_not_eq, f&#39;!= {value}&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, _Eq):</span>
<span class="gi">+        value = constraint.value</span>
<span class="gi">+</span>
<span class="gi">+        def check_eq(v: Any) -&gt; bool:</span>
<span class="gi">+            return operator.__eq__(v, value)</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_eq, f&#39;== {value}&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, _In):</span>
<span class="gi">+        values = constraint.values</span>
<span class="gi">+</span>
<span class="gi">+        def check_in(v: Any) -&gt; bool:</span>
<span class="gi">+            return operator.__contains__(values, v)</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_in, f&#39;in {values}&#39;, s)</span>
<span class="gi">+    elif isinstance(constraint, _NotIn):</span>
<span class="gi">+        values = constraint.values</span>
<span class="gi">+</span>
<span class="gi">+        def check_not_in(v: Any) -&gt; bool:</span>
<span class="gi">+            return operator.__not__(operator.__contains__(values, v))</span>
<span class="gi">+</span>
<span class="gi">+        s = _check_func(check_not_in, f&#39;not in {values}&#39;, s)</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert isinstance(constraint, Pattern)</span>
<span class="gi">+        if s and s[&#39;type&#39;] == &#39;str&#39;:</span>
<span class="gi">+            s = s.copy()</span>
<span class="gi">+            s[&#39;pattern&#39;] = constraint.pattern</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def check_pattern(v: object) -&gt; bool:</span>
<span class="gi">+                assert isinstance(v, str)</span>
<span class="gi">+                return constraint.match(v) is not None</span>
<span class="gi">+</span>
<span class="gi">+            s = _check_func(check_pattern, f&#39;~ {constraint.pattern}&#39;, s)</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _SupportsRange(annotated_types.SupportsLe, annotated_types.SupportsGe, Protocol):</span>
<span class="w"> </span>    pass


<span class="w"> </span>class _SupportsLen(Protocol):
<span class="gd">-</span>
<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __len__(self) -&gt; int: ...</span>


<span class="w"> </span>_NewOutGt = TypeVar(&#39;_NewOutGt&#39;, bound=annotated_types.SupportsGt)
<span class="gh">diff --git a/pydantic/fields.py b/pydantic/fields.py</span>
<span class="gh">index 6b34290ae..7b41a4d94 100644</span>
<span class="gd">--- a/pydantic/fields.py</span>
<span class="gi">+++ b/pydantic/fields.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Defining fields on models.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import inspect
<span class="w"> </span>import sys
<span class="gu">@@ -9,31 +11,42 @@ from dataclasses import Field as DataclassField</span>
<span class="w"> </span>from functools import cached_property
<span class="w"> </span>from typing import Any, ClassVar
<span class="w"> </span>from warnings import warn
<span class="gi">+</span>
<span class="w"> </span>import annotated_types
<span class="w"> </span>import typing_extensions
<span class="w"> </span>from pydantic_core import PydanticUndefined
<span class="w"> </span>from typing_extensions import Literal, TypeAlias, Unpack, deprecated
<span class="gi">+</span>
<span class="w"> </span>from . import types
<span class="w"> </span>from ._internal import _decorators, _fields, _generics, _internal_dataclass, _repr, _typing_extra, _utils
<span class="w"> </span>from .aliases import AliasChoices, AliasPath
<span class="w"> </span>from .config import JsonDict
<span class="w"> </span>from .errors import PydanticUserError
<span class="w"> </span>from .warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from ._internal._repr import ReprArgs
<span class="w"> </span>else:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;Field&#39;, &#39;PrivateAttr&#39;, &#39;computed_field&#39;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_Unset: Any = PydanticUndefined
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 13):
<span class="w"> </span>    import warnings
<span class="gi">+</span>
<span class="w"> </span>    Deprecated: TypeAlias = warnings.deprecated | deprecated
<span class="w"> </span>else:
<span class="w"> </span>    Deprecated: TypeAlias = deprecated


<span class="gd">-class _FromFieldInfoInputs(typing_extensions.TypedDict, total=(False)):</span>
<span class="gi">+class _FromFieldInfoInputs(typing_extensions.TypedDict, total=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;This class exists solely to add type checking for the `**kwargs` in `FieldInfo.from_field`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    annotation: type[Any] | None
<span class="w"> </span>    default_factory: typing.Callable[[], Any] | None
<span class="w"> </span>    alias: str | None
<span class="gu">@@ -41,8 +54,7 @@ class _FromFieldInfoInputs(typing_extensions.TypedDict, total=(False)):</span>
<span class="w"> </span>    validation_alias: str | AliasPath | AliasChoices | None
<span class="w"> </span>    serialization_alias: str | None
<span class="w"> </span>    title: str | None
<span class="gd">-    field_title_generator: typing_extensions.Callable[[str, FieldInfo], str</span>
<span class="gd">-        ] | None</span>
<span class="gi">+    field_title_generator: typing_extensions.Callable[[str, FieldInfo], str] | None</span>
<span class="w"> </span>    description: str | None
<span class="w"> </span>    examples: list[Any] | None
<span class="w"> </span>    exclude: bool | None
<span class="gu">@@ -72,8 +84,9 @@ class _FromFieldInfoInputs(typing_extensions.TypedDict, total=(False)):</span>
<span class="w"> </span>    fail_fast: bool | None


<span class="gd">-class _FieldInfoInputs(_FromFieldInfoInputs, total=(False)):</span>
<span class="gi">+class _FieldInfoInputs(_FromFieldInfoInputs, total=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;This class exists solely to add type checking for the `**kwargs` in `FieldInfo.__init__`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default: Any


<span class="gu">@@ -112,6 +125,7 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.
<span class="w"> </span>        metadata: List of metadata constraints.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    annotation: type[Any] | None
<span class="w"> </span>    default: Any
<span class="w"> </span>    default_factory: typing.Callable[[], Any] | None
<span class="gu">@@ -134,69 +148,100 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>    init_var: bool | None
<span class="w"> </span>    kw_only: bool | None
<span class="w"> </span>    metadata: list[Any]
<span class="gd">-    __slots__ = (&#39;annotation&#39;, &#39;default&#39;, &#39;default_factory&#39;, &#39;alias&#39;,</span>
<span class="gd">-        &#39;alias_priority&#39;, &#39;validation_alias&#39;, &#39;serialization_alias&#39;,</span>
<span class="gd">-        &#39;title&#39;, &#39;field_title_generator&#39;, &#39;description&#39;, &#39;examples&#39;,</span>
<span class="gd">-        &#39;exclude&#39;, &#39;discriminator&#39;, &#39;deprecated&#39;, &#39;json_schema_extra&#39;,</span>
<span class="gd">-        &#39;frozen&#39;, &#39;validate_default&#39;, &#39;repr&#39;, &#39;init&#39;, &#39;init_var&#39;, &#39;kw_only&#39;,</span>
<span class="gd">-        &#39;metadata&#39;, &#39;_attributes_set&#39;)</span>
<span class="gd">-    metadata_lookup: ClassVar[dict[str, typing.Callable[[Any], Any] | None]</span>
<span class="gd">-        ] = {&#39;strict&#39;: types.Strict, &#39;gt&#39;: annotated_types.Gt, &#39;ge&#39;:</span>
<span class="gd">-        annotated_types.Ge, &#39;lt&#39;: annotated_types.Lt, &#39;le&#39;: annotated_types</span>
<span class="gd">-        .Le, &#39;multiple_of&#39;: annotated_types.MultipleOf, &#39;min_length&#39;:</span>
<span class="gd">-        annotated_types.MinLen, &#39;max_length&#39;: annotated_types.MaxLen,</span>
<span class="gd">-        &#39;pattern&#39;: None, &#39;allow_inf_nan&#39;: None, &#39;max_digits&#39;: None,</span>
<span class="gd">-        &#39;decimal_places&#39;: None, &#39;union_mode&#39;: None, &#39;coerce_numbers_to_str&#39;:</span>
<span class="gd">-        None, &#39;fail_fast&#39;: types.FailFast}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;annotation&#39;,</span>
<span class="gi">+        &#39;default&#39;,</span>
<span class="gi">+        &#39;default_factory&#39;,</span>
<span class="gi">+        &#39;alias&#39;,</span>
<span class="gi">+        &#39;alias_priority&#39;,</span>
<span class="gi">+        &#39;validation_alias&#39;,</span>
<span class="gi">+        &#39;serialization_alias&#39;,</span>
<span class="gi">+        &#39;title&#39;,</span>
<span class="gi">+        &#39;field_title_generator&#39;,</span>
<span class="gi">+        &#39;description&#39;,</span>
<span class="gi">+        &#39;examples&#39;,</span>
<span class="gi">+        &#39;exclude&#39;,</span>
<span class="gi">+        &#39;discriminator&#39;,</span>
<span class="gi">+        &#39;deprecated&#39;,</span>
<span class="gi">+        &#39;json_schema_extra&#39;,</span>
<span class="gi">+        &#39;frozen&#39;,</span>
<span class="gi">+        &#39;validate_default&#39;,</span>
<span class="gi">+        &#39;repr&#39;,</span>
<span class="gi">+        &#39;init&#39;,</span>
<span class="gi">+        &#39;init_var&#39;,</span>
<span class="gi">+        &#39;kw_only&#39;,</span>
<span class="gi">+        &#39;metadata&#39;,</span>
<span class="gi">+        &#39;_attributes_set&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # used to convert kwargs to metadata/constraints,</span>
<span class="gi">+    # None has a special meaning - these items are collected into a `PydanticGeneralMetadata`</span>
<span class="gi">+    metadata_lookup: ClassVar[dict[str, typing.Callable[[Any], Any] | None]] = {</span>
<span class="gi">+        &#39;strict&#39;: types.Strict,</span>
<span class="gi">+        &#39;gt&#39;: annotated_types.Gt,</span>
<span class="gi">+        &#39;ge&#39;: annotated_types.Ge,</span>
<span class="gi">+        &#39;lt&#39;: annotated_types.Lt,</span>
<span class="gi">+        &#39;le&#39;: annotated_types.Le,</span>
<span class="gi">+        &#39;multiple_of&#39;: annotated_types.MultipleOf,</span>
<span class="gi">+        &#39;min_length&#39;: annotated_types.MinLen,</span>
<span class="gi">+        &#39;max_length&#39;: annotated_types.MaxLen,</span>
<span class="gi">+        &#39;pattern&#39;: None,</span>
<span class="gi">+        &#39;allow_inf_nan&#39;: None,</span>
<span class="gi">+        &#39;max_digits&#39;: None,</span>
<span class="gi">+        &#39;decimal_places&#39;: None,</span>
<span class="gi">+        &#39;union_mode&#39;: None,</span>
<span class="gi">+        &#39;coerce_numbers_to_str&#39;: None,</span>
<span class="gi">+        &#39;fail_fast&#39;: types.FailFast,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This class should generally not be initialized directly; instead, use the `pydantic.fields.Field` function
<span class="w"> </span>        or one of the constructor classmethods.

<span class="w"> </span>        See the signature of `pydantic.fields.Field` for more details about the expected arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self._attributes_set = {k: v for k, v in kwargs.items() if v is not</span>
<span class="gd">-            _Unset}</span>
<span class="gd">-        kwargs = {k: (_DefaultValues.get(k) if v is _Unset else v) for k, v in</span>
<span class="gd">-            kwargs.items()}</span>
<span class="gd">-        self.annotation, annotation_metadata = self._extract_metadata(kwargs</span>
<span class="gd">-            .get(&#39;annotation&#39;))</span>
<span class="gi">+        self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset}</span>
<span class="gi">+        kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore</span>
<span class="gi">+        self.annotation, annotation_metadata = self._extract_metadata(kwargs.get(&#39;annotation&#39;))</span>
<span class="gi">+</span>
<span class="w"> </span>        default = kwargs.pop(&#39;default&#39;, PydanticUndefined)
<span class="w"> </span>        if default is Ellipsis:
<span class="w"> </span>            self.default = PydanticUndefined
<span class="w"> </span>        else:
<span class="w"> </span>            self.default = default
<span class="gi">+</span>
<span class="w"> </span>        self.default_factory = kwargs.pop(&#39;default_factory&#39;, None)
<span class="gd">-        if (self.default is not PydanticUndefined and self.default_factory</span>
<span class="gd">-             is not None):</span>
<span class="gi">+</span>
<span class="gi">+        if self.default is not PydanticUndefined and self.default_factory is not None:</span>
<span class="w"> </span>            raise TypeError(&#39;cannot specify both default and default_factory&#39;)
<span class="gi">+</span>
<span class="w"> </span>        self.alias = kwargs.pop(&#39;alias&#39;, None)
<span class="w"> </span>        self.validation_alias = kwargs.pop(&#39;validation_alias&#39;, None)
<span class="w"> </span>        self.serialization_alias = kwargs.pop(&#39;serialization_alias&#39;, None)
<span class="gd">-        alias_is_set = any(alias is not None for alias in (self.alias, self</span>
<span class="gd">-            .validation_alias, self.serialization_alias))</span>
<span class="gd">-        self.alias_priority = kwargs.pop(&#39;alias_priority&#39;, None</span>
<span class="gd">-            ) or 2 if alias_is_set else None</span>
<span class="gi">+        alias_is_set = any(alias is not None for alias in (self.alias, self.validation_alias, self.serialization_alias))</span>
<span class="gi">+        self.alias_priority = kwargs.pop(&#39;alias_priority&#39;, None) or 2 if alias_is_set else None</span>
<span class="w"> </span>        self.title = kwargs.pop(&#39;title&#39;, None)
<span class="w"> </span>        self.field_title_generator = kwargs.pop(&#39;field_title_generator&#39;, None)
<span class="w"> </span>        self.description = kwargs.pop(&#39;description&#39;, None)
<span class="w"> </span>        self.examples = kwargs.pop(&#39;examples&#39;, None)
<span class="w"> </span>        self.exclude = kwargs.pop(&#39;exclude&#39;, None)
<span class="w"> </span>        self.discriminator = kwargs.pop(&#39;discriminator&#39;, None)
<span class="gd">-        self.deprecated = kwargs.pop(&#39;deprecated&#39;, getattr(self,</span>
<span class="gd">-            &#39;deprecated&#39;, None))</span>
<span class="gi">+        # For compatibility with FastAPI&lt;=0.110.0, we preserve the existing value if it is not overridden</span>
<span class="gi">+        self.deprecated = kwargs.pop(&#39;deprecated&#39;, getattr(self, &#39;deprecated&#39;, None))</span>
<span class="w"> </span>        self.repr = kwargs.pop(&#39;repr&#39;, True)
<span class="w"> </span>        self.json_schema_extra = kwargs.pop(&#39;json_schema_extra&#39;, None)
<span class="w"> </span>        self.validate_default = kwargs.pop(&#39;validate_default&#39;, None)
<span class="w"> </span>        self.frozen = kwargs.pop(&#39;frozen&#39;, None)
<span class="gi">+        # currently only used on dataclasses</span>
<span class="w"> </span>        self.init = kwargs.pop(&#39;init&#39;, None)
<span class="w"> </span>        self.init_var = kwargs.pop(&#39;init_var&#39;, None)
<span class="w"> </span>        self.kw_only = kwargs.pop(&#39;kw_only&#39;, None)
<span class="gd">-        self.metadata = self._collect_metadata(kwargs) + annotation_metadata</span>
<span class="gi">+</span>
<span class="gi">+        self.metadata = self._collect_metadata(kwargs) + annotation_metadata  # type: ignore</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def from_field(default: Any=PydanticUndefined, **kwargs: Unpack[</span>
<span class="gd">-        _FromFieldInfoInputs]) -&gt;FieldInfo:</span>
<span class="gi">+    def from_field(default: Any = PydanticUndefined, **kwargs: Unpack[_FromFieldInfoInputs]) -&gt; FieldInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new `FieldInfo` object with the `Field` function.

<span class="w"> </span>        Args:
<span class="gu">@@ -219,10 +264,12 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>                foo: int = pydantic.Field(4)
<span class="w"> </span>            ```
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;annotation&#39; in kwargs:</span>
<span class="gi">+            raise TypeError(&#39;&quot;annotation&quot; is not permitted as a Field keyword argument&#39;)</span>
<span class="gi">+        return FieldInfo(default=default, **kwargs)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def from_annotation(annotation: type[Any]) -&gt;FieldInfo:</span>
<span class="gi">+    def from_annotation(annotation: type[Any]) -&gt; FieldInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a `FieldInfo` instance from a bare annotation.

<span class="w"> </span>        This function is used internally to create a `FieldInfo` from a bare annotation like this:
<span class="gu">@@ -254,11 +301,37 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            An instance of the field metadata.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        final = False</span>
<span class="gi">+        if _typing_extra.is_finalvar(annotation):</span>
<span class="gi">+            final = True</span>
<span class="gi">+            if annotation is not typing_extensions.Final:</span>
<span class="gi">+                annotation = typing_extensions.get_args(annotation)[0]</span>
<span class="gi">+</span>
<span class="gi">+        if _typing_extra.is_annotated(annotation):</span>
<span class="gi">+            first_arg, *extra_args = typing_extensions.get_args(annotation)</span>
<span class="gi">+            if _typing_extra.is_finalvar(first_arg):</span>
<span class="gi">+                final = True</span>
<span class="gi">+            field_info_annotations = [a for a in extra_args if isinstance(a, FieldInfo)]</span>
<span class="gi">+            field_info = FieldInfo.merge_field_infos(*field_info_annotations, annotation=first_arg)</span>
<span class="gi">+            if field_info:</span>
<span class="gi">+                new_field_info = copy(field_info)</span>
<span class="gi">+                new_field_info.annotation = first_arg</span>
<span class="gi">+                new_field_info.frozen = final or field_info.frozen</span>
<span class="gi">+                metadata: list[Any] = []</span>
<span class="gi">+                for a in extra_args:</span>
<span class="gi">+                    if _typing_extra.is_deprecated_instance(a):</span>
<span class="gi">+                        new_field_info.deprecated = a.message</span>
<span class="gi">+                    elif not isinstance(a, FieldInfo):</span>
<span class="gi">+                        metadata.append(a)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        metadata.extend(a.metadata)</span>
<span class="gi">+                new_field_info.metadata = metadata</span>
<span class="gi">+                return new_field_info</span>
<span class="gi">+</span>
<span class="gi">+        return FieldInfo(annotation=annotation, frozen=final or None)  # pyright: ignore[reportArgumentType]</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def from_annotated_attribute(annotation: type[Any], default: Any</span>
<span class="gd">-        ) -&gt;FieldInfo:</span>
<span class="gi">+    def from_annotated_attribute(annotation: type[Any], default: Any) -&gt; FieldInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create `FieldInfo` from an annotation with a default value.

<span class="w"> </span>        This is used in cases like the following:
<span class="gu">@@ -282,11 +355,68 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A field object with the passed values.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if annotation is default:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;Error when building FieldInfo from annotated attribute. &#39;</span>
<span class="gi">+                &quot;Make sure you don&#39;t have any field name clashing with a type annotation &quot;,</span>
<span class="gi">+                code=&#39;unevaluable-type-annotation&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        final = False</span>
<span class="gi">+        if _typing_extra.is_finalvar(annotation):</span>
<span class="gi">+            final = True</span>
<span class="gi">+            if annotation is not typing_extensions.Final:</span>
<span class="gi">+                annotation = typing_extensions.get_args(annotation)[0]</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(default, FieldInfo):</span>
<span class="gi">+            default.annotation, annotation_metadata = FieldInfo._extract_metadata(annotation)  # pyright: ignore[reportArgumentType]</span>
<span class="gi">+            default.metadata += annotation_metadata</span>
<span class="gi">+            default = default.merge_field_infos(</span>
<span class="gi">+                *[x for x in annotation_metadata if isinstance(x, FieldInfo)], default, annotation=default.annotation</span>
<span class="gi">+            )</span>
<span class="gi">+            default.frozen = final or default.frozen</span>
<span class="gi">+            return default</span>
<span class="gi">+        elif isinstance(default, dataclasses.Field):</span>
<span class="gi">+            init_var = False</span>
<span class="gi">+            if annotation is dataclasses.InitVar:</span>
<span class="gi">+                init_var = True</span>
<span class="gi">+                annotation = typing.cast(Any, Any)</span>
<span class="gi">+            elif isinstance(annotation, dataclasses.InitVar):</span>
<span class="gi">+                init_var = True</span>
<span class="gi">+                annotation = annotation.type</span>
<span class="gi">+            pydantic_field = FieldInfo._from_dataclass_field(default)</span>
<span class="gi">+            pydantic_field.annotation, annotation_metadata = FieldInfo._extract_metadata(annotation)  # pyright: ignore[reportArgumentType]</span>
<span class="gi">+            pydantic_field.metadata += annotation_metadata</span>
<span class="gi">+            pydantic_field = pydantic_field.merge_field_infos(</span>
<span class="gi">+                *[x for x in annotation_metadata if isinstance(x, FieldInfo)],</span>
<span class="gi">+                pydantic_field,</span>
<span class="gi">+                annotation=pydantic_field.annotation,</span>
<span class="gi">+            )</span>
<span class="gi">+            pydantic_field.frozen = final or pydantic_field.frozen</span>
<span class="gi">+            pydantic_field.init_var = init_var</span>
<span class="gi">+            pydantic_field.init = getattr(default, &#39;init&#39;, None)</span>
<span class="gi">+            pydantic_field.kw_only = getattr(default, &#39;kw_only&#39;, None)</span>
<span class="gi">+            return pydantic_field</span>
<span class="gi">+        else:</span>
<span class="gi">+            if _typing_extra.is_annotated(annotation):</span>
<span class="gi">+                first_arg, *extra_args = typing_extensions.get_args(annotation)</span>
<span class="gi">+                field_infos = [a for a in extra_args if isinstance(a, FieldInfo)]</span>
<span class="gi">+                field_info = FieldInfo.merge_field_infos(*field_infos, annotation=first_arg, default=default)</span>
<span class="gi">+                metadata: list[Any] = []</span>
<span class="gi">+                for a in extra_args:</span>
<span class="gi">+                    if _typing_extra.is_deprecated_instance(a):</span>
<span class="gi">+                        field_info.deprecated = a.message</span>
<span class="gi">+                    elif not isinstance(a, FieldInfo):</span>
<span class="gi">+                        metadata.append(a)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        metadata.extend(a.metadata)</span>
<span class="gi">+                field_info.metadata = metadata</span>
<span class="gi">+                return field_info</span>
<span class="gi">+</span>
<span class="gi">+            return FieldInfo(annotation=annotation, default=default, frozen=final or None)  # pyright: ignore[reportArgumentType]</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def merge_field_infos(*field_infos: FieldInfo, **overrides: Any</span>
<span class="gd">-        ) -&gt;FieldInfo:</span>
<span class="gi">+    def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -&gt; FieldInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;Merge `FieldInfo` instances keeping only explicitly set attributes.

<span class="w"> </span>        Later `FieldInfo` instances override earlier ones.
<span class="gu">@@ -294,10 +424,40 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            FieldInfo: A merged FieldInfo instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        flattened_field_infos: list[FieldInfo] = []</span>
<span class="gi">+        for field_info in field_infos:</span>
<span class="gi">+            flattened_field_infos.extend(x for x in field_info.metadata if isinstance(x, FieldInfo))</span>
<span class="gi">+            flattened_field_infos.append(field_info)</span>
<span class="gi">+        field_infos = tuple(flattened_field_infos)</span>
<span class="gi">+        if len(field_infos) == 1:</span>
<span class="gi">+            # No merging necessary, but we still need to make a copy and apply the overrides</span>
<span class="gi">+            field_info = copy(field_infos[0])</span>
<span class="gi">+            field_info._attributes_set.update(overrides)</span>
<span class="gi">+</span>
<span class="gi">+            default_override = overrides.pop(&#39;default&#39;, PydanticUndefined)</span>
<span class="gi">+            if default_override is Ellipsis:</span>
<span class="gi">+                default_override = PydanticUndefined</span>
<span class="gi">+            if default_override is not PydanticUndefined:</span>
<span class="gi">+                field_info.default = default_override</span>
<span class="gi">+</span>
<span class="gi">+            for k, v in overrides.items():</span>
<span class="gi">+                setattr(field_info, k, v)</span>
<span class="gi">+            return field_info  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        new_kwargs: dict[str, Any] = {}</span>
<span class="gi">+        metadata = {}</span>
<span class="gi">+        for field_info in field_infos:</span>
<span class="gi">+            new_kwargs.update(field_info._attributes_set)</span>
<span class="gi">+            for x in field_info.metadata:</span>
<span class="gi">+                if not isinstance(x, FieldInfo):</span>
<span class="gi">+                    metadata[type(x)] = x</span>
<span class="gi">+        new_kwargs.update(overrides)</span>
<span class="gi">+        field_info = FieldInfo(**new_kwargs)</span>
<span class="gi">+        field_info.metadata = list(metadata.values())</span>
<span class="gi">+        return field_info</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _from_dataclass_field(dc_field: DataclassField[Any]) -&gt;FieldInfo:</span>
<span class="gi">+    def _from_dataclass_field(dc_field: DataclassField[Any]) -&gt; FieldInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new `FieldInfo` instance from a `dataclasses.Field` instance.

<span class="w"> </span>        Args:
<span class="gu">@@ -309,11 +469,21 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            TypeError: If any of the `FieldInfo` kwargs does not match the `dataclass.Field` kwargs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        default = dc_field.default</span>
<span class="gi">+        if default is dataclasses.MISSING:</span>
<span class="gi">+            default = PydanticUndefined</span>
<span class="gi">+</span>
<span class="gi">+        if dc_field.default_factory is dataclasses.MISSING:</span>
<span class="gi">+            default_factory: typing.Callable[[], Any] | None = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            default_factory = dc_field.default_factory</span>
<span class="gi">+</span>
<span class="gi">+        # use the `Field` function so in correct kwargs raise the correct `TypeError`</span>
<span class="gi">+        dc_field_metadata = {k: v for k, v in dc_field.metadata.items() if k in _FIELD_ARG_NAMES}</span>
<span class="gi">+        return Field(default=default, default_factory=default_factory, repr=dc_field.repr, **dc_field_metadata)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _extract_metadata(annotation: (type[Any] | None)) -&gt;tuple[type[Any] |</span>
<span class="gd">-        None, list[Any]]:</span>
<span class="gi">+    def _extract_metadata(annotation: type[Any] | None) -&gt; tuple[type[Any] | None, list[Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Tries to extract metadata/constraints from an annotation if it uses `Annotated`.

<span class="w"> </span>        Args:
<span class="gu">@@ -322,10 +492,15 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A tuple containing the extracted metadata type and the list of extra arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if annotation is not None:</span>
<span class="gi">+            if _typing_extra.is_annotated(annotation):</span>
<span class="gi">+                first_arg, *extra_args = typing_extensions.get_args(annotation)</span>
<span class="gi">+                return first_arg, list(extra_args)</span>
<span class="gi">+</span>
<span class="gi">+        return annotation, []</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _collect_metadata(kwargs: dict[str, Any]) -&gt;list[Any]:</span>
<span class="gi">+    def _collect_metadata(kwargs: dict[str, Any]) -&gt; list[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Collect annotations from kwargs.

<span class="w"> </span>        Args:
<span class="gu">@@ -335,14 +510,34 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>            A list of metadata objects - a combination of `annotated_types.BaseMetadata` and
<span class="w"> </span>                `PydanticMetadata`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        metadata: list[Any] = []</span>
<span class="gi">+        general_metadata = {}</span>
<span class="gi">+        for key, value in list(kwargs.items()):</span>
<span class="gi">+            try:</span>
<span class="gi">+                marker = FieldInfo.metadata_lookup[key]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            del kwargs[key]</span>
<span class="gi">+            if value is not None:</span>
<span class="gi">+                if marker is None:</span>
<span class="gi">+                    general_metadata[key] = value</span>
<span class="gi">+                else:</span>
<span class="gi">+                    metadata.append(marker(value))</span>
<span class="gi">+        if general_metadata:</span>
<span class="gi">+            metadata.append(_fields.pydantic_general_metadata(**general_metadata))</span>
<span class="gi">+        return metadata</span>

<span class="w"> </span>    @property
<span class="gd">-    def deprecation_message(self) -&gt;(str | None):</span>
<span class="gi">+    def deprecation_message(self) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The deprecation message to be emitted, or `None` if not set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.deprecated is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if isinstance(self.deprecated, bool):</span>
<span class="gi">+            return &#39;deprecated&#39; if self.deprecated else None</span>
<span class="gi">+        return self.deprecated if isinstance(self.deprecated, str) else self.deprecated.message</span>

<span class="gd">-    def get_default(self, *, call_default_factory: bool=False) -&gt;Any:</span>
<span class="gi">+    def get_default(self, *, call_default_factory: bool = False) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the default value.

<span class="w"> </span>        We expose an option for whether to call the default_factory (if present), as calling it may
<span class="gu">@@ -355,17 +550,22 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The default value, calling the default factory if requested or `None` if not set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_factory is None:</span>
<span class="gi">+            return _utils.smart_deepcopy(self.default)</span>
<span class="gi">+        elif call_default_factory:</span>
<span class="gi">+            return self.default_factory()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>

<span class="gd">-    def is_required(self) -&gt;bool:</span>
<span class="gi">+    def is_required(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the field is required (i.e., does not have a default value or factory).

<span class="w"> </span>        Returns:
<span class="w"> </span>            `True` if the field is required, `False` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.default is PydanticUndefined and self.default_factory is None</span>

<span class="gd">-    def rebuild_annotation(self) -&gt;Any:</span>
<span class="gi">+    def rebuild_annotation(self) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempts to rebuild the original annotation for use in function signatures.

<span class="w"> </span>        If metadata is present, it adds it to the original annotation using
<span class="gu">@@ -378,10 +578,13 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The rebuilt annotation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.metadata:</span>
<span class="gi">+            return self.annotation</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Annotated arguments must be a tuple</span>
<span class="gi">+            return typing_extensions.Annotated[(self.annotation, *self.metadata)]  # type: ignore</span>

<span class="gd">-    def apply_typevars_map(self, typevars_map: (dict[Any, Any] | None),</span>
<span class="gd">-        types_namespace: (dict[str, Any] | None)) -&gt;None:</span>
<span class="gi">+    def apply_typevars_map(self, typevars_map: dict[Any, Any] | None, types_namespace: dict[str, Any] | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply a `typevars_map` to the annotation.

<span class="w"> </span>        This method is used when analyzing parametrized generic types to replace typevars with their concrete types.
<span class="gu">@@ -396,12 +599,13 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>            pydantic._internal._generics.replace_types is used for replacing the typevars with
<span class="w"> </span>                their concrete types.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        annotation = _typing_extra.eval_type_lenient(self.annotation, types_namespace)</span>
<span class="gi">+        self.annotation = _generics.replace_types(annotation, typevars_map)</span>

<span class="gd">-    def __repr_args__(self) -&gt;ReprArgs:</span>
<span class="gd">-        yield &#39;annotation&#39;, _repr.PlainRepr(_repr.display_as_type(self.</span>
<span class="gd">-            annotation))</span>
<span class="gi">+    def __repr_args__(self) -&gt; ReprArgs:</span>
<span class="gi">+        yield &#39;annotation&#39;, _repr.PlainRepr(_repr.display_as_type(self.annotation))</span>
<span class="w"> </span>        yield &#39;required&#39;, self.is_required()
<span class="gi">+</span>
<span class="w"> </span>        for s in self.__slots__:
<span class="w"> </span>            if s == &#39;_attributes_set&#39;:
<span class="w"> </span>                continue
<span class="gu">@@ -415,14 +619,12 @@ class FieldInfo(_repr.Representation):</span>
<span class="w"> </span>                continue
<span class="w"> </span>            if s == &#39;validation_alias&#39; and self.validation_alias == self.alias:
<span class="w"> </span>                continue
<span class="gd">-            if (s == &#39;serialization_alias&#39; and self.serialization_alias ==</span>
<span class="gd">-                self.alias):</span>
<span class="gi">+            if s == &#39;serialization_alias&#39; and self.serialization_alias == self.alias:</span>
<span class="w"> </span>                continue
<span class="w"> </span>            if s == &#39;default&#39; and self.default is not PydanticUndefined:
<span class="w"> </span>                yield &#39;default&#39;, self.default
<span class="w"> </span>            elif s == &#39;default_factory&#39; and self.default_factory is not None:
<span class="gd">-                yield &#39;default_factory&#39;, _repr.PlainRepr(_repr.</span>
<span class="gd">-                    display_as_type(self.default_factory))</span>
<span class="gi">+                yield &#39;default_factory&#39;, _repr.PlainRepr(_repr.display_as_type(self.default_factory))</span>
<span class="w"> </span>            else:
<span class="w"> </span>                value = getattr(self, s)
<span class="w"> </span>                if value is not None and value is not PydanticUndefined:
<span class="gu">@@ -433,38 +635,80 @@ class _EmptyKwargs(typing_extensions.TypedDict):</span>
<span class="w"> </span>    &quot;&quot;&quot;This class exists solely to ensure that type checking warns about passing `**extra` in `Field`.&quot;&quot;&quot;


<span class="gd">-_DefaultValues = dict(default=..., default_factory=None, alias=None,</span>
<span class="gd">-    alias_priority=None, validation_alias=None, serialization_alias=None,</span>
<span class="gd">-    title=None, description=None, examples=None, exclude=None,</span>
<span class="gd">-    discriminator=None, json_schema_extra=None, frozen=None,</span>
<span class="gd">-    validate_default=None, repr=True, init=None, init_var=None, kw_only=</span>
<span class="gd">-    None, pattern=None, strict=None, gt=None, ge=None, lt=None, le=None,</span>
<span class="gd">-    multiple_of=None, allow_inf_nan=None, max_digits=None, decimal_places=</span>
<span class="gd">-    None, min_length=None, max_length=None, coerce_numbers_to_str=None)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def Field(default: Any=PydanticUndefined, *, default_factory: (typing.</span>
<span class="gd">-    Callable[[], Any] | None)=_Unset, alias: (str | None)=_Unset,</span>
<span class="gd">-    alias_priority: (int | None)=_Unset, validation_alias: (str | AliasPath |</span>
<span class="gd">-    AliasChoices | None)=_Unset, serialization_alias: (str | None)=_Unset,</span>
<span class="gd">-    title: (str | None)=_Unset, field_title_generator: (typing_extensions.</span>
<span class="gd">-    Callable[[str, FieldInfo], str] | None)=_Unset, description: (str |</span>
<span class="gd">-    None)=_Unset, examples: (list[Any] | None)=_Unset, exclude: (bool |</span>
<span class="gd">-    None)=_Unset, discriminator: (str | types.Discriminator | None)=_Unset,</span>
<span class="gd">-    deprecated: (Deprecated | str | bool | None)=_Unset, json_schema_extra:</span>
<span class="gd">-    (JsonDict | typing.Callable[[JsonDict], None] | None)=_Unset, frozen: (</span>
<span class="gd">-    bool | None)=_Unset, validate_default: (bool | None)=_Unset, repr: bool</span>
<span class="gd">-    =_Unset, init: (bool | None)=_Unset, init_var: (bool | None)=_Unset,</span>
<span class="gd">-    kw_only: (bool | None)=_Unset, pattern: (str | typing.Pattern[str] |</span>
<span class="gd">-    None)=_Unset, strict: (bool | None)=_Unset, coerce_numbers_to_str: (</span>
<span class="gd">-    bool | None)=_Unset, gt: (annotated_types.SupportsGt | None)=_Unset, ge:</span>
<span class="gd">-    (annotated_types.SupportsGe | None)=_Unset, lt: (annotated_types.</span>
<span class="gd">-    SupportsLt | None)=_Unset, le: (annotated_types.SupportsLe | None)=</span>
<span class="gd">-    _Unset, multiple_of: (float | None)=_Unset, allow_inf_nan: (bool | None</span>
<span class="gd">-    )=_Unset, max_digits: (int | None)=_Unset, decimal_places: (int | None)</span>
<span class="gd">-    =_Unset, min_length: (int | None)=_Unset, max_length: (int | None)=</span>
<span class="gd">-    _Unset, union_mode: Literal[&#39;smart&#39;, &#39;left_to_right&#39;]=_Unset, fail_fast:</span>
<span class="gd">-    (bool | None)=_Unset, **extra: Unpack[_EmptyKwargs]) -&gt;Any:</span>
<span class="gi">+_DefaultValues = dict(</span>
<span class="gi">+    default=...,</span>
<span class="gi">+    default_factory=None,</span>
<span class="gi">+    alias=None,</span>
<span class="gi">+    alias_priority=None,</span>
<span class="gi">+    validation_alias=None,</span>
<span class="gi">+    serialization_alias=None,</span>
<span class="gi">+    title=None,</span>
<span class="gi">+    description=None,</span>
<span class="gi">+    examples=None,</span>
<span class="gi">+    exclude=None,</span>
<span class="gi">+    discriminator=None,</span>
<span class="gi">+    json_schema_extra=None,</span>
<span class="gi">+    frozen=None,</span>
<span class="gi">+    validate_default=None,</span>
<span class="gi">+    repr=True,</span>
<span class="gi">+    init=None,</span>
<span class="gi">+    init_var=None,</span>
<span class="gi">+    kw_only=None,</span>
<span class="gi">+    pattern=None,</span>
<span class="gi">+    strict=None,</span>
<span class="gi">+    gt=None,</span>
<span class="gi">+    ge=None,</span>
<span class="gi">+    lt=None,</span>
<span class="gi">+    le=None,</span>
<span class="gi">+    multiple_of=None,</span>
<span class="gi">+    allow_inf_nan=None,</span>
<span class="gi">+    max_digits=None,</span>
<span class="gi">+    decimal_places=None,</span>
<span class="gi">+    min_length=None,</span>
<span class="gi">+    max_length=None,</span>
<span class="gi">+    coerce_numbers_to_str=None,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def Field(  # noqa: C901</span>
<span class="gi">+    default: Any = PydanticUndefined,</span>
<span class="gi">+    *,</span>
<span class="gi">+    default_factory: typing.Callable[[], Any] | None = _Unset,</span>
<span class="gi">+    alias: str | None = _Unset,</span>
<span class="gi">+    alias_priority: int | None = _Unset,</span>
<span class="gi">+    validation_alias: str | AliasPath | AliasChoices | None = _Unset,</span>
<span class="gi">+    serialization_alias: str | None = _Unset,</span>
<span class="gi">+    title: str | None = _Unset,</span>
<span class="gi">+    field_title_generator: typing_extensions.Callable[[str, FieldInfo], str] | None = _Unset,</span>
<span class="gi">+    description: str | None = _Unset,</span>
<span class="gi">+    examples: list[Any] | None = _Unset,</span>
<span class="gi">+    exclude: bool | None = _Unset,</span>
<span class="gi">+    discriminator: str | types.Discriminator | None = _Unset,</span>
<span class="gi">+    deprecated: Deprecated | str | bool | None = _Unset,</span>
<span class="gi">+    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = _Unset,</span>
<span class="gi">+    frozen: bool | None = _Unset,</span>
<span class="gi">+    validate_default: bool | None = _Unset,</span>
<span class="gi">+    repr: bool = _Unset,</span>
<span class="gi">+    init: bool | None = _Unset,</span>
<span class="gi">+    init_var: bool | None = _Unset,</span>
<span class="gi">+    kw_only: bool | None = _Unset,</span>
<span class="gi">+    pattern: str | typing.Pattern[str] | None = _Unset,</span>
<span class="gi">+    strict: bool | None = _Unset,</span>
<span class="gi">+    coerce_numbers_to_str: bool | None = _Unset,</span>
<span class="gi">+    gt: annotated_types.SupportsGt | None = _Unset,</span>
<span class="gi">+    ge: annotated_types.SupportsGe | None = _Unset,</span>
<span class="gi">+    lt: annotated_types.SupportsLt | None = _Unset,</span>
<span class="gi">+    le: annotated_types.SupportsLe | None = _Unset,</span>
<span class="gi">+    multiple_of: float | None = _Unset,</span>
<span class="gi">+    allow_inf_nan: bool | None = _Unset,</span>
<span class="gi">+    max_digits: int | None = _Unset,</span>
<span class="gi">+    decimal_places: int | None = _Unset,</span>
<span class="gi">+    min_length: int | None = _Unset,</span>
<span class="gi">+    max_length: int | None = _Unset,</span>
<span class="gi">+    union_mode: Literal[&#39;smart&#39;, &#39;left_to_right&#39;] = _Unset,</span>
<span class="gi">+    fail_fast: bool | None = _Unset,</span>
<span class="gi">+    **extra: Unpack[_EmptyKwargs],</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/fields

<span class="w"> </span>    Create a field for objects that can be configured.
<span class="gu">@@ -529,11 +773,111 @@ def Field(default: Any=PydanticUndefined, *, default_factory: (typing.</span>
<span class="w"> </span>        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on
<span class="w"> </span>            type-annotated fields without causing a type error.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check deprecated and removed params from V1. This logic should eventually be removed.</span>
<span class="gi">+    const = extra.pop(&#39;const&#39;, None)  # type: ignore</span>
<span class="gi">+    if const is not None:</span>
<span class="gi">+        raise PydanticUserError(&#39;`const` is removed, use `Literal` instead&#39;, code=&#39;removed-kwargs&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    min_items = extra.pop(&#39;min_items&#39;, None)  # type: ignore</span>
<span class="gi">+    if min_items is not None:</span>
<span class="gi">+        warn(&#39;`min_items` is deprecated and will be removed, use `min_length` instead&#39;, DeprecationWarning)</span>
<span class="gi">+        if min_length in (None, _Unset):</span>
<span class="gi">+            min_length = min_items  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    max_items = extra.pop(&#39;max_items&#39;, None)  # type: ignore</span>
<span class="gi">+    if max_items is not None:</span>
<span class="gi">+        warn(&#39;`max_items` is deprecated and will be removed, use `max_length` instead&#39;, DeprecationWarning)</span>
<span class="gi">+        if max_length in (None, _Unset):</span>
<span class="gi">+            max_length = max_items  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    unique_items = extra.pop(&#39;unique_items&#39;, None)  # type: ignore</span>
<span class="gi">+    if unique_items is not None:</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            (</span>
<span class="gi">+                &#39;`unique_items` is removed, use `Set` instead&#39;</span>
<span class="gi">+                &#39;(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)&#39;</span>
<span class="gi">+            ),</span>
<span class="gi">+            code=&#39;removed-kwargs&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    allow_mutation = extra.pop(&#39;allow_mutation&#39;, None)  # type: ignore</span>
<span class="gi">+    if allow_mutation is not None:</span>
<span class="gi">+        warn(&#39;`allow_mutation` is deprecated and will be removed. use `frozen` instead&#39;, DeprecationWarning)</span>
<span class="gi">+        if allow_mutation is False:</span>
<span class="gi">+            frozen = True</span>
<span class="gi">+</span>
<span class="gi">+    regex = extra.pop(&#39;regex&#39;, None)  # type: ignore</span>
<span class="gi">+    if regex is not None:</span>
<span class="gi">+        raise PydanticUserError(&#39;`regex` is removed. use `pattern` instead&#39;, code=&#39;removed-kwargs&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if extra:</span>
<span class="gi">+        warn(</span>
<span class="gi">+            &#39;Using extra keyword arguments on `Field` is deprecated and will be removed.&#39;</span>
<span class="gi">+            &#39; Use `json_schema_extra` instead.&#39;</span>
<span class="gi">+            f&#39; (Extra keys: {&quot;, &quot;.join(k.__repr__() for k in extra.keys())})&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+        )</span>
<span class="gi">+        if not json_schema_extra or json_schema_extra is _Unset:</span>
<span class="gi">+            json_schema_extra = extra  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        validation_alias</span>
<span class="gi">+        and validation_alias is not _Unset</span>
<span class="gi">+        and not isinstance(validation_alias, (str, AliasChoices, AliasPath))</span>
<span class="gi">+    ):</span>
<span class="gi">+        raise TypeError(&#39;Invalid `validation_alias` type. it should be `str`, `AliasChoices`, or `AliasPath`&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if serialization_alias in (_Unset, None) and isinstance(alias, str):</span>
<span class="gi">+        serialization_alias = alias</span>
<span class="gi">+</span>
<span class="gi">+    if validation_alias in (_Unset, None):</span>
<span class="gi">+        validation_alias = alias</span>
<span class="gi">+</span>
<span class="gi">+    include = extra.pop(&#39;include&#39;, None)  # type: ignore</span>
<span class="gi">+    if include is not None:</span>
<span class="gi">+        warn(&#39;`include` is deprecated and does nothing. It will be removed, use `exclude` instead&#39;, DeprecationWarning)</span>
<span class="gi">+</span>
<span class="gi">+    return FieldInfo.from_field(</span>
<span class="gi">+        default,</span>
<span class="gi">+        default_factory=default_factory,</span>
<span class="gi">+        alias=alias,</span>
<span class="gi">+        alias_priority=alias_priority,</span>
<span class="gi">+        validation_alias=validation_alias,</span>
<span class="gi">+        serialization_alias=serialization_alias,</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        field_title_generator=field_title_generator,</span>
<span class="gi">+        description=description,</span>
<span class="gi">+        examples=examples,</span>
<span class="gi">+        exclude=exclude,</span>
<span class="gi">+        discriminator=discriminator,</span>
<span class="gi">+        deprecated=deprecated,</span>
<span class="gi">+        json_schema_extra=json_schema_extra,</span>
<span class="gi">+        frozen=frozen,</span>
<span class="gi">+        pattern=pattern,</span>
<span class="gi">+        validate_default=validate_default,</span>
<span class="gi">+        repr=repr,</span>
<span class="gi">+        init=init,</span>
<span class="gi">+        init_var=init_var,</span>
<span class="gi">+        kw_only=kw_only,</span>
<span class="gi">+        coerce_numbers_to_str=coerce_numbers_to_str,</span>
<span class="gi">+        strict=strict,</span>
<span class="gi">+        gt=gt,</span>
<span class="gi">+        ge=ge,</span>
<span class="gi">+        lt=lt,</span>
<span class="gi">+        le=le,</span>
<span class="gi">+        multiple_of=multiple_of,</span>
<span class="gi">+        min_length=min_length,</span>
<span class="gi">+        max_length=max_length,</span>
<span class="gi">+        allow_inf_nan=allow_inf_nan,</span>
<span class="gi">+        max_digits=max_digits,</span>
<span class="gi">+        decimal_places=decimal_places,</span>
<span class="gi">+        union_mode=union_mode,</span>
<span class="gi">+        fail_fast=fail_fast,</span>
<span class="gi">+    )</span>


<span class="w"> </span>_FIELD_ARG_NAMES = set(inspect.signature(Field).parameters)
<span class="gd">-_FIELD_ARG_NAMES.remove(&#39;extra&#39;)</span>
<span class="gi">+_FIELD_ARG_NAMES.remove(&#39;extra&#39;)  # do not include the varkwargs parameter</span>


<span class="w"> </span>class ModelPrivateAttr(_repr.Representation):
<span class="gu">@@ -548,25 +892,28 @@ class ModelPrivateAttr(_repr.Representation):</span>
<span class="w"> </span>        default_factory: A callable function that generates the default value of the
<span class="w"> </span>            attribute if not provided.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = &#39;default&#39;, &#39;default_factory&#39;

<span class="gd">-    def __init__(self, default: Any=PydanticUndefined, *, default_factory:</span>
<span class="gd">-        (typing.Callable[[], Any] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, default: Any = PydanticUndefined, *, default_factory: typing.Callable[[], Any] | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.default = default
<span class="w"> </span>        self.default_factory = default_factory
<span class="gi">+</span>
<span class="w"> </span>    if not typing.TYPE_CHECKING:
<span class="gi">+        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access</span>

<span class="gd">-        def __getattr__(self, item: str) -&gt;Any:</span>
<span class="gi">+        def __getattr__(self, item: str) -&gt; Any:</span>
<span class="w"> </span>            &quot;&quot;&quot;This function improves compatibility with custom descriptors by ensuring delegation happens
<span class="w"> </span>            as expected when the default value of a private attribute is a descriptor.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            if item in {&#39;__get__&#39;, &#39;__set__&#39;, &#39;__delete__&#39;}:
<span class="w"> </span>                if hasattr(self.default, item):
<span class="w"> </span>                    return getattr(self.default, item)
<span class="gd">-            raise AttributeError(</span>
<span class="gd">-                f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;)</span>
<span class="gi">+            raise AttributeError(f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;)</span>

<span class="gd">-    def __set_name__(self, cls: type[Any], name: str) -&gt;None:</span>
<span class="gi">+    def __set_name__(self, cls: type[Any], name: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487.&quot;&quot;&quot;
<span class="w"> </span>        if self.default is PydanticUndefined:
<span class="w"> </span>            return
<span class="gu">@@ -576,7 +923,7 @@ class ModelPrivateAttr(_repr.Representation):</span>
<span class="w"> </span>        if callable(set_name):
<span class="w"> </span>            set_name(cls, name)

<span class="gd">-    def get_default(self) -&gt;Any:</span>
<span class="gi">+    def get_default(self) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the default value of the object.

<span class="w"> </span>        If `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object.
<span class="gu">@@ -586,15 +933,21 @@ class ModelPrivateAttr(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The default value of the object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _utils.smart_deepcopy(self.default) if self.default_factory is None else self.default_factory()</span>

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, self.__class__) and (self.default, self.</span>
<span class="gd">-            default_factory) == (other.default, other.default_factory)</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, self.__class__) and (self.default, self.default_factory) == (</span>
<span class="gi">+            other.default,</span>
<span class="gi">+            other.default_factory,</span>
<span class="gi">+        )</span>


<span class="gd">-def PrivateAttr(default: Any=PydanticUndefined, *, default_factory: (typing</span>
<span class="gd">-    .Callable[[], Any] | None)=None, init: Literal[False]=False) -&gt;Any:</span>
<span class="gi">+def PrivateAttr(</span>
<span class="gi">+    default: Any = PydanticUndefined,</span>
<span class="gi">+    *,</span>
<span class="gi">+    default_factory: typing.Callable[[], Any] | None = None,</span>
<span class="gi">+    init: Literal[False] = False,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/models/#private-model-attributes

<span class="w"> </span>    Indicates that an attribute is intended for private use and not handled during normal validation/serialization.
<span class="gu">@@ -616,7 +969,13 @@ def PrivateAttr(default: Any=PydanticUndefined, *, default_factory: (typing</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        ValueError: If both `default` and `default_factory` are set.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default is not PydanticUndefined and default_factory is not None:</span>
<span class="gi">+        raise TypeError(&#39;cannot specify both default and default_factory&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return ModelPrivateAttr(</span>
<span class="gi">+        default,</span>
<span class="gi">+        default_factory=default_factory,</span>
<span class="gi">+    )</span>


<span class="w"> </span>@dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -638,14 +997,14 @@ class ComputedFieldInfo:</span>
<span class="w"> </span>        json_schema_extra: A dict or callable to provide extra JSON schema properties.
<span class="w"> </span>        repr: A boolean indicating whether to include the field in the __repr__ output.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    decorator_repr: ClassVar[str] = &#39;@computed_field&#39;
<span class="w"> </span>    wrapped_property: property
<span class="w"> </span>    return_type: Any
<span class="w"> </span>    alias: str | None
<span class="w"> </span>    alias_priority: int | None
<span class="w"> </span>    title: str | None
<span class="gd">-    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str</span>
<span class="gd">-        ] | None</span>
<span class="gi">+    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None</span>
<span class="w"> </span>    description: str | None
<span class="w"> </span>    deprecated: Deprecated | str | bool | None
<span class="w"> </span>    examples: list[Any] | None
<span class="gu">@@ -653,28 +1012,67 @@ class ComputedFieldInfo:</span>
<span class="w"> </span>    repr: bool

<span class="w"> </span>    @property
<span class="gd">-    def deprecation_message(self) -&gt;(str | None):</span>
<span class="gi">+    def deprecation_message(self) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The deprecation message to be emitted, or `None` if not set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.deprecated is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if isinstance(self.deprecated, bool):</span>
<span class="gi">+            return &#39;deprecated&#39; if self.deprecated else None</span>
<span class="gi">+        return self.deprecated if isinstance(self.deprecated, str) else self.deprecated.message</span>


<span class="gd">-def _wrapped_property_is_private(property_: (cached_property | property)</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def _wrapped_property_is_private(property_: cached_property | property) -&gt; bool:  # type: ignore</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns true if provided property is private, False otherwise.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    wrapped_name: str = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(property_, property):</span>
<span class="gi">+        wrapped_name = getattr(property_.fget, &#39;__name__&#39;, &#39;&#39;)</span>
<span class="gi">+    elif isinstance(property_, cached_property):  # type: ignore</span>
<span class="gi">+        wrapped_name = getattr(property_.func, &#39;__name__&#39;, &#39;&#39;)  # type: ignore</span>

<span class="gi">+    return wrapped_name.startswith(&#39;_&#39;) and not wrapped_name.startswith(&#39;__&#39;)</span>

<span class="gi">+</span>
<span class="gi">+# this should really be `property[T], cached_property[T]` but property is not generic unlike cached_property</span>
<span class="gi">+# See https://github.com/python/typing/issues/985 and linked issues</span>
<span class="w"> </span>PropertyT = typing.TypeVar(&#39;PropertyT&#39;)


<span class="gd">-def computed_field(func: (PropertyT | None)=None, /, *, alias: (str | None)</span>
<span class="gd">-    =None, alias_priority: (int | None)=None, title: (str | None)=None,</span>
<span class="gd">-    field_title_generator: (typing.Callable[[str, ComputedFieldInfo], str] |</span>
<span class="gd">-    None)=None, description: (str | None)=None, deprecated: (Deprecated |</span>
<span class="gd">-    str | bool | None)=None, examples: (list[Any] | None)=None,</span>
<span class="gd">-    json_schema_extra: (JsonDict | typing.Callable[[JsonDict], None] | None</span>
<span class="gd">-    )=None, repr: (bool | None)=None, return_type: Any=PydanticUndefined) -&gt;(</span>
<span class="gd">-    PropertyT | typing.Callable[[PropertyT], PropertyT]):</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def computed_field(</span>
<span class="gi">+    *,</span>
<span class="gi">+    alias: str | None = None,</span>
<span class="gi">+    alias_priority: int | None = None,</span>
<span class="gi">+    title: str | None = None,</span>
<span class="gi">+    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None = None,</span>
<span class="gi">+    description: str | None = None,</span>
<span class="gi">+    deprecated: Deprecated | str | bool | None = None,</span>
<span class="gi">+    examples: list[Any] | None = None,</span>
<span class="gi">+    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = None,</span>
<span class="gi">+    repr: bool = True,</span>
<span class="gi">+    return_type: Any = PydanticUndefined,</span>
<span class="gi">+) -&gt; typing.Callable[[PropertyT], PropertyT]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def computed_field(__func: PropertyT) -&gt; PropertyT: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def computed_field(</span>
<span class="gi">+    func: PropertyT | None = None,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *,</span>
<span class="gi">+    alias: str | None = None,</span>
<span class="gi">+    alias_priority: int | None = None,</span>
<span class="gi">+    title: str | None = None,</span>
<span class="gi">+    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None = None,</span>
<span class="gi">+    description: str | None = None,</span>
<span class="gi">+    deprecated: Deprecated | str | bool | None = None,</span>
<span class="gi">+    examples: list[Any] | None = None,</span>
<span class="gi">+    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = None,</span>
<span class="gi">+    repr: bool | None = None,</span>
<span class="gi">+    return_type: Any = PydanticUndefined,</span>
<span class="gi">+) -&gt; PropertyT | typing.Callable[[PropertyT], PropertyT]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/fields#the-computed_field-decorator

<span class="w"> </span>    Decorator to include `property` and `cached_property` when serializing models or dataclasses.
<span class="gu">@@ -816,4 +1214,42 @@ def computed_field(func: (PropertyT | None)=None, /, *, alias: (str | None)</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A proxy wrapper for the property.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def dec(f: Any) -&gt; Any:</span>
<span class="gi">+        nonlocal description, deprecated, return_type, alias_priority</span>
<span class="gi">+        unwrapped = _decorators.unwrap_wrapped_function(f)</span>
<span class="gi">+</span>
<span class="gi">+        if description is None and unwrapped.__doc__:</span>
<span class="gi">+            description = inspect.cleandoc(unwrapped.__doc__)</span>
<span class="gi">+</span>
<span class="gi">+        if deprecated is None and hasattr(unwrapped, &#39;__deprecated__&#39;):</span>
<span class="gi">+            deprecated = unwrapped.__deprecated__</span>
<span class="gi">+</span>
<span class="gi">+        # if the function isn&#39;t already decorated with `@property` (or another descriptor), then we wrap it now</span>
<span class="gi">+        f = _decorators.ensure_property(f)</span>
<span class="gi">+        alias_priority = (alias_priority or 2) if alias is not None else None</span>
<span class="gi">+</span>
<span class="gi">+        if repr is None:</span>
<span class="gi">+            repr_: bool = not _wrapped_property_is_private(property_=f)</span>
<span class="gi">+        else:</span>
<span class="gi">+            repr_ = repr</span>
<span class="gi">+</span>
<span class="gi">+        dec_info = ComputedFieldInfo(</span>
<span class="gi">+            f,</span>
<span class="gi">+            return_type,</span>
<span class="gi">+            alias,</span>
<span class="gi">+            alias_priority,</span>
<span class="gi">+            title,</span>
<span class="gi">+            field_title_generator,</span>
<span class="gi">+            description,</span>
<span class="gi">+            deprecated,</span>
<span class="gi">+            examples,</span>
<span class="gi">+            json_schema_extra,</span>
<span class="gi">+            repr_,</span>
<span class="gi">+        )</span>
<span class="gi">+        return _decorators.PydanticDescriptorProxy(f, dec_info)</span>
<span class="gi">+</span>
<span class="gi">+    if func is None:</span>
<span class="gi">+        return dec</span>
<span class="gi">+    else:</span>
<span class="gi">+        return dec(func)</span>
<span class="gh">diff --git a/pydantic/functional_serializers.py b/pydantic/functional_serializers.py</span>
<span class="gh">index a588b3b52..478c4a98d 100644</span>
<span class="gd">--- a/pydantic/functional_serializers.py</span>
<span class="gi">+++ b/pydantic/functional_serializers.py</span>
<span class="gu">@@ -1,11 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;This module contains related classes and functions for serialization.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>from functools import partialmethod
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, TypeVar, Union, overload
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import PydanticUndefined, core_schema
<span class="w"> </span>from pydantic_core import core_schema as _core_schema
<span class="w"> </span>from typing_extensions import Annotated, Literal, TypeAlias
<span class="gi">+</span>
<span class="w"> </span>from . import PydanticUndefinedAnnotation
<span class="w"> </span>from ._internal import _decorators, _internal_dataclass
<span class="w"> </span>from .annotated_handlers import GetCoreSchemaHandler
<span class="gu">@@ -43,13 +47,12 @@ class PlainSerializer:</span>
<span class="w"> </span>        when_used: Determines when this serializer should be used. Accepts a string with values `&#39;always&#39;`,
<span class="w"> </span>            `&#39;unless-none&#39;`, `&#39;json&#39;`, and `&#39;json-unless-none&#39;`. Defaults to &#39;always&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    func: core_schema.SerializerFunction
<span class="w"> </span>    return_type: Any = PydanticUndefined
<span class="gd">-    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;</span>
<span class="gd">-        ] = &#39;always&#39;</span>
<span class="gi">+    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;] = &#39;always&#39;</span>

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Gets the Pydantic core schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -61,17 +64,18 @@ class PlainSerializer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        schema = handler(source_type)
<span class="w"> </span>        try:
<span class="gd">-            return_type = _decorators.get_function_return_type(self.func,</span>
<span class="gd">-                self.return_type, handler._get_types_namespace())</span>
<span class="gi">+            return_type = _decorators.get_function_return_type(</span>
<span class="gi">+                self.func, self.return_type, handler._get_types_namespace()</span>
<span class="gi">+            )</span>
<span class="w"> </span>        except NameError as e:
<span class="w"> </span>            raise PydanticUndefinedAnnotation.from_name_error(e) from e
<span class="gd">-        return_schema = (None if return_type is PydanticUndefined else</span>
<span class="gd">-            handler.generate_schema(return_type))</span>
<span class="gd">-        schema[&#39;serialization&#39;</span>
<span class="gd">-            ] = core_schema.plain_serializer_function_ser_schema(function=</span>
<span class="gd">-            self.func, info_arg=_decorators.inspect_annotated_serializer(</span>
<span class="gd">-            self.func, &#39;plain&#39;), return_schema=return_schema, when_used=</span>
<span class="gd">-            self.when_used)</span>
<span class="gi">+        return_schema = None if return_type is PydanticUndefined else handler.generate_schema(return_type)</span>
<span class="gi">+        schema[&#39;serialization&#39;] = core_schema.plain_serializer_function_ser_schema(</span>
<span class="gi">+            function=self.func,</span>
<span class="gi">+            info_arg=_decorators.inspect_annotated_serializer(self.func, &#39;plain&#39;),</span>
<span class="gi">+            return_schema=return_schema,</span>
<span class="gi">+            when_used=self.when_used,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return schema


<span class="gu">@@ -139,13 +143,12 @@ class WrapSerializer:</span>
<span class="w"> </span>        when_used: Determines when this serializer should be used. Accepts a string with values `&#39;always&#39;`,
<span class="w"> </span>            `&#39;unless-none&#39;`, `&#39;json&#39;`, and `&#39;json-unless-none&#39;`. Defaults to &#39;always&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    func: core_schema.WrapSerializerFunction
<span class="w"> </span>    return_type: Any = PydanticUndefined
<span class="gd">-    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;</span>
<span class="gd">-        ] = &#39;always&#39;</span>
<span class="gi">+    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;] = &#39;always&#39;</span>

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method is used to get the Pydantic core schema of the class.

<span class="w"> </span>        Args:
<span class="gu">@@ -157,37 +160,71 @@ class WrapSerializer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        schema = handler(source_type)
<span class="w"> </span>        try:
<span class="gd">-            return_type = _decorators.get_function_return_type(self.func,</span>
<span class="gd">-                self.return_type, handler._get_types_namespace())</span>
<span class="gi">+            return_type = _decorators.get_function_return_type(</span>
<span class="gi">+                self.func, self.return_type, handler._get_types_namespace()</span>
<span class="gi">+            )</span>
<span class="w"> </span>        except NameError as e:
<span class="w"> </span>            raise PydanticUndefinedAnnotation.from_name_error(e) from e
<span class="gd">-        return_schema = (None if return_type is PydanticUndefined else</span>
<span class="gd">-            handler.generate_schema(return_type))</span>
<span class="gd">-        schema[&#39;serialization&#39;</span>
<span class="gd">-            ] = core_schema.wrap_serializer_function_ser_schema(function=</span>
<span class="gd">-            self.func, info_arg=_decorators.inspect_annotated_serializer(</span>
<span class="gd">-            self.func, &#39;wrap&#39;), return_schema=return_schema, when_used=self</span>
<span class="gd">-            .when_used)</span>
<span class="gi">+        return_schema = None if return_type is PydanticUndefined else handler.generate_schema(return_type)</span>
<span class="gi">+        schema[&#39;serialization&#39;] = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gi">+            function=self.func,</span>
<span class="gi">+            info_arg=_decorators.inspect_annotated_serializer(self.func, &#39;wrap&#39;),</span>
<span class="gi">+            return_schema=return_schema,</span>
<span class="gi">+            when_used=self.when_used,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return schema


<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any],</span>
<span class="gd">-        staticmethod[Any, Any], partialmethod[Any]]</span>
<span class="gd">-    _PlainSerializationFunction = Union[_core_schema.SerializerFunction,</span>
<span class="gd">-        _PartialClsOrStaticMethod]</span>
<span class="gd">-    _WrapSerializationFunction = Union[_core_schema.WrapSerializerFunction,</span>
<span class="gd">-        _PartialClsOrStaticMethod]</span>
<span class="gd">-    _PlainSerializeMethodType = TypeVar(&#39;_PlainSerializeMethodType&#39;, bound=</span>
<span class="gd">-        _PlainSerializationFunction)</span>
<span class="gd">-    _WrapSerializeMethodType = TypeVar(&#39;_WrapSerializeMethodType&#39;, bound=</span>
<span class="gd">-        _WrapSerializationFunction)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def field_serializer(*fields: str, mode: Literal[&#39;plain&#39;, &#39;wrap&#39;]=&#39;plain&#39;,</span>
<span class="gd">-    return_type: Any=PydanticUndefined, when_used: Literal[&#39;always&#39;,</span>
<span class="gd">-    &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;]=&#39;always&#39;, check_fields: (</span>
<span class="gd">-    bool | None)=None) -&gt;Callable[[Any], Any]:</span>
<span class="gi">+    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any]]</span>
<span class="gi">+    _PlainSerializationFunction = Union[_core_schema.SerializerFunction, _PartialClsOrStaticMethod]</span>
<span class="gi">+    _WrapSerializationFunction = Union[_core_schema.WrapSerializerFunction, _PartialClsOrStaticMethod]</span>
<span class="gi">+    _PlainSerializeMethodType = TypeVar(&#39;_PlainSerializeMethodType&#39;, bound=_PlainSerializationFunction)</span>
<span class="gi">+    _WrapSerializeMethodType = TypeVar(&#39;_WrapSerializeMethodType&#39;, bound=_WrapSerializationFunction)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def field_serializer(</span>
<span class="gi">+    field: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    return_type: Any = ...,</span>
<span class="gi">+    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;] = ...,</span>
<span class="gi">+    check_fields: bool | None = ...,</span>
<span class="gi">+) -&gt; Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def field_serializer(</span>
<span class="gi">+    field: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    mode: Literal[&#39;plain&#39;],</span>
<span class="gi">+    return_type: Any = ...,</span>
<span class="gi">+    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;] = ...,</span>
<span class="gi">+    check_fields: bool | None = ...,</span>
<span class="gi">+) -&gt; Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def field_serializer(</span>
<span class="gi">+    field: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    mode: Literal[&#39;wrap&#39;],</span>
<span class="gi">+    return_type: Any = ...,</span>
<span class="gi">+    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;] = ...,</span>
<span class="gi">+    check_fields: bool | None = ...,</span>
<span class="gi">+) -&gt; Callable[[_WrapSerializeMethodType], _WrapSerializeMethodType]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def field_serializer(</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    mode: Literal[&#39;plain&#39;, &#39;wrap&#39;] = &#39;plain&#39;,</span>
<span class="gi">+    return_type: Any = PydanticUndefined,</span>
<span class="gi">+    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;] = &#39;always&#39;,</span>
<span class="gi">+    check_fields: bool | None = None,</span>
<span class="gi">+) -&gt; Callable[[Any], Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator that enables custom field serialization.

<span class="w"> </span>    In the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.
<span class="gu">@@ -233,16 +270,46 @@ def field_serializer(*fields: str, mode: Literal[&#39;plain&#39;, &#39;wrap&#39;]=&#39;plain&#39;,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The decorator function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def dec(</span>
<span class="gi">+        f: Callable[..., Any] | staticmethod[Any, Any] | classmethod[Any, Any, Any],</span>
<span class="gi">+    ) -&gt; _decorators.PydanticDescriptorProxy[Any]:</span>
<span class="gi">+        dec_info = _decorators.FieldSerializerDecoratorInfo(</span>
<span class="gi">+            fields=fields,</span>
<span class="gi">+            mode=mode,</span>
<span class="gi">+            return_type=return_type,</span>
<span class="gi">+            when_used=when_used,</span>
<span class="gi">+            check_fields=check_fields,</span>
<span class="gi">+        )</span>
<span class="gi">+        return _decorators.PydanticDescriptorProxy(f, dec_info)</span>
<span class="gi">+</span>
<span class="gi">+    return dec</span>


<span class="w"> </span>FuncType = TypeVar(&#39;FuncType&#39;, bound=Callable[..., Any])


<span class="gd">-def model_serializer(f: (Callable[..., Any] | None)=None, /, *, mode:</span>
<span class="gd">-    Literal[&#39;plain&#39;, &#39;wrap&#39;]=&#39;plain&#39;, when_used: Literal[&#39;always&#39;,</span>
<span class="gd">-    &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;]=&#39;always&#39;, return_type: Any=</span>
<span class="gd">-    PydanticUndefined) -&gt;Callable[[Any], Any]:</span>
<span class="gi">+@overload</span>
<span class="gi">+def model_serializer(__f: FuncType) -&gt; FuncType: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def model_serializer(</span>
<span class="gi">+    *,</span>
<span class="gi">+    mode: Literal[&#39;plain&#39;, &#39;wrap&#39;] = ...,</span>
<span class="gi">+    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;] = &#39;always&#39;,</span>
<span class="gi">+    return_type: Any = ...,</span>
<span class="gi">+) -&gt; Callable[[FuncType], FuncType]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def model_serializer(</span>
<span class="gi">+    f: Callable[..., Any] | None = None,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *,</span>
<span class="gi">+    mode: Literal[&#39;plain&#39;, &#39;wrap&#39;] = &#39;plain&#39;,</span>
<span class="gi">+    when_used: Literal[&#39;always&#39;, &#39;unless-none&#39;, &#39;json&#39;, &#39;json-unless-none&#39;] = &#39;always&#39;,</span>
<span class="gi">+    return_type: Any = PydanticUndefined,</span>
<span class="gi">+) -&gt; Callable[[Any], Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator that enables custom model serialization.

<span class="w"> </span>    This is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.
<span class="gu">@@ -284,12 +351,22 @@ def model_serializer(f: (Callable[..., Any] | None)=None, /, *, mode:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The decorator function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def dec(f: Callable[..., Any]) -&gt; _decorators.PydanticDescriptorProxy[Any]:</span>
<span class="gi">+        dec_info = _decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=return_type, when_used=when_used)</span>
<span class="gi">+        return _decorators.PydanticDescriptorProxy(f, dec_info)</span>
<span class="gi">+</span>
<span class="gi">+    if f is None:</span>
<span class="gi">+        return dec</span>
<span class="gi">+    else:</span>
<span class="gi">+        return dec(f)  # type: ignore</span>


<span class="w"> </span>AnyType = TypeVar(&#39;AnyType&#39;)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    SerializeAsAny = Annotated[AnyType, ...]</span>
<span class="gi">+    SerializeAsAny = Annotated[AnyType, ...]  # SerializeAsAny[list[str]] will be treated by type checkers as list[str]</span>
<span class="w"> </span>    &quot;&quot;&quot;Force serialization to ignore whatever is defined in the schema and instead ask the object
<span class="w"> </span>    itself how it should be serialized.
<span class="w"> </span>    In particular, this means that when model subclasses are serialized, fields present in the subclass
<span class="gu">@@ -297,22 +374,22 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    @dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gd">-    class SerializeAsAny:</span>
<span class="gd">-</span>
<span class="gd">-        def __class_getitem__(cls, item: Any) -&gt;Any:</span>
<span class="gi">+    class SerializeAsAny:  # noqa: D101</span>
<span class="gi">+        def __class_getitem__(cls, item: Any) -&gt; Any:</span>
<span class="w"> </span>            return Annotated[item, SerializeAsAny()]

<span class="gd">-        def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            self, source_type: Any, handler: GetCoreSchemaHandler</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            schema = handler(source_type)
<span class="w"> </span>            schema_to_update = schema
<span class="w"> </span>            while schema_to_update[&#39;type&#39;] == &#39;definitions&#39;:
<span class="w"> </span>                schema_to_update = schema_to_update.copy()
<span class="w"> </span>                schema_to_update = schema_to_update[&#39;schema&#39;]
<span class="gd">-            schema_to_update[&#39;serialization&#39;</span>
<span class="gd">-                ] = core_schema.wrap_serializer_function_ser_schema(lambda</span>
<span class="gd">-                x, h: h(x), schema=core_schema.any_schema())</span>
<span class="gi">+            schema_to_update[&#39;serialization&#39;] = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gi">+                lambda x, h: h(x), schema=core_schema.any_schema()</span>
<span class="gi">+            )</span>
<span class="w"> </span>            return schema
<span class="gi">+</span>
<span class="w"> </span>        __hash__ = object.__hash__
<span class="gh">diff --git a/pydantic/functional_validators.py b/pydantic/functional_validators.py</span>
<span class="gh">index 92ed2fbb5..b29880fd4 100644</span>
<span class="gd">--- a/pydantic/functional_validators.py</span>
<span class="gi">+++ b/pydantic/functional_validators.py</span>
<span class="gu">@@ -1,21 +1,27 @@</span>
<span class="w"> </span>&quot;&quot;&quot;This module contains related classes and functions for validation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import sys
<span class="w"> </span>from functools import partialmethod
<span class="w"> </span>from types import FunctionType
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, TypeVar, Union, cast, overload
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import core_schema
<span class="w"> </span>from pydantic_core import core_schema as _core_schema
<span class="w"> </span>from typing_extensions import Annotated, Literal, TypeAlias
<span class="gi">+</span>
<span class="w"> </span>from . import GetCoreSchemaHandler as _GetCoreSchemaHandler
<span class="w"> </span>from ._internal import _core_metadata, _decorators, _generics, _internal_dataclass
<span class="w"> </span>from .annotated_handlers import GetCoreSchemaHandler
<span class="w"> </span>from .errors import PydanticUserError
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 11):
<span class="w"> </span>    from typing_extensions import Protocol
<span class="w"> </span>else:
<span class="w"> </span>    from typing import Protocol
<span class="gi">+</span>
<span class="w"> </span>_inspect_validator = _decorators.inspect_validator


<span class="gu">@@ -61,20 +67,18 @@ class AfterValidator:</span>
<span class="w"> </span>            &#39;&#39;&#39;
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        _GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        schema = handler(source_type)
<span class="w"> </span>        info_arg = _inspect_validator(self.func, &#39;after&#39;)
<span class="w"> </span>        if info_arg:
<span class="w"> </span>            func = cast(core_schema.WithInfoValidatorFunction, self.func)
<span class="gd">-            return core_schema.with_info_after_validator_function(func,</span>
<span class="gd">-                schema=schema, field_name=handler.field_name)</span>
<span class="gi">+            return core_schema.with_info_after_validator_function(func, schema=schema, field_name=handler.field_name)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            func = cast(core_schema.NoInfoValidatorFunction, self.func)
<span class="gd">-            return core_schema.no_info_after_validator_function(func,</span>
<span class="gd">-                schema=schema)</span>
<span class="gi">+            return core_schema.no_info_after_validator_function(func, schema=schema)</span>


<span class="w"> </span>@dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)
<span class="gu">@@ -107,20 +111,18 @@ class BeforeValidator:</span>
<span class="w"> </span>            #&gt; can only concatenate str (not &quot;int&quot;) to str
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        _GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        schema = handler(source_type)
<span class="w"> </span>        info_arg = _inspect_validator(self.func, &#39;before&#39;)
<span class="w"> </span>        if info_arg:
<span class="w"> </span>            func = cast(core_schema.WithInfoValidatorFunction, self.func)
<span class="gd">-            return core_schema.with_info_before_validator_function(func,</span>
<span class="gd">-                schema=schema, field_name=handler.field_name)</span>
<span class="gi">+            return core_schema.with_info_before_validator_function(func, schema=schema, field_name=handler.field_name)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            func = cast(core_schema.NoInfoValidatorFunction, self.func)
<span class="gd">-            return core_schema.no_info_before_validator_function(func,</span>
<span class="gd">-                schema=schema)</span>
<span class="gi">+            return core_schema.no_info_before_validator_function(func, schema=schema)</span>


<span class="w"> </span>@dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)
<span class="gu">@@ -147,26 +149,32 @@ class PlainValidator:</span>
<span class="w"> </span>        #&gt; 2
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        _GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        # Note that for some valid uses of PlainValidator, it is not possible to generate a core schema for the</span>
<span class="gi">+        # source_type, so calling `handler(source_type)` will error, which prevents us from generating a proper</span>
<span class="gi">+        # serialization schema. To work around this for use cases that will not involve serialization, we simply</span>
<span class="gi">+        # catch any PydanticSchemaGenerationError that may be raised while attempting to build the serialization schema</span>
<span class="gi">+        # and abort any attempts to handle special serialization.</span>
<span class="w"> </span>        from pydantic import PydanticSchemaGenerationError
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="w"> </span>            schema = handler(source_type)
<span class="gd">-            serialization = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gd">-                function=lambda v, h: h(v), schema=schema)</span>
<span class="gi">+            serialization = core_schema.wrap_serializer_function_ser_schema(function=lambda v, h: h(v), schema=schema)</span>
<span class="w"> </span>        except PydanticSchemaGenerationError:
<span class="w"> </span>            serialization = None
<span class="gi">+</span>
<span class="w"> </span>        info_arg = _inspect_validator(self.func, &#39;plain&#39;)
<span class="w"> </span>        if info_arg:
<span class="w"> </span>            func = cast(core_schema.WithInfoValidatorFunction, self.func)
<span class="gd">-            return core_schema.with_info_plain_validator_function(func,</span>
<span class="gd">-                field_name=handler.field_name, serialization=serialization)</span>
<span class="gi">+            return core_schema.with_info_plain_validator_function(</span>
<span class="gi">+                func, field_name=handler.field_name, serialization=serialization</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            func = cast(core_schema.NoInfoValidatorFunction, self.func)
<span class="gd">-            return core_schema.no_info_plain_validator_function(func,</span>
<span class="gd">-                serialization=serialization)</span>
<span class="gi">+            return core_schema.no_info_plain_validator_function(func, serialization=serialization)</span>


<span class="w"> </span>@dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)
<span class="gu">@@ -206,61 +214,90 @@ class WrapValidator:</span>
<span class="w"> </span>    #&gt; 2000-01-01 00:00:00
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    func: core_schema.NoInfoWrapValidatorFunction | core_schema.WithInfoWrapValidatorFunction

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        _GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        schema = handler(source_type)
<span class="w"> </span>        info_arg = _inspect_validator(self.func, &#39;wrap&#39;)
<span class="w"> </span>        if info_arg:
<span class="w"> </span>            func = cast(core_schema.WithInfoWrapValidatorFunction, self.func)
<span class="gd">-            return core_schema.with_info_wrap_validator_function(func,</span>
<span class="gd">-                schema=schema, field_name=handler.field_name)</span>
<span class="gi">+            return core_schema.with_info_wrap_validator_function(func, schema=schema, field_name=handler.field_name)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            func = cast(core_schema.NoInfoWrapValidatorFunction, self.func)
<span class="gd">-            return core_schema.no_info_wrap_validator_function(func, schema</span>
<span class="gd">-                =schema)</span>
<span class="gi">+            return core_schema.no_info_wrap_validator_function(func, schema=schema)</span>


<span class="w"> </span>if TYPE_CHECKING:

<span class="gd">-</span>
<span class="w"> </span>    class _OnlyValueValidatorClsMethod(Protocol):
<span class="gi">+        def __call__(self, cls: Any, value: Any, /) -&gt; Any: ...</span>

<span class="gd">-        def __call__(self, cls: Any, value: Any, /) -&gt;Any:</span>
<span class="gd">-            ...</span>
<span class="gi">+    class _V2ValidatorClsMethod(Protocol):</span>
<span class="gi">+        def __call__(self, cls: Any, value: Any, info: _core_schema.ValidationInfo, /) -&gt; Any: ...</span>

<span class="gi">+    class _V2WrapValidatorClsMethod(Protocol):</span>
<span class="gi">+        def __call__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            cls: Any,</span>
<span class="gi">+            value: Any,</span>
<span class="gi">+            handler: _core_schema.ValidatorFunctionWrapHandler,</span>
<span class="gi">+            info: _core_schema.ValidationInfo,</span>
<span class="gi">+            /,</span>
<span class="gi">+        ) -&gt; Any: ...</span>
<span class="gi">+</span>
<span class="gi">+    _V2Validator = Union[</span>
<span class="gi">+        _V2ValidatorClsMethod,</span>
<span class="gi">+        _core_schema.WithInfoValidatorFunction,</span>
<span class="gi">+        _OnlyValueValidatorClsMethod,</span>
<span class="gi">+        _core_schema.NoInfoValidatorFunction,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    _V2WrapValidator = Union[</span>
<span class="gi">+        _V2WrapValidatorClsMethod,</span>
<span class="gi">+        _core_schema.WithInfoWrapValidatorFunction,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any]]</span>

<span class="gd">-    class _V2ValidatorClsMethod(Protocol):</span>
<span class="gi">+    _V2BeforeAfterOrPlainValidatorType = TypeVar(</span>
<span class="gi">+        &#39;_V2BeforeAfterOrPlainValidatorType&#39;,</span>
<span class="gi">+        _V2Validator,</span>
<span class="gi">+        _PartialClsOrStaticMethod,</span>
<span class="gi">+    )</span>
<span class="gi">+    _V2WrapValidatorType = TypeVar(&#39;_V2WrapValidatorType&#39;, _V2WrapValidator, _PartialClsOrStaticMethod)</span>

<span class="gd">-        def __call__(self, cls: Any, value: Any, info: _core_schema.</span>
<span class="gd">-            ValidationInfo, /) -&gt;Any:</span>
<span class="gd">-            ...</span>

<span class="gi">+@overload</span>
<span class="gi">+def field_validator(</span>
<span class="gi">+    field: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    mode: Literal[&#39;before&#39;, &#39;after&#39;, &#39;plain&#39;] = ...,</span>
<span class="gi">+    check_fields: bool | None = ...,</span>
<span class="gi">+) -&gt; Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def field_validator(</span>
<span class="gi">+    field: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    mode: Literal[&#39;wrap&#39;],</span>
<span class="gi">+    check_fields: bool | None = ...,</span>
<span class="gi">+) -&gt; Callable[[_V2WrapValidatorType], _V2WrapValidatorType]: ...</span>

<span class="gd">-    class _V2WrapValidatorClsMethod(Protocol):</span>

<span class="gd">-        def __call__(self, cls: Any, value: Any, handler: _core_schema.</span>
<span class="gd">-            ValidatorFunctionWrapHandler, info: _core_schema.ValidationInfo, /</span>
<span class="gd">-            ) -&gt;Any:</span>
<span class="gd">-            ...</span>
<span class="gd">-    _V2Validator = Union[_V2ValidatorClsMethod, _core_schema.</span>
<span class="gd">-        WithInfoValidatorFunction, _OnlyValueValidatorClsMethod,</span>
<span class="gd">-        _core_schema.NoInfoValidatorFunction]</span>
<span class="gd">-    _V2WrapValidator = Union[_V2WrapValidatorClsMethod, _core_schema.</span>
<span class="gd">-        WithInfoWrapValidatorFunction]</span>
<span class="gd">-    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any],</span>
<span class="gd">-        staticmethod[Any, Any], partialmethod[Any]]</span>
<span class="gd">-    _V2BeforeAfterOrPlainValidatorType = TypeVar(</span>
<span class="gd">-        &#39;_V2BeforeAfterOrPlainValidatorType&#39;, _V2Validator,</span>
<span class="gd">-        _PartialClsOrStaticMethod)</span>
<span class="gd">-    _V2WrapValidatorType = TypeVar(&#39;_V2WrapValidatorType&#39;, _V2WrapValidator,</span>
<span class="gd">-        _PartialClsOrStaticMethod)</span>
<span class="w"> </span>FieldValidatorModes: TypeAlias = Literal[&#39;before&#39;, &#39;after&#39;, &#39;wrap&#39;, &#39;plain&#39;]


<span class="gd">-def field_validator(field: str, /, *fields: str, mode: FieldValidatorModes=</span>
<span class="gd">-    &#39;after&#39;, check_fields: (bool | None)=None) -&gt;Callable[[Any], Any]:</span>
<span class="gi">+def field_validator(</span>
<span class="gi">+    field: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    mode: FieldValidatorModes = &#39;after&#39;,</span>
<span class="gi">+    check_fields: bool | None = None,</span>
<span class="gi">+) -&gt; Callable[[Any], Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#field-validators

<span class="w"> </span>    Decorate methods on the class indicating that they should be used to validate fields.
<span class="gu">@@ -317,19 +354,50 @@ def field_validator(field: str, /, *fields: str, mode: FieldValidatorModes=</span>
<span class="w"> </span>            - If the args passed to `@field_validator` as fields are not strings.
<span class="w"> </span>            - If `@field_validator` applied to instance methods.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(field, FunctionType):</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            &#39;`@field_validator` should be used with fields and keyword arguments, not bare. &#39;</span>
<span class="gi">+            &quot;E.g. usage should be `@validator(&#39;&lt;field_name&gt;&#39;, ...)`&quot;,</span>
<span class="gi">+            code=&#39;validator-no-fields&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+    fields = field, *fields</span>
<span class="gi">+    if not all(isinstance(field, str) for field in fields):</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            &#39;`@field_validator` fields should be passed as separate string args. &#39;</span>
<span class="gi">+            &quot;E.g. usage should be `@validator(&#39;&lt;field_name_1&gt;&#39;, &#39;&lt;field_name_2&gt;&#39;, ...)`&quot;,</span>
<span class="gi">+            code=&#39;validator-invalid-fields&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def dec(</span>
<span class="gi">+        f: Callable[..., Any] | staticmethod[Any, Any] | classmethod[Any, Any, Any],</span>
<span class="gi">+    ) -&gt; _decorators.PydanticDescriptorProxy[Any]:</span>
<span class="gi">+        if _decorators.is_instance_method_from_sig(f):</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;`@field_validator` cannot be applied to instance methods&#39;, code=&#39;validator-instance-method&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # auto apply the @classmethod decorator</span>
<span class="gi">+        f = _decorators.ensure_classmethod_based_on_signature(f)</span>
<span class="gi">+</span>
<span class="gi">+        dec_info = _decorators.FieldValidatorDecoratorInfo(fields=fields, mode=mode, check_fields=check_fields)</span>
<span class="gi">+        return _decorators.PydanticDescriptorProxy(f, dec_info)</span>
<span class="gi">+</span>
<span class="gi">+    return dec</span>


<span class="w"> </span>_ModelType = TypeVar(&#39;_ModelType&#39;)
<span class="w"> </span>_ModelTypeCo = TypeVar(&#39;_ModelTypeCo&#39;, covariant=True)


<span class="gd">-class ModelWrapValidatorHandler(_core_schema.ValidatorFunctionWrapHandler,</span>
<span class="gd">-    Protocol[_ModelTypeCo]):</span>
<span class="gi">+class ModelWrapValidatorHandler(_core_schema.ValidatorFunctionWrapHandler, Protocol[_ModelTypeCo]):</span>
<span class="w"> </span>    &quot;&quot;&quot;@model_validator decorated function handler argument type. This is used when `mode=&#39;wrap&#39;`.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, value: Any, outer_location: (str | int | None)=None, /</span>
<span class="gd">-        ) -&gt;_ModelTypeCo:</span>
<span class="gi">+    def __call__(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        outer_location: str | int | None = None,</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; _ModelTypeCo:  # pragma: no cover</span>
<span class="w"> </span>        ...


<span class="gu">@@ -338,18 +406,32 @@ class ModelWrapValidatorWithoutInfo(Protocol[_ModelType]):</span>
<span class="w"> </span>    This is used when `mode=&#39;wrap&#39;` and the function does not have info argument.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __call__(self, cls: type[_ModelType], value: Any, handler:</span>
<span class="gd">-        ModelWrapValidatorHandler[_ModelType], /) -&gt;_ModelType:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        cls: type[_ModelType],</span>
<span class="gi">+        # this can be a dict, a model instance</span>
<span class="gi">+        # or anything else that gets passed to validate_python</span>
<span class="gi">+        # thus validators _must_ handle all cases</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        handler: ModelWrapValidatorHandler[_ModelType],</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; _ModelType: ...</span>


<span class="w"> </span>class ModelWrapValidator(Protocol[_ModelType]):
<span class="w"> </span>    &quot;&quot;&quot;A @model_validator decorated function signature. This is used when `mode=&#39;wrap&#39;`.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, cls: type[_ModelType], value: Any, handler:</span>
<span class="gd">-        ModelWrapValidatorHandler[_ModelType], info: _core_schema.</span>
<span class="gd">-        ValidationInfo, /) -&gt;_ModelType:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        cls: type[_ModelType],</span>
<span class="gi">+        # this can be a dict, a model instance</span>
<span class="gi">+        # or anything else that gets passed to validate_python</span>
<span class="gi">+        # thus validators _must_ handle all cases</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        handler: ModelWrapValidatorHandler[_ModelType],</span>
<span class="gi">+        info: _core_schema.ValidationInfo,</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; _ModelType: ...</span>


<span class="w"> </span>class FreeModelBeforeValidatorWithoutInfo(Protocol):
<span class="gu">@@ -357,8 +439,14 @@ class FreeModelBeforeValidatorWithoutInfo(Protocol):</span>
<span class="w"> </span>    This is used when `mode=&#39;before&#39;` and the function does not have info argument.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __call__(self, value: Any, /) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        # this can be a dict, a model instance</span>
<span class="gi">+        # or anything else that gets passed to validate_python</span>
<span class="gi">+        # thus validators _must_ handle all cases</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; Any: ...</span>


<span class="w"> </span>class ModelBeforeValidatorWithoutInfo(Protocol):
<span class="gu">@@ -366,42 +454,92 @@ class ModelBeforeValidatorWithoutInfo(Protocol):</span>
<span class="w"> </span>    This is used when `mode=&#39;before&#39;` and the function does not have info argument.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __call__(self, cls: Any, value: Any, /) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        cls: Any,</span>
<span class="gi">+        # this can be a dict, a model instance</span>
<span class="gi">+        # or anything else that gets passed to validate_python</span>
<span class="gi">+        # thus validators _must_ handle all cases</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; Any: ...</span>


<span class="w"> </span>class FreeModelBeforeValidator(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;A `@model_validator` decorated function signature. This is used when `mode=&#39;before&#39;`.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, value: Any, info: _core_schema.ValidationInfo, /) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        # this can be a dict, a model instance</span>
<span class="gi">+        # or anything else that gets passed to validate_python</span>
<span class="gi">+        # thus validators _must_ handle all cases</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        info: _core_schema.ValidationInfo,</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; Any: ...</span>


<span class="w"> </span>class ModelBeforeValidator(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;A `@model_validator` decorated function signature. This is used when `mode=&#39;before&#39;`.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, cls: Any, value: Any, info: _core_schema.</span>
<span class="gd">-        ValidationInfo, /) -&gt;Any:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        cls: Any,</span>
<span class="gi">+        # this can be a dict, a model instance</span>
<span class="gi">+        # or anything else that gets passed to validate_python</span>
<span class="gi">+        # thus validators _must_ handle all cases</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        info: _core_schema.ValidationInfo,</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; Any: ...</span>


<span class="w"> </span>ModelAfterValidatorWithoutInfo = Callable[[_ModelType], _ModelType]
<span class="w"> </span>&quot;&quot;&quot;A `@model_validator` decorated function signature. This is used when `mode=&#39;after&#39;` and the function does not
<span class="w"> </span>have info argument.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-ModelAfterValidator = Callable[[_ModelType, _core_schema.ValidationInfo],</span>
<span class="gd">-    _ModelType]</span>
<span class="gi">+</span>
<span class="gi">+ModelAfterValidator = Callable[[_ModelType, _core_schema.ValidationInfo], _ModelType]</span>
<span class="w"> </span>&quot;&quot;&quot;A `@model_validator` decorated function signature. This is used when `mode=&#39;after&#39;`.&quot;&quot;&quot;
<span class="gd">-_AnyModelWrapValidator = Union[ModelWrapValidator[_ModelType],</span>
<span class="gd">-    ModelWrapValidatorWithoutInfo[_ModelType]]</span>
<span class="gd">-_AnyModeBeforeValidator = Union[FreeModelBeforeValidator,</span>
<span class="gd">-    ModelBeforeValidator, FreeModelBeforeValidatorWithoutInfo,</span>
<span class="gd">-    ModelBeforeValidatorWithoutInfo]</span>
<span class="gd">-_AnyModelAfterValidator = Union[ModelAfterValidator[_ModelType],</span>
<span class="gd">-    ModelAfterValidatorWithoutInfo[_ModelType]]</span>

<span class="gi">+_AnyModelWrapValidator = Union[ModelWrapValidator[_ModelType], ModelWrapValidatorWithoutInfo[_ModelType]]</span>
<span class="gi">+_AnyModeBeforeValidator = Union[</span>
<span class="gi">+    FreeModelBeforeValidator, ModelBeforeValidator, FreeModelBeforeValidatorWithoutInfo, ModelBeforeValidatorWithoutInfo</span>
<span class="gi">+]</span>
<span class="gi">+_AnyModelAfterValidator = Union[ModelAfterValidator[_ModelType], ModelAfterValidatorWithoutInfo[_ModelType]]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def model_validator(</span>
<span class="gi">+    *,</span>
<span class="gi">+    mode: Literal[&#39;wrap&#39;],</span>
<span class="gi">+) -&gt; Callable[</span>
<span class="gi">+    [_AnyModelWrapValidator[_ModelType]], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]</span>
<span class="gi">+]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def model_validator(</span>
<span class="gi">+    *,</span>
<span class="gi">+    mode: Literal[&#39;before&#39;],</span>
<span class="gi">+) -&gt; Callable[</span>
<span class="gi">+    [_AnyModeBeforeValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]</span>
<span class="gi">+]: ...</span>

<span class="gd">-def model_validator(*, mode: Literal[&#39;wrap&#39;, &#39;before&#39;, &#39;after&#39;]) -&gt;Any:</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def model_validator(</span>
<span class="gi">+    *,</span>
<span class="gi">+    mode: Literal[&#39;after&#39;],</span>
<span class="gi">+) -&gt; Callable[</span>
<span class="gi">+    [_AnyModelAfterValidator[_ModelType]], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]</span>
<span class="gi">+]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def model_validator(</span>
<span class="gi">+    *,</span>
<span class="gi">+    mode: Literal[&#39;wrap&#39;, &#39;before&#39;, &#39;after&#39;],</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#model-validators

<span class="w"> </span>    Decorate model methods for validation purposes.
<span class="gu">@@ -445,18 +583,28 @@ def model_validator(*, mode: Literal[&#39;wrap&#39;, &#39;before&#39;, &#39;after&#39;]) -&gt;Any:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A decorator that can be used to decorate a function to be used as a model validator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def dec(f: Any) -&gt; _decorators.PydanticDescriptorProxy[Any]:</span>
<span class="gi">+        # auto apply the @classmethod decorator</span>
<span class="gi">+        f = _decorators.ensure_classmethod_based_on_signature(f)</span>
<span class="gi">+        dec_info = _decorators.ModelValidatorDecoratorInfo(mode=mode)</span>
<span class="gi">+        return _decorators.PydanticDescriptorProxy(f, dec_info)</span>
<span class="gi">+</span>
<span class="gi">+    return dec</span>


<span class="w"> </span>AnyType = TypeVar(&#39;AnyType&#39;)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    InstanceOf = Annotated[AnyType, ...]</span>
<span class="gd">-else:</span>
<span class="gi">+    # If we add configurable attributes to IsInstance, we&#39;d probably need to stop hiding it from type checkers like this</span>
<span class="gi">+    InstanceOf = Annotated[AnyType, ...]  # `IsInstance[Sequence]` will be recognized by type checkers as `Sequence`</span>

<span class="gi">+else:</span>

<span class="w"> </span>    @dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="w"> </span>    class InstanceOf:
<span class="gd">-        &quot;&quot;&quot;Generic type for annotating a type that is an instance of a given class.</span>
<span class="gi">+        &#39;&#39;&#39;Generic type for annotating a type that is an instance of a given class.</span>

<span class="w"> </span>        Example:
<span class="w"> </span>            ```py
<span class="gu">@@ -473,7 +621,7 @@ else:</span>
<span class="w"> </span>                Bar(foo=42)
<span class="w"> </span>            except ValidationError as e:
<span class="w"> </span>                print(e)
<span class="gd">-                &quot;&quot;\&quot;</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="w"> </span>                [
<span class="w"> </span>                │   {
<span class="w"> </span>                │   │   &#39;type&#39;: &#39;is_instance_of&#39;,
<span class="gu">@@ -484,36 +632,41 @@ else:</span>
<span class="w"> </span>                │   │   &#39;url&#39;: &#39;https://errors.pydantic.dev/0.38.0/v/is_instance_of&#39;
<span class="w"> </span>                │   }
<span class="w"> </span>                ]
<span class="gd">-                &quot;&quot;\&quot;</span>
<span class="gi">+                &quot;&quot;&quot;</span>
<span class="w"> </span>            ```
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;</span>

<span class="w"> </span>        @classmethod
<span class="gd">-        def __class_getitem__(cls, item: AnyType) -&gt;AnyType:</span>
<span class="gi">+        def __class_getitem__(cls, item: AnyType) -&gt; AnyType:</span>
<span class="w"> </span>            return Annotated[item, cls()]

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: Any, handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            from pydantic import PydanticSchemaGenerationError
<span class="gd">-            instance_of_schema = core_schema.is_instance_schema(_generics.</span>
<span class="gd">-                get_origin(source) or source)</span>
<span class="gi">+</span>
<span class="gi">+            # use the generic _origin_ as the second argument to isinstance when appropriate</span>
<span class="gi">+            instance_of_schema = core_schema.is_instance_schema(_generics.get_origin(source) or source)</span>
<span class="gi">+</span>
<span class="w"> </span>            try:
<span class="gi">+                # Try to generate the &quot;standard&quot; schema, which will be used when loading from JSON</span>
<span class="w"> </span>                original_schema = handler(source)
<span class="w"> </span>            except PydanticSchemaGenerationError:
<span class="gi">+                # If that fails, just produce a schema that can validate from python</span>
<span class="w"> </span>                return instance_of_schema
<span class="w"> </span>            else:
<span class="gd">-                instance_of_schema[&#39;serialization&#39;</span>
<span class="gd">-                    ] = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gd">-                    function=lambda v, h: h(v), schema=original_schema)</span>
<span class="gd">-                return core_schema.json_or_python_schema(python_schema=</span>
<span class="gd">-                    instance_of_schema, json_schema=original_schema)</span>
<span class="gi">+                # Use the &quot;original&quot; approach to serialization</span>
<span class="gi">+                instance_of_schema[&#39;serialization&#39;] = core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gi">+                    function=lambda v, h: h(v), schema=original_schema</span>
<span class="gi">+                )</span>
<span class="gi">+                return core_schema.json_or_python_schema(python_schema=instance_of_schema, json_schema=original_schema)</span>
<span class="gi">+</span>
<span class="w"> </span>        __hash__ = object.__hash__
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    SkipValidation = Annotated[AnyType, ...]</span>
<span class="gi">+    SkipValidation = Annotated[AnyType, ...]  # SkipValidation[list[str]] will be treated by type checkers as list[str]</span>
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    @dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="w"> </span>    class SkipValidation:
<span class="w"> </span>        &quot;&quot;&quot;If this is applied as an annotation (e.g., via `x: Annotated[int, SkipValidation]`), validation will be
<span class="gu">@@ -527,16 +680,18 @@ else:</span>
<span class="w"> </span>        annotation applied to a type.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-        def __class_getitem__(cls, item: Any) -&gt;Any:</span>
<span class="gi">+        def __class_getitem__(cls, item: Any) -&gt; Any:</span>
<span class="w"> </span>            return Annotated[item, SkipValidation()]

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: Any, handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            original_schema = handler(source)
<span class="gd">-            metadata = _core_metadata.build_metadata_dict(</span>
<span class="gd">-                js_annotation_functions=[lambda _c, h: h(original_schema)])</span>
<span class="gd">-            return core_schema.any_schema(metadata=metadata, serialization=</span>
<span class="gd">-                core_schema.wrap_serializer_function_ser_schema(function=lambda</span>
<span class="gd">-                v, h: h(v), schema=original_schema))</span>
<span class="gi">+            metadata = _core_metadata.build_metadata_dict(js_annotation_functions=[lambda _c, h: h(original_schema)])</span>
<span class="gi">+            return core_schema.any_schema(</span>
<span class="gi">+                metadata=metadata,</span>
<span class="gi">+                serialization=core_schema.wrap_serializer_function_ser_schema(</span>
<span class="gi">+                    function=lambda v, h: h(v), schema=original_schema</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        __hash__ = object.__hash__
<span class="gh">diff --git a/pydantic/generics.py b/pydantic/generics.py</span>
<span class="gh">index 84c33fed7..3f1070d08 100644</span>
<span class="gd">--- a/pydantic/generics.py</span>
<span class="gi">+++ b/pydantic/generics.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `generics` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/json.py b/pydantic/json.py</span>
<span class="gh">index 5207cab1e..bcaff9f57 100644</span>
<span class="gd">--- a/pydantic/json.py</span>
<span class="gi">+++ b/pydantic/json.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `json` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/json_schema.py b/pydantic/json_schema.py</span>
<span class="gh">index 32ba228d9..63dcde7a3 100644</span>
<span class="gd">--- a/pydantic/json_schema.py</span>
<span class="gi">+++ b/pydantic/json_schema.py</span>
<span class="gu">@@ -8,7 +8,9 @@ In general you shouldn&#39;t need to use this module directly; instead, you can use</span>
<span class="w"> </span>[`BaseModel.model_json_schema`][pydantic.BaseModel.model_json_schema] and
<span class="w"> </span>[`TypeAdapter.json_schema`][pydantic.TypeAdapter.json_schema].
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import inspect
<span class="w"> </span>import math
<span class="gu">@@ -18,33 +20,64 @@ from collections import defaultdict</span>
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from dataclasses import is_dataclass
<span class="w"> </span>from enum import Enum
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, Counter, Dict, Hashable, Iterable, NewType, Pattern, Sequence, Tuple, TypeVar, Union, cast</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Counter,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Hashable,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    NewType,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>import pydantic_core
<span class="w"> </span>from pydantic_core import CoreSchema, PydanticOmit, core_schema, to_jsonable_python
<span class="w"> </span>from pydantic_core.core_schema import ComputedField
<span class="w"> </span>from typing_extensions import Annotated, Literal, TypeAlias, assert_never, deprecated, final
<span class="gi">+</span>
<span class="w"> </span>from pydantic.warnings import PydanticDeprecatedSince26
<span class="gd">-from ._internal import _config, _core_metadata, _core_utils, _decorators, _internal_dataclass, _mock_val_ser, _schema_generation_shared, _typing_extra</span>
<span class="gi">+</span>
<span class="gi">+from ._internal import (</span>
<span class="gi">+    _config,</span>
<span class="gi">+    _core_metadata,</span>
<span class="gi">+    _core_utils,</span>
<span class="gi">+    _decorators,</span>
<span class="gi">+    _internal_dataclass,</span>
<span class="gi">+    _mock_val_ser,</span>
<span class="gi">+    _schema_generation_shared,</span>
<span class="gi">+    _typing_extra,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .annotated_handlers import GetJsonSchemaHandler
<span class="w"> </span>from .config import JsonDict, JsonSchemaExtraCallable, JsonValue
<span class="w"> </span>from .errors import PydanticInvalidForJsonSchema, PydanticSchemaGenerationError, PydanticUserError
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from . import ConfigDict
<span class="w"> </span>    from ._internal._core_utils import CoreSchemaField, CoreSchemaOrField
<span class="w"> </span>    from ._internal._dataclasses import PydanticDataclass
<span class="w"> </span>    from ._internal._schema_generation_shared import GetJsonSchemaFunction
<span class="w"> </span>    from .main import BaseModel
<span class="gd">-CoreSchemaOrFieldType = Literal[core_schema.CoreSchemaType, core_schema.</span>
<span class="gd">-    CoreSchemaFieldType]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+CoreSchemaOrFieldType = Literal[core_schema.CoreSchemaType, core_schema.CoreSchemaFieldType]</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>A type alias for defined schema types that represents a union of
<span class="w"> </span>`core_schema.CoreSchemaType` and
<span class="w"> </span>`core_schema.CoreSchemaFieldType`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>JsonSchemaValue = Dict[str, Any]
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>A type alias for a JSON schema value. This is a dictionary of string keys to arbitrary JSON values.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>JsonSchemaMode = Literal[&#39;validation&#39;, &#39;serialization&#39;]
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>A type alias that represents the mode of a JSON schema; either &#39;validation&#39; or &#39;serialization&#39;.
<span class="gu">@@ -54,15 +87,15 @@ computed fields will only be present when serializing, and should not be provide</span>
<span class="w"> </span>validating. This flag provides a way to indicate whether you want the JSON schema required
<span class="w"> </span>for validation inputs, or that will be matched by serialization outputs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-_MODE_TITLE_MAPPING: dict[JsonSchemaMode, str] = {&#39;validation&#39;: &#39;Input&#39;,</span>
<span class="gd">-    &#39;serialization&#39;: &#39;Output&#39;}</span>
<span class="gi">+</span>
<span class="gi">+_MODE_TITLE_MAPPING: dict[JsonSchemaMode, str] = {&#39;validation&#39;: &#39;Input&#39;, &#39;serialization&#39;: &#39;Output&#39;}</span>


<span class="w"> </span>@deprecated(
<span class="gd">-    &#39;`update_json_schema` is deprecated, use a simple `my_dict.update(update_dict)` call instead.&#39;</span>
<span class="gd">-    , category=None)</span>
<span class="gd">-def update_json_schema(schema: JsonSchemaValue, updates: dict[str, Any]</span>
<span class="gd">-    ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    &#39;`update_json_schema` is deprecated, use a simple `my_dict.update(update_dict)` call instead.&#39;,</span>
<span class="gi">+    category=None,</span>
<span class="gi">+)</span>
<span class="gi">+def update_json_schema(schema: JsonSchemaValue, updates: dict[str, Any]) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>    &quot;&quot;&quot;Update a JSON schema in-place by providing a dictionary of updates.

<span class="w"> </span>    This function sets the provided key-value pairs in the schema and returns the updated schema.
<span class="gu">@@ -74,7 +107,8 @@ def update_json_schema(schema: JsonSchemaValue, updates: dict[str, Any]</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The updated JSON schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    schema.update(updates)</span>
<span class="gi">+    return schema</span>


<span class="w"> </span>JsonSchemaWarningKind = Literal[&#39;skipped-choice&#39;, &#39;non-serializable-default&#39;]
<span class="gu">@@ -94,11 +128,22 @@ class PydanticJsonSchemaWarning(UserWarning):</span>
<span class="w"> </span>    &quot;&quot;&quot;


<span class="gi">+# ##### JSON Schema Generation #####</span>
<span class="w"> </span>DEFAULT_REF_TEMPLATE = &#39;#/$defs/{model}&#39;
<span class="w"> </span>&quot;&quot;&quot;The default format string used to generate reference names.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# There are three types of references relevant to building JSON schemas:</span>
<span class="gi">+#   1. core_schema &quot;ref&quot; values; these are not exposed as part of the JSON schema</span>
<span class="gi">+#       * these might look like the fully qualified path of a model, its id, or something similar</span>
<span class="w"> </span>CoreRef = NewType(&#39;CoreRef&#39;, str)
<span class="gi">+#   2. keys of the &quot;definitions&quot; object that will eventually go into the JSON schema</span>
<span class="gi">+#       * by default, these look like &quot;MyModel&quot;, though may change in the presence of collisions</span>
<span class="gi">+#       * eventually, we may want to make it easier to modify the way these names are generated</span>
<span class="w"> </span>DefsRef = NewType(&#39;DefsRef&#39;, str)
<span class="gi">+#   3. the values corresponding to the &quot;$ref&quot; key in the schema</span>
<span class="gi">+#       * By default, these look like &quot;#/$defs/MyModel&quot;, as in {&quot;$ref&quot;: &quot;#/$defs/MyModel&quot;}</span>
<span class="w"> </span>JsonRef = NewType(&#39;JsonRef&#39;, str)
<span class="gi">+</span>
<span class="w"> </span>CoreModeRef = Tuple[CoreRef, JsonSchemaMode]
<span class="w"> </span>JsonSchemaKeyT = TypeVar(&#39;JsonSchemaKeyT&#39;, bound=Hashable)

<span class="gu">@@ -109,20 +154,79 @@ class _DefinitionsRemapping:</span>
<span class="w"> </span>    json_remapping: dict[JsonRef, JsonRef]

<span class="w"> </span>    @staticmethod
<span class="gd">-    def from_prioritized_choices(prioritized_choices: dict[DefsRef, list[</span>
<span class="gd">-        DefsRef]], defs_to_json: dict[DefsRef, JsonRef], definitions: dict[</span>
<span class="gd">-        DefsRef, JsonSchemaValue]) -&gt;_DefinitionsRemapping:</span>
<span class="gi">+    def from_prioritized_choices(</span>
<span class="gi">+        prioritized_choices: dict[DefsRef, list[DefsRef]],</span>
<span class="gi">+        defs_to_json: dict[DefsRef, JsonRef],</span>
<span class="gi">+        definitions: dict[DefsRef, JsonSchemaValue],</span>
<span class="gi">+    ) -&gt; _DefinitionsRemapping:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This function should produce a remapping that replaces complex DefsRef with the simpler ones from the
<span class="w"> </span>        prioritized_choices such that applying the name remapping would result in an equivalent JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def remap_json_schema(self, schema: Any) -&gt;Any:</span>
<span class="gi">+        # We need to iteratively simplify the definitions until we reach a fixed point.</span>
<span class="gi">+        # The reason for this is that outer definitions may reference inner definitions that get simplified</span>
<span class="gi">+        # into an equivalent reference, and the outer definitions won&#39;t be equivalent until we&#39;ve simplified</span>
<span class="gi">+        # the inner definitions.</span>
<span class="gi">+        copied_definitions = deepcopy(definitions)</span>
<span class="gi">+        definitions_schema = {&#39;$defs&#39;: copied_definitions}</span>
<span class="gi">+        for _iter in range(100):  # prevent an infinite loop in the case of a bug, 100 iterations should be enough</span>
<span class="gi">+            # For every possible remapped DefsRef, collect all schemas that that DefsRef might be used for:</span>
<span class="gi">+            schemas_for_alternatives: dict[DefsRef, list[JsonSchemaValue]] = defaultdict(list)</span>
<span class="gi">+            for defs_ref in copied_definitions:</span>
<span class="gi">+                alternatives = prioritized_choices[defs_ref]</span>
<span class="gi">+                for alternative in alternatives:</span>
<span class="gi">+                    schemas_for_alternatives[alternative].append(copied_definitions[defs_ref])</span>
<span class="gi">+</span>
<span class="gi">+            # Deduplicate the schemas for each alternative; the idea is that we only want to remap to a new DefsRef</span>
<span class="gi">+            # if it introduces no ambiguity, i.e., there is only one distinct schema for that DefsRef.</span>
<span class="gi">+            for defs_ref, schemas in schemas_for_alternatives.items():</span>
<span class="gi">+                schemas_for_alternatives[defs_ref] = _deduplicate_schemas(schemas_for_alternatives[defs_ref])</span>
<span class="gi">+</span>
<span class="gi">+            # Build the remapping</span>
<span class="gi">+            defs_remapping: dict[DefsRef, DefsRef] = {}</span>
<span class="gi">+            json_remapping: dict[JsonRef, JsonRef] = {}</span>
<span class="gi">+            for original_defs_ref in definitions:</span>
<span class="gi">+                alternatives = prioritized_choices[original_defs_ref]</span>
<span class="gi">+                # Pick the first alternative that has only one schema, since that means there is no collision</span>
<span class="gi">+                remapped_defs_ref = next(x for x in alternatives if len(schemas_for_alternatives[x]) == 1)</span>
<span class="gi">+                defs_remapping[original_defs_ref] = remapped_defs_ref</span>
<span class="gi">+                json_remapping[defs_to_json[original_defs_ref]] = defs_to_json[remapped_defs_ref]</span>
<span class="gi">+            remapping = _DefinitionsRemapping(defs_remapping, json_remapping)</span>
<span class="gi">+            new_definitions_schema = remapping.remap_json_schema({&#39;$defs&#39;: copied_definitions})</span>
<span class="gi">+            if definitions_schema == new_definitions_schema:</span>
<span class="gi">+                # We&#39;ve reached the fixed point</span>
<span class="gi">+                return remapping</span>
<span class="gi">+            definitions_schema = new_definitions_schema</span>
<span class="gi">+</span>
<span class="gi">+        raise PydanticInvalidForJsonSchema(&#39;Failed to simplify the JSON schema definitions&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def remap_defs_ref(self, ref: DefsRef) -&gt; DefsRef:</span>
<span class="gi">+        return self.defs_remapping.get(ref, ref)</span>
<span class="gi">+</span>
<span class="gi">+    def remap_json_ref(self, ref: JsonRef) -&gt; JsonRef:</span>
<span class="gi">+        return self.json_remapping.get(ref, ref)</span>
<span class="gi">+</span>
<span class="gi">+    def remap_json_schema(self, schema: Any) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Recursively update the JSON schema replacing all $refs
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(schema, str):</span>
<span class="gi">+            # Note: this may not really be a JsonRef; we rely on having no collisions between JsonRefs and other strings</span>
<span class="gi">+            return self.remap_json_ref(JsonRef(schema))</span>
<span class="gi">+        elif isinstance(schema, list):</span>
<span class="gi">+            return [self.remap_json_schema(item) for item in schema]</span>
<span class="gi">+        elif isinstance(schema, dict):</span>
<span class="gi">+            for key, value in schema.items():</span>
<span class="gi">+                if key == &#39;$ref&#39; and isinstance(value, str):</span>
<span class="gi">+                    schema[&#39;$ref&#39;] = self.remap_json_ref(JsonRef(value))</span>
<span class="gi">+                elif key == &#39;$defs&#39;:</span>
<span class="gi">+                    schema[&#39;$defs&#39;] = {</span>
<span class="gi">+                        self.remap_defs_ref(DefsRef(key)): self.remap_json_schema(value)</span>
<span class="gi">+                        for key, value in schema[&#39;$defs&#39;].items()</span>
<span class="gi">+                    }</span>
<span class="gi">+                else:</span>
<span class="gi">+                    schema[key] = self.remap_json_schema(value)</span>
<span class="gi">+        return schema</span>


<span class="w"> </span>class GenerateJsonSchema:
<span class="gu">@@ -157,31 +261,63 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        JsonSchemaError: If the instance of the class is inadvertently re-used after generating a schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    schema_dialect = &#39;https://json-schema.org/draft/2020-12/schema&#39;
<span class="gi">+</span>
<span class="gi">+    # `self.render_warning_message` will do nothing if its argument `kind` is in `ignored_warning_kinds`;</span>
<span class="gi">+    # this value can be modified on subclasses to easily control which warnings are emitted</span>
<span class="w"> </span>    ignored_warning_kinds: set[JsonSchemaWarningKind] = {&#39;skipped-choice&#39;}

<span class="gd">-    def __init__(self, by_alias: bool=True, ref_template: str=</span>
<span class="gd">-        DEFAULT_REF_TEMPLATE):</span>
<span class="gi">+    def __init__(self, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE):</span>
<span class="w"> </span>        self.by_alias = by_alias
<span class="w"> </span>        self.ref_template = ref_template
<span class="gi">+</span>
<span class="w"> </span>        self.core_to_json_refs: dict[CoreModeRef, JsonRef] = {}
<span class="w"> </span>        self.core_to_defs_refs: dict[CoreModeRef, DefsRef] = {}
<span class="w"> </span>        self.defs_to_core_refs: dict[DefsRef, CoreModeRef] = {}
<span class="w"> </span>        self.json_to_defs_refs: dict[JsonRef, DefsRef] = {}
<span class="gi">+</span>
<span class="w"> </span>        self.definitions: dict[DefsRef, JsonSchemaValue] = {}
<span class="gd">-        self._config_wrapper_stack = _config.ConfigWrapperStack(_config.</span>
<span class="gd">-            ConfigWrapper({}))</span>
<span class="gi">+        self._config_wrapper_stack = _config.ConfigWrapperStack(_config.ConfigWrapper({}))</span>
<span class="gi">+</span>
<span class="w"> </span>        self._mode: JsonSchemaMode = &#39;validation&#39;
<span class="gi">+</span>
<span class="gi">+        # The following includes a mapping of a fully-unique defs ref choice to a list of preferred</span>
<span class="gi">+        # alternatives, which are generally simpler, such as only including the class name.</span>
<span class="gi">+        # At the end of schema generation, we use these to produce a JSON schema with more human-readable</span>
<span class="gi">+        # definitions, which would also work better in a generated OpenAPI client, etc.</span>
<span class="w"> </span>        self._prioritized_defsref_choices: dict[DefsRef, list[DefsRef]] = {}
<span class="w"> </span>        self._collision_counter: dict[str, int] = defaultdict(int)
<span class="w"> </span>        self._collision_index: dict[str, int] = {}
<span class="gi">+</span>
<span class="w"> </span>        self._schema_type_to_method = self.build_schema_type_to_method()
<span class="gd">-        self._core_defs_invalid_for_json_schema: dict[DefsRef,</span>
<span class="gd">-            PydanticInvalidForJsonSchema] = {}</span>
<span class="gi">+</span>
<span class="gi">+        # When we encounter definitions we need to try to build them immediately</span>
<span class="gi">+        # so that they are available schemas that reference them</span>
<span class="gi">+        # But it&#39;s possible that CoreSchema was never going to be used</span>
<span class="gi">+        # (e.g. because the CoreSchema that references short circuits is JSON schema generation without needing</span>
<span class="gi">+        #  the reference) so instead of failing altogether if we can&#39;t build a definition we</span>
<span class="gi">+        # store the error raised and re-throw it if we end up needing that def</span>
<span class="gi">+        self._core_defs_invalid_for_json_schema: dict[DefsRef, PydanticInvalidForJsonSchema] = {}</span>
<span class="gi">+</span>
<span class="gi">+        # This changes to True after generating a schema, to prevent issues caused by accidental re-use</span>
<span class="gi">+        # of a single instance of a schema generator</span>
<span class="w"> </span>        self._used = False

<span class="gd">-    def build_schema_type_to_method(self) -&gt;dict[CoreSchemaOrFieldType,</span>
<span class="gd">-        Callable[[CoreSchemaOrField], JsonSchemaValue]]:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _config(self) -&gt; _config.ConfigWrapper:</span>
<span class="gi">+        return self._config_wrapper_stack.tail</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def mode(self) -&gt; JsonSchemaMode:</span>
<span class="gi">+        if self._config.json_schema_mode_override is not None:</span>
<span class="gi">+            return self._config.json_schema_mode_override</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._mode</span>
<span class="gi">+</span>
<span class="gi">+    def build_schema_type_to_method(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Builds a dictionary mapping fields to methods for generating JSON schemas.

<span class="w"> </span>        Returns:
<span class="gu">@@ -190,12 +326,24 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def generate_definitions(self, inputs: Sequence[tuple[JsonSchemaKeyT,</span>
<span class="gd">-        JsonSchemaMode, core_schema.CoreSchema]]) -&gt;tuple[dict[tuple[</span>
<span class="gd">-        JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef,</span>
<span class="gd">-        JsonSchemaValue]]:</span>
<span class="gi">+        mapping: dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]] = {}</span>
<span class="gi">+        core_schema_types: list[CoreSchemaOrFieldType] = _typing_extra.all_literal_values(</span>
<span class="gi">+            CoreSchemaOrFieldType  # type: ignore</span>
<span class="gi">+        )</span>
<span class="gi">+        for key in core_schema_types:</span>
<span class="gi">+            method_name = f&quot;{key.replace(&#39;-&#39;, &#39;_&#39;)}_schema&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                mapping[key] = getattr(self, method_name)</span>
<span class="gi">+            except AttributeError as e:  # pragma: no cover</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&#39;No method for generating JsonSchema for core_schema.type={key!r} &#39;</span>
<span class="gi">+                    f&#39;(expected: {type(self).__name__}.{method_name})&#39;</span>
<span class="gi">+                ) from e</span>
<span class="gi">+        return mapping</span>
<span class="gi">+</span>
<span class="gi">+    def generate_definitions(</span>
<span class="gi">+        self, inputs: Sequence[tuple[JsonSchemaKeyT, JsonSchemaMode, core_schema.CoreSchema]]</span>
<span class="gi">+    ) -&gt; tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef, JsonSchemaValue]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a
<span class="w"> </span>        mapping that links the input keys to the definition references.

<span class="gu">@@ -218,10 +366,31 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            PydanticUserError: Raised if the JSON schema generator has already been used to generate a JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._used:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;This JSON schema generator has already been used to generate a JSON schema. &#39;</span>
<span class="gi">+                f&#39;You must create a new instance of {type(self).__name__} to generate a new JSON schema.&#39;,</span>
<span class="gi">+                code=&#39;json-schema-already-used&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        for key, mode, schema in inputs:</span>
<span class="gi">+            self._mode = mode</span>
<span class="gi">+            self.generate_inner(schema)</span>
<span class="gi">+</span>
<span class="gi">+        definitions_remapping = self._build_definitions_remapping()</span>

<span class="gd">-    def generate(self, schema: CoreSchema, mode: JsonSchemaMode=&#39;validation&#39;</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+        json_schemas_map: dict[tuple[JsonSchemaKeyT, JsonSchemaMode], DefsRef] = {}</span>
<span class="gi">+        for key, mode, schema in inputs:</span>
<span class="gi">+            self._mode = mode</span>
<span class="gi">+            json_schema = self.generate_inner(schema)</span>
<span class="gi">+            json_schemas_map[(key, mode)] = definitions_remapping.remap_json_schema(json_schema)</span>
<span class="gi">+</span>
<span class="gi">+        json_schema = {&#39;$defs&#39;: self.definitions}</span>
<span class="gi">+        json_schema = definitions_remapping.remap_json_schema(json_schema)</span>
<span class="gi">+        self._used = True</span>
<span class="gi">+        return json_schemas_map, _sort_json_schema(json_schema[&#39;$defs&#39;])  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def generate(self, schema: CoreSchema, mode: JsonSchemaMode = &#39;validation&#39;) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema for a specified schema in a specified mode.

<span class="w"> </span>        Args:
<span class="gu">@@ -234,9 +403,46 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            PydanticUserError: If the JSON schema generator has already been used to generate a JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def generate_inner(self, schema: CoreSchemaOrField) -&gt;JsonSchemaValue:</span>
<span class="gi">+        self._mode = mode</span>
<span class="gi">+        if self._used:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;This JSON schema generator has already been used to generate a JSON schema. &#39;</span>
<span class="gi">+                f&#39;You must create a new instance of {type(self).__name__} to generate a new JSON schema.&#39;,</span>
<span class="gi">+                code=&#39;json-schema-already-used&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        json_schema: JsonSchemaValue = self.generate_inner(schema)</span>
<span class="gi">+        json_ref_counts = self.get_json_ref_counts(json_schema)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove the top-level $ref if present; note that the _generate method already ensures there are no sibling keys</span>
<span class="gi">+        ref = cast(JsonRef, json_schema.get(&#39;$ref&#39;))</span>
<span class="gi">+        while ref is not None:  # may need to unpack multiple levels</span>
<span class="gi">+            ref_json_schema = self.get_schema_from_definitions(ref)</span>
<span class="gi">+            if json_ref_counts[ref] &gt; 1 or ref_json_schema is None:</span>
<span class="gi">+                # Keep the ref, but use an allOf to remove the top level $ref</span>
<span class="gi">+                json_schema = {&#39;allOf&#39;: [{&#39;$ref&#39;: ref}]}</span>
<span class="gi">+            else:</span>
<span class="gi">+                # &quot;Unpack&quot; the ref since this is the only reference</span>
<span class="gi">+                json_schema = ref_json_schema.copy()  # copy to prevent recursive dict reference</span>
<span class="gi">+                json_ref_counts[ref] -= 1</span>
<span class="gi">+            ref = cast(JsonRef, json_schema.get(&#39;$ref&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        self._garbage_collect_definitions(json_schema)</span>
<span class="gi">+        definitions_remapping = self._build_definitions_remapping()</span>
<span class="gi">+</span>
<span class="gi">+        if self.definitions:</span>
<span class="gi">+            json_schema[&#39;$defs&#39;] = self.definitions</span>
<span class="gi">+</span>
<span class="gi">+        json_schema = definitions_remapping.remap_json_schema(json_schema)</span>
<span class="gi">+</span>
<span class="gi">+        # For now, we will not set the $schema key. However, if desired, this can be easily added by overriding</span>
<span class="gi">+        # this method and adding the following line after a call to super().generate(schema):</span>
<span class="gi">+        # json_schema[&#39;$schema&#39;] = self.schema_dialect</span>
<span class="gi">+</span>
<span class="gi">+        self._used = True</span>
<span class="gi">+        return _sort_json_schema(json_schema)</span>
<span class="gi">+</span>
<span class="gi">+    def generate_inner(self, schema: CoreSchemaOrField) -&gt; JsonSchemaValue:  # noqa: C901</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema for a given core schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -245,9 +451,113 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # If a schema with the same CoreRef has been handled, just return a reference to it</span>
<span class="gi">+        # Note that this assumes that it will _never_ be the case that the same CoreRef is used</span>
<span class="gi">+        # on types that should have different JSON schemas</span>
<span class="gi">+        if &#39;ref&#39; in schema:</span>
<span class="gi">+            core_ref = CoreRef(schema[&#39;ref&#39;])  # type: ignore[typeddict-item]</span>
<span class="gi">+            core_mode_ref = (core_ref, self.mode)</span>
<span class="gi">+            if core_mode_ref in self.core_to_defs_refs and self.core_to_defs_refs[core_mode_ref] in self.definitions:</span>
<span class="gi">+                return {&#39;$ref&#39;: self.core_to_json_refs[core_mode_ref]}</span>
<span class="gi">+</span>
<span class="gi">+        # Generate the JSON schema, accounting for the json_schema_override and core_schema_override</span>
<span class="gi">+        metadata_handler = _core_metadata.CoreMetadataHandler(schema)</span>
<span class="gi">+</span>
<span class="gi">+        def populate_defs(core_schema: CoreSchema, json_schema: JsonSchemaValue) -&gt; JsonSchemaValue:</span>
<span class="gi">+            if &#39;ref&#39; in core_schema:</span>
<span class="gi">+                core_ref = CoreRef(core_schema[&#39;ref&#39;])  # type: ignore[typeddict-item]</span>
<span class="gi">+                defs_ref, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)</span>
<span class="gi">+                json_ref = JsonRef(ref_json_schema[&#39;$ref&#39;])</span>
<span class="gi">+                self.json_to_defs_refs[json_ref] = defs_ref</span>
<span class="gi">+                # Replace the schema if it&#39;s not a reference to itself</span>
<span class="gi">+                # What we want to avoid is having the def be just a ref to itself</span>
<span class="gi">+                # which is what would happen if we blindly assigned any</span>
<span class="gi">+                if json_schema.get(&#39;$ref&#39;, None) != json_ref:</span>
<span class="gi">+                    self.definitions[defs_ref] = json_schema</span>
<span class="gi">+                    self._core_defs_invalid_for_json_schema.pop(defs_ref, None)</span>
<span class="gi">+                json_schema = ref_json_schema</span>
<span class="gi">+            return json_schema</span>
<span class="gi">+</span>
<span class="gi">+        def convert_to_all_of(json_schema: JsonSchemaValue) -&gt; JsonSchemaValue:</span>
<span class="gi">+            if &#39;$ref&#39; in json_schema and len(json_schema.keys()) &gt; 1:</span>
<span class="gi">+                # technically you can&#39;t have any other keys next to a &quot;$ref&quot;</span>
<span class="gi">+                # but it&#39;s an easy mistake to make and not hard to correct automatically here</span>
<span class="gi">+                json_schema = json_schema.copy()</span>
<span class="gi">+                ref = json_schema.pop(&#39;$ref&#39;)</span>
<span class="gi">+                json_schema = {&#39;allOf&#39;: [{&#39;$ref&#39;: ref}], **json_schema}</span>
<span class="gi">+            return json_schema</span>
<span class="gi">+</span>
<span class="gi">+        def handler_func(schema_or_field: CoreSchemaOrField) -&gt; JsonSchemaValue:</span>
<span class="gi">+            &quot;&quot;&quot;Generate a JSON schema based on the input schema.</span>
<span class="gi">+</span>
<span class="gi">+            Args:</span>
<span class="gi">+                schema_or_field: The core schema to generate a JSON schema from.</span>
<span class="gi">+</span>
<span class="gi">+            Returns:</span>
<span class="gi">+                The generated JSON schema.</span>
<span class="gi">+</span>
<span class="gi">+            Raises:</span>
<span class="gi">+                TypeError: If an unexpected schema type is encountered.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            # Generate the core-schema-type-specific bits of the schema generation:</span>
<span class="gi">+            json_schema: JsonSchemaValue | None = None</span>
<span class="gi">+            if self.mode == &#39;serialization&#39; and &#39;serialization&#39; in schema_or_field:</span>
<span class="gi">+                ser_schema = schema_or_field[&#39;serialization&#39;]  # type: ignore</span>
<span class="gi">+                json_schema = self.ser_schema(ser_schema)</span>
<span class="gi">+            if json_schema is None:</span>
<span class="gi">+                if _core_utils.is_core_schema(schema_or_field) or _core_utils.is_core_schema_field(schema_or_field):</span>
<span class="gi">+                    generate_for_schema_type = self._schema_type_to_method[schema_or_field[&#39;type&#39;]]</span>
<span class="gi">+                    json_schema = generate_for_schema_type(schema_or_field)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise TypeError(f&#39;Unexpected schema type: schema={schema_or_field}&#39;)</span>
<span class="gi">+            if _core_utils.is_core_schema(schema_or_field):</span>
<span class="gi">+                json_schema = populate_defs(schema_or_field, json_schema)</span>
<span class="gi">+                json_schema = convert_to_all_of(json_schema)</span>
<span class="gi">+            return json_schema</span>
<span class="gi">+</span>
<span class="gi">+        current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, handler_func)</span>
<span class="gi">+</span>
<span class="gi">+        for js_modify_function in metadata_handler.metadata.get(&#39;pydantic_js_functions&#39;, ()):</span>
<span class="gi">+</span>
<span class="gi">+            def new_handler_func(</span>
<span class="gi">+                schema_or_field: CoreSchemaOrField,</span>
<span class="gi">+                current_handler: GetJsonSchemaHandler = current_handler,</span>
<span class="gi">+                js_modify_function: GetJsonSchemaFunction = js_modify_function,</span>
<span class="gi">+            ) -&gt; JsonSchemaValue:</span>
<span class="gi">+                json_schema = js_modify_function(schema_or_field, current_handler)</span>
<span class="gi">+                if _core_utils.is_core_schema(schema_or_field):</span>
<span class="gi">+                    json_schema = populate_defs(schema_or_field, json_schema)</span>
<span class="gi">+                original_schema = current_handler.resolve_ref_schema(json_schema)</span>
<span class="gi">+                ref = json_schema.pop(&#39;$ref&#39;, None)</span>
<span class="gi">+                if ref and json_schema:</span>
<span class="gi">+                    original_schema.update(json_schema)</span>
<span class="gi">+                return original_schema</span>
<span class="gi">+</span>
<span class="gi">+            current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)</span>
<span class="gi">+</span>
<span class="gi">+        for js_modify_function in metadata_handler.metadata.get(&#39;pydantic_js_annotation_functions&#39;, ()):</span>
<span class="gi">+</span>
<span class="gi">+            def new_handler_func(</span>
<span class="gi">+                schema_or_field: CoreSchemaOrField,</span>
<span class="gi">+                current_handler: GetJsonSchemaHandler = current_handler,</span>
<span class="gi">+                js_modify_function: GetJsonSchemaFunction = js_modify_function,</span>
<span class="gi">+            ) -&gt; JsonSchemaValue:</span>
<span class="gi">+                json_schema = js_modify_function(schema_or_field, current_handler)</span>
<span class="gi">+                if _core_utils.is_core_schema(schema_or_field):</span>
<span class="gi">+                    json_schema = populate_defs(schema_or_field, json_schema)</span>
<span class="gi">+                    json_schema = convert_to_all_of(json_schema)</span>
<span class="gi">+                return json_schema</span>
<span class="gi">+</span>
<span class="gi">+            current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)</span>
<span class="gi">+</span>
<span class="gi">+        json_schema = current_handler(schema)</span>
<span class="gi">+        if _core_utils.is_core_schema(schema):</span>
<span class="gi">+            json_schema = populate_defs(schema, json_schema)</span>
<span class="gi">+            json_schema = convert_to_all_of(json_schema)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def any_schema(self, schema: core_schema.AnySchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    # ### Schema generation methods</span>
<span class="gi">+    def any_schema(self, schema: core_schema.AnySchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches any value.

<span class="w"> </span>        Args:
<span class="gu">@@ -256,9 +566,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {}</span>

<span class="gd">-    def none_schema(self, schema: core_schema.NoneSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def none_schema(self, schema: core_schema.NoneSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches `None`.

<span class="w"> </span>        Args:
<span class="gu">@@ -267,9 +577,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {&#39;type&#39;: &#39;null&#39;}</span>

<span class="gd">-    def bool_schema(self, schema: core_schema.BoolSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def bool_schema(self, schema: core_schema.BoolSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a bool value.

<span class="w"> </span>        Args:
<span class="gu">@@ -278,9 +588,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {&#39;type&#39;: &#39;boolean&#39;}</span>

<span class="gd">-    def int_schema(self, schema: core_schema.IntSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def int_schema(self, schema: core_schema.IntSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches an int value.

<span class="w"> </span>        Args:
<span class="gu">@@ -289,9 +599,12 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema: dict[str, Any] = {&#39;type&#39;: &#39;integer&#39;}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)</span>
<span class="gi">+        json_schema = {k: v for k, v in json_schema.items() if v not in {math.inf, -math.inf}}</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def float_schema(self, schema: core_schema.FloatSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def float_schema(self, schema: core_schema.FloatSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a float value.

<span class="w"> </span>        Args:
<span class="gu">@@ -300,10 +613,12 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema: dict[str, Any] = {&#39;type&#39;: &#39;number&#39;}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)</span>
<span class="gi">+        json_schema = {k: v for k, v in json_schema.items() if v not in {math.inf, -math.inf}}</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def decimal_schema(self, schema: core_schema.DecimalSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def decimal_schema(self, schema: core_schema.DecimalSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a decimal value.

<span class="w"> </span>        Args:
<span class="gu">@@ -312,9 +627,31 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema = self.str_schema(core_schema.str_schema())</span>
<span class="gi">+        if self.mode == &#39;validation&#39;:</span>
<span class="gi">+            multiple_of = schema.get(&#39;multiple_of&#39;)</span>
<span class="gi">+            le = schema.get(&#39;le&#39;)</span>
<span class="gi">+            ge = schema.get(&#39;ge&#39;)</span>
<span class="gi">+            lt = schema.get(&#39;lt&#39;)</span>
<span class="gi">+            gt = schema.get(&#39;gt&#39;)</span>
<span class="gi">+            json_schema = {</span>
<span class="gi">+                &#39;anyOf&#39;: [</span>
<span class="gi">+                    self.float_schema(</span>
<span class="gi">+                        core_schema.float_schema(</span>
<span class="gi">+                            allow_inf_nan=schema.get(&#39;allow_inf_nan&#39;),</span>
<span class="gi">+                            multiple_of=None if multiple_of is None else float(multiple_of),</span>
<span class="gi">+                            le=None if le is None else float(le),</span>
<span class="gi">+                            ge=None if ge is None else float(ge),</span>
<span class="gi">+                            lt=None if lt is None else float(lt),</span>
<span class="gi">+                            gt=None if gt is None else float(gt),</span>
<span class="gi">+                        )</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    json_schema,</span>
<span class="gi">+                ],</span>
<span class="gi">+            }</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def str_schema(self, schema: core_schema.StringSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def str_schema(self, schema: core_schema.StringSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a string value.

<span class="w"> </span>        Args:
<span class="gu">@@ -323,9 +660,14 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;string&#39;}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)</span>
<span class="gi">+        if isinstance(json_schema.get(&#39;pattern&#39;), Pattern):</span>
<span class="gi">+            # TODO: should we add regex flags to the pattern?</span>
<span class="gi">+            json_schema[&#39;pattern&#39;] = json_schema.get(&#39;pattern&#39;).pattern  # type: ignore</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def bytes_schema(self, schema: core_schema.BytesSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def bytes_schema(self, schema: core_schema.BytesSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a bytes value.

<span class="w"> </span>        Args:
<span class="gu">@@ -334,9 +676,11 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;base64url&#39; if self._config.ser_json_bytes == &#39;base64&#39; else &#39;binary&#39;}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.bytes)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def date_schema(self, schema: core_schema.DateSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def date_schema(self, schema: core_schema.DateSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a date value.

<span class="w"> </span>        Args:
<span class="gu">@@ -345,9 +689,11 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;date&#39;}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.date)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def time_schema(self, schema: core_schema.TimeSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def time_schema(self, schema: core_schema.TimeSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a time value.

<span class="w"> </span>        Args:
<span class="gu">@@ -356,10 +702,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;time&#39;}</span>

<span class="gd">-    def datetime_schema(self, schema: core_schema.DatetimeSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def datetime_schema(self, schema: core_schema.DatetimeSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a datetime value.

<span class="w"> </span>        Args:
<span class="gu">@@ -368,10 +713,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;date-time&#39;}</span>

<span class="gd">-    def timedelta_schema(self, schema: core_schema.TimedeltaSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def timedelta_schema(self, schema: core_schema.TimedeltaSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a timedelta value.

<span class="w"> </span>        Args:
<span class="gu">@@ -380,10 +724,11 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._config.ser_json_timedelta == &#39;float&#39;:</span>
<span class="gi">+            return {&#39;type&#39;: &#39;number&#39;}</span>
<span class="gi">+        return {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;duration&#39;}</span>

<span class="gd">-    def literal_schema(self, schema: core_schema.LiteralSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def literal_schema(self, schema: core_schema.LiteralSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a literal value.

<span class="w"> </span>        Args:
<span class="gu">@@ -392,9 +737,30 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def enum_schema(self, schema: core_schema.EnumSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+        expected = [v.value if isinstance(v, Enum) else v for v in schema[&#39;expected&#39;]]</span>
<span class="gi">+        # jsonify the expected values</span>
<span class="gi">+        expected = [to_jsonable_python(v) for v in expected]</span>
<span class="gi">+</span>
<span class="gi">+        result: dict[str, Any] = {&#39;enum&#39;: expected}</span>
<span class="gi">+        if len(expected) == 1:</span>
<span class="gi">+            result[&#39;const&#39;] = expected[0]</span>
<span class="gi">+</span>
<span class="gi">+        types = {type(e) for e in expected}</span>
<span class="gi">+        if types == {str}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;string&#39;</span>
<span class="gi">+        elif types == {int}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;integer&#39;</span>
<span class="gi">+        elif types == {float}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;numeric&#39;</span>
<span class="gi">+        elif types == {bool}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;boolean&#39;</span>
<span class="gi">+        elif types == {list}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;array&#39;</span>
<span class="gi">+        elif types == {type(None)}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;null&#39;</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def enum_schema(self, schema: core_schema.EnumSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches an Enum value.

<span class="w"> </span>        Args:
<span class="gu">@@ -403,10 +769,36 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def is_instance_schema(self, schema: core_schema.IsInstanceSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+        enum_type = schema[&#39;cls&#39;]</span>
<span class="gi">+        description = None if not enum_type.__doc__ else inspect.cleandoc(enum_type.__doc__)</span>
<span class="gi">+        if (</span>
<span class="gi">+            description == &#39;An enumeration.&#39;</span>
<span class="gi">+        ):  # This is the default value provided by enum.EnumMeta.__new__; don&#39;t use it</span>
<span class="gi">+            description = None</span>
<span class="gi">+        result: dict[str, Any] = {&#39;title&#39;: enum_type.__name__, &#39;description&#39;: description}</span>
<span class="gi">+        result = {k: v for k, v in result.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+        expected = [to_jsonable_python(v.value) for v in schema[&#39;members&#39;]]</span>
<span class="gi">+</span>
<span class="gi">+        result[&#39;enum&#39;] = expected</span>
<span class="gi">+        if len(expected) == 1:</span>
<span class="gi">+            result[&#39;const&#39;] = expected[0]</span>
<span class="gi">+</span>
<span class="gi">+        types = {type(e) for e in expected}</span>
<span class="gi">+        if isinstance(enum_type, str) or types == {str}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;string&#39;</span>
<span class="gi">+        elif isinstance(enum_type, int) or types == {int}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;integer&#39;</span>
<span class="gi">+        elif isinstance(enum_type, float) or types == {float}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;numeric&#39;</span>
<span class="gi">+        elif types == {bool}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;boolean&#39;</span>
<span class="gi">+        elif types == {list}:</span>
<span class="gi">+            result[&#39;type&#39;] = &#39;array&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def is_instance_schema(self, schema: core_schema.IsInstanceSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles JSON schema generation for a core schema that checks if a value is an instance of a class.

<span class="w"> </span>        Unless overridden in a subclass, this raises an error.
<span class="gu">@@ -417,10 +809,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.handle_invalid_for_json_schema(schema, f&#39;core_schema.IsInstanceSchema ({schema[&quot;cls&quot;]})&#39;)</span>

<span class="gd">-    def is_subclass_schema(self, schema: core_schema.IsSubclassSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def is_subclass_schema(self, schema: core_schema.IsSubclassSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles JSON schema generation for a core schema that checks if a value is a subclass of a class.

<span class="w"> </span>        For backwards compatibility with v1, this does not raise an error, but can be overridden to change this.
<span class="gu">@@ -431,10 +822,10 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Note: This is for compatibility with V1; you can override if you want different behavior.</span>
<span class="gi">+        return {}</span>

<span class="gd">-    def callable_schema(self, schema: core_schema.CallableSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def callable_schema(self, schema: core_schema.CallableSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a callable value.

<span class="w"> </span>        Unless overridden in a subclass, this raises an error.
<span class="gu">@@ -445,9 +836,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.handle_invalid_for_json_schema(schema, &#39;core_schema.CallableSchema&#39;)</span>

<span class="gd">-    def list_schema(self, schema: core_schema.ListSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def list_schema(self, schema: core_schema.ListSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a schema that matches a list schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -456,27 +847,34 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        items_schema = {} if &#39;items_schema&#39; not in schema else self.generate_inner(schema[&#39;items_schema&#39;])</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: items_schema}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    @deprecated(</span>
<span class="gd">-        &#39;`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.&#39;,</span>
<span class="gd">-        category=None)</span>
<span class="gi">+    @deprecated(&#39;`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.&#39;, category=None)</span>
<span class="w"> </span>    @final
<span class="gd">-    def tuple_positional_schema(self, schema: core_schema.TupleSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def tuple_positional_schema(self, schema: core_schema.TupleSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replaced by `tuple_schema`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @deprecated(</span>
<span class="gd">-        &#39;`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.&#39;,</span>
<span class="gd">-        category=None)</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.&#39;,</span>
<span class="gi">+            PydanticDeprecatedSince26,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.tuple_schema(schema)</span>
<span class="gi">+</span>
<span class="gi">+    @deprecated(&#39;`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.&#39;, category=None)</span>
<span class="w"> </span>    @final
<span class="gd">-    def tuple_variable_schema(self, schema: core_schema.TupleSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def tuple_variable_schema(self, schema: core_schema.TupleSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replaced by `tuple_schema`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def tuple_schema(self, schema: core_schema.TupleSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.&#39;,</span>
<span class="gi">+            PydanticDeprecatedSince26,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.tuple_schema(schema)</span>
<span class="gi">+</span>
<span class="gi">+    def tuple_schema(self, schema: core_schema.TupleSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a tuple schema e.g. `Tuple[int,
<span class="w"> </span>        str, bool]` or `Tuple[int, ...]`.

<span class="gu">@@ -486,9 +884,32 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema: JsonSchemaValue = {&#39;type&#39;: &#39;array&#39;}</span>
<span class="gi">+        if &#39;variadic_item_index&#39; in schema:</span>
<span class="gi">+            variadic_item_index = schema[&#39;variadic_item_index&#39;]</span>
<span class="gi">+            if variadic_item_index &gt; 0:</span>
<span class="gi">+                json_schema[&#39;minItems&#39;] = variadic_item_index</span>
<span class="gi">+                json_schema[&#39;prefixItems&#39;] = [</span>
<span class="gi">+                    self.generate_inner(item) for item in schema[&#39;items_schema&#39;][:variadic_item_index]</span>
<span class="gi">+                ]</span>
<span class="gi">+            if variadic_item_index + 1 == len(schema[&#39;items_schema&#39;]):</span>
<span class="gi">+                # if the variadic item is the last item, then represent it faithfully</span>
<span class="gi">+                json_schema[&#39;items&#39;] = self.generate_inner(schema[&#39;items_schema&#39;][variadic_item_index])</span>
<span class="gi">+            else:</span>
<span class="gi">+                # otherwise, &#39;items&#39; represents the schema for the variadic</span>
<span class="gi">+                # item plus the suffix, so just allow anything for simplicity</span>
<span class="gi">+                # for now</span>
<span class="gi">+                json_schema[&#39;items&#39;] = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            prefixItems = [self.generate_inner(item) for item in schema[&#39;items_schema&#39;]]</span>
<span class="gi">+            if prefixItems:</span>
<span class="gi">+                json_schema[&#39;prefixItems&#39;] = prefixItems</span>
<span class="gi">+            json_schema[&#39;minItems&#39;] = len(prefixItems)</span>
<span class="gi">+            json_schema[&#39;maxItems&#39;] = len(prefixItems)</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def set_schema(self, schema: core_schema.SetSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def set_schema(self, schema: core_schema.SetSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a set schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -497,10 +918,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._common_set_schema(schema)</span>

<span class="gd">-    def frozenset_schema(self, schema: core_schema.FrozenSetSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def frozenset_schema(self, schema: core_schema.FrozenSetSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a frozenset schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -509,10 +929,15 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._common_set_schema(schema)</span>
<span class="gi">+</span>
<span class="gi">+    def _common_set_schema(self, schema: core_schema.SetSchema | core_schema.FrozenSetSchema) -&gt; JsonSchemaValue:</span>
<span class="gi">+        items_schema = {} if &#39;items_schema&#39; not in schema else self.generate_inner(schema[&#39;items_schema&#39;])</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;array&#39;, &#39;uniqueItems&#39;: True, &#39;items&#39;: items_schema}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def generator_schema(self, schema: core_schema.GeneratorSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def generator_schema(self, schema: core_schema.GeneratorSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a JSON schema that represents the provided GeneratorSchema.

<span class="w"> </span>        Args:
<span class="gu">@@ -521,9 +946,12 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        items_schema = {} if &#39;items_schema&#39; not in schema else self.generate_inner(schema[&#39;items_schema&#39;])</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: items_schema}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def dict_schema(self, schema: core_schema.DictSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def dict_schema(self, schema: core_schema.DictSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a dict schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -532,10 +960,37 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema: JsonSchemaValue = {&#39;type&#39;: &#39;object&#39;}</span>
<span class="gi">+</span>
<span class="gi">+        keys_schema = self.generate_inner(schema[&#39;keys_schema&#39;]).copy() if &#39;keys_schema&#39; in schema else {}</span>
<span class="gi">+        keys_pattern = keys_schema.pop(&#39;pattern&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+        values_schema = self.generate_inner(schema[&#39;values_schema&#39;]).copy() if &#39;values_schema&#39; in schema else {}</span>
<span class="gi">+        values_schema.pop(&#39;title&#39;, None)  # don&#39;t give a title to the additionalProperties</span>
<span class="gi">+        if values_schema or keys_pattern is not None:  # don&#39;t add additionalProperties if it&#39;s empty</span>
<span class="gi">+            if keys_pattern is None:</span>
<span class="gi">+                json_schema[&#39;additionalProperties&#39;] = values_schema</span>
<span class="gi">+            else:</span>
<span class="gi">+                json_schema[&#39;patternProperties&#39;] = {keys_pattern: values_schema}</span>
<span class="gi">+</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.object)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def function_before_schema(self, schema: core_schema.</span>
<span class="gd">-        BeforeValidatorFunctionSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def _function_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        schema: _core_utils.AnyFunctionSchema,</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="gi">+        if _core_utils.is_function_with_inner_schema(schema):</span>
<span class="gi">+            # This could be wrong if the function&#39;s mode is &#39;before&#39;, but in practice will often be right, and when it</span>
<span class="gi">+            # isn&#39;t, I think it would be hard to automatically infer what the desired schema should be.</span>
<span class="gi">+            return self.generate_inner(schema[&#39;schema&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        # function-plain</span>
<span class="gi">+        return self.handle_invalid_for_json_schema(</span>
<span class="gi">+            schema, f&#39;core_schema.PlainValidatorFunctionSchema ({schema[&quot;function&quot;]})&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def function_before_schema(self, schema: core_schema.BeforeValidatorFunctionSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a function-before schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -544,10 +999,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._function_schema(schema)</span>

<span class="gd">-    def function_after_schema(self, schema: core_schema.</span>
<span class="gd">-        AfterValidatorFunctionSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def function_after_schema(self, schema: core_schema.AfterValidatorFunctionSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a function-after schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -556,10 +1010,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._function_schema(schema)</span>

<span class="gd">-    def function_plain_schema(self, schema: core_schema.</span>
<span class="gd">-        PlainValidatorFunctionSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def function_plain_schema(self, schema: core_schema.PlainValidatorFunctionSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a function-plain schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -568,10 +1021,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._function_schema(schema)</span>

<span class="gd">-    def function_wrap_schema(self, schema: core_schema.</span>
<span class="gd">-        WrapValidatorFunctionSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def function_wrap_schema(self, schema: core_schema.WrapValidatorFunctionSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a function-wrap schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -580,10 +1032,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._function_schema(schema)</span>

<span class="gd">-    def default_schema(self, schema: core_schema.WithDefaultSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def default_schema(self, schema: core_schema.WithDefaultSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema with a default value.

<span class="w"> </span>        Args:
<span class="gu">@@ -592,10 +1043,51 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema = self.generate_inner(schema[&#39;schema&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;default&#39; not in schema:</span>
<span class="gi">+            return json_schema</span>
<span class="gi">+        default = schema[&#39;default&#39;]</span>
<span class="gi">+        # Note: if you want to include the value returned by the default_factory,</span>
<span class="gi">+        # override this method and replace the code above with:</span>
<span class="gi">+        # if &#39;default&#39; in schema:</span>
<span class="gi">+        #     default = schema[&#39;default&#39;]</span>
<span class="gi">+        # elif &#39;default_factory&#39; in schema:</span>
<span class="gi">+        #     default = schema[&#39;default_factory&#39;]()</span>
<span class="gi">+        # else:</span>
<span class="gi">+        #     return json_schema</span>
<span class="gi">+</span>
<span class="gi">+        # we reflect the application of custom plain, no-info serializers to defaults for</span>
<span class="gi">+        # json schemas viewed in serialization mode</span>
<span class="gi">+        # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208</span>
<span class="gi">+        # TODO: improve type safety here</span>
<span class="gi">+        if self.mode == &#39;serialization&#39;:</span>
<span class="gi">+            if (</span>
<span class="gi">+                (ser_schema := schema[&#39;schema&#39;].get(&#39;serialization&#39;, {}))</span>
<span class="gi">+                and (ser_func := ser_schema.get(&#39;function&#39;))</span>
<span class="gi">+                and ser_schema.get(&#39;type&#39;) == &#39;function-plain&#39;  # type: ignore</span>
<span class="gi">+                and ser_schema.get(&#39;info_arg&#39;) is False  # type: ignore</span>
<span class="gi">+            ):</span>
<span class="gi">+                default = ser_func(default)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            encoded_default = self.encode_default(default)</span>
<span class="gi">+        except pydantic_core.PydanticSerializationError:</span>
<span class="gi">+            self.emit_warning(</span>
<span class="gi">+                &#39;non-serializable-default&#39;,</span>
<span class="gi">+                f&#39;Default value {default} is not JSON serializable; excluding default from JSON schema&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+            # Return the inner schema, as though there was no default</span>
<span class="gi">+            return json_schema</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;$ref&#39; in json_schema:</span>
<span class="gi">+            # Since reference schemas do not support child keys, we wrap the reference schema in a single-case allOf:</span>
<span class="gi">+            return {&#39;allOf&#39;: [json_schema], &#39;default&#39;: encoded_default}</span>
<span class="gi">+        else:</span>
<span class="gi">+            json_schema[&#39;default&#39;] = encoded_default</span>
<span class="gi">+            return json_schema</span>

<span class="gd">-    def nullable_schema(self, schema: core_schema.NullableSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def nullable_schema(self, schema: core_schema.NullableSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that allows null values.

<span class="w"> </span>        Args:
<span class="gu">@@ -604,9 +1096,17 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        null_schema = {&#39;type&#39;: &#39;null&#39;}</span>
<span class="gi">+        inner_json_schema = self.generate_inner(schema[&#39;schema&#39;])</span>

<span class="gd">-    def union_schema(self, schema: core_schema.UnionSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+        if inner_json_schema == null_schema:</span>
<span class="gi">+            return null_schema</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Thanks to the equality check against `null_schema` above, I think &#39;oneOf&#39; would also be valid here;</span>
<span class="gi">+            # I&#39;ll use &#39;anyOf&#39; for now, but it could be changed it if it would work better with some external tooling</span>
<span class="gi">+            return self.get_flattened_anyof([inner_json_schema, null_schema])</span>
<span class="gi">+</span>
<span class="gi">+    def union_schema(self, schema: core_schema.UnionSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that allows values matching any of the given schemas.

<span class="w"> </span>        Args:
<span class="gu">@@ -615,10 +1115,23 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def tagged_union_schema(self, schema: core_schema.TaggedUnionSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+        generated: list[JsonSchemaValue] = []</span>
<span class="gi">+</span>
<span class="gi">+        choices = schema[&#39;choices&#39;]</span>
<span class="gi">+        for choice in choices:</span>
<span class="gi">+            # choice will be a tuple if an explicit label was provided</span>
<span class="gi">+            choice_schema = choice[0] if isinstance(choice, tuple) else choice</span>
<span class="gi">+            try:</span>
<span class="gi">+                generated.append(self.generate_inner(choice_schema))</span>
<span class="gi">+            except PydanticOmit:</span>
<span class="gi">+                continue</span>
<span class="gi">+            except PydanticInvalidForJsonSchema as exc:</span>
<span class="gi">+                self.emit_warning(&#39;skipped-choice&#39;, exc.message)</span>
<span class="gi">+        if len(generated) == 1:</span>
<span class="gi">+            return generated[0]</span>
<span class="gi">+        return self.get_flattened_anyof(generated)</span>
<span class="gi">+</span>
<span class="gi">+    def tagged_union_schema(self, schema: core_schema.TaggedUnionSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where
<span class="w"> </span>        the schemas are tagged with a discriminator field that indicates which schema should be used to validate
<span class="w"> </span>        the value.
<span class="gu">@@ -629,15 +1142,73 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        generated: dict[str, JsonSchemaValue] = {}</span>
<span class="gi">+        for k, v in schema[&#39;choices&#39;].items():</span>
<span class="gi">+            if isinstance(k, Enum):</span>
<span class="gi">+                k = k.value</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Use str(k) since keys must be strings for json; while not technically correct,</span>
<span class="gi">+                # it&#39;s the closest that can be represented in valid JSON</span>
<span class="gi">+                generated[str(k)] = self.generate_inner(v).copy()</span>
<span class="gi">+            except PydanticOmit:</span>
<span class="gi">+                continue</span>
<span class="gi">+            except PydanticInvalidForJsonSchema as exc:</span>
<span class="gi">+                self.emit_warning(&#39;skipped-choice&#39;, exc.message)</span>
<span class="gi">+</span>
<span class="gi">+        one_of_choices = _deduplicate_schemas(generated.values())</span>
<span class="gi">+        json_schema: JsonSchemaValue = {&#39;oneOf&#39;: one_of_choices}</span>
<span class="gi">+</span>
<span class="gi">+        # This reflects the v1 behavior; TODO: we should make it possible to exclude OpenAPI stuff from the JSON schema</span>
<span class="gi">+        openapi_discriminator = self._extract_discriminator(schema, one_of_choices)</span>
<span class="gi">+        if openapi_discriminator is not None:</span>
<span class="gi">+            json_schema[&#39;discriminator&#39;] = {</span>
<span class="gi">+                &#39;propertyName&#39;: openapi_discriminator,</span>
<span class="gi">+                &#39;mapping&#39;: {k: v.get(&#39;$ref&#39;, v) for k, v in generated.items()},</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def _extract_discriminator(self, schema: core_schema.TaggedUnionSchema,</span>
<span class="gd">-        one_of_choices: list[JsonDict]) -&gt;(str | None):</span>
<span class="gi">+    def _extract_discriminator(</span>
<span class="gi">+        self, schema: core_schema.TaggedUnionSchema, one_of_choices: list[JsonDict]</span>
<span class="gi">+    ) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract a compatible OpenAPI discriminator from the schema and one_of choices that end up in the final
<span class="w"> </span>        schema.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def chain_schema(self, schema: core_schema.ChainSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+        openapi_discriminator: str | None = None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(schema[&#39;discriminator&#39;], str):</span>
<span class="gi">+            return schema[&#39;discriminator&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(schema[&#39;discriminator&#39;], list):</span>
<span class="gi">+            # If the discriminator is a single item list containing a string, that is equivalent to the string case</span>
<span class="gi">+            if len(schema[&#39;discriminator&#39;]) == 1 and isinstance(schema[&#39;discriminator&#39;][0], str):</span>
<span class="gi">+                return schema[&#39;discriminator&#39;][0]</span>
<span class="gi">+            # When an alias is used that is different from the field name, the discriminator will be a list of single</span>
<span class="gi">+            # str lists, one for the attribute and one for the actual alias. The logic here will work even if there is</span>
<span class="gi">+            # more than one possible attribute, and looks for whether a single alias choice is present as a documented</span>
<span class="gi">+            # property on all choices. If so, that property will be used as the OpenAPI discriminator.</span>
<span class="gi">+            for alias_path in schema[&#39;discriminator&#39;]:</span>
<span class="gi">+                if not isinstance(alias_path, list):</span>
<span class="gi">+                    break  # this means that the discriminator is not a list of alias paths</span>
<span class="gi">+                if len(alias_path) != 1:</span>
<span class="gi">+                    continue  # this means that the &quot;alias&quot; does not represent a single field</span>
<span class="gi">+                alias = alias_path[0]</span>
<span class="gi">+                if not isinstance(alias, str):</span>
<span class="gi">+                    continue  # this means that the &quot;alias&quot; does not represent a field</span>
<span class="gi">+                alias_is_present_on_all_choices = True</span>
<span class="gi">+                for choice in one_of_choices:</span>
<span class="gi">+                    while &#39;$ref&#39; in choice:</span>
<span class="gi">+                        assert isinstance(choice[&#39;$ref&#39;], str)</span>
<span class="gi">+                        choice = self.get_schema_from_definitions(JsonRef(choice[&#39;$ref&#39;])) or {}</span>
<span class="gi">+                    properties = choice.get(&#39;properties&#39;, {})</span>
<span class="gi">+                    if not isinstance(properties, dict) or alias not in properties:</span>
<span class="gi">+                        alias_is_present_on_all_choices = False</span>
<span class="gi">+                        break</span>
<span class="gi">+                if alias_is_present_on_all_choices:</span>
<span class="gi">+                    openapi_discriminator = alias</span>
<span class="gi">+                    break</span>
<span class="gi">+        return openapi_discriminator</span>
<span class="gi">+</span>
<span class="gi">+    def chain_schema(self, schema: core_schema.ChainSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a core_schema.ChainSchema.

<span class="w"> </span>        When generating a schema for validation, we return the validation JSON schema for the first step in the chain.
<span class="gu">@@ -649,10 +1220,10 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        step_index = 0 if self.mode == &#39;validation&#39; else -1  # use first step for validation, last for serialization</span>
<span class="gi">+        return self.generate_inner(schema[&#39;steps&#39;][step_index])</span>

<span class="gd">-    def lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that allows values matching either the lax schema or the
<span class="w"> </span>        strict schema.

<span class="gu">@@ -662,10 +1233,16 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: Need to read the default value off of model config or whatever</span>
<span class="gi">+        use_strict = schema.get(&#39;strict&#39;, False)  # TODO: replace this default False</span>
<span class="gi">+        # If your JSON schema fails to generate it is probably</span>
<span class="gi">+        # because one of the following two branches failed.</span>
<span class="gi">+        if use_strict:</span>
<span class="gi">+            return self.generate_inner(schema[&#39;strict_schema&#39;])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.generate_inner(schema[&#39;lax_schema&#39;])</span>

<span class="gd">-    def json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the
<span class="w"> </span>        Python schema.

<span class="gu">@@ -678,10 +1255,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.generate_inner(schema[&#39;json_schema&#39;])</span>

<span class="gd">-    def typed_dict_schema(self, schema: core_schema.TypedDictSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def typed_dict_schema(self, schema: core_schema.TypedDictSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a typed dict.

<span class="w"> </span>        Args:
<span class="gu">@@ -690,10 +1266,88 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        total = schema.get(&#39;total&#39;, True)</span>
<span class="gi">+        named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [</span>
<span class="gi">+            (name, self.field_is_required(field, total), field)</span>
<span class="gi">+            for name, field in schema[&#39;fields&#39;].items()</span>
<span class="gi">+            if self.field_is_present(field)</span>
<span class="gi">+        ]</span>
<span class="gi">+        if self.mode == &#39;serialization&#39;:</span>
<span class="gi">+            named_required_fields.extend(self._name_required_computed_fields(schema.get(&#39;computed_fields&#39;, [])))</span>
<span class="gi">+        cls = _get_typed_dict_cls(schema)</span>
<span class="gi">+        config = _get_typed_dict_config(cls)</span>
<span class="gi">+        with self._config_wrapper_stack.push(config):</span>
<span class="gi">+            json_schema = self._named_required_fields_schema(named_required_fields)</span>
<span class="gi">+</span>
<span class="gi">+        json_schema_extra = config.get(&#39;json_schema_extra&#39;)</span>
<span class="gi">+        extra = schema.get(&#39;extra_behavior&#39;)</span>
<span class="gi">+        if extra is None:</span>
<span class="gi">+            extra = config.get(&#39;extra&#39;, &#39;ignore&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if cls is not None:</span>
<span class="gi">+            title = config.get(&#39;title&#39;) or cls.__name__</span>
<span class="gi">+            json_schema = self._update_class_schema(json_schema, title, extra, cls, json_schema_extra)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if extra == &#39;forbid&#39;:</span>
<span class="gi">+                json_schema[&#39;additionalProperties&#39;] = False</span>
<span class="gi">+            elif extra == &#39;allow&#39;:</span>
<span class="gi">+                json_schema[&#39;additionalProperties&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def typed_dict_field_schema(self, schema: core_schema.TypedDictField</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _name_required_computed_fields(</span>
<span class="gi">+        computed_fields: list[ComputedField],</span>
<span class="gi">+    ) -&gt; list[tuple[str, bool, core_schema.ComputedField]]:</span>
<span class="gi">+        return [(field[&#39;property_name&#39;], True, field) for field in computed_fields]</span>
<span class="gi">+</span>
<span class="gi">+    def _named_required_fields_schema(</span>
<span class="gi">+        self, named_required_fields: Sequence[tuple[str, bool, CoreSchemaField]]</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="gi">+        properties: dict[str, JsonSchemaValue] = {}</span>
<span class="gi">+        required_fields: list[str] = []</span>
<span class="gi">+        for name, required, field in named_required_fields:</span>
<span class="gi">+            if self.by_alias:</span>
<span class="gi">+                name = self._get_alias_name(field, name)</span>
<span class="gi">+            try:</span>
<span class="gi">+                field_json_schema = self.generate_inner(field).copy()</span>
<span class="gi">+            except PydanticOmit:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if &#39;title&#39; not in field_json_schema and self.field_title_should_be_set(field):</span>
<span class="gi">+                title = self.get_title_from_name(name)</span>
<span class="gi">+                field_json_schema[&#39;title&#39;] = title</span>
<span class="gi">+            field_json_schema = self.handle_ref_overrides(field_json_schema)</span>
<span class="gi">+            properties[name] = field_json_schema</span>
<span class="gi">+            if required:</span>
<span class="gi">+                required_fields.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;object&#39;, &#39;properties&#39;: properties}</span>
<span class="gi">+        if required_fields:</span>
<span class="gi">+            json_schema[&#39;required&#39;] = required_fields</span>
<span class="gi">+        return json_schema</span>
<span class="gi">+</span>
<span class="gi">+    def _get_alias_name(self, field: CoreSchemaField, name: str) -&gt; str:</span>
<span class="gi">+        if field[&#39;type&#39;] == &#39;computed-field&#39;:</span>
<span class="gi">+            alias: Any = field.get(&#39;alias&#39;, name)</span>
<span class="gi">+        elif self.mode == &#39;validation&#39;:</span>
<span class="gi">+            alias = field.get(&#39;validation_alias&#39;, name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            alias = field.get(&#39;serialization_alias&#39;, name)</span>
<span class="gi">+        if isinstance(alias, str):</span>
<span class="gi">+            name = alias</span>
<span class="gi">+        elif isinstance(alias, list):</span>
<span class="gi">+            alias = cast(&#39;list[str] | str&#39;, alias)</span>
<span class="gi">+            for path in alias:</span>
<span class="gi">+                if isinstance(path, list) and len(path) == 1 and isinstance(path[0], str):</span>
<span class="gi">+                    # Use the first valid single-item string path; the code that constructs the alias array</span>
<span class="gi">+                    # should ensure the first such item is what belongs in the JSON schema</span>
<span class="gi">+                    name = path[0]</span>
<span class="gi">+                    break</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert_never(alias)</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def typed_dict_field_schema(self, schema: core_schema.TypedDictField) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a typed dict field.

<span class="w"> </span>        Args:
<span class="gu">@@ -702,10 +1356,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.generate_inner(schema[&#39;schema&#39;])</span>

<span class="gd">-    def dataclass_field_schema(self, schema: core_schema.DataclassField</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def dataclass_field_schema(self, schema: core_schema.DataclassField) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a dataclass field.

<span class="w"> </span>        Args:
<span class="gu">@@ -714,10 +1367,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.generate_inner(schema[&#39;schema&#39;])</span>

<span class="gd">-    def model_field_schema(self, schema: core_schema.ModelField</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def model_field_schema(self, schema: core_schema.ModelField) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a model field.

<span class="w"> </span>        Args:
<span class="gu">@@ -726,10 +1378,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.generate_inner(schema[&#39;schema&#39;])</span>

<span class="gd">-    def computed_field_schema(self, schema: core_schema.ComputedField</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def computed_field_schema(self, schema: core_schema.ComputedField) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a computed field.

<span class="w"> </span>        Args:
<span class="gu">@@ -738,9 +1389,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.generate_inner(schema[&#39;return_schema&#39;])</span>

<span class="gd">-    def model_schema(self, schema: core_schema.ModelSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def model_schema(self, schema: core_schema.ModelSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a model.

<span class="w"> </span>        Args:
<span class="gu">@@ -749,10 +1400,75 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # We do not use schema[&#39;model&#39;].model_json_schema() here</span>
<span class="gi">+        # because it could lead to inconsistent refs handling, etc.</span>
<span class="gi">+        cls = cast(&#39;type[BaseModel]&#39;, schema[&#39;cls&#39;])</span>
<span class="gi">+        config = cls.model_config</span>
<span class="gi">+        title = config.get(&#39;title&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        with self._config_wrapper_stack.push(config):</span>
<span class="gi">+            json_schema = self.generate_inner(schema[&#39;schema&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        json_schema_extra = config.get(&#39;json_schema_extra&#39;)</span>
<span class="gi">+        if cls.__pydantic_root_model__:</span>
<span class="gi">+            root_json_schema_extra = cls.model_fields[&#39;root&#39;].json_schema_extra</span>
<span class="gi">+            if json_schema_extra and root_json_schema_extra:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &#39;&quot;model_config[\&#39;json_schema_extra\&#39;]&quot; and &quot;Field.json_schema_extra&quot; on &quot;RootModel.root&quot;&#39;</span>
<span class="gi">+                    &#39; field must not be set simultaneously&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            if root_json_schema_extra:</span>
<span class="gi">+                json_schema_extra = root_json_schema_extra</span>
<span class="gi">+</span>
<span class="gi">+        json_schema = self._update_class_schema(json_schema, title, config.get(&#39;extra&#39;, None), cls, json_schema_extra)</span>
<span class="gi">+</span>
<span class="gi">+        return json_schema</span>
<span class="gi">+</span>
<span class="gi">+    def _update_class_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        json_schema: JsonSchemaValue,</span>
<span class="gi">+        title: str | None,</span>
<span class="gi">+        extra: Literal[&#39;allow&#39;, &#39;ignore&#39;, &#39;forbid&#39;] | None,</span>
<span class="gi">+        cls: type[Any],</span>
<span class="gi">+        json_schema_extra: JsonDict | JsonSchemaExtraCallable | None,</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="gi">+        if &#39;$ref&#39; in json_schema:</span>
<span class="gi">+            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema[&#39;$ref&#39;])) or json_schema</span>
<span class="gi">+        else:</span>
<span class="gi">+            schema_to_update = json_schema</span>
<span class="gi">+</span>
<span class="gi">+        if title is not None:</span>
<span class="gi">+            # referenced_schema[&#39;title&#39;] = title</span>
<span class="gi">+            schema_to_update.setdefault(&#39;title&#39;, title)</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;additionalProperties&#39; not in schema_to_update:</span>
<span class="gi">+            if extra == &#39;allow&#39;:</span>
<span class="gi">+                schema_to_update[&#39;additionalProperties&#39;] = True</span>
<span class="gi">+            elif extra == &#39;forbid&#39;:</span>
<span class="gi">+                schema_to_update[&#39;additionalProperties&#39;] = False</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(json_schema_extra, (staticmethod, classmethod)):</span>
<span class="gi">+            # In older versions of python, this is necessary to ensure staticmethod/classmethods are callable</span>
<span class="gi">+            json_schema_extra = json_schema_extra.__get__(cls)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(json_schema_extra, dict):</span>
<span class="gi">+            schema_to_update.update(json_schema_extra)</span>
<span class="gi">+        elif callable(json_schema_extra):</span>
<span class="gi">+            if len(inspect.signature(json_schema_extra).parameters) &gt; 1:</span>
<span class="gi">+                json_schema_extra(schema_to_update, cls)  # type: ignore</span>
<span class="gi">+            else:</span>
<span class="gi">+                json_schema_extra(schema_to_update)  # type: ignore</span>
<span class="gi">+        elif json_schema_extra is not None:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&quot;model_config[&#39;json_schema_extra&#39;]={json_schema_extra} should be a dict, callable, or None&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(cls, &#39;__deprecated__&#39;):</span>
<span class="gi">+            json_schema[&#39;deprecated&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def resolve_schema_to_update(self, json_schema: JsonSchemaValue</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def resolve_schema_to_update(self, json_schema: JsonSchemaValue) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -761,10 +1477,16 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The resolved schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;$ref&#39; in json_schema:</span>
<span class="gi">+            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema[&#39;$ref&#39;]))</span>
<span class="gi">+            if schema_to_update is None:</span>
<span class="gi">+                raise RuntimeError(f&#39;Cannot update undefined schema for $ref={json_schema[&quot;$ref&quot;]}&#39;)</span>
<span class="gi">+            return self.resolve_schema_to_update(schema_to_update)</span>
<span class="gi">+        else:</span>
<span class="gi">+            schema_to_update = json_schema</span>
<span class="gi">+        return schema_to_update</span>

<span class="gd">-    def model_fields_schema(self, schema: core_schema.ModelFieldsSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def model_fields_schema(self, schema: core_schema.ModelFieldsSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a model&#39;s fields.

<span class="w"> </span>        Args:
<span class="gu">@@ -773,9 +1495,21 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [</span>
<span class="gi">+            (name, self.field_is_required(field, total=True), field)</span>
<span class="gi">+            for name, field in schema[&#39;fields&#39;].items()</span>
<span class="gi">+            if self.field_is_present(field)</span>
<span class="gi">+        ]</span>
<span class="gi">+        if self.mode == &#39;serialization&#39;:</span>
<span class="gi">+            named_required_fields.extend(self._name_required_computed_fields(schema.get(&#39;computed_fields&#39;, [])))</span>
<span class="gi">+        json_schema = self._named_required_fields_schema(named_required_fields)</span>
<span class="gi">+        extras_schema = schema.get(&#39;extras_schema&#39;, None)</span>
<span class="gi">+        if extras_schema is not None:</span>
<span class="gi">+            schema_to_update = self.resolve_schema_to_update(json_schema)</span>
<span class="gi">+            schema_to_update[&#39;additionalProperties&#39;] = self.generate_inner(extras_schema)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def field_is_present(self, field: CoreSchemaField) -&gt;bool:</span>
<span class="gi">+    def field_is_present(self, field: CoreSchemaField) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether the field should be included in the generated JSON schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -784,11 +1518,20 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            `True` if the field should be included in the generated JSON schema, `False` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.mode == &#39;serialization&#39;:</span>
<span class="gi">+            # If you still want to include the field in the generated JSON schema,</span>
<span class="gi">+            # override this method and return True</span>
<span class="gi">+            return not field.get(&#39;serialization_exclude&#39;)</span>
<span class="gi">+        elif self.mode == &#39;validation&#39;:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert_never(self.mode)</span>

<span class="gd">-    def field_is_required(self, field: (core_schema.ModelField |</span>
<span class="gd">-        core_schema.DataclassField | core_schema.TypedDictField), total: bool</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def field_is_required(</span>
<span class="gi">+        self,</span>
<span class="gi">+        field: core_schema.ModelField | core_schema.DataclassField | core_schema.TypedDictField,</span>
<span class="gi">+        total: bool,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether the field should be marked as required in the generated JSON schema.
<span class="w"> </span>        (Note that this is irrelevant if the field is not present in the JSON schema.).

<span class="gu">@@ -801,10 +1544,15 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            `True` if the field should be marked as required in the generated JSON schema, `False` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.mode == &#39;serialization&#39; and self._config.json_schema_serialization_defaults_required:</span>
<span class="gi">+            return not field.get(&#39;serialization_exclude&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if field[&#39;type&#39;] == &#39;typed-dict-field&#39;:</span>
<span class="gi">+                return field.get(&#39;required&#39;, total)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return field[&#39;schema&#39;][&#39;type&#39;] != &#39;default&#39;</span>

<span class="gd">-    def dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a dataclass&#39;s constructor arguments.

<span class="w"> </span>        Args:
<span class="gu">@@ -813,10 +1561,16 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [</span>
<span class="gi">+            (field[&#39;name&#39;], self.field_is_required(field, total=True), field)</span>
<span class="gi">+            for field in schema[&#39;fields&#39;]</span>
<span class="gi">+            if self.field_is_present(field)</span>
<span class="gi">+        ]</span>
<span class="gi">+        if self.mode == &#39;serialization&#39;:</span>
<span class="gi">+            named_required_fields.extend(self._name_required_computed_fields(schema.get(&#39;computed_fields&#39;, [])))</span>
<span class="gi">+        return self._named_required_fields_schema(named_required_fields)</span>

<span class="gd">-    def dataclass_schema(self, schema: core_schema.DataclassSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def dataclass_schema(self, schema: core_schema.DataclassSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a dataclass.

<span class="w"> </span>        Args:
<span class="gu">@@ -825,10 +1579,28 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls = schema[&#39;cls&#39;]</span>
<span class="gi">+        config: ConfigDict = getattr(cls, &#39;__pydantic_config__&#39;, cast(&#39;ConfigDict&#39;, {}))</span>
<span class="gi">+        title = config.get(&#39;title&#39;) or cls.__name__</span>
<span class="gi">+</span>
<span class="gi">+        with self._config_wrapper_stack.push(config):</span>
<span class="gi">+            json_schema = self.generate_inner(schema[&#39;schema&#39;]).copy()</span>
<span class="gi">+</span>
<span class="gi">+        json_schema_extra = config.get(&#39;json_schema_extra&#39;)</span>
<span class="gi">+        json_schema = self._update_class_schema(json_schema, title, config.get(&#39;extra&#39;, None), cls, json_schema_extra)</span>
<span class="gi">+</span>
<span class="gi">+        # Dataclass-specific handling of description</span>
<span class="gi">+        if is_dataclass(cls) and not hasattr(cls, &#39;__pydantic_validator__&#39;):</span>
<span class="gi">+            # vanilla dataclass; don&#39;t use cls.__doc__ as it will contain the class signature by default</span>
<span class="gi">+            description = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            description = None if cls.__doc__ is None else inspect.cleandoc(cls.__doc__)</span>
<span class="gi">+        if description:</span>
<span class="gi">+            json_schema[&#39;description&#39;] = description</span>
<span class="gi">+</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def arguments_schema(self, schema: core_schema.ArgumentsSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def arguments_schema(self, schema: core_schema.ArgumentsSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function&#39;s arguments.

<span class="w"> </span>        Args:
<span class="gu">@@ -837,11 +1609,37 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def kw_arguments_schema(self, arguments: list[core_schema.</span>
<span class="gd">-        ArgumentsParameter], var_kwargs_schema: (CoreSchema | None)</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+        metadata = _core_metadata.CoreMetadataHandler(schema).metadata</span>
<span class="gi">+        prefer_positional = metadata.get(&#39;pydantic_js_prefer_positional_arguments&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        arguments = schema[&#39;arguments_schema&#39;]</span>
<span class="gi">+        kw_only_arguments = [a for a in arguments if a.get(&#39;mode&#39;) == &#39;keyword_only&#39;]</span>
<span class="gi">+        kw_or_p_arguments = [a for a in arguments if a.get(&#39;mode&#39;) in {&#39;positional_or_keyword&#39;, None}]</span>
<span class="gi">+        p_only_arguments = [a for a in arguments if a.get(&#39;mode&#39;) == &#39;positional_only&#39;]</span>
<span class="gi">+        var_args_schema = schema.get(&#39;var_args_schema&#39;)</span>
<span class="gi">+        var_kwargs_schema = schema.get(&#39;var_kwargs_schema&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if prefer_positional:</span>
<span class="gi">+            positional_possible = not kw_only_arguments and not var_kwargs_schema</span>
<span class="gi">+            if positional_possible:</span>
<span class="gi">+                return self.p_arguments_schema(p_only_arguments + kw_or_p_arguments, var_args_schema)</span>
<span class="gi">+</span>
<span class="gi">+        keyword_possible = not p_only_arguments and not var_args_schema</span>
<span class="gi">+        if keyword_possible:</span>
<span class="gi">+            return self.kw_arguments_schema(kw_or_p_arguments + kw_only_arguments, var_kwargs_schema)</span>
<span class="gi">+</span>
<span class="gi">+        if not prefer_positional:</span>
<span class="gi">+            positional_possible = not kw_only_arguments and not var_kwargs_schema</span>
<span class="gi">+            if positional_possible:</span>
<span class="gi">+                return self.p_arguments_schema(p_only_arguments + kw_or_p_arguments, var_args_schema)</span>
<span class="gi">+</span>
<span class="gi">+        raise PydanticInvalidForJsonSchema(</span>
<span class="gi">+            &#39;Unable to generate JSON schema for arguments validator with positional-only and keyword-only arguments&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def kw_arguments_schema(</span>
<span class="gi">+        self, arguments: list[core_schema.ArgumentsParameter], var_kwargs_schema: CoreSchema | None</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function&#39;s keyword arguments.

<span class="w"> </span>        Args:
<span class="gu">@@ -850,11 +1648,35 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        properties: dict[str, JsonSchemaValue] = {}</span>
<span class="gi">+        required: list[str] = []</span>
<span class="gi">+        for argument in arguments:</span>
<span class="gi">+            name = self.get_argument_name(argument)</span>
<span class="gi">+            argument_schema = self.generate_inner(argument[&#39;schema&#39;]).copy()</span>
<span class="gi">+            argument_schema[&#39;title&#39;] = self.get_title_from_name(name)</span>
<span class="gi">+            properties[name] = argument_schema</span>
<span class="gi">+</span>
<span class="gi">+            if argument[&#39;schema&#39;][&#39;type&#39;] != &#39;default&#39;:</span>
<span class="gi">+                # This assumes that if the argument has a default value,</span>
<span class="gi">+                # the inner schema must be of type WithDefaultSchema.</span>
<span class="gi">+                # I believe this is true, but I am not 100% sure</span>
<span class="gi">+                required.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        json_schema: JsonSchemaValue = {&#39;type&#39;: &#39;object&#39;, &#39;properties&#39;: properties}</span>
<span class="gi">+        if required:</span>
<span class="gi">+            json_schema[&#39;required&#39;] = required</span>
<span class="gi">+</span>
<span class="gi">+        if var_kwargs_schema:</span>
<span class="gi">+            additional_properties_schema = self.generate_inner(var_kwargs_schema)</span>
<span class="gi">+            if additional_properties_schema:</span>
<span class="gi">+                json_schema[&#39;additionalProperties&#39;] = additional_properties_schema</span>
<span class="gi">+        else:</span>
<span class="gi">+            json_schema[&#39;additionalProperties&#39;] = False</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def p_arguments_schema(self, arguments: list[core_schema.</span>
<span class="gd">-        ArgumentsParameter], var_args_schema: (CoreSchema | None)</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def p_arguments_schema(</span>
<span class="gi">+        self, arguments: list[core_schema.ArgumentsParameter], var_args_schema: CoreSchema | None</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function&#39;s positional arguments.

<span class="w"> </span>        Args:
<span class="gu">@@ -863,10 +1685,36 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prefix_items: list[JsonSchemaValue] = []</span>
<span class="gi">+        min_items = 0</span>
<span class="gi">+</span>
<span class="gi">+        for argument in arguments:</span>
<span class="gi">+            name = self.get_argument_name(argument)</span>
<span class="gi">+</span>
<span class="gi">+            argument_schema = self.generate_inner(argument[&#39;schema&#39;]).copy()</span>
<span class="gi">+            argument_schema[&#39;title&#39;] = self.get_title_from_name(name)</span>
<span class="gi">+            prefix_items.append(argument_schema)</span>
<span class="gi">+</span>
<span class="gi">+            if argument[&#39;schema&#39;][&#39;type&#39;] != &#39;default&#39;:</span>
<span class="gi">+                # This assumes that if the argument has a default value,</span>
<span class="gi">+                # the inner schema must be of type WithDefaultSchema.</span>
<span class="gi">+                # I believe this is true, but I am not 100% sure</span>
<span class="gi">+                min_items += 1</span>
<span class="gi">+</span>
<span class="gi">+        json_schema: JsonSchemaValue = {&#39;type&#39;: &#39;array&#39;, &#39;prefixItems&#39;: prefix_items}</span>
<span class="gi">+        if min_items:</span>
<span class="gi">+            json_schema[&#39;minItems&#39;] = min_items</span>

<span class="gd">-    def get_argument_name(self, argument: core_schema.ArgumentsParameter</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+        if var_args_schema:</span>
<span class="gi">+            items_schema = self.generate_inner(var_args_schema)</span>
<span class="gi">+            if items_schema:</span>
<span class="gi">+                json_schema[&#39;items&#39;] = items_schema</span>
<span class="gi">+        else:</span>
<span class="gi">+            json_schema[&#39;maxItems&#39;] = len(prefix_items)</span>
<span class="gi">+</span>
<span class="gi">+        return json_schema</span>
<span class="gi">+</span>
<span class="gi">+    def get_argument_name(self, argument: core_schema.ArgumentsParameter) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieves the name of an argument.

<span class="w"> </span>        Args:
<span class="gu">@@ -875,9 +1723,16 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The name of the argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = argument[&#39;name&#39;]</span>
<span class="gi">+        if self.by_alias:</span>
<span class="gi">+            alias = argument.get(&#39;alias&#39;)</span>
<span class="gi">+            if isinstance(alias, str):</span>
<span class="gi">+                name = alias</span>
<span class="gi">+            else:</span>
<span class="gi">+                pass  # might want to do something else?</span>
<span class="gi">+        return name</span>

<span class="gd">-    def call_schema(self, schema: core_schema.CallSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def call_schema(self, schema: core_schema.CallSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a function call.

<span class="w"> </span>        Args:
<span class="gu">@@ -886,10 +1741,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.generate_inner(schema[&#39;arguments_schema&#39;])</span>

<span class="gd">-    def custom_error_schema(self, schema: core_schema.CustomErrorSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def custom_error_schema(self, schema: core_schema.CustomErrorSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a custom error.

<span class="w"> </span>        Args:
<span class="gu">@@ -898,9 +1752,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.generate_inner(schema[&#39;schema&#39;])</span>

<span class="gd">-    def json_schema(self, schema: core_schema.JsonSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def json_schema(self, schema: core_schema.JsonSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a JSON object.

<span class="w"> </span>        Args:
<span class="gu">@@ -909,9 +1763,15 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        content_core_schema = schema.get(&#39;schema&#39;) or core_schema.any_schema()</span>
<span class="gi">+        content_json_schema = self.generate_inner(content_core_schema)</span>
<span class="gi">+        if self.mode == &#39;validation&#39;:</span>
<span class="gi">+            return {&#39;type&#39;: &#39;string&#39;, &#39;contentMediaType&#39;: &#39;application/json&#39;, &#39;contentSchema&#39;: content_json_schema}</span>
<span class="gi">+        else:</span>
<span class="gi">+            # self.mode == &#39;serialization&#39;</span>
<span class="gi">+            return content_json_schema</span>

<span class="gd">-    def url_schema(self, schema: core_schema.UrlSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def url_schema(self, schema: core_schema.UrlSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a URL.

<span class="w"> </span>        Args:
<span class="gu">@@ -920,10 +1780,11 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;uri&#39;, &#39;minLength&#39;: 1}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def multi_host_url_schema(self, schema: core_schema.MultiHostUrlSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def multi_host_url_schema(self, schema: core_schema.MultiHostUrlSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts.

<span class="w"> </span>        Args:
<span class="gu">@@ -932,9 +1793,12 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Note: &#39;multi-host-uri&#39; is a custom/pydantic-specific format, not part of the JSON Schema spec</span>
<span class="gi">+        json_schema = {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;multi-host-uri&#39;, &#39;minLength&#39;: 1}</span>
<span class="gi">+        self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)</span>
<span class="gi">+        return json_schema</span>

<span class="gd">-    def uuid_schema(self, schema: core_schema.UuidSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def uuid_schema(self, schema: core_schema.UuidSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a UUID.

<span class="w"> </span>        Args:
<span class="gu">@@ -943,10 +1807,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;uuid&#39;}</span>

<span class="gd">-    def definitions_schema(self, schema: core_schema.DefinitionsSchema</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def definitions_schema(self, schema: core_schema.DefinitionsSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a JSON object with definitions.

<span class="w"> </span>        Args:
<span class="gu">@@ -955,10 +1818,16 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for definition in schema[&#39;definitions&#39;]:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.generate_inner(definition)</span>
<span class="gi">+            except PydanticInvalidForJsonSchema as e:</span>
<span class="gi">+                core_ref: CoreRef = CoreRef(definition[&#39;ref&#39;])  # type: ignore</span>
<span class="gi">+                self._core_defs_invalid_for_json_schema[self.get_defs_ref((core_ref, self.mode))] = e</span>
<span class="gi">+                continue</span>
<span class="gi">+        return self.generate_inner(schema[&#39;schema&#39;])</span>

<span class="gd">-    def definition_ref_schema(self, schema: core_schema.</span>
<span class="gd">-        DefinitionReferenceSchema) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def definition_ref_schema(self, schema: core_schema.DefinitionReferenceSchema) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that references a definition.

<span class="w"> </span>        Args:
<span class="gu">@@ -967,11 +1836,13 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        core_ref = CoreRef(schema[&#39;schema_ref&#39;])</span>
<span class="gi">+        _, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)</span>
<span class="gi">+        return ref_json_schema</span>

<span class="gd">-    def ser_schema(self, schema: (core_schema.SerSchema | core_schema.</span>
<span class="gd">-        IncExSeqSerSchema | core_schema.IncExDictSerSchema)) -&gt;(JsonSchemaValue</span>
<span class="gd">-         | None):</span>
<span class="gi">+    def ser_schema(</span>
<span class="gi">+        self, schema: core_schema.SerSchema | core_schema.IncExSeqSerSchema | core_schema.IncExDictSerSchema</span>
<span class="gi">+    ) -&gt; JsonSchemaValue | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema that matches a schema that defines a serialized object.

<span class="w"> </span>        Args:
<span class="gu">@@ -980,9 +1851,23 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The generated JSON schema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_title_from_name(self, name: str) -&gt;str:</span>
<span class="gi">+        schema_type = schema[&#39;type&#39;]</span>
<span class="gi">+        if schema_type == &#39;function-plain&#39; or schema_type == &#39;function-wrap&#39;:</span>
<span class="gi">+            # PlainSerializerFunctionSerSchema or WrapSerializerFunctionSerSchema</span>
<span class="gi">+            return_schema = schema.get(&#39;return_schema&#39;)</span>
<span class="gi">+            if return_schema is not None:</span>
<span class="gi">+                return self.generate_inner(return_schema)</span>
<span class="gi">+        elif schema_type == &#39;format&#39; or schema_type == &#39;to-string&#39;:</span>
<span class="gi">+            # FormatSerSchema or ToStringSerSchema</span>
<span class="gi">+            return self.str_schema(core_schema.str_schema())</span>
<span class="gi">+        elif schema[&#39;type&#39;] == &#39;model&#39;:</span>
<span class="gi">+            # ModelSerSchema</span>
<span class="gi">+            return self.generate_inner(schema[&#39;schema&#39;])</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # ### Utility methods</span>
<span class="gi">+</span>
<span class="gi">+    def get_title_from_name(self, name: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieves a title from a name.

<span class="w"> </span>        Args:
<span class="gu">@@ -991,9 +1876,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The title.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return name.title().replace(&#39;_&#39;, &#39; &#39;)</span>

<span class="gd">-    def field_title_should_be_set(self, schema: CoreSchemaOrField) -&gt;bool:</span>
<span class="gi">+    def field_title_should_be_set(self, schema: CoreSchemaOrField) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns true if a field with the given schema should have a title set based on the field name.

<span class="w"> </span>        Intuitively, we want this to return true for schemas that wouldn&#39;t otherwise provide their own title
<span class="gu">@@ -1005,9 +1890,30 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            `True` if the field should have a title set, `False` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if _core_utils.is_core_schema_field(schema):</span>
<span class="gi">+            if schema[&#39;type&#39;] == &#39;computed-field&#39;:</span>
<span class="gi">+                field_schema = schema[&#39;return_schema&#39;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                field_schema = schema[&#39;schema&#39;]</span>
<span class="gi">+            return self.field_title_should_be_set(field_schema)</span>
<span class="gi">+</span>
<span class="gi">+        elif _core_utils.is_core_schema(schema):</span>
<span class="gi">+            if schema.get(&#39;ref&#39;):  # things with refs, such as models and enums, should not have titles set</span>
<span class="gi">+                return False</span>
<span class="gi">+            if schema[&#39;type&#39;] in {&#39;default&#39;, &#39;nullable&#39;, &#39;definitions&#39;}:</span>
<span class="gi">+                return self.field_title_should_be_set(schema[&#39;schema&#39;])  # type: ignore[typeddict-item]</span>
<span class="gi">+            if _core_utils.is_function_with_inner_schema(schema):</span>
<span class="gi">+                return self.field_title_should_be_set(schema[&#39;schema&#39;])</span>
<span class="gi">+            if schema[&#39;type&#39;] == &#39;definition-ref&#39;:</span>
<span class="gi">+                # Referenced schemas should not have titles set for the same reason</span>
<span class="gi">+                # schemas with refs should not</span>
<span class="gi">+                return False</span>
<span class="gi">+            return True  # anything else should have title set</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticInvalidForJsonSchema(f&#39;Unexpected schema type: schema={schema}&#39;)  # pragma: no cover</span>

<span class="gd">-    def normalize_name(self, name: str) -&gt;str:</span>
<span class="gi">+    def normalize_name(self, name: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Normalizes a name to be used as a key in a dictionary.

<span class="w"> </span>        Args:
<span class="gu">@@ -1016,9 +1922,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The normalized name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return re.sub(r&#39;[^a-zA-Z0-9.\-_]&#39;, &#39;_&#39;, name).replace(&#39;.&#39;, &#39;__&#39;)</span>

<span class="gd">-    def get_defs_ref(self, core_mode_ref: CoreModeRef) -&gt;DefsRef:</span>
<span class="gi">+    def get_defs_ref(self, core_mode_ref: CoreModeRef) -&gt; DefsRef:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override this method to change the way that definitions keys are generated from a core reference.

<span class="w"> </span>        Args:
<span class="gu">@@ -1027,10 +1933,46 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The definitions key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_cache_defs_ref_schema(self, core_ref: CoreRef) -&gt;tuple[DefsRef,</span>
<span class="gd">-        JsonSchemaValue]:</span>
<span class="gi">+        # Split the core ref into &quot;components&quot;; generic origins and arguments are each separate components</span>
<span class="gi">+        core_ref, mode = core_mode_ref</span>
<span class="gi">+        components = re.split(r&#39;([\][,])&#39;, core_ref)</span>
<span class="gi">+        # Remove IDs from each component</span>
<span class="gi">+        components = [x.rsplit(&#39;:&#39;, 1)[0] for x in components]</span>
<span class="gi">+        core_ref_no_id = &#39;&#39;.join(components)</span>
<span class="gi">+        # Remove everything before the last period from each &quot;component&quot;</span>
<span class="gi">+        components = [re.sub(r&#39;(?:[^.[\]]+\.)+((?:[^.[\]]+))&#39;, r&#39;\1&#39;, x) for x in components]</span>
<span class="gi">+        short_ref = &#39;&#39;.join(components)</span>
<span class="gi">+</span>
<span class="gi">+        mode_title = _MODE_TITLE_MAPPING[mode]</span>
<span class="gi">+</span>
<span class="gi">+        # It is important that the generated defs_ref values be such that at least one choice will not</span>
<span class="gi">+        # be generated for any other core_ref. Currently, this should be the case because we include</span>
<span class="gi">+        # the id of the source type in the core_ref</span>
<span class="gi">+        name = DefsRef(self.normalize_name(short_ref))</span>
<span class="gi">+        name_mode = DefsRef(self.normalize_name(short_ref) + f&#39;-{mode_title}&#39;)</span>
<span class="gi">+        module_qualname = DefsRef(self.normalize_name(core_ref_no_id))</span>
<span class="gi">+        module_qualname_mode = DefsRef(f&#39;{module_qualname}-{mode_title}&#39;)</span>
<span class="gi">+        module_qualname_id = DefsRef(self.normalize_name(core_ref))</span>
<span class="gi">+        occurrence_index = self._collision_index.get(module_qualname_id)</span>
<span class="gi">+        if occurrence_index is None:</span>
<span class="gi">+            self._collision_counter[module_qualname] += 1</span>
<span class="gi">+            occurrence_index = self._collision_index[module_qualname_id] = self._collision_counter[module_qualname]</span>
<span class="gi">+</span>
<span class="gi">+        module_qualname_occurrence = DefsRef(f&#39;{module_qualname}__{occurrence_index}&#39;)</span>
<span class="gi">+        module_qualname_occurrence_mode = DefsRef(f&#39;{module_qualname_mode}__{occurrence_index}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        self._prioritized_defsref_choices[module_qualname_occurrence_mode] = [</span>
<span class="gi">+            name,</span>
<span class="gi">+            name_mode,</span>
<span class="gi">+            module_qualname,</span>
<span class="gi">+            module_qualname_mode,</span>
<span class="gi">+            module_qualname_occurrence,</span>
<span class="gi">+            module_qualname_occurrence_mode,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        return module_qualname_occurrence_mode</span>
<span class="gi">+</span>
<span class="gi">+    def get_cache_defs_ref_schema(self, core_ref: CoreRef) -&gt; tuple[DefsRef, JsonSchemaValue]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method wraps the get_defs_ref method with some cache-lookup/population logic,
<span class="w"> </span>        and returns both the produced defs_ref and the JSON schema that will refer to the right definition.

<span class="gu">@@ -1040,10 +1982,25 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A tuple of the definitions reference and the JSON schema that will refer to it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        core_mode_ref = (core_ref, self.mode)</span>
<span class="gi">+        maybe_defs_ref = self.core_to_defs_refs.get(core_mode_ref)</span>
<span class="gi">+        if maybe_defs_ref is not None:</span>
<span class="gi">+            json_ref = self.core_to_json_refs[core_mode_ref]</span>
<span class="gi">+            return maybe_defs_ref, {&#39;$ref&#39;: json_ref}</span>
<span class="gi">+</span>
<span class="gi">+        defs_ref = self.get_defs_ref(core_mode_ref)</span>
<span class="gi">+</span>
<span class="gi">+        # populate the ref translation mappings</span>
<span class="gi">+        self.core_to_defs_refs[core_mode_ref] = defs_ref</span>
<span class="gi">+        self.defs_to_core_refs[defs_ref] = core_mode_ref</span>

<span class="gd">-    def handle_ref_overrides(self, json_schema: JsonSchemaValue</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+        json_ref = JsonRef(self.ref_template.format(model=defs_ref))</span>
<span class="gi">+        self.core_to_json_refs[core_mode_ref] = json_ref</span>
<span class="gi">+        self.json_to_defs_refs[json_ref] = defs_ref</span>
<span class="gi">+        ref_json_schema = {&#39;$ref&#39;: json_ref}</span>
<span class="gi">+        return defs_ref, ref_json_schema</span>
<span class="gi">+</span>
<span class="gi">+    def handle_ref_overrides(self, json_schema: JsonSchemaValue) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;It is not valid for a schema with a top-level $ref to have sibling keys.

<span class="w"> </span>        During our own schema generation, we treat sibling keys as overrides to the referenced schema,
<span class="gu">@@ -1053,9 +2010,44 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        any remain, we transform the schema from a top-level &#39;$ref&#39; to use allOf to move the $ref out of the top level.
<span class="w"> </span>        (See bottom of https://swagger.io/docs/specification/using-ref/ for a reference about this behavior)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;$ref&#39; in json_schema:</span>
<span class="gi">+            # prevent modifications to the input; this copy may be safe to drop if there is significant overhead</span>
<span class="gi">+            json_schema = json_schema.copy()</span>
<span class="gi">+</span>
<span class="gi">+            referenced_json_schema = self.get_schema_from_definitions(JsonRef(json_schema[&#39;$ref&#39;]))</span>
<span class="gi">+            if referenced_json_schema is None:</span>
<span class="gi">+                # This can happen when building schemas for models with not-yet-defined references.</span>
<span class="gi">+                # It may be a good idea to do a recursive pass at the end of the generation to remove</span>
<span class="gi">+                # any redundant override keys.</span>
<span class="gi">+                if len(json_schema) &gt; 1:</span>
<span class="gi">+                    # Make it an allOf to at least resolve the sibling keys issue</span>
<span class="gi">+                    json_schema = json_schema.copy()</span>
<span class="gi">+                    json_schema.setdefault(&#39;allOf&#39;, [])</span>
<span class="gi">+                    json_schema[&#39;allOf&#39;].append({&#39;$ref&#39;: json_schema[&#39;$ref&#39;]})</span>
<span class="gi">+                    del json_schema[&#39;$ref&#39;]</span>
<span class="gi">+</span>
<span class="gi">+                return json_schema</span>
<span class="gi">+            for k, v in list(json_schema.items()):</span>
<span class="gi">+                if k == &#39;$ref&#39;:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if k in referenced_json_schema and referenced_json_schema[k] == v:</span>
<span class="gi">+                    del json_schema[k]  # redundant key</span>
<span class="gi">+            if len(json_schema) &gt; 1:</span>
<span class="gi">+                # There is a remaining &quot;override&quot; key, so we need to move $ref out of the top level</span>
<span class="gi">+                json_ref = JsonRef(json_schema[&#39;$ref&#39;])</span>
<span class="gi">+                del json_schema[&#39;$ref&#39;]</span>
<span class="gi">+                assert &#39;allOf&#39; not in json_schema  # this should never happen, but just in case</span>
<span class="gi">+                json_schema[&#39;allOf&#39;] = [{&#39;$ref&#39;: json_ref}]</span>
<span class="gi">+</span>
<span class="gi">+        return json_schema</span>
<span class="gi">+</span>
<span class="gi">+    def get_schema_from_definitions(self, json_ref: JsonRef) -&gt; JsonSchemaValue | None:</span>
<span class="gi">+        def_ref = self.json_to_defs_refs[json_ref]</span>
<span class="gi">+        if def_ref in self._core_defs_invalid_for_json_schema:</span>
<span class="gi">+            raise self._core_defs_invalid_for_json_schema[def_ref]</span>
<span class="gi">+        return self.definitions.get(def_ref, None)</span>

<span class="gd">-    def encode_default(self, dft: Any) -&gt;Any:</span>
<span class="gi">+    def encode_default(self, dft: Any) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode a default value to a JSON-serializable value.

<span class="w"> </span>        This is used to encode default values for fields in the generated JSON schema.
<span class="gu">@@ -1066,10 +2058,27 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The encoded default value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def update_with_validations(self, json_schema: JsonSchemaValue,</span>
<span class="gd">-        core_schema: CoreSchema, mapping: dict[str, str]) -&gt;None:</span>
<span class="gi">+        from .type_adapter import TypeAdapter, _type_has_config</span>
<span class="gi">+</span>
<span class="gi">+        config = self._config</span>
<span class="gi">+        try:</span>
<span class="gi">+            default = (</span>
<span class="gi">+                dft</span>
<span class="gi">+                if _type_has_config(type(dft))</span>
<span class="gi">+                else TypeAdapter(type(dft), config=config.config_dict).dump_python(dft, mode=&#39;json&#39;)</span>
<span class="gi">+            )</span>
<span class="gi">+        except PydanticSchemaGenerationError:</span>
<span class="gi">+            raise pydantic_core.PydanticSerializationError(f&#39;Unable to encode default value {dft}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return pydantic_core.to_jsonable_python(</span>
<span class="gi">+            default,</span>
<span class="gi">+            timedelta_mode=config.ser_json_timedelta,</span>
<span class="gi">+            bytes_mode=config.ser_json_bytes,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def update_with_validations(</span>
<span class="gi">+        self, json_schema: JsonSchemaValue, core_schema: CoreSchema, mapping: dict[str, str]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update the json_schema with the corresponding validations specified in the core_schema,
<span class="w"> </span>        using the provided mapping to translate keys in core_schema to the appropriate keys for a JSON schema.

<span class="gu">@@ -1078,8 +2087,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>            core_schema: The core schema to get the validations from.
<span class="w"> </span>            mapping: A mapping from core_schema attribute names to the corresponding JSON schema attribute names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        for core_key, json_schema_key in mapping.items():</span>
<span class="gi">+            if core_key in core_schema:</span>
<span class="gi">+                json_schema[json_schema_key] = core_schema[core_key]</span>

<span class="w"> </span>    class ValidationsMapping:
<span class="w"> </span>        &quot;&quot;&quot;This class just contains mappings from core_schema attribute names to the corresponding
<span class="gu">@@ -1087,27 +2097,88 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        principle override this class in a subclass of GenerateJsonSchema (by inheriting from
<span class="w"> </span>        GenerateJsonSchema.ValidationsMapping) to change these mappings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        numeric = {&#39;multiple_of&#39;: &#39;multipleOf&#39;, &#39;le&#39;: &#39;maximum&#39;, &#39;ge&#39;:</span>
<span class="gd">-            &#39;minimum&#39;, &#39;lt&#39;: &#39;exclusiveMaximum&#39;, &#39;gt&#39;: &#39;exclusiveMinimum&#39;}</span>
<span class="gd">-        bytes = {&#39;min_length&#39;: &#39;minLength&#39;, &#39;max_length&#39;: &#39;maxLength&#39;}</span>
<span class="gd">-        string = {&#39;min_length&#39;: &#39;minLength&#39;, &#39;max_length&#39;: &#39;maxLength&#39;,</span>
<span class="gd">-            &#39;pattern&#39;: &#39;pattern&#39;}</span>
<span class="gd">-        array = {&#39;min_length&#39;: &#39;minItems&#39;, &#39;max_length&#39;: &#39;maxItems&#39;}</span>
<span class="gd">-        object = {&#39;min_length&#39;: &#39;minProperties&#39;, &#39;max_length&#39;: &#39;maxProperties&#39;}</span>
<span class="gd">-        date = {&#39;le&#39;: &#39;maximum&#39;, &#39;ge&#39;: &#39;minimum&#39;, &#39;lt&#39;: &#39;exclusiveMaximum&#39;,</span>
<span class="gd">-            &#39;gt&#39;: &#39;exclusiveMinimum&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def get_json_ref_counts(self, json_schema: JsonSchemaValue) -&gt;dict[</span>
<span class="gd">-        JsonRef, int]:</span>
<span class="gd">-        &quot;&quot;&quot;Get all values corresponding to the key &#39;$ref&#39; anywhere in the json_schema.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>

<span class="gd">-    def emit_warning(self, kind: JsonSchemaWarningKind, detail: str) -&gt;None:</span>
<span class="gi">+        numeric = {</span>
<span class="gi">+            &#39;multiple_of&#39;: &#39;multipleOf&#39;,</span>
<span class="gi">+            &#39;le&#39;: &#39;maximum&#39;,</span>
<span class="gi">+            &#39;ge&#39;: &#39;minimum&#39;,</span>
<span class="gi">+            &#39;lt&#39;: &#39;exclusiveMaximum&#39;,</span>
<span class="gi">+            &#39;gt&#39;: &#39;exclusiveMinimum&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+        bytes = {</span>
<span class="gi">+            &#39;min_length&#39;: &#39;minLength&#39;,</span>
<span class="gi">+            &#39;max_length&#39;: &#39;maxLength&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+        string = {</span>
<span class="gi">+            &#39;min_length&#39;: &#39;minLength&#39;,</span>
<span class="gi">+            &#39;max_length&#39;: &#39;maxLength&#39;,</span>
<span class="gi">+            &#39;pattern&#39;: &#39;pattern&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+        array = {</span>
<span class="gi">+            &#39;min_length&#39;: &#39;minItems&#39;,</span>
<span class="gi">+            &#39;max_length&#39;: &#39;maxItems&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+        object = {</span>
<span class="gi">+            &#39;min_length&#39;: &#39;minProperties&#39;,</span>
<span class="gi">+            &#39;max_length&#39;: &#39;maxProperties&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+        date = {</span>
<span class="gi">+            &#39;le&#39;: &#39;maximum&#39;,</span>
<span class="gi">+            &#39;ge&#39;: &#39;minimum&#39;,</span>
<span class="gi">+            &#39;lt&#39;: &#39;exclusiveMaximum&#39;,</span>
<span class="gi">+            &#39;gt&#39;: &#39;exclusiveMinimum&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def get_flattened_anyof(self, schemas: list[JsonSchemaValue]) -&gt; JsonSchemaValue:</span>
<span class="gi">+        members = []</span>
<span class="gi">+        for schema in schemas:</span>
<span class="gi">+            if len(schema) == 1 and &#39;anyOf&#39; in schema:</span>
<span class="gi">+                members.extend(schema[&#39;anyOf&#39;])</span>
<span class="gi">+            else:</span>
<span class="gi">+                members.append(schema)</span>
<span class="gi">+        members = _deduplicate_schemas(members)</span>
<span class="gi">+        if len(members) == 1:</span>
<span class="gi">+            return members[0]</span>
<span class="gi">+        return {&#39;anyOf&#39;: members}</span>
<span class="gi">+</span>
<span class="gi">+    def get_json_ref_counts(self, json_schema: JsonSchemaValue) -&gt; dict[JsonRef, int]:</span>
<span class="gi">+        &quot;&quot;&quot;Get all values corresponding to the key &#39;$ref&#39; anywhere in the json_schema.&quot;&quot;&quot;</span>
<span class="gi">+        json_refs: dict[JsonRef, int] = Counter()</span>
<span class="gi">+</span>
<span class="gi">+        def _add_json_refs(schema: Any) -&gt; None:</span>
<span class="gi">+            if isinstance(schema, dict):</span>
<span class="gi">+                if &#39;$ref&#39; in schema:</span>
<span class="gi">+                    json_ref = JsonRef(schema[&#39;$ref&#39;])</span>
<span class="gi">+                    if not isinstance(json_ref, str):</span>
<span class="gi">+                        return  # in this case, &#39;$ref&#39; might have been the name of a property</span>
<span class="gi">+                    already_visited = json_ref in json_refs</span>
<span class="gi">+                    json_refs[json_ref] += 1</span>
<span class="gi">+                    if already_visited:</span>
<span class="gi">+                        return  # prevent recursion on a definition that was already visited</span>
<span class="gi">+                    defs_ref = self.json_to_defs_refs[json_ref]</span>
<span class="gi">+                    if defs_ref in self._core_defs_invalid_for_json_schema:</span>
<span class="gi">+                        raise self._core_defs_invalid_for_json_schema[defs_ref]</span>
<span class="gi">+                    _add_json_refs(self.definitions[defs_ref])</span>
<span class="gi">+</span>
<span class="gi">+                for v in schema.values():</span>
<span class="gi">+                    _add_json_refs(v)</span>
<span class="gi">+            elif isinstance(schema, list):</span>
<span class="gi">+                for v in schema:</span>
<span class="gi">+                    _add_json_refs(v)</span>
<span class="gi">+</span>
<span class="gi">+        _add_json_refs(json_schema)</span>
<span class="gi">+        return json_refs</span>
<span class="gi">+</span>
<span class="gi">+    def handle_invalid_for_json_schema(self, schema: CoreSchemaOrField, error_info: str) -&gt; JsonSchemaValue:</span>
<span class="gi">+        raise PydanticInvalidForJsonSchema(f&#39;Cannot generate a JsonSchema for {error_info}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def emit_warning(self, kind: JsonSchemaWarningKind, detail: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message = self.render_warning_message(kind, detail)</span>
<span class="gi">+        if message is not None:</span>
<span class="gi">+            warnings.warn(message, PydanticJsonSchemaWarning)</span>

<span class="gd">-    def render_warning_message(self, kind: JsonSchemaWarningKind, detail: str</span>
<span class="gd">-        ) -&gt;(str | None):</span>
<span class="gi">+    def render_warning_message(self, kind: JsonSchemaWarningKind, detail: str) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method is responsible for ignoring warnings as desired, and for formatting the warning messages.

<span class="w"> </span>        You can override the value of `ignored_warning_kinds` in a subclass of GenerateJsonSchema
<span class="gu">@@ -1124,13 +2195,45 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The formatted warning message, or `None` if no warning should be emitted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def model_json_schema(cls: (type[BaseModel] | type[PydanticDataclass]),</span>
<span class="gd">-    by_alias: bool=True, ref_template: str=DEFAULT_REF_TEMPLATE,</span>
<span class="gd">-    schema_generator: type[GenerateJsonSchema]=GenerateJsonSchema, mode:</span>
<span class="gd">-    JsonSchemaMode=&#39;validation&#39;) -&gt;dict[str, Any]:</span>
<span class="gi">+        if kind in self.ignored_warning_kinds:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return f&#39;{detail} [{kind}]&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def _build_definitions_remapping(self) -&gt; _DefinitionsRemapping:</span>
<span class="gi">+        defs_to_json: dict[DefsRef, JsonRef] = {}</span>
<span class="gi">+        for defs_refs in self._prioritized_defsref_choices.values():</span>
<span class="gi">+            for defs_ref in defs_refs:</span>
<span class="gi">+                json_ref = JsonRef(self.ref_template.format(model=defs_ref))</span>
<span class="gi">+                defs_to_json[defs_ref] = json_ref</span>
<span class="gi">+</span>
<span class="gi">+        return _DefinitionsRemapping.from_prioritized_choices(</span>
<span class="gi">+            self._prioritized_defsref_choices, defs_to_json, self.definitions</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _garbage_collect_definitions(self, schema: JsonSchemaValue) -&gt; None:</span>
<span class="gi">+        visited_defs_refs: set[DefsRef] = set()</span>
<span class="gi">+        unvisited_json_refs = _get_all_json_refs(schema)</span>
<span class="gi">+        while unvisited_json_refs:</span>
<span class="gi">+            next_json_ref = unvisited_json_refs.pop()</span>
<span class="gi">+            next_defs_ref = self.json_to_defs_refs[next_json_ref]</span>
<span class="gi">+            if next_defs_ref in visited_defs_refs:</span>
<span class="gi">+                continue</span>
<span class="gi">+            visited_defs_refs.add(next_defs_ref)</span>
<span class="gi">+            unvisited_json_refs.update(_get_all_json_refs(self.definitions[next_defs_ref]))</span>
<span class="gi">+</span>
<span class="gi">+        self.definitions = {k: v for k, v in self.definitions.items() if k in visited_defs_refs}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ##### Start JSON Schema Generation Functions #####</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def model_json_schema(</span>
<span class="gi">+    cls: type[BaseModel] | type[PydanticDataclass],</span>
<span class="gi">+    by_alias: bool = True,</span>
<span class="gi">+    ref_template: str = DEFAULT_REF_TEMPLATE,</span>
<span class="gi">+    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,</span>
<span class="gi">+    mode: JsonSchemaMode = &#39;validation&#39;,</span>
<span class="gi">+) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Utility function to generate a JSON Schema for a model.

<span class="w"> </span>    Args:
<span class="gu">@@ -1147,15 +2250,29 @@ def model_json_schema(cls: (type[BaseModel] | type[PydanticDataclass]),</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The generated JSON Schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from .main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)</span>

<span class="gi">+    if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema):</span>
<span class="gi">+        cls.__pydantic_core_schema__.rebuild()</span>

<span class="gd">-def models_json_schema(models: Sequence[tuple[type[BaseModel] | type[</span>
<span class="gd">-    PydanticDataclass], JsonSchemaMode]], *, by_alias: bool=True, title: (</span>
<span class="gd">-    str | None)=None, description: (str | None)=None, ref_template: str=</span>
<span class="gd">-    DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema]=</span>
<span class="gd">-    GenerateJsonSchema) -&gt;tuple[dict[tuple[type[BaseModel] | type[</span>
<span class="gd">-    PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:</span>
<span class="gi">+    if cls is BaseModel:</span>
<span class="gi">+        raise AttributeError(&#39;model_json_schema() must be called on a subclass of BaseModel, not BaseModel itself.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    assert not isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema), &#39;this is a bug! please report it&#39;</span>
<span class="gi">+    return schema_generator_instance.generate(cls.__pydantic_core_schema__, mode=mode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def models_json_schema(</span>
<span class="gi">+    models: Sequence[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode]],</span>
<span class="gi">+    *,</span>
<span class="gi">+    by_alias: bool = True,</span>
<span class="gi">+    title: str | None = None,</span>
<span class="gi">+    description: str | None = None,</span>
<span class="gi">+    ref_template: str = DEFAULT_REF_TEMPLATE,</span>
<span class="gi">+    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,</span>
<span class="gi">+) -&gt; tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Utility function to generate a JSON Schema for multiple models.

<span class="w"> </span>    Args:
<span class="gu">@@ -1174,11 +2291,64 @@ def models_json_schema(models: Sequence[tuple[type[BaseModel] | type[</span>
<span class="w"> </span>            - The second element is a JSON schema containing all definitions referenced in the first returned
<span class="w"> </span>                    element, along with the optional title and description keys.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for cls, _ in models:</span>
<span class="gi">+        if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema):</span>
<span class="gi">+            cls.__pydantic_core_schema__.rebuild()</span>
<span class="gi">+</span>
<span class="gi">+    instance = schema_generator(by_alias=by_alias, ref_template=ref_template)</span>
<span class="gi">+    inputs: list[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode, CoreSchema]] = [</span>
<span class="gi">+        (m, mode, m.__pydantic_core_schema__) for m, mode in models</span>
<span class="gi">+    ]</span>
<span class="gi">+    json_schemas_map, definitions = instance.generate_definitions(inputs)</span>
<span class="gi">+</span>
<span class="gi">+    json_schema: dict[str, Any] = {}</span>
<span class="gi">+    if definitions:</span>
<span class="gi">+        json_schema[&#39;$defs&#39;] = definitions</span>
<span class="gi">+    if title:</span>
<span class="gi">+        json_schema[&#39;title&#39;] = title</span>
<span class="gi">+    if description:</span>
<span class="gi">+        json_schema[&#39;description&#39;] = description</span>

<span class="gi">+    return json_schemas_map, json_schema</span>

<span class="gd">-_HashableJsonValue: TypeAlias = Union[int, float, str, bool, None, Tuple[</span>
<span class="gd">-    &#39;_HashableJsonValue&#39;, ...], Tuple[Tuple[str, &#39;_HashableJsonValue&#39;], ...]]</span>
<span class="gi">+</span>
<span class="gi">+# ##### End JSON Schema Generation Functions #####</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_HashableJsonValue: TypeAlias = Union[</span>
<span class="gi">+    int, float, str, bool, None, Tuple[&#39;_HashableJsonValue&#39;, ...], Tuple[Tuple[str, &#39;_HashableJsonValue&#39;], ...]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _deduplicate_schemas(schemas: Iterable[JsonDict]) -&gt; list[JsonDict]:</span>
<span class="gi">+    return list({_make_json_hashable(schema): schema for schema in schemas}.values())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_json_hashable(value: JsonValue) -&gt; _HashableJsonValue:</span>
<span class="gi">+    if isinstance(value, dict):</span>
<span class="gi">+        return tuple(sorted((k, _make_json_hashable(v)) for k, v in value.items()))</span>
<span class="gi">+    elif isinstance(value, list):</span>
<span class="gi">+        return tuple(_make_json_hashable(v) for v in value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sort_json_schema(value: JsonSchemaValue, parent_key: str | None = None) -&gt; JsonSchemaValue:</span>
<span class="gi">+    if isinstance(value, dict):</span>
<span class="gi">+        sorted_dict: dict[str, JsonSchemaValue] = {}</span>
<span class="gi">+        keys = value.keys()</span>
<span class="gi">+        if (parent_key != &#39;properties&#39;) and (parent_key != &#39;default&#39;):</span>
<span class="gi">+            keys = sorted(keys)</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+            sorted_dict[key] = _sort_json_schema(value[key], parent_key=key)</span>
<span class="gi">+        return sorted_dict</span>
<span class="gi">+    elif isinstance(value, list):</span>
<span class="gi">+        sorted_list: list[JsonSchemaValue] = []</span>
<span class="gi">+        for item in value:  # type: ignore</span>
<span class="gi">+            sorted_list.append(_sort_json_schema(item, parent_key))</span>
<span class="gi">+        return sorted_list  # type: ignore</span>
<span class="gi">+    else:</span>
<span class="gi">+        return value</span>


<span class="w"> </span>@dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -1195,20 +2365,23 @@ class WithJsonSchema:</span>
<span class="w"> </span>    If `mode` is set this will only apply to that schema generation mode, allowing you
<span class="w"> </span>    to set different json schemas for validation and serialization.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    json_schema: JsonSchemaValue | None
<span class="w"> </span>    mode: Literal[&#39;validation&#39;, &#39;serialization&#39;] | None = None

<span class="gd">-    def __get_pydantic_json_schema__(self, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        mode = self.mode or handler.mode
<span class="w"> </span>        if mode != handler.mode:
<span class="w"> </span>            return handler(core_schema)
<span class="w"> </span>        if self.json_schema is None:
<span class="gi">+            # This exception is handled in pydantic.json_schema.GenerateJsonSchema._named_required_fields_schema</span>
<span class="w"> </span>            raise PydanticOmit
<span class="w"> </span>        else:
<span class="w"> </span>            return self.json_schema

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(type(self.mode))


<span class="gu">@@ -1222,11 +2395,13 @@ class Examples:</span>
<span class="w"> </span>    If `mode` is set this will only apply to that schema generation mode,
<span class="w"> </span>    allowing you to add different examples for validation and serialization.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    examples: dict[str, Any]
<span class="w"> </span>    mode: Literal[&#39;validation&#39;, &#39;serialization&#39;] | None = None

<span class="gd">-    def __get_pydantic_json_schema__(self, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        mode = self.mode or handler.mode
<span class="w"> </span>        json_schema = handler(core_schema)
<span class="w"> </span>        if mode != handler.mode:
<span class="gu">@@ -1236,21 +2411,37 @@ class Examples:</span>
<span class="w"> </span>        json_schema[&#39;examples&#39;] = examples
<span class="w"> </span>        return json_schema

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(type(self.mode))


<span class="gd">-def _get_all_json_refs(item: Any) -&gt;set[JsonRef]:</span>
<span class="gi">+def _get_all_json_refs(item: Any) -&gt; set[JsonRef]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get all the definitions references from a JSON schema.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    refs: set[JsonRef] = set()</span>
<span class="gi">+    stack = [item]</span>
<span class="gi">+</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        current = stack.pop()</span>
<span class="gi">+        if isinstance(current, dict):</span>
<span class="gi">+            for key, value in current.items():</span>
<span class="gi">+                if key == &#39;$ref&#39; and isinstance(value, str):</span>
<span class="gi">+                    refs.add(JsonRef(value))</span>
<span class="gi">+                elif isinstance(value, dict):</span>
<span class="gi">+                    stack.append(value)</span>
<span class="gi">+                elif isinstance(value, list):</span>
<span class="gi">+                    stack.extend(value)</span>
<span class="gi">+        elif isinstance(current, list):</span>
<span class="gi">+            stack.extend(current)</span>
<span class="gi">+</span>
<span class="gi">+    return refs</span>


<span class="w"> </span>AnyType = TypeVar(&#39;AnyType&#39;)
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    SkipJsonSchema = Annotated[AnyType, ...]
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    @dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="w"> </span>    class SkipJsonSchema:
<span class="w"> </span>        &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/json_schema/#skipjsonschema-annotation
<span class="gu">@@ -1302,12 +2493,28 @@ else:</span>
<span class="w"> </span>            3. The entirety of the `c` field is omitted from the schema.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-        def __class_getitem__(cls, item: AnyType) -&gt;AnyType:</span>
<span class="gi">+        def __class_getitem__(cls, item: AnyType) -&gt; AnyType:</span>
<span class="w"> </span>            return Annotated[item, cls()]

<span class="gd">-        def __get_pydantic_json_schema__(self, core_schema: CoreSchema,</span>
<span class="gd">-            handler: GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+        def __get_pydantic_json_schema__(</span>
<span class="gi">+            self, core_schema: CoreSchema, handler: GetJsonSchemaHandler</span>
<span class="gi">+        ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>            raise PydanticOmit

<span class="gd">-        def __hash__(self) -&gt;int:</span>
<span class="gi">+        def __hash__(self) -&gt; int:</span>
<span class="w"> </span>            return hash(type(self))
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_typed_dict_cls(schema: core_schema.TypedDictSchema) -&gt; type[Any] | None:</span>
<span class="gi">+    metadata = _core_metadata.CoreMetadataHandler(schema).metadata</span>
<span class="gi">+    cls = metadata.get(&#39;pydantic_typed_dict_cls&#39;)</span>
<span class="gi">+    return cls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_typed_dict_config(cls: type[Any] | None) -&gt; ConfigDict:</span>
<span class="gi">+    if cls is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _decorators.get_attribute_from_bases(cls, &#39;__pydantic_config__&#39;)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    return {}</span>
<span class="gh">diff --git a/pydantic/main.py b/pydantic/main.py</span>
<span class="gh">index 0f604ce09..c40c818b4 100644</span>
<span class="gd">--- a/pydantic/main.py</span>
<span class="gi">+++ b/pydantic/main.py</span>
<span class="gu">@@ -1,17 +1,46 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Logic for creating models.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import operator
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="w"> </span>import typing
<span class="w"> </span>import warnings
<span class="w"> </span>from copy import copy, deepcopy
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, ClassVar, Dict, Generator, Literal, Set, Tuple, TypeVar, Union, cast, overload</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    ClassVar,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Literal,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    overload,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>import pydantic_core
<span class="w"> </span>import typing_extensions
<span class="w"> </span>from pydantic_core import PydanticUndefined
<span class="w"> </span>from typing_extensions import Self, TypeAlias, Unpack
<span class="gd">-from ._internal import _config, _decorators, _fields, _forward_ref, _generics, _mock_val_ser, _model_construction, _repr, _typing_extra, _utils</span>
<span class="gi">+</span>
<span class="gi">+from ._internal import (</span>
<span class="gi">+    _config,</span>
<span class="gi">+    _decorators,</span>
<span class="gi">+    _fields,</span>
<span class="gi">+    _forward_ref,</span>
<span class="gi">+    _generics,</span>
<span class="gi">+    _mock_val_ser,</span>
<span class="gi">+    _model_construction,</span>
<span class="gi">+    _repr,</span>
<span class="gi">+    _typing_extra,</span>
<span class="gi">+    _utils,</span>
<span class="gi">+)</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="w"> </span>from .aliases import AliasChoices, AliasPath
<span class="w"> </span>from .annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler
<span class="gu">@@ -20,21 +49,32 @@ from .errors import PydanticUndefinedAnnotation, PydanticUserError</span>
<span class="w"> </span>from .json_schema import DEFAULT_REF_TEMPLATE, GenerateJsonSchema, JsonSchemaMode, JsonSchemaValue, model_json_schema
<span class="w"> </span>from .plugin._schema_validator import PluggableSchemaValidator
<span class="w"> </span>from .warnings import PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="gi">+# Always define certain types that are needed to resolve method type hints/annotations</span>
<span class="gi">+# (even when not type checking) via typing.get_type_hints.</span>
<span class="w"> </span>ModelT = TypeVar(&#39;ModelT&#39;, bound=&#39;BaseModel&#39;)
<span class="w"> </span>TupleGenerator = Generator[Tuple[str, Any], None, None]
<span class="gd">-IncEx: TypeAlias = Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any],</span>
<span class="gd">-    None]</span>
<span class="gi">+# should be `set[int] | set[str] | dict[int, IncEx] | dict[str, IncEx] | None`, but mypy can&#39;t cope</span>
<span class="gi">+IncEx: TypeAlias = Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], None]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from inspect import Signature
<span class="w"> </span>    from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>    from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator
<span class="gi">+</span>
<span class="w"> </span>    from ._internal._utils import AbstractSetIntStr, MappingIntStrAny
<span class="w"> </span>    from .deprecated.parse import Protocol as DeprecatedParseProtocol
<span class="w"> </span>    from .fields import ComputedFieldInfo, FieldInfo, ModelPrivateAttr
<span class="w"> </span>    from .fields import PrivateAttr as _PrivateAttr
<span class="w"> </span>else:
<span class="gi">+    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
<span class="gi">+    # and https://youtrack.jetbrains.com/issue/PY-51428</span>
<span class="w"> </span>    DeprecationWarning = PydanticDeprecatedSince20
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;BaseModel&#39;, &#39;create_model&#39;
<span class="gi">+</span>
<span class="w"> </span>_object_setattr = _model_construction.object_setattr


<span class="gu">@@ -66,11 +106,19 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        __pydantic_fields_set__: An instance attribute with the names of fields explicitly set.
<span class="w"> </span>        __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="gi">+        # Here we provide annotations for the attributes of BaseModel.</span>
<span class="gi">+        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.</span>
<span class="gi">+        # However, for the sake of easy review, we have included type annotations of all class and instance attributes</span>
<span class="gi">+        # of `BaseModel` here:</span>
<span class="gi">+</span>
<span class="gi">+        # Class attributes</span>
<span class="w"> </span>        model_config: ClassVar[ConfigDict]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        model_fields: ClassVar[dict[str, FieldInfo]]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Metadata about the fields defined on the model,
<span class="gu">@@ -78,47 +126,61 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>

<span class="w"> </span>        This replaces `Model.__fields__` from Pydantic V1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]
<span class="w"> </span>        &quot;&quot;&quot;A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        __class_vars__: ClassVar[set[str]]
<span class="w"> </span>        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]
<span class="w"> </span>        __signature__: ClassVar[Signature]
<span class="gi">+</span>
<span class="w"> </span>        __pydantic_complete__: ClassVar[bool]
<span class="w"> </span>        __pydantic_core_schema__: ClassVar[CoreSchema]
<span class="w"> </span>        __pydantic_custom_init__: ClassVar[bool]
<span class="w"> </span>        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]
<span class="gd">-        __pydantic_generic_metadata__: ClassVar[_generics.</span>
<span class="gd">-            PydanticGenericMetadata]</span>
<span class="gi">+        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]</span>
<span class="w"> </span>        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]
<span class="w"> </span>        __pydantic_post_init__: ClassVar[None | Literal[&#39;model_post_init&#39;]]
<span class="w"> </span>        __pydantic_root_model__: ClassVar[bool]
<span class="w"> </span>        __pydantic_serializer__: ClassVar[SchemaSerializer]
<span class="gd">-        __pydantic_validator__: ClassVar[SchemaValidator |</span>
<span class="gd">-            PluggableSchemaValidator]</span>
<span class="gi">+        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]</span>
<span class="gi">+</span>
<span class="gi">+        # Instance attributes</span>
<span class="w"> </span>        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()
<span class="w"> </span>        __pydantic_fields_set__: set[str] = _PrivateAttr()
<span class="w"> </span>        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()
<span class="gi">+</span>
<span class="w"> </span>    else:
<span class="gi">+        # `model_fields` and `__pydantic_decorators__` must be set for</span>
<span class="gi">+        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation</span>
<span class="w"> </span>        model_fields = {}
<span class="w"> </span>        model_computed_fields = {}
<span class="gi">+</span>
<span class="w"> </span>        __pydantic_decorators__ = _decorators.DecoratorInfos()
<span class="w"> </span>        __pydantic_parent_namespace__ = None
<span class="gi">+        # Prevent `BaseModel` from being instantiated directly:</span>
<span class="w"> </span>        __pydantic_core_schema__ = _mock_val_ser.MockCoreSchema(
<span class="gd">-            &#39;Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly&#39;</span>
<span class="gd">-            , code=&#39;base-model-instantiated&#39;)</span>
<span class="gi">+            &#39;Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly&#39;,</span>
<span class="gi">+            code=&#39;base-model-instantiated&#39;,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        __pydantic_validator__ = _mock_val_ser.MockValSer(
<span class="gd">-            &#39;Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly&#39;</span>
<span class="gd">-            , val_or_ser=&#39;validator&#39;, code=&#39;base-model-instantiated&#39;)</span>
<span class="gi">+            &#39;Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly&#39;,</span>
<span class="gi">+            val_or_ser=&#39;validator&#39;,</span>
<span class="gi">+            code=&#39;base-model-instantiated&#39;,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        __pydantic_serializer__ = _mock_val_ser.MockValSer(
<span class="gd">-            &#39;Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly&#39;</span>
<span class="gd">-            , val_or_ser=&#39;serializer&#39;, code=&#39;base-model-instantiated&#39;)</span>
<span class="gd">-    __slots__ = (&#39;__dict__&#39;, &#39;__pydantic_fields_set__&#39;,</span>
<span class="gd">-        &#39;__pydantic_extra__&#39;, &#39;__pydantic_private__&#39;)</span>
<span class="gi">+            &#39;Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly&#39;,</span>
<span class="gi">+            val_or_ser=&#39;serializer&#39;,</span>
<span class="gi">+            code=&#39;base-model-instantiated&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = &#39;__dict__&#39;, &#39;__pydantic_fields_set__&#39;, &#39;__pydantic_extra__&#39;, &#39;__pydantic_private__&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    model_config = ConfigDict()
<span class="w"> </span>    __pydantic_complete__ = False
<span class="w"> </span>    __pydantic_root_model__ = False

<span class="gd">-    def __init__(self, /, **data: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, /, **data: Any) -&gt; None:  # type: ignore</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new model by parsing and validating input data from keyword arguments.

<span class="w"> </span>        Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
<span class="gu">@@ -126,32 +188,34 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>

<span class="w"> </span>        `self` is explicitly positional-only to allow `self` as a field name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks</span>
<span class="w"> </span>        __tracebackhide__ = True
<span class="w"> </span>        self.__pydantic_validator__.validate_python(data, self_instance=self)
<span class="gd">-    __init__.__pydantic_base_init__ = True</span>
<span class="gi">+</span>
<span class="gi">+    # The following line sets a flag that we use to determine when `__init__` gets overridden by the user</span>
<span class="gi">+    __init__.__pydantic_base_init__ = True  # pyright: ignore[reportFunctionMemberAccess]</span>

<span class="w"> </span>    @property
<span class="gd">-    def model_extra(self) -&gt;(dict[str, Any] | None):</span>
<span class="gi">+    def model_extra(self) -&gt; dict[str, Any] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get extra fields set during validation.

<span class="w"> </span>        Returns:
<span class="w"> </span>            A dictionary of extra fields, or `None` if `config.extra` is not set to `&quot;allow&quot;`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__pydantic_extra__</span>

<span class="w"> </span>    @property
<span class="gd">-    def model_fields_set(self) -&gt;set[str]:</span>
<span class="gi">+    def model_fields_set(self) -&gt; set[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the set of fields that have been explicitly set on this model instance.

<span class="w"> </span>        Returns:
<span class="w"> </span>            A set of strings representing the fields that have been set,
<span class="w"> </span>                i.e. that were not filled from defaults.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__pydantic_fields_set__</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def model_construct(cls, _fields_set: (set[str] | None)=None, **values: Any</span>
<span class="gd">-        ) -&gt;Self:</span>
<span class="gi">+    def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a new instance of the `Model` class with validated data.

<span class="w"> </span>        Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
<span class="gu">@@ -171,10 +235,67 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A new instance of the `Model` class with validated data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = cls.__new__(cls)</span>
<span class="gi">+        fields_values: dict[str, Any] = {}</span>
<span class="gi">+        fields_set = set()</span>
<span class="gi">+</span>
<span class="gi">+        for name, field in cls.model_fields.items():</span>
<span class="gi">+            if field.alias is not None and field.alias in values:</span>
<span class="gi">+                fields_values[name] = values.pop(field.alias)</span>
<span class="gi">+                fields_set.add(name)</span>
<span class="gi">+</span>
<span class="gi">+            if (name not in fields_set) and (field.validation_alias is not None):</span>
<span class="gi">+                validation_aliases: list[str | AliasPath] = (</span>
<span class="gi">+                    field.validation_alias.choices</span>
<span class="gi">+                    if isinstance(field.validation_alias, AliasChoices)</span>
<span class="gi">+                    else [field.validation_alias]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                for alias in validation_aliases:</span>
<span class="gi">+                    if isinstance(alias, str) and alias in values:</span>
<span class="gi">+                        fields_values[name] = values.pop(alias)</span>
<span class="gi">+                        fields_set.add(name)</span>
<span class="gi">+                        break</span>
<span class="gi">+                    elif isinstance(alias, AliasPath):</span>
<span class="gi">+                        value = alias.search_dict_for_path(values)</span>
<span class="gi">+                        if value is not PydanticUndefined:</span>
<span class="gi">+                            fields_values[name] = value</span>
<span class="gi">+                            fields_set.add(name)</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+            if name not in fields_set:</span>
<span class="gi">+                if name in values:</span>
<span class="gi">+                    fields_values[name] = values.pop(name)</span>
<span class="gi">+                    fields_set.add(name)</span>
<span class="gi">+                elif not field.is_required():</span>
<span class="gi">+                    fields_values[name] = field.get_default(call_default_factory=True)</span>
<span class="gi">+        if _fields_set is None:</span>
<span class="gi">+            _fields_set = fields_set</span>
<span class="gi">+</span>
<span class="gi">+        _extra: dict[str, Any] | None = (</span>
<span class="gi">+            {k: v for k, v in values.items()} if cls.model_config.get(&#39;extra&#39;) == &#39;allow&#39; else None</span>
<span class="gi">+        )</span>
<span class="gi">+        _object_setattr(m, &#39;__dict__&#39;, fields_values)</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, _fields_set)</span>
<span class="gi">+        if not cls.__pydantic_root_model__:</span>
<span class="gi">+            _object_setattr(m, &#39;__pydantic_extra__&#39;, _extra)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.__pydantic_post_init__:</span>
<span class="gi">+            m.model_post_init(None)</span>
<span class="gi">+            # update private attributes with values set</span>
<span class="gi">+            if hasattr(m, &#39;__pydantic_private__&#39;) and m.__pydantic_private__ is not None:</span>
<span class="gi">+                for k, v in values.items():</span>
<span class="gi">+                    if k in m.__private_attributes__:</span>
<span class="gi">+                        m.__pydantic_private__[k] = v</span>
<span class="gi">+</span>
<span class="gi">+        elif not cls.__pydantic_root_model__:</span>
<span class="gi">+            # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist</span>
<span class="gi">+            # Since it doesn&#39;t, that means that `__pydantic_private__` should be set to None</span>
<span class="gi">+            _object_setattr(m, &#39;__pydantic_private__&#39;, None)</span>

<span class="gd">-    def model_copy(self, *, update: (dict[str, Any] | None)=None, deep:</span>
<span class="gd">-        bool=False) -&gt;Self:</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    def model_copy(self, *, update: dict[str, Any] | None = None, deep: bool = False) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/serialization/#model_copy

<span class="w"> </span>        Returns a copy of the model.
<span class="gu">@@ -187,14 +308,36 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            New model instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def model_dump(self, *, mode: (Literal[&#39;json&#39;, &#39;python&#39;] | str)=</span>
<span class="gd">-        &#39;python&#39;, include: IncEx=None, exclude: IncEx=None, context: (Any |</span>
<span class="gd">-        None)=None, by_alias: bool=False, exclude_unset: bool=False,</span>
<span class="gd">-        exclude_defaults: bool=False, exclude_none: bool=False, round_trip:</span>
<span class="gd">-        bool=False, warnings: (bool | Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;])=</span>
<span class="gd">-        True, serialize_as_any: bool=False) -&gt;dict[str, Any]:</span>
<span class="gi">+        copied = self.__deepcopy__() if deep else self.__copy__()</span>
<span class="gi">+        if update:</span>
<span class="gi">+            if self.model_config.get(&#39;extra&#39;) == &#39;allow&#39;:</span>
<span class="gi">+                for k, v in update.items():</span>
<span class="gi">+                    if k in self.model_fields:</span>
<span class="gi">+                        copied.__dict__[k] = v</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if copied.__pydantic_extra__ is None:</span>
<span class="gi">+                            copied.__pydantic_extra__ = {}</span>
<span class="gi">+                        copied.__pydantic_extra__[k] = v</span>
<span class="gi">+            else:</span>
<span class="gi">+                copied.__dict__.update(update)</span>
<span class="gi">+            copied.__pydantic_fields_set__.update(update.keys())</span>
<span class="gi">+        return copied</span>
<span class="gi">+</span>
<span class="gi">+    def model_dump(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        mode: Literal[&#39;json&#39;, &#39;python&#39;] | str = &#39;python&#39;,</span>
<span class="gi">+        include: IncEx = None,</span>
<span class="gi">+        exclude: IncEx = None,</span>
<span class="gi">+        context: Any | None = None,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+        round_trip: bool = False,</span>
<span class="gi">+        warnings: bool | Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;] = True,</span>
<span class="gi">+        serialize_as_any: bool = False,</span>
<span class="gi">+    ) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/serialization/#modelmodel_dump

<span class="w"> </span>        Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
<span class="gu">@@ -218,14 +361,36 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A dictionary representation of the model.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def model_dump_json(self, *, indent: (int | None)=None, include: IncEx=</span>
<span class="gd">-        None, exclude: IncEx=None, context: (Any | None)=None, by_alias:</span>
<span class="gd">-        bool=False, exclude_unset: bool=False, exclude_defaults: bool=False,</span>
<span class="gd">-        exclude_none: bool=False, round_trip: bool=False, warnings: (bool |</span>
<span class="gd">-        Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;])=True, serialize_as_any: bool=False</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+        return self.__pydantic_serializer__.to_python(</span>
<span class="gi">+            self,</span>
<span class="gi">+            mode=mode,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none,</span>
<span class="gi">+            round_trip=round_trip,</span>
<span class="gi">+            warnings=warnings,</span>
<span class="gi">+            serialize_as_any=serialize_as_any,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def model_dump_json(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        indent: int | None = None,</span>
<span class="gi">+        include: IncEx = None,</span>
<span class="gi">+        exclude: IncEx = None,</span>
<span class="gi">+        context: Any | None = None,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+        round_trip: bool = False,</span>
<span class="gi">+        warnings: bool | Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;] = True,</span>
<span class="gi">+        serialize_as_any: bool = False,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/serialization/#modelmodel_dump_json

<span class="w"> </span>        Generates a JSON representation of the model using Pydantic&#39;s `to_json` method.
<span class="gu">@@ -247,13 +412,29 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A JSON string representation of the model.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__pydantic_serializer__.to_json(</span>
<span class="gi">+            self,</span>
<span class="gi">+            indent=indent,</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none,</span>
<span class="gi">+            round_trip=round_trip,</span>
<span class="gi">+            warnings=warnings,</span>
<span class="gi">+            serialize_as_any=serialize_as_any,</span>
<span class="gi">+        ).decode()</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def model_json_schema(cls, by_alias: bool=True, ref_template: str=</span>
<span class="gd">-        DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema]=</span>
<span class="gd">-        GenerateJsonSchema, mode: JsonSchemaMode=&#39;validation&#39;) -&gt;dict[str, Any</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def model_json_schema(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        by_alias: bool = True,</span>
<span class="gi">+        ref_template: str = DEFAULT_REF_TEMPLATE,</span>
<span class="gi">+        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,</span>
<span class="gi">+        mode: JsonSchemaMode = &#39;validation&#39;,</span>
<span class="gi">+    ) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a JSON schema for a model class.

<span class="w"> </span>        Args:
<span class="gu">@@ -266,10 +447,12 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The JSON schema for the given model class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return model_json_schema(</span>
<span class="gi">+            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt;str:</span>
<span class="gi">+    def model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compute the class name for parametrizations of generic classes.

<span class="w"> </span>        This method can be overridden to achieve a custom naming scheme for generic BaseModels.
<span class="gu">@@ -285,18 +468,31 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            TypeError: Raised when trying to generate concrete names for non-generic models.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not issubclass(cls, typing.Generic):</span>
<span class="gi">+            raise TypeError(&#39;Concrete names should only be generated for generic models.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Any strings received should represent forward references, so we handle them specially below.</span>
<span class="gi">+        # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,</span>
<span class="gi">+        # we may be able to remove this special case.</span>
<span class="gi">+        param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]</span>
<span class="gi">+        params_component = &#39;, &#39;.join(param_names)</span>
<span class="gi">+        return f&#39;{cls.__name__}[{params_component}]&#39;</span>

<span class="gd">-    def model_post_init(self, __context: Any) -&gt;None:</span>
<span class="gi">+    def model_post_init(self, __context: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override this method to perform additional initialization after `__init__` and `model_construct`.
<span class="w"> </span>        This is useful if you want to do some validation that requires the entire model to be initialized.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="w"> </span>    @classmethod
<span class="gd">-    def model_rebuild(cls, *, force: bool=False, raise_errors: bool=True,</span>
<span class="gd">-        _parent_namespace_depth: int=2, _types_namespace: (dict[str, Any] |</span>
<span class="gd">-        None)=None) -&gt;(bool | None):</span>
<span class="gi">+    def model_rebuild(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        *,</span>
<span class="gi">+        force: bool = False,</span>
<span class="gi">+        raise_errors: bool = True,</span>
<span class="gi">+        _parent_namespace_depth: int = 2,</span>
<span class="gi">+        _types_namespace: dict[str, Any] | None = None,</span>
<span class="gi">+    ) -&gt; bool | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to rebuild the pydantic-core schema for the model.

<span class="w"> </span>        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
<span class="gu">@@ -312,12 +508,47 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>            Returns `None` if the schema is already &quot;complete&quot; and rebuilding was not required.
<span class="w"> </span>            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not force and cls.__pydantic_complete__:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            if &#39;__pydantic_core_schema__&#39; in cls.__dict__:</span>
<span class="gi">+                delattr(cls, &#39;__pydantic_core_schema__&#39;)  # delete cached value to ensure full rebuild happens</span>
<span class="gi">+            if _types_namespace is not None:</span>
<span class="gi">+                types_namespace: dict[str, Any] | None = _types_namespace.copy()</span>
<span class="gi">+            else:</span>
<span class="gi">+                if _parent_namespace_depth &gt; 0:</span>
<span class="gi">+                    frame_parent_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth) or {}</span>
<span class="gi">+                    cls_parent_ns = (</span>
<span class="gi">+                        _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}</span>
<span class="gi">+                    )</span>
<span class="gi">+                    types_namespace = {**cls_parent_ns, **frame_parent_ns}</span>
<span class="gi">+                    cls.__pydantic_parent_namespace__ = _model_construction.build_lenient_weakvaluedict(types_namespace)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    types_namespace = _model_construction.unpack_lenient_weakvaluedict(</span>
<span class="gi">+                        cls.__pydantic_parent_namespace__</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                types_namespace = _typing_extra.get_cls_types_namespace(cls, types_namespace)</span>
<span class="gi">+</span>
<span class="gi">+            # manually override defer_build so complete_model_class doesn&#39;t skip building the model again</span>
<span class="gi">+            config = {**cls.model_config, &#39;defer_build&#39;: False}</span>
<span class="gi">+            return _model_construction.complete_model_class(</span>
<span class="gi">+                cls,</span>
<span class="gi">+                cls.__name__,</span>
<span class="gi">+                _config.ConfigWrapper(config, check=False),</span>
<span class="gi">+                raise_errors=raise_errors,</span>
<span class="gi">+                types_namespace=types_namespace,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def model_validate(cls, obj: Any, *, strict: (bool | None)=None,</span>
<span class="gd">-        from_attributes: (bool | None)=None, context: (Any | None)=None</span>
<span class="gd">-        ) -&gt;Self:</span>
<span class="gi">+    def model_validate(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        obj: Any,</span>
<span class="gi">+        *,</span>
<span class="gi">+        strict: bool | None = None,</span>
<span class="gi">+        from_attributes: bool | None = None,</span>
<span class="gi">+        context: Any | None = None,</span>
<span class="gi">+    ) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate a pydantic model instance.

<span class="w"> </span>        Args:
<span class="gu">@@ -332,11 +563,20 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The validated model instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks</span>
<span class="gi">+        __tracebackhide__ = True</span>
<span class="gi">+        return cls.__pydantic_validator__.validate_python(</span>
<span class="gi">+            obj, strict=strict, from_attributes=from_attributes, context=context</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def model_validate_json(cls, json_data: (str | bytes | bytearray), *,</span>
<span class="gd">-        strict: (bool | None)=None, context: (Any | None)=None) -&gt;Self:</span>
<span class="gi">+    def model_validate_json(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        json_data: str | bytes | bytearray,</span>
<span class="gi">+        *,</span>
<span class="gi">+        strict: bool | None = None,</span>
<span class="gi">+        context: Any | None = None,</span>
<span class="gi">+    ) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/json/#json-parsing

<span class="w"> </span>        Validate the given JSON data against the Pydantic model.
<span class="gu">@@ -352,11 +592,18 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            ValueError: If `json_data` is not a JSON string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks</span>
<span class="gi">+        __tracebackhide__ = True</span>
<span class="gi">+        return cls.__pydantic_validator__.validate_json(json_data, strict=strict, context=context)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def model_validate_strings(cls, obj: Any, *, strict: (bool | None)=None,</span>
<span class="gd">-        context: (Any | None)=None) -&gt;Self:</span>
<span class="gi">+    def model_validate_strings(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        obj: Any,</span>
<span class="gi">+        *,</span>
<span class="gi">+        strict: bool | None = None,</span>
<span class="gi">+        context: Any | None = None,</span>
<span class="gi">+    ) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate the given object with string data against the Pydantic model.

<span class="w"> </span>        Args:
<span class="gu">@@ -367,11 +614,12 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The validated Pydantic model.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks</span>
<span class="gi">+        __tracebackhide__ = True</span>
<span class="gi">+        return cls.__pydantic_validator__.validate_strings(obj, strict=strict, context=context)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler:</span>
<span class="gd">-        GetCoreSchemaHandler, /) -&gt;CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook into generating the model&#39;s CoreSchema.

<span class="w"> </span>        Args:
<span class="gu">@@ -382,16 +630,25 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A `pydantic-core` `CoreSchema`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # Only use the cached value from this _exact_ class; we don&#39;t want one from a parent class</span>
<span class="gi">+        # This is why we check `cls.__dict__` and don&#39;t use `cls.__pydantic_core_schema__` or similar.</span>
<span class="w"> </span>        schema = cls.__dict__.get(&#39;__pydantic_core_schema__&#39;)
<span class="gd">-        if schema is not None and not isinstance(schema, _mock_val_ser.</span>
<span class="gd">-            MockCoreSchema):</span>
<span class="gi">+        if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):</span>
<span class="gi">+            # Due to the way generic classes are built, it&#39;s possible that an invalid schema may be temporarily</span>
<span class="gi">+            # set on generic classes. I think we could resolve this to ensure that we get proper schema caching</span>
<span class="gi">+            # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin.</span>
<span class="w"> </span>            if not cls.__pydantic_generic_metadata__[&#39;origin&#39;]:
<span class="w"> </span>                return cls.__pydantic_core_schema__
<span class="gi">+</span>
<span class="w"> </span>        return handler(source)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_json_schema__(cls, core_schema: CoreSchema, handler:</span>
<span class="gd">-        GetJsonSchemaHandler, /) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        core_schema: CoreSchema,</span>
<span class="gi">+        handler: GetJsonSchemaHandler,</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook into generating the model&#39;s JSON schema.

<span class="w"> </span>        Args:
<span class="gu">@@ -412,7 +669,7 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        return handler(core_schema)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __pydantic_init_subclass__(cls, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
<span class="w"> </span>        only after the class is actually fully initialized. In particular, attributes like `model_fields` will
<span class="w"> </span>        be present when this is called.
<span class="gu">@@ -430,186 +687,205 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def __class_getitem__(cls, typevar_values: (type[Any] | tuple[type[Any],</span>
<span class="gd">-        ...])) -&gt;(type[BaseModel] | _forward_ref.PydanticRecursiveRef):</span>
<span class="gi">+    def __class_getitem__(</span>
<span class="gi">+        cls, typevar_values: type[Any] | tuple[type[Any], ...]</span>
<span class="gi">+    ) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:</span>
<span class="w"> </span>        cached = _generics.get_cached_generic_type_early(cls, typevar_values)
<span class="w"> </span>        if cached is not None:
<span class="w"> </span>            return cached
<span class="gi">+</span>
<span class="w"> </span>        if cls is BaseModel:
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                &#39;Type parameters should be placed on typing.Generic, not BaseModel&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise TypeError(&#39;Type parameters should be placed on typing.Generic, not BaseModel&#39;)</span>
<span class="w"> </span>        if not hasattr(cls, &#39;__parameters__&#39;):
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                f&#39;{cls} cannot be parametrized because it does not inherit from typing.Generic&#39;</span>
<span class="gd">-                )</span>
<span class="gd">-        if not cls.__pydantic_generic_metadata__[&#39;parameters&#39;</span>
<span class="gd">-            ] and typing.Generic not in cls.__bases__:</span>
<span class="gi">+            raise TypeError(f&#39;{cls} cannot be parametrized because it does not inherit from typing.Generic&#39;)</span>
<span class="gi">+        if not cls.__pydantic_generic_metadata__[&#39;parameters&#39;] and typing.Generic not in cls.__bases__:</span>
<span class="w"> </span>            raise TypeError(f&#39;{cls} is not a generic class&#39;)
<span class="gi">+</span>
<span class="w"> </span>        if not isinstance(typevar_values, tuple):
<span class="gd">-            typevar_values = typevar_values,</span>
<span class="gi">+            typevar_values = (typevar_values,)</span>
<span class="w"> </span>        _generics.check_parameters_count(cls, typevar_values)
<span class="gd">-        typevars_map: dict[_typing_extra.TypeVarType, type[Any]] = dict(zip</span>
<span class="gd">-            (cls.__pydantic_generic_metadata__[&#39;parameters&#39;], typevar_values))</span>
<span class="gd">-        if _utils.all_identical(typevars_map.keys(), typevars_map.values()</span>
<span class="gd">-            ) and typevars_map:</span>
<span class="gd">-            submodel = cls</span>
<span class="gi">+</span>
<span class="gi">+        # Build map from generic typevars to passed params</span>
<span class="gi">+        typevars_map: dict[_typing_extra.TypeVarType, type[Any]] = dict(</span>
<span class="gi">+            zip(cls.__pydantic_generic_metadata__[&#39;parameters&#39;], typevar_values)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:</span>
<span class="gi">+            submodel = cls  # if arguments are equal to parameters it&#39;s the same object</span>
<span class="w"> </span>            _generics.set_cached_generic_type(cls, typevar_values, submodel)
<span class="w"> </span>        else:
<span class="w"> </span>            parent_args = cls.__pydantic_generic_metadata__[&#39;args&#39;]
<span class="w"> </span>            if not parent_args:
<span class="w"> </span>                args = typevar_values
<span class="w"> </span>            else:
<span class="gd">-                args = tuple(_generics.replace_types(arg, typevars_map) for</span>
<span class="gd">-                    arg in parent_args)</span>
<span class="gi">+                args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)</span>
<span class="gi">+</span>
<span class="w"> </span>            origin = cls.__pydantic_generic_metadata__[&#39;origin&#39;] or cls
<span class="w"> </span>            model_name = origin.model_parametrized_name(args)
<span class="gd">-            params = tuple({param: None for param in _generics.</span>
<span class="gd">-                iter_contained_typevars(typevars_map.values())})</span>
<span class="gd">-            with _generics.generic_recursion_self_type(origin, args</span>
<span class="gd">-                ) as maybe_self_type:</span>
<span class="gi">+            params = tuple(</span>
<span class="gi">+                {param: None for param in _generics.iter_contained_typevars(typevars_map.values())}</span>
<span class="gi">+            )  # use dict as ordered set</span>
<span class="gi">+</span>
<span class="gi">+            with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:</span>
<span class="w"> </span>                if maybe_self_type is not None:
<span class="w"> </span>                    return maybe_self_type
<span class="gd">-                cached = _generics.get_cached_generic_type_late(cls,</span>
<span class="gd">-                    typevar_values, origin, args)</span>
<span class="gi">+</span>
<span class="gi">+                cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)</span>
<span class="w"> </span>                if cached is not None:
<span class="w"> </span>                    return cached
<span class="gi">+</span>
<span class="gi">+                # Attempt to rebuild the origin in case new types have been defined</span>
<span class="w"> </span>                try:
<span class="gi">+                    # depth 3 gets you above this __class_getitem__ call</span>
<span class="w"> </span>                    origin.model_rebuild(_parent_namespace_depth=3)
<span class="w"> </span>                except PydanticUndefinedAnnotation:
<span class="gi">+                    # It&#39;s okay if it fails, it just means there are still undefined types</span>
<span class="gi">+                    # that could be evaluated later.</span>
<span class="gi">+                    # TODO: Make sure validation fails if there are still undefined types, perhaps using MockValidator</span>
<span class="w"> </span>                    pass
<span class="gd">-                submodel = _generics.create_generic_submodel(model_name,</span>
<span class="gd">-                    origin, args, params)</span>
<span class="gd">-                _generics.set_cached_generic_type(cls, typevar_values,</span>
<span class="gd">-                    submodel, origin, args)</span>
<span class="gi">+</span>
<span class="gi">+                submodel = _generics.create_generic_submodel(model_name, origin, args, params)</span>
<span class="gi">+</span>
<span class="gi">+                # Update cache</span>
<span class="gi">+                _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)</span>
<span class="gi">+</span>
<span class="w"> </span>        return submodel

<span class="gd">-    def __copy__(self) -&gt;Self:</span>
<span class="gi">+    def __copy__(self) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a shallow copy of the model.&quot;&quot;&quot;
<span class="w"> </span>        cls = type(self)
<span class="w"> </span>        m = cls.__new__(cls)
<span class="w"> </span>        _object_setattr(m, &#39;__dict__&#39;, copy(self.__dict__))
<span class="w"> </span>        _object_setattr(m, &#39;__pydantic_extra__&#39;, copy(self.__pydantic_extra__))
<span class="gd">-        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, copy(self.</span>
<span class="gd">-            __pydantic_fields_set__))</span>
<span class="gd">-        if not hasattr(self, &#39;__pydantic_private__&#39;</span>
<span class="gd">-            ) or self.__pydantic_private__ is None:</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, copy(self.__pydantic_fields_set__))</span>
<span class="gi">+</span>
<span class="gi">+        if not hasattr(self, &#39;__pydantic_private__&#39;) or self.__pydantic_private__ is None:</span>
<span class="w"> </span>            _object_setattr(m, &#39;__pydantic_private__&#39;, None)
<span class="w"> </span>        else:
<span class="gd">-            _object_setattr(m, &#39;__pydantic_private__&#39;, {k: v for k, v in</span>
<span class="gd">-                self.__pydantic_private__.items() if v is not</span>
<span class="gd">-                PydanticUndefined})</span>
<span class="gi">+            _object_setattr(</span>
<span class="gi">+                m,</span>
<span class="gi">+                &#39;__pydantic_private__&#39;,</span>
<span class="gi">+                {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        return m

<span class="gd">-    def __deepcopy__(self, memo: (dict[int, Any] | None)=None) -&gt;Self:</span>
<span class="gi">+    def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a deep copy of the model.&quot;&quot;&quot;
<span class="w"> </span>        cls = type(self)
<span class="w"> </span>        m = cls.__new__(cls)
<span class="w"> </span>        _object_setattr(m, &#39;__dict__&#39;, deepcopy(self.__dict__, memo=memo))
<span class="gd">-        _object_setattr(m, &#39;__pydantic_extra__&#39;, deepcopy(self.</span>
<span class="gd">-            __pydantic_extra__, memo=memo))</span>
<span class="gd">-        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, copy(self.</span>
<span class="gd">-            __pydantic_fields_set__))</span>
<span class="gd">-        if not hasattr(self, &#39;__pydantic_private__&#39;</span>
<span class="gd">-            ) or self.__pydantic_private__ is None:</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_extra__&#39;, deepcopy(self.__pydantic_extra__, memo=memo))</span>
<span class="gi">+        # This next line doesn&#39;t need a deepcopy because __pydantic_fields_set__ is a set[str],</span>
<span class="gi">+        # and attempting a deepcopy would be marginally slower.</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, copy(self.__pydantic_fields_set__))</span>
<span class="gi">+</span>
<span class="gi">+        if not hasattr(self, &#39;__pydantic_private__&#39;) or self.__pydantic_private__ is None:</span>
<span class="w"> </span>            _object_setattr(m, &#39;__pydantic_private__&#39;, None)
<span class="w"> </span>        else:
<span class="gd">-            _object_setattr(m, &#39;__pydantic_private__&#39;, deepcopy({k: v for k,</span>
<span class="gd">-                v in self.__pydantic_private__.items() if v is not</span>
<span class="gd">-                PydanticUndefined}, memo=memo))</span>
<span class="gi">+            _object_setattr(</span>
<span class="gi">+                m,</span>
<span class="gi">+                &#39;__pydantic_private__&#39;,</span>
<span class="gi">+                deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        return m
<span class="gi">+</span>
<span class="w"> </span>    if not TYPE_CHECKING:
<span class="gi">+        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access</span>
<span class="gi">+        # The same goes for __setattr__ and __delattr__, see: https://github.com/pydantic/pydantic/issues/8643</span>

<span class="gd">-        def __getattr__(self, item: str) -&gt;Any:</span>
<span class="gd">-            private_attributes = object.__getattribute__(self,</span>
<span class="gd">-                &#39;__private_attributes__&#39;)</span>
<span class="gi">+        def __getattr__(self, item: str) -&gt; Any:</span>
<span class="gi">+            private_attributes = object.__getattribute__(self, &#39;__private_attributes__&#39;)</span>
<span class="w"> </span>            if item in private_attributes:
<span class="w"> </span>                attribute = private_attributes[item]
<span class="w"> </span>                if hasattr(attribute, &#39;__get__&#39;):
<span class="gd">-                    return attribute.__get__(self, type(self))</span>
<span class="gi">+                    return attribute.__get__(self, type(self))  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>                try:
<span class="gd">-                    return self.__pydantic_private__[item]</span>
<span class="gi">+                    # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items</span>
<span class="gi">+                    return self.__pydantic_private__[item]  # type: ignore</span>
<span class="w"> </span>                except KeyError as exc:
<span class="gd">-                    raise AttributeError(</span>
<span class="gd">-                        f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;</span>
<span class="gd">-                        ) from exc</span>
<span class="gi">+                    raise AttributeError(f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;) from exc</span>
<span class="w"> </span>            else:
<span class="gi">+                # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.</span>
<span class="gi">+                # See `BaseModel.__repr_args__` for more details</span>
<span class="w"> </span>                try:
<span class="gd">-                    pydantic_extra = object.__getattribute__(self,</span>
<span class="gd">-                        &#39;__pydantic_extra__&#39;)</span>
<span class="gi">+                    pydantic_extra = object.__getattribute__(self, &#39;__pydantic_extra__&#39;)</span>
<span class="w"> </span>                except AttributeError:
<span class="w"> </span>                    pydantic_extra = None
<span class="gi">+</span>
<span class="w"> </span>                if pydantic_extra:
<span class="w"> </span>                    try:
<span class="w"> </span>                        return pydantic_extra[item]
<span class="w"> </span>                    except KeyError as exc:
<span class="gd">-                        raise AttributeError(</span>
<span class="gd">-                            f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;</span>
<span class="gd">-                            ) from exc</span>
<span class="gd">-                elif hasattr(self.__class__, item):</span>
<span class="gd">-                    return super().__getattribute__(item)</span>
<span class="gi">+                        raise AttributeError(f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;) from exc</span>
<span class="w"> </span>                else:
<span class="gd">-                    raise AttributeError(</span>
<span class="gd">-                        f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;</span>
<span class="gd">-                        )</span>
<span class="gi">+                    if hasattr(self.__class__, item):</span>
<span class="gi">+                        return super().__getattribute__(item)  # Raises AttributeError if appropriate</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # this is the current error</span>
<span class="gi">+                        raise AttributeError(f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;)</span>

<span class="gd">-        def __setattr__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+        def __setattr__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>            if name in self.__class_vars__:
<span class="w"> </span>                raise AttributeError(
<span class="gd">-                    f&#39;{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    f&#39;{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. &#39;</span>
<span class="gi">+                    f&#39;If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.&#39;</span>
<span class="gi">+                )</span>
<span class="w"> </span>            elif not _fields.is_valid_field_name(name):
<span class="gd">-                if (self.__pydantic_private__ is None or name not in self.</span>
<span class="gd">-                    __private_attributes__):</span>
<span class="gi">+                if self.__pydantic_private__ is None or name not in self.__private_attributes__:</span>
<span class="w"> </span>                    _object_setattr(self, name, value)
<span class="w"> </span>                else:
<span class="w"> </span>                    attribute = self.__private_attributes__[name]
<span class="w"> </span>                    if hasattr(attribute, &#39;__set__&#39;):
<span class="gd">-                        attribute.__set__(self, value)</span>
<span class="gi">+                        attribute.__set__(self, value)  # type: ignore</span>
<span class="w"> </span>                    else:
<span class="w"> </span>                        self.__pydantic_private__[name] = value
<span class="w"> </span>                return
<span class="gi">+</span>
<span class="w"> </span>            self._check_frozen(name, value)
<span class="gi">+</span>
<span class="w"> </span>            attr = getattr(self.__class__, name, None)
<span class="w"> </span>            if isinstance(attr, property):
<span class="w"> </span>                attr.__set__(self, value)
<span class="w"> </span>            elif self.model_config.get(&#39;validate_assignment&#39;, None):
<span class="gd">-                self.__pydantic_validator__.validate_assignment(self, name,</span>
<span class="gd">-                    value)</span>
<span class="gd">-            elif self.model_config.get(&#39;extra&#39;</span>
<span class="gd">-                ) != &#39;allow&#39; and name not in self.model_fields:</span>
<span class="gd">-                raise ValueError(</span>
<span class="gd">-                    f&#39;&quot;{self.__class__.__name__}&quot; object has no field &quot;{name}&quot;&#39;</span>
<span class="gd">-                    )</span>
<span class="gd">-            elif self.model_config.get(&#39;extra&#39;</span>
<span class="gd">-                ) == &#39;allow&#39; and name not in self.model_fields:</span>
<span class="gi">+                self.__pydantic_validator__.validate_assignment(self, name, value)</span>
<span class="gi">+            elif self.model_config.get(&#39;extra&#39;) != &#39;allow&#39; and name not in self.model_fields:</span>
<span class="gi">+                # TODO - matching error</span>
<span class="gi">+                raise ValueError(f&#39;&quot;{self.__class__.__name__}&quot; object has no field &quot;{name}&quot;&#39;)</span>
<span class="gi">+            elif self.model_config.get(&#39;extra&#39;) == &#39;allow&#39; and name not in self.model_fields:</span>
<span class="w"> </span>                if self.model_extra and name in self.model_extra:
<span class="gd">-                    self.__pydantic_extra__[name] = value</span>
<span class="gi">+                    self.__pydantic_extra__[name] = value  # type: ignore</span>
<span class="w"> </span>                else:
<span class="w"> </span>                    try:
<span class="w"> </span>                        getattr(self, name)
<span class="w"> </span>                    except AttributeError:
<span class="gd">-                        self.__pydantic_extra__[name] = value</span>
<span class="gi">+                        # attribute does not already exist on instance, so put it in extra</span>
<span class="gi">+                        self.__pydantic_extra__[name] = value  # type: ignore</span>
<span class="w"> </span>                    else:
<span class="gi">+                        # attribute _does_ already exist on instance, and was not in extra, so update it</span>
<span class="w"> </span>                        _object_setattr(self, name, value)
<span class="w"> </span>            else:
<span class="w"> </span>                self.__dict__[name] = value
<span class="w"> </span>                self.__pydantic_fields_set__.add(name)

<span class="gd">-        def __delattr__(self, item: str) -&gt;Any:</span>
<span class="gi">+        def __delattr__(self, item: str) -&gt; Any:</span>
<span class="w"> </span>            if item in self.__private_attributes__:
<span class="w"> </span>                attribute = self.__private_attributes__[item]
<span class="w"> </span>                if hasattr(attribute, &#39;__delete__&#39;):
<span class="gd">-                    attribute.__delete__(self)</span>
<span class="gi">+                    attribute.__delete__(self)  # type: ignore</span>
<span class="w"> </span>                    return
<span class="gi">+</span>
<span class="w"> </span>                try:
<span class="gd">-                    del self.__pydantic_private__[item]</span>
<span class="gi">+                    # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items</span>
<span class="gi">+                    del self.__pydantic_private__[item]  # type: ignore</span>
<span class="w"> </span>                    return
<span class="w"> </span>                except KeyError as exc:
<span class="gd">-                    raise AttributeError(</span>
<span class="gd">-                        f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;</span>
<span class="gd">-                        ) from exc</span>
<span class="gi">+                    raise AttributeError(f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;) from exc</span>
<span class="gi">+</span>
<span class="w"> </span>            self._check_frozen(item, None)
<span class="gi">+</span>
<span class="w"> </span>            if item in self.model_fields:
<span class="w"> </span>                object.__delattr__(self, item)
<span class="w"> </span>            elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:
<span class="gu">@@ -618,60 +894,100 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>                try:
<span class="w"> </span>                    object.__delattr__(self, item)
<span class="w"> </span>                except AttributeError:
<span class="gd">-                    raise AttributeError(</span>
<span class="gd">-                        f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;</span>
<span class="gd">-                        )</span>
<span class="gi">+                    raise AttributeError(f&#39;{type(self).__name__!r} object has no attribute {item!r}&#39;)</span>

<span class="gd">-    def __getstate__(self) -&gt;dict[Any, Any]:</span>
<span class="gi">+    def _check_frozen(self, name: str, value: Any) -&gt; None:</span>
<span class="gi">+        if self.model_config.get(&#39;frozen&#39;, None):</span>
<span class="gi">+            typ = &#39;frozen_instance&#39;</span>
<span class="gi">+        elif getattr(self.model_fields.get(name), &#39;frozen&#39;, False):</span>
<span class="gi">+            typ = &#39;frozen_field&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+        error: pydantic_core.InitErrorDetails = {</span>
<span class="gi">+            &#39;type&#39;: typ,</span>
<span class="gi">+            &#39;loc&#39;: (name,),</span>
<span class="gi">+            &#39;input&#39;: value,</span>
<span class="gi">+        }</span>
<span class="gi">+        raise pydantic_core.ValidationError.from_exception_data(self.__class__.__name__, [error])</span>
<span class="gi">+</span>
<span class="gi">+    def __getstate__(self) -&gt; dict[Any, Any]:</span>
<span class="w"> </span>        private = self.__pydantic_private__
<span class="w"> </span>        if private:
<span class="gd">-            private = {k: v for k, v in private.items() if v is not</span>
<span class="gd">-                PydanticUndefined}</span>
<span class="gd">-        return {&#39;__dict__&#39;: self.__dict__, &#39;__pydantic_extra__&#39;: self.</span>
<span class="gd">-            __pydantic_extra__, &#39;__pydantic_fields_set__&#39;: self.</span>
<span class="gd">-            __pydantic_fields_set__, &#39;__pydantic_private__&#39;: private}</span>
<span class="gd">-</span>
<span class="gd">-    def __setstate__(self, state: dict[Any, Any]) -&gt;None:</span>
<span class="gd">-        _object_setattr(self, &#39;__pydantic_fields_set__&#39;, state.get(</span>
<span class="gd">-            &#39;__pydantic_fields_set__&#39;, {}))</span>
<span class="gd">-        _object_setattr(self, &#39;__pydantic_extra__&#39;, state.get(</span>
<span class="gd">-            &#39;__pydantic_extra__&#39;, {}))</span>
<span class="gd">-        _object_setattr(self, &#39;__pydantic_private__&#39;, state.get(</span>
<span class="gd">-            &#39;__pydantic_private__&#39;, {}))</span>
<span class="gi">+            private = {k: v for k, v in private.items() if v is not PydanticUndefined}</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;__dict__&#39;: self.__dict__,</span>
<span class="gi">+            &#39;__pydantic_extra__&#39;: self.__pydantic_extra__,</span>
<span class="gi">+            &#39;__pydantic_fields_set__&#39;: self.__pydantic_fields_set__,</span>
<span class="gi">+            &#39;__pydantic_private__&#39;: private,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def __setstate__(self, state: dict[Any, Any]) -&gt; None:</span>
<span class="gi">+        _object_setattr(self, &#39;__pydantic_fields_set__&#39;, state.get(&#39;__pydantic_fields_set__&#39;, {}))</span>
<span class="gi">+        _object_setattr(self, &#39;__pydantic_extra__&#39;, state.get(&#39;__pydantic_extra__&#39;, {}))</span>
<span class="gi">+        _object_setattr(self, &#39;__pydantic_private__&#39;, state.get(&#39;__pydantic_private__&#39;, {}))</span>
<span class="w"> </span>        _object_setattr(self, &#39;__dict__&#39;, state.get(&#39;__dict__&#39;, {}))
<span class="gi">+</span>
<span class="w"> </span>    if not TYPE_CHECKING:

<span class="gd">-        def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gi">+        def __eq__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>            if isinstance(other, BaseModel):
<span class="gd">-                self_type = self.__pydantic_generic_metadata__[&#39;origin&#39;</span>
<span class="gd">-                    ] or self.__class__</span>
<span class="gd">-                other_type = other.__pydantic_generic_metadata__[&#39;origin&#39;</span>
<span class="gd">-                    ] or other.__class__</span>
<span class="gd">-                if not (self_type == other_type and getattr(self,</span>
<span class="gd">-                    &#39;__pydantic_private__&#39;, None) == getattr(other,</span>
<span class="gd">-                    &#39;__pydantic_private__&#39;, None) and self.</span>
<span class="gd">-                    __pydantic_extra__ == other.__pydantic_extra__):</span>
<span class="gi">+                # When comparing instances of generic types for equality, as long as all field values are equal,</span>
<span class="gi">+                # only require their generic origin types to be equal, rather than exact type equality.</span>
<span class="gi">+                # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).</span>
<span class="gi">+                self_type = self.__pydantic_generic_metadata__[&#39;origin&#39;] or self.__class__</span>
<span class="gi">+                other_type = other.__pydantic_generic_metadata__[&#39;origin&#39;] or other.__class__</span>
<span class="gi">+</span>
<span class="gi">+                # Perform common checks first</span>
<span class="gi">+                if not (</span>
<span class="gi">+                    self_type == other_type</span>
<span class="gi">+                    and getattr(self, &#39;__pydantic_private__&#39;, None) == getattr(other, &#39;__pydantic_private__&#39;, None)</span>
<span class="gi">+                    and self.__pydantic_extra__ == other.__pydantic_extra__</span>
<span class="gi">+                ):</span>
<span class="w"> </span>                    return False
<span class="gi">+</span>
<span class="gi">+                # We only want to compare pydantic fields but ignoring fields is costly.</span>
<span class="gi">+                # We&#39;ll perform a fast check first, and fallback only when needed</span>
<span class="gi">+                # See GH-7444 and GH-7825 for rationale and a performance benchmark</span>
<span class="gi">+</span>
<span class="gi">+                # First, do the fast (and sometimes faulty) __dict__ comparison</span>
<span class="w"> </span>                if self.__dict__ == other.__dict__:
<span class="gi">+                    # If the check above passes, then pydantic fields are equal, we can return early</span>
<span class="w"> </span>                    return True
<span class="gi">+</span>
<span class="gi">+                # We don&#39;t want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return</span>
<span class="gi">+                # early if there are no keys to ignore (we would just return False later on anyway)</span>
<span class="w"> </span>                model_fields = type(self).model_fields.keys()
<span class="gd">-                if self.__dict__.keys(</span>
<span class="gd">-                    ) &lt;= model_fields and other.__dict__.keys(</span>
<span class="gd">-                    ) &lt;= model_fields:</span>
<span class="gi">+                if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:</span>
<span class="w"> </span>                    return False
<span class="gd">-                getter = operator.itemgetter(*model_fields</span>
<span class="gd">-                    ) if model_fields else lambda _: _utils._SENTINEL</span>
<span class="gi">+</span>
<span class="gi">+                # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore</span>
<span class="gi">+                # Resort to costly filtering of the __dict__ objects</span>
<span class="gi">+                # We use operator.itemgetter because it is much faster than dict comprehensions</span>
<span class="gi">+                # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an</span>
<span class="gi">+                # attribute and the model instance doesn&#39;t have a corresponding attribute, accessing the missing attribute</span>
<span class="gi">+                # raises an error in BaseModel.__getattr__ instead of returning the class attribute</span>
<span class="gi">+                # So we can use operator.itemgetter() instead of operator.attrgetter()</span>
<span class="gi">+                getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL</span>
<span class="w"> </span>                try:
<span class="w"> </span>                    return getter(self.__dict__) == getter(other.__dict__)
<span class="w"> </span>                except KeyError:
<span class="gi">+                    # In rare cases (such as when using the deprecated BaseModel.copy() method),</span>
<span class="gi">+                    # the __dict__ may not contain all model fields, which is how we can get here.</span>
<span class="gi">+                    # getter(self.__dict__) is much faster than any &#39;safe&#39; method that accounts</span>
<span class="gi">+                    # for missing keys, and wrapping it in a `try` doesn&#39;t slow things down much</span>
<span class="gi">+                    # in the common case.</span>
<span class="w"> </span>                    self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)
<span class="gd">-                    other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__</span>
<span class="gd">-                        )</span>
<span class="gd">-                    return getter(self_fields_proxy) == getter(</span>
<span class="gd">-                        other_fields_proxy)</span>
<span class="gi">+                    other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)</span>
<span class="gi">+                    return getter(self_fields_proxy) == getter(other_fields_proxy)</span>
<span class="gi">+</span>
<span class="gi">+            # other instance is not a BaseModel</span>
<span class="w"> </span>            else:
<span class="gd">-                return NotImplemented</span>
<span class="gi">+                return NotImplemented  # delegate to the other item in the comparison</span>
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="gi">+        # We put `__init_subclass__` in a TYPE_CHECKING block because, even though we want the type-checking benefits</span>
<span class="gi">+        # described in the signature of `__init_subclass__` below, we don&#39;t want to modify the default behavior of</span>
<span class="gi">+        # subclass initialization.</span>

<span class="w"> </span>        def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):
<span class="w"> </span>            &quot;&quot;&quot;This signature is included purely to help type-checkers check arguments to class declaration, which
<span class="gu">@@ -696,65 +1012,251 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>                *after* the class is fully initialized.
<span class="w"> </span>            &quot;&quot;&quot;

<span class="gd">-    def __iter__(self) -&gt;TupleGenerator:</span>
<span class="gi">+    def __iter__(self) -&gt; TupleGenerator:</span>
<span class="w"> </span>        &quot;&quot;&quot;So `dict(model)` works.&quot;&quot;&quot;
<span class="gd">-        yield from [(k, v) for k, v in self.__dict__.items() if not k.</span>
<span class="gd">-            startswith(&#39;_&#39;)]</span>
<span class="gi">+        yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith(&#39;_&#39;)]</span>
<span class="w"> </span>        extra = self.__pydantic_extra__
<span class="w"> </span>        if extra:
<span class="w"> </span>            yield from extra.items()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&quot;{self.__repr_name__()}({self.__repr_str__(&#39;, &#39;)})&quot;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&#39;{self.__repr_name__()}({self.__repr_str__(&quot;, &quot;)})&#39;</span>

<span class="gd">-    def __repr_args__(self) -&gt;_repr.ReprArgs:</span>
<span class="gi">+    def __repr_args__(self) -&gt; _repr.ReprArgs:</span>
<span class="w"> </span>        for k, v in self.__dict__.items():
<span class="w"> </span>            field = self.model_fields.get(k)
<span class="w"> </span>            if field and field.repr:
<span class="w"> </span>                yield k, v
<span class="gi">+</span>
<span class="gi">+        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.</span>
<span class="gi">+        # This can happen if a `ValidationError` is raised during initialization and the instance&#39;s</span>
<span class="gi">+        # repr is generated as part of the exception handling. Therefore, we use `getattr` here</span>
<span class="gi">+        # with a fallback, even though the type hints indicate the attribute will always be present.</span>
<span class="w"> </span>        try:
<span class="gd">-            pydantic_extra = object.__getattribute__(self, &#39;__pydantic_extra__&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            pydantic_extra = object.__getattribute__(self, &#39;__pydantic_extra__&#39;)</span>
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            pydantic_extra = None
<span class="gi">+</span>
<span class="w"> </span>        if pydantic_extra is not None:
<span class="w"> </span>            yield from ((k, v) for k, v in pydantic_extra.items())
<span class="gd">-        yield from ((k, getattr(self, k)) for k, v in self.</span>
<span class="gd">-            model_computed_fields.items() if v.repr)</span>
<span class="gi">+        yield from ((k, getattr(self, k)) for k, v in self.model_computed_fields.items() if v.repr)</span>
<span class="gi">+</span>
<span class="gi">+    # take logic from `_repr.Representation` without the side effects of inheritance, see #5740</span>
<span class="w"> </span>    __repr_name__ = _repr.Representation.__repr_name__
<span class="w"> </span>    __repr_str__ = _repr.Representation.__repr_str__
<span class="w"> </span>    __pretty__ = _repr.Representation.__pretty__
<span class="w"> </span>    __rich_repr__ = _repr.Representation.__rich_repr__

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.__repr_str__(&#39; &#39;)

<span class="gi">+    # ##### Deprecated methods from v1 #####</span>
<span class="w"> </span>    @property
<span class="w"> </span>    @typing_extensions.deprecated(
<span class="gd">-        &#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;</span>
<span class="gd">-        , category=None)</span>
<span class="gd">-    def __fields__(self) -&gt;dict[str, FieldInfo]:</span>
<span class="gi">+        &#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;, category=None</span>
<span class="gi">+    )</span>
<span class="gi">+    def __fields__(self) -&gt; dict[str, FieldInfo]:</span>
<span class="w"> </span>        warnings.warn(
<span class="gd">-            &#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;</span>
<span class="gd">-            , category=PydanticDeprecatedSince20)</span>
<span class="gi">+            &#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;, category=PydanticDeprecatedSince20</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return self.model_fields

<span class="w"> </span>    @property
<span class="w"> </span>    @typing_extensions.deprecated(
<span class="gd">-        &#39;The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.&#39;</span>
<span class="gd">-        , category=None)</span>
<span class="gd">-    def __fields_set__(self) -&gt;set[str]:</span>
<span class="gi">+        &#39;The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def __fields_set__(self) -&gt; set[str]:</span>
<span class="w"> </span>        warnings.warn(
<span class="gd">-            &#39;The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.&#39;</span>
<span class="gd">-            , category=PydanticDeprecatedSince20)</span>
<span class="gi">+            &#39;The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return self.__pydantic_fields_set__

<span class="gi">+    @typing_extensions.deprecated(&#39;The `dict` method is deprecated; use `model_dump` instead.&#39;, category=None)</span>
<span class="gi">+    def dict(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        include: IncEx = None,</span>
<span class="gi">+        exclude: IncEx = None,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:  # noqa UP006</span>
<span class="gi">+        warnings.warn(&#39;The `dict` method is deprecated; use `model_dump` instead.&#39;, category=PydanticDeprecatedSince20)</span>
<span class="gi">+        return self.model_dump(</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @typing_extensions.deprecated(&#39;The `json` method is deprecated; use `model_dump_json` instead.&#39;, category=None)</span>
<span class="gi">+    def json(  # noqa: D102</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        include: IncEx = None,</span>
<span class="gi">+        exclude: IncEx = None,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+        encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]</span>
<span class="gi">+        models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]</span>
<span class="gi">+        **dumps_kwargs: Any,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `json` method is deprecated; use `model_dump_json` instead.&#39;, category=PydanticDeprecatedSince20</span>
<span class="gi">+        )</span>
<span class="gi">+        if encoder is not PydanticUndefined:</span>
<span class="gi">+            raise TypeError(&#39;The `encoder` argument is no longer supported; use field serializers instead.&#39;)</span>
<span class="gi">+        if models_as_dict is not PydanticUndefined:</span>
<span class="gi">+            raise TypeError(&#39;The `models_as_dict` argument is no longer supported; use a model serializer instead.&#39;)</span>
<span class="gi">+        if dumps_kwargs:</span>
<span class="gi">+            raise TypeError(&#39;`dumps_kwargs` keyword arguments are no longer supported.&#39;)</span>
<span class="gi">+        return self.model_dump_json(</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(&#39;The `parse_obj` method is deprecated; use `model_validate` instead.&#39;, category=None)</span>
<span class="gi">+    def parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `parse_obj` method is deprecated; use `model_validate` instead.&#39;, category=PydanticDeprecatedSince20</span>
<span class="gi">+        )</span>
<span class="gi">+        return cls.model_validate(obj)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, &#39;</span>
<span class="gi">+        &#39;otherwise load the data then use `model_validate` instead.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def parse_raw(  # noqa: D102</span>
<span class="gi">+        cls,</span>
<span class="gi">+        b: str | bytes,</span>
<span class="gi">+        *,</span>
<span class="gi">+        content_type: str | None = None,</span>
<span class="gi">+        encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+        proto: DeprecatedParseProtocol | None = None,</span>
<span class="gi">+        allow_pickle: bool = False,</span>
<span class="gi">+    ) -&gt; Self:  # pragma: no cover</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, &#39;</span>
<span class="gi">+            &#39;otherwise load the data then use `model_validate` instead.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        from .deprecated import parse</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj = parse.load_str_bytes(</span>
<span class="gi">+                b,</span>
<span class="gi">+                proto=proto,</span>
<span class="gi">+                content_type=content_type,</span>
<span class="gi">+                encoding=encoding,</span>
<span class="gi">+                allow_pickle=allow_pickle,</span>
<span class="gi">+            )</span>
<span class="gi">+        except (ValueError, TypeError) as exc:</span>
<span class="gi">+            import json</span>
<span class="gi">+</span>
<span class="gi">+            # try to match V1</span>
<span class="gi">+            if isinstance(exc, UnicodeDecodeError):</span>
<span class="gi">+                type_str = &#39;value_error.unicodedecode&#39;</span>
<span class="gi">+            elif isinstance(exc, json.JSONDecodeError):</span>
<span class="gi">+                type_str = &#39;value_error.jsondecode&#39;</span>
<span class="gi">+            elif isinstance(exc, ValueError):</span>
<span class="gi">+                type_str = &#39;value_error&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                type_str = &#39;type_error&#39;</span>
<span class="gi">+</span>
<span class="gi">+            # ctx is missing here, but since we&#39;ve added `input` to the error, we&#39;re not pretending it&#39;s the same</span>
<span class="gi">+            error: pydantic_core.InitErrorDetails = {</span>
<span class="gi">+                # The type: ignore on the next line is to ignore the requirement of LiteralString</span>
<span class="gi">+                &#39;type&#39;: pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore</span>
<span class="gi">+                &#39;loc&#39;: (&#39;__root__&#39;,),</span>
<span class="gi">+                &#39;input&#39;: b,</span>
<span class="gi">+            }</span>
<span class="gi">+            raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])</span>
<span class="gi">+        return cls.model_validate(obj)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The `parse_file` method is deprecated; load the data from file, then if your data is JSON &#39;</span>
<span class="gi">+        &#39;use `model_validate_json`, otherwise `model_validate` instead.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def parse_file(  # noqa: D102</span>
<span class="gi">+        cls,</span>
<span class="gi">+        path: str | Path,</span>
<span class="gi">+        *,</span>
<span class="gi">+        content_type: str | None = None,</span>
<span class="gi">+        encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+        proto: DeprecatedParseProtocol | None = None,</span>
<span class="gi">+        allow_pickle: bool = False,</span>
<span class="gi">+    ) -&gt; Self:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `parse_file` method is deprecated; load the data from file, then if your data is JSON &#39;</span>
<span class="gi">+            &#39;use `model_validate_json`, otherwise `model_validate` instead.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        from .deprecated import parse</span>
<span class="gi">+</span>
<span class="gi">+        obj = parse.load_file(</span>
<span class="gi">+            path,</span>
<span class="gi">+            proto=proto,</span>
<span class="gi">+            content_type=content_type,</span>
<span class="gi">+            encoding=encoding,</span>
<span class="gi">+            allow_pickle=allow_pickle,</span>
<span class="gi">+        )</span>
<span class="gi">+        return cls.parse_obj(obj)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The `from_orm` method is deprecated; set &#39;</span>
<span class="gi">+        &quot;`model_config[&#39;from_attributes&#39;]=True` and use `model_validate` instead.&quot;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `from_orm` method is deprecated; set &#39;</span>
<span class="gi">+            &quot;`model_config[&#39;from_attributes&#39;]=True` and use `model_validate` instead.&quot;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        if not cls.model_config.get(&#39;from_attributes&#39;, None):</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;You must set the config attribute `from_attributes=True` to use from_orm&#39;, code=None</span>
<span class="gi">+            )</span>
<span class="gi">+        return cls.model_validate(obj)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(&#39;The `construct` method is deprecated; use `model_construct` instead.&#39;, category=None)</span>
<span class="gi">+    def construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `construct` method is deprecated; use `model_construct` instead.&#39;, category=PydanticDeprecatedSince20</span>
<span class="gi">+        )</span>
<span class="gi">+        return cls.model_construct(_fields_set=_fields_set, **values)</span>
<span class="gi">+</span>
<span class="w"> </span>    @typing_extensions.deprecated(
<span class="gd">-        &#39;The `copy` method is deprecated; use `model_copy` instead. See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.&#39;</span>
<span class="gd">-        , category=None)</span>
<span class="gd">-    def copy(self, *, include: (AbstractSetIntStr | MappingIntStrAny | None</span>
<span class="gd">-        )=None, exclude: (AbstractSetIntStr | MappingIntStrAny | None)=None,</span>
<span class="gd">-        update: (Dict[str, Any] | None)=None, deep: bool=False) -&gt;Self:</span>
<span class="gi">+        &#39;The `copy` method is deprecated; use `model_copy` instead. &#39;</span>
<span class="gi">+        &#39;See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def copy(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        include: AbstractSetIntStr | MappingIntStrAny | None = None,</span>
<span class="gi">+        exclude: AbstractSetIntStr | MappingIntStrAny | None = None,</span>
<span class="gi">+        update: Dict[str, Any] | None = None,  # noqa UP006</span>
<span class="gi">+        deep: bool = False,</span>
<span class="gi">+    ) -&gt; Self:  # pragma: no cover</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a copy of the model.

<span class="w"> </span>        !!! warning &quot;Deprecated&quot;
<span class="gu">@@ -777,15 +1279,197 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A copy of the model with included, excluded and updated fields as specified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `copy` method is deprecated; use `model_copy` instead. &#39;</span>
<span class="gi">+            &#39;See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        from .deprecated import copy_internals</span>
<span class="gi">+</span>
<span class="gi">+        values = dict(</span>
<span class="gi">+            copy_internals._iter(</span>
<span class="gi">+                self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False</span>
<span class="gi">+            ),</span>
<span class="gi">+            **(update or {}),</span>
<span class="gi">+        )</span>
<span class="gi">+        if self.__pydantic_private__ is None:</span>
<span class="gi">+            private = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}</span>
<span class="gi">+</span>
<span class="gi">+        if self.__pydantic_extra__ is None:</span>
<span class="gi">+            extra: dict[str, Any] | None = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            extra = self.__pydantic_extra__.copy()</span>
<span class="gi">+            for k in list(self.__pydantic_extra__):</span>
<span class="gi">+                if k not in values:  # k was in the exclude</span>
<span class="gi">+                    extra.pop(k)</span>
<span class="gi">+            for k in list(values):</span>
<span class="gi">+                if k in self.__pydantic_extra__:  # k must have come from extra</span>
<span class="gi">+                    extra[k] = values.pop(k)</span>
<span class="gi">+</span>
<span class="gi">+        # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg</span>
<span class="gi">+        if update:</span>
<span class="gi">+            fields_set = self.__pydantic_fields_set__ | update.keys()</span>
<span class="gi">+        else:</span>
<span class="gi">+            fields_set = set(self.__pydantic_fields_set__)</span>
<span class="gi">+</span>
<span class="gi">+        # removing excluded fields from `__pydantic_fields_set__`</span>
<span class="gi">+        if exclude:</span>
<span class="gi">+            fields_set -= set(exclude)</span>

<span class="gi">+        return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)</span>

<span class="gd">-def create_model(model_name: str, /, *, __config__: (ConfigDict | None)=</span>
<span class="gd">-    None, __doc__: (str | None)=None, __base__: (type[ModelT] | tuple[type[</span>
<span class="gd">-    ModelT], ...] | None)=None, __module__: (str | None)=None,</span>
<span class="gd">-    __validators__: (dict[str, Callable[..., Any]] | None)=None,</span>
<span class="gd">-    __cls_kwargs__: (dict[str, Any] | None)=None, __slots__: (tuple[str,</span>
<span class="gd">-    ...] | None)=None, **field_definitions: Any) -&gt;type[ModelT]:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(&#39;The `schema` method is deprecated; use `model_json_schema` instead.&#39;, category=None)</span>
<span class="gi">+    def schema(  # noqa: D102</span>
<span class="gi">+        cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:  # noqa UP006</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `schema` method is deprecated; use `model_json_schema` instead.&#39;, category=PydanticDeprecatedSince20</span>
<span class="gi">+        )</span>
<span class="gi">+        return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def schema_json(  # noqa: D102</span>
<span class="gi">+        cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any</span>
<span class="gi">+    ) -&gt; str:  # pragma: no cover</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        import json</span>
<span class="gi">+</span>
<span class="gi">+        from .deprecated.json import pydantic_encoder</span>
<span class="gi">+</span>
<span class="gi">+        return json.dumps(</span>
<span class="gi">+            cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),</span>
<span class="gi">+            default=pydantic_encoder,</span>
<span class="gi">+            **dumps_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(&#39;The `validate` method is deprecated; use `model_validate` instead.&#39;, category=None)</span>
<span class="gi">+    def validate(cls, value: Any) -&gt; Self:  # noqa: D102</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `validate` method is deprecated; use `model_validate` instead.&#39;, category=PydanticDeprecatedSince20</span>
<span class="gi">+        )</span>
<span class="gi">+        return cls.model_validate(value)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The `update_forward_refs` method is deprecated; use `model_rebuild` instead.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `update_forward_refs` method is deprecated; use `model_rebuild` instead.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        if localns:  # pragma: no cover</span>
<span class="gi">+            raise TypeError(&#39;`localns` arguments are not longer accepted.&#39;)</span>
<span class="gi">+        cls.model_rebuild(force=True)</span>
<span class="gi">+</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The private method `_iter` will be removed and should no longer be used.&#39;, category=None</span>
<span class="gi">+    )</span>
<span class="gi">+    def _iter(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The private method `_iter` will be removed and should no longer be used.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        from .deprecated import copy_internals</span>
<span class="gi">+</span>
<span class="gi">+        return copy_internals._iter(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The private method `_copy_and_set_values` will be removed and should no longer be used.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def _copy_and_set_values(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The private method `_copy_and_set_values` will be removed and should no longer be used.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        from .deprecated import copy_internals</span>
<span class="gi">+</span>
<span class="gi">+        return copy_internals._copy_and_set_values(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The private method `_get_value` will be removed and should no longer be used.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def _get_value(cls, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The private method `_get_value` will be removed and should no longer be used.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        from .deprecated import copy_internals</span>
<span class="gi">+</span>
<span class="gi">+        return copy_internals._get_value(cls, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    @typing_extensions.deprecated(</span>
<span class="gi">+        &#39;The private method `_calculate_keys` will be removed and should no longer be used.&#39;,</span>
<span class="gi">+        category=None,</span>
<span class="gi">+    )</span>
<span class="gi">+    def _calculate_keys(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The private method `_calculate_keys` will be removed and should no longer be used.&#39;,</span>
<span class="gi">+            category=PydanticDeprecatedSince20,</span>
<span class="gi">+        )</span>
<span class="gi">+        from .deprecated import copy_internals</span>
<span class="gi">+</span>
<span class="gi">+        return copy_internals._calculate_keys(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def create_model(</span>
<span class="gi">+    model_name: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *,</span>
<span class="gi">+    __config__: ConfigDict | None = None,</span>
<span class="gi">+    __doc__: str | None = None,</span>
<span class="gi">+    __base__: None = None,</span>
<span class="gi">+    __module__: str = __name__,</span>
<span class="gi">+    __validators__: dict[str, Callable[..., Any]] | None = None,</span>
<span class="gi">+    __cls_kwargs__: dict[str, Any] | None = None,</span>
<span class="gi">+    **field_definitions: Any,</span>
<span class="gi">+) -&gt; type[BaseModel]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def create_model(</span>
<span class="gi">+    model_name: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *,</span>
<span class="gi">+    __config__: ConfigDict | None = None,</span>
<span class="gi">+    __doc__: str | None = None,</span>
<span class="gi">+    __base__: type[ModelT] | tuple[type[ModelT], ...],</span>
<span class="gi">+    __module__: str = __name__,</span>
<span class="gi">+    __validators__: dict[str, Callable[..., Any]] | None = None,</span>
<span class="gi">+    __cls_kwargs__: dict[str, Any] | None = None,</span>
<span class="gi">+    **field_definitions: Any,</span>
<span class="gi">+) -&gt; type[ModelT]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_model(  # noqa: C901</span>
<span class="gi">+    model_name: str,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *,</span>
<span class="gi">+    __config__: ConfigDict | None = None,</span>
<span class="gi">+    __doc__: str | None = None,</span>
<span class="gi">+    __base__: type[ModelT] | tuple[type[ModelT], ...] | None = None,</span>
<span class="gi">+    __module__: str | None = None,</span>
<span class="gi">+    __validators__: dict[str, Callable[..., Any]] | None = None,</span>
<span class="gi">+    __cls_kwargs__: dict[str, Any] | None = None,</span>
<span class="gi">+    __slots__: tuple[str, ...] | None = None,</span>
<span class="gi">+    **field_definitions: Any,</span>
<span class="gi">+) -&gt; type[ModelT]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/models/#dynamic-model-creation

<span class="w"> </span>    Dynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a
<span class="gu">@@ -813,7 +1497,84 @@ def create_model(model_name: str, /, *, __config__: (ConfigDict | None)=</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticUserError: If `__base__` and `__config__` are both passed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if __slots__ is not None:</span>
<span class="gi">+        # __slots__ will be ignored from here on</span>
<span class="gi">+        warnings.warn(&#39;__slots__ should not be passed to create_model&#39;, RuntimeWarning)</span>
<span class="gi">+</span>
<span class="gi">+    if __base__ is not None:</span>
<span class="gi">+        if __config__ is not None:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                &#39;to avoid confusion `__config__` and `__base__` cannot be used together&#39;,</span>
<span class="gi">+                code=&#39;create-model-config-base&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+        if not isinstance(__base__, tuple):</span>
<span class="gi">+            __base__ = (__base__,)</span>
<span class="gi">+    else:</span>
<span class="gi">+        __base__ = (cast(&#39;type[ModelT]&#39;, BaseModel),)</span>
<span class="gi">+</span>
<span class="gi">+    __cls_kwargs__ = __cls_kwargs__ or {}</span>
<span class="gi">+</span>
<span class="gi">+    fields = {}</span>
<span class="gi">+    annotations = {}</span>
<span class="gi">+</span>
<span class="gi">+    for f_name, f_def in field_definitions.items():</span>
<span class="gi">+        if not _fields.is_valid_field_name(f_name):</span>
<span class="gi">+            warnings.warn(f&#39;fields may not start with an underscore, ignoring &quot;{f_name}&quot;&#39;, RuntimeWarning)</span>
<span class="gi">+        if isinstance(f_def, tuple):</span>
<span class="gi">+            f_def = cast(&#39;tuple[str, Any]&#39;, f_def)</span>
<span class="gi">+            try:</span>
<span class="gi">+                f_annotation, f_value = f_def</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                raise PydanticUserError(</span>
<span class="gi">+                    &#39;Field definitions should be a `(&lt;type&gt;, &lt;default&gt;)`.&#39;,</span>
<span class="gi">+                    code=&#39;create-model-field-definitions&#39;,</span>
<span class="gi">+                ) from e</span>
<span class="gi">+</span>
<span class="gi">+        elif _typing_extra.is_annotated(f_def):</span>
<span class="gi">+            (f_annotation, f_value, *_) = typing_extensions.get_args(</span>
<span class="gi">+                f_def</span>
<span class="gi">+            )  # first two input are expected from Annotated, refer to https://docs.python.org/3/library/typing.html#typing.Annotated</span>
<span class="gi">+            from .fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(f_value, FieldInfo):</span>
<span class="gi">+                raise PydanticUserError(</span>
<span class="gi">+                    &#39;Field definitions should be a Annotated[&lt;type&gt;, &lt;FieldInfo&gt;]&#39;,</span>
<span class="gi">+                    code=&#39;create-model-field-definitions&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            f_annotation, f_value = None, f_def</span>
<span class="gi">+</span>
<span class="gi">+        if f_annotation:</span>
<span class="gi">+            annotations[f_name] = f_annotation</span>
<span class="gi">+        fields[f_name] = f_value</span>
<span class="gi">+</span>
<span class="gi">+    if __module__ is None:</span>
<span class="gi">+        f = sys._getframe(1)</span>
<span class="gi">+        __module__ = f.f_globals[&#39;__name__&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    namespace: dict[str, Any] = {&#39;__annotations__&#39;: annotations, &#39;__module__&#39;: __module__}</span>
<span class="gi">+    if __doc__:</span>
<span class="gi">+        namespace.update({&#39;__doc__&#39;: __doc__})</span>
<span class="gi">+    if __validators__:</span>
<span class="gi">+        namespace.update(__validators__)</span>
<span class="gi">+    namespace.update(fields)</span>
<span class="gi">+    if __config__:</span>
<span class="gi">+        namespace[&#39;model_config&#39;] = _config.ConfigWrapper(__config__).config_dict</span>
<span class="gi">+    resolved_bases = types.resolve_bases(__base__)</span>
<span class="gi">+    meta, ns, kwds = types.prepare_class(model_name, resolved_bases, kwds=__cls_kwargs__)</span>
<span class="gi">+    if resolved_bases is not __base__:</span>
<span class="gi">+        ns[&#39;__orig_bases__&#39;] = __base__</span>
<span class="gi">+    namespace.update(ns)</span>
<span class="gi">+</span>
<span class="gi">+    return meta(</span>
<span class="gi">+        model_name,</span>
<span class="gi">+        resolved_bases,</span>
<span class="gi">+        namespace,</span>
<span class="gi">+        __pydantic_reset_parent_namespace__=False,</span>
<span class="gi">+        _create_model_module=__module__,</span>
<span class="gi">+        **kwds,</span>
<span class="gi">+    )</span>


<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/mypy.py b/pydantic/mypy.py</span>
<span class="gh">index 03f2edc6a..93e29d5c6 100644</span>
<span class="gd">--- a/pydantic/mypy.py</span>
<span class="gi">+++ b/pydantic/mypy.py</span>
<span class="gu">@@ -1,52 +1,118 @@</span>
<span class="w"> </span>&quot;&quot;&quot;This module includes classes and functions designed specifically for use with the mypy plugin.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from configparser import ConfigParser
<span class="w"> </span>from typing import Any, Callable, Iterator
<span class="gi">+</span>
<span class="w"> </span>from mypy.errorcodes import ErrorCode
<span class="w"> </span>from mypy.expandtype import expand_type, expand_type_by_instance
<span class="gd">-from mypy.nodes import ARG_NAMED, ARG_NAMED_OPT, ARG_OPT, ARG_POS, ARG_STAR2, INVARIANT, MDEF, Argument, AssignmentStmt, Block, CallExpr, ClassDef, Context, Decorator, DictExpr, EllipsisExpr, Expression, FuncDef, IfStmt, JsonDict, MemberExpr, NameExpr, PassStmt, PlaceholderNode, RefExpr, Statement, StrExpr, SymbolTableNode, TempNode, TypeAlias, TypeInfo, Var</span>
<span class="gi">+from mypy.nodes import (</span>
<span class="gi">+    ARG_NAMED,</span>
<span class="gi">+    ARG_NAMED_OPT,</span>
<span class="gi">+    ARG_OPT,</span>
<span class="gi">+    ARG_POS,</span>
<span class="gi">+    ARG_STAR2,</span>
<span class="gi">+    INVARIANT,</span>
<span class="gi">+    MDEF,</span>
<span class="gi">+    Argument,</span>
<span class="gi">+    AssignmentStmt,</span>
<span class="gi">+    Block,</span>
<span class="gi">+    CallExpr,</span>
<span class="gi">+    ClassDef,</span>
<span class="gi">+    Context,</span>
<span class="gi">+    Decorator,</span>
<span class="gi">+    DictExpr,</span>
<span class="gi">+    EllipsisExpr,</span>
<span class="gi">+    Expression,</span>
<span class="gi">+    FuncDef,</span>
<span class="gi">+    IfStmt,</span>
<span class="gi">+    JsonDict,</span>
<span class="gi">+    MemberExpr,</span>
<span class="gi">+    NameExpr,</span>
<span class="gi">+    PassStmt,</span>
<span class="gi">+    PlaceholderNode,</span>
<span class="gi">+    RefExpr,</span>
<span class="gi">+    Statement,</span>
<span class="gi">+    StrExpr,</span>
<span class="gi">+    SymbolTableNode,</span>
<span class="gi">+    TempNode,</span>
<span class="gi">+    TypeAlias,</span>
<span class="gi">+    TypeInfo,</span>
<span class="gi">+    Var,</span>
<span class="gi">+)</span>
<span class="w"> </span>from mypy.options import Options
<span class="gd">-from mypy.plugin import CheckerPluginInterface, ClassDefContext, FunctionContext, MethodContext, Plugin, ReportConfigContext, SemanticAnalyzerPluginInterface</span>
<span class="gi">+from mypy.plugin import (</span>
<span class="gi">+    CheckerPluginInterface,</span>
<span class="gi">+    ClassDefContext,</span>
<span class="gi">+    FunctionContext,</span>
<span class="gi">+    MethodContext,</span>
<span class="gi">+    Plugin,</span>
<span class="gi">+    ReportConfigContext,</span>
<span class="gi">+    SemanticAnalyzerPluginInterface,</span>
<span class="gi">+)</span>
<span class="w"> </span>from mypy.plugins import dataclasses
<span class="gd">-from mypy.plugins.common import deserialize_and_fixup_type</span>
<span class="gi">+from mypy.plugins.common import (</span>
<span class="gi">+    deserialize_and_fixup_type,</span>
<span class="gi">+)</span>
<span class="w"> </span>from mypy.semanal import set_callable_name
<span class="w"> </span>from mypy.server.trigger import make_wildcard_trigger
<span class="w"> </span>from mypy.state import state
<span class="w"> </span>from mypy.typeops import map_type_from_supertype
<span class="gd">-from mypy.types import AnyType, CallableType, Instance, NoneType, Overloaded, Type, TypeOfAny, TypeType, TypeVarType, UnionType, get_proper_type</span>
<span class="gi">+from mypy.types import (</span>
<span class="gi">+    AnyType,</span>
<span class="gi">+    CallableType,</span>
<span class="gi">+    Instance,</span>
<span class="gi">+    NoneType,</span>
<span class="gi">+    Overloaded,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeOfAny,</span>
<span class="gi">+    TypeType,</span>
<span class="gi">+    TypeVarType,</span>
<span class="gi">+    UnionType,</span>
<span class="gi">+    get_proper_type,</span>
<span class="gi">+)</span>
<span class="w"> </span>from mypy.typevars import fill_typevars
<span class="w"> </span>from mypy.util import get_unique_redefinition_name
<span class="w"> </span>from mypy.version import __version__ as mypy_version
<span class="gi">+</span>
<span class="w"> </span>from pydantic._internal import _fields
<span class="w"> </span>from pydantic.version import parse_mypy_version
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    from mypy.types import TypeVarDef</span>
<span class="gd">-except ImportError:</span>
<span class="gi">+    from mypy.types import TypeVarDef  # type: ignore[attr-defined]</span>
<span class="gi">+except ImportError:  # pragma: no cover</span>
<span class="gi">+    # Backward-compatible with TypeVarDef from Mypy 0.930.</span>
<span class="w"> </span>    from mypy.types import TypeVarType as TypeVarDef
<span class="gi">+</span>
<span class="w"> </span>CONFIGFILE_KEY = &#39;pydantic-mypy&#39;
<span class="w"> </span>METADATA_KEY = &#39;pydantic-mypy-metadata&#39;
<span class="w"> </span>BASEMODEL_FULLNAME = &#39;pydantic.main.BaseModel&#39;
<span class="w"> </span>BASESETTINGS_FULLNAME = &#39;pydantic_settings.main.BaseSettings&#39;
<span class="w"> </span>ROOT_MODEL_FULLNAME = &#39;pydantic.root_model.RootModel&#39;
<span class="gd">-MODEL_METACLASS_FULLNAME = (</span>
<span class="gd">-    &#39;pydantic._internal._model_construction.ModelMetaclass&#39;)</span>
<span class="gi">+MODEL_METACLASS_FULLNAME = &#39;pydantic._internal._model_construction.ModelMetaclass&#39;</span>
<span class="w"> </span>FIELD_FULLNAME = &#39;pydantic.fields.Field&#39;
<span class="w"> </span>DATACLASS_FULLNAME = &#39;pydantic.dataclasses.dataclass&#39;
<span class="w"> </span>MODEL_VALIDATOR_FULLNAME = &#39;pydantic.functional_validators.model_validator&#39;
<span class="gd">-DECORATOR_FULLNAMES = {&#39;pydantic.functional_validators.field_validator&#39;,</span>
<span class="gi">+DECORATOR_FULLNAMES = {</span>
<span class="gi">+    &#39;pydantic.functional_validators.field_validator&#39;,</span>
<span class="w"> </span>    &#39;pydantic.functional_validators.model_validator&#39;,
<span class="w"> </span>    &#39;pydantic.functional_serializers.serializer&#39;,
<span class="w"> </span>    &#39;pydantic.functional_serializers.model_serializer&#39;,
<span class="w"> </span>    &#39;pydantic.deprecated.class_validators.validator&#39;,
<span class="gd">-    &#39;pydantic.deprecated.class_validators.root_validator&#39;}</span>
<span class="gi">+    &#39;pydantic.deprecated.class_validators.root_validator&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>MYPY_VERSION_TUPLE = parse_mypy_version(mypy_version)
<span class="gd">-BUILTINS_NAME = &#39;builtins&#39; if MYPY_VERSION_TUPLE &gt;= (0, 930</span>
<span class="gd">-    ) else &#39;__builtins__&#39;</span>
<span class="gi">+BUILTINS_NAME = &#39;builtins&#39; if MYPY_VERSION_TUPLE &gt;= (0, 930) else &#39;__builtins__&#39;</span>
<span class="gi">+</span>
<span class="gi">+# Increment version if plugin changes and mypy caches should be invalidated</span>
<span class="w"> </span>__version__ = 2


<span class="gd">-def plugin(version: str) -&gt;type[Plugin]:</span>
<span class="gi">+def plugin(version: str) -&gt; type[Plugin]:</span>
<span class="w"> </span>    &quot;&quot;&quot;`version` is the mypy version string.

<span class="w"> </span>    We might want to use this to print a warning if the mypy version being used is
<span class="gu">@@ -58,62 +124,79 @@ def plugin(version: str) -&gt;type[Plugin]:</span>
<span class="w"> </span>    Return:
<span class="w"> </span>        The Pydantic mypy plugin type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return PydanticPlugin</span>


<span class="w"> </span>class PydanticPlugin(Plugin):
<span class="w"> </span>    &quot;&quot;&quot;The Pydantic mypy plugin.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, options: Options) -&gt;None:</span>
<span class="gi">+    def __init__(self, options: Options) -&gt; None:</span>
<span class="w"> </span>        self.plugin_config = PydanticPluginConfig(options)
<span class="w"> </span>        self._plugin_data = self.plugin_config.to_data()
<span class="w"> </span>        super().__init__(options)

<span class="gd">-    def get_base_class_hook(self, fullname: str) -&gt;(Callable[[</span>
<span class="gd">-        ClassDefContext], bool] | None):</span>
<span class="gi">+    def get_base_class_hook(self, fullname: str) -&gt; Callable[[ClassDefContext], bool] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update Pydantic model class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_metaclass_hook(self, fullname: str) -&gt;(Callable[[</span>
<span class="gd">-        ClassDefContext], None] | None):</span>
<span class="gi">+        sym = self.lookup_fully_qualified(fullname)</span>
<span class="gi">+        if sym and isinstance(sym.node, TypeInfo):  # pragma: no branch</span>
<span class="gi">+            # No branching may occur if the mypy cache has not been cleared</span>
<span class="gi">+            if any(base.fullname == BASEMODEL_FULLNAME for base in sym.node.mro):</span>
<span class="gi">+                return self._pydantic_model_class_maker_callback</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_metaclass_hook(self, fullname: str) -&gt; Callable[[ClassDefContext], None] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update Pydantic `ModelMetaclass` definition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname == MODEL_METACLASS_FULLNAME:</span>
<span class="gi">+            return self._pydantic_model_metaclass_marker_callback</span>
<span class="gi">+        return None</span>

<span class="gd">-    def get_function_hook(self, fullname: str) -&gt;(Callable[[FunctionContext</span>
<span class="gd">-        ], Type] | None):</span>
<span class="gi">+    def get_function_hook(self, fullname: str) -&gt; Callable[[FunctionContext], Type] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adjust the return type of the `Field` function.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sym = self.lookup_fully_qualified(fullname)</span>
<span class="gi">+        if sym and sym.fullname == FIELD_FULLNAME:</span>
<span class="gi">+            return self._pydantic_field_callback</span>
<span class="gi">+        return None</span>

<span class="gd">-    def get_method_hook(self, fullname: str) -&gt;(Callable[[MethodContext],</span>
<span class="gd">-        Type] | None):</span>
<span class="gi">+    def get_method_hook(self, fullname: str) -&gt; Callable[[MethodContext], Type] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adjust return type of `from_orm` method call.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname.endswith(&#39;.from_orm&#39;):</span>
<span class="gi">+            return from_attributes_callback</span>
<span class="gi">+        return None</span>

<span class="gd">-    def get_class_decorator_hook(self, fullname: str) -&gt;(Callable[[</span>
<span class="gd">-        ClassDefContext], None] | None):</span>
<span class="gi">+    def get_class_decorator_hook(self, fullname: str) -&gt; Callable[[ClassDefContext], None] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mark pydantic.dataclasses as dataclass.

<span class="w"> </span>        Mypy version 1.1.1 added support for `@dataclass_transform` decorator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname == DATACLASS_FULLNAME and MYPY_VERSION_TUPLE &lt; (1, 1):</span>
<span class="gi">+            return dataclasses.dataclass_class_maker_callback  # type: ignore[return-value]</span>
<span class="gi">+        return None</span>

<span class="gd">-    def report_config_data(self, ctx: ReportConfigContext) -&gt;dict[str, Any]:</span>
<span class="gi">+    def report_config_data(self, ctx: ReportConfigContext) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return all plugin config data.

<span class="w"> </span>        Used by mypy to determine if cache needs to be discarded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._plugin_data</span>
<span class="gi">+</span>
<span class="gi">+    def _pydantic_model_class_maker_callback(self, ctx: ClassDefContext) -&gt; bool:</span>
<span class="gi">+        transformer = PydanticModelTransformer(ctx.cls, ctx.reason, ctx.api, self.plugin_config)</span>
<span class="gi">+        return transformer.transform()</span>

<span class="gd">-    def _pydantic_model_metaclass_marker_callback(self, ctx: ClassDefContext</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _pydantic_model_metaclass_marker_callback(self, ctx: ClassDefContext) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset dataclass_transform_spec attribute of ModelMetaclass.

<span class="w"> </span>        Let the plugin handle it. This behavior can be disabled
<span class="w"> </span>        if &#39;debug_dataclass_transform&#39; is set to True&#39;, for testing purposes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.plugin_config.debug_dataclass_transform:</span>
<span class="gi">+            return</span>
<span class="gi">+        info_metaclass = ctx.cls.info.declared_metaclass</span>
<span class="gi">+        assert info_metaclass, &quot;callback not passed from &#39;get_metaclass_hook&#39;&quot;</span>
<span class="gi">+        if getattr(info_metaclass.type, &#39;dataclass_transform_spec&#39;, None):</span>
<span class="gi">+            info_metaclass.type.dataclass_transform_spec = None</span>

<span class="gd">-    def _pydantic_field_callback(self, ctx: FunctionContext) -&gt;Type:</span>
<span class="gi">+    def _pydantic_field_callback(self, ctx: FunctionContext) -&gt; Type:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract the type of the `default` argument from the Field function, and use it as the return type.

<span class="w"> </span>        In particular:
<span class="gu">@@ -121,7 +204,45 @@ class PydanticPlugin(Plugin):</span>
<span class="w"> </span>        * Output an error if both are specified.
<span class="w"> </span>        * Retrieve the type of the argument which is specified, and use it as return type for the function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        default_any_type = ctx.default_return_type</span>
<span class="gi">+</span>
<span class="gi">+        assert ctx.callee_arg_names[0] == &#39;default&#39;, &#39;&quot;default&quot; is no longer first argument in Field()&#39;</span>
<span class="gi">+        assert ctx.callee_arg_names[1] == &#39;default_factory&#39;, &#39;&quot;default_factory&quot; is no longer second argument in Field()&#39;</span>
<span class="gi">+        default_args = ctx.args[0]</span>
<span class="gi">+        default_factory_args = ctx.args[1]</span>
<span class="gi">+</span>
<span class="gi">+        if default_args and default_factory_args:</span>
<span class="gi">+            error_default_and_default_factory_specified(ctx.api, ctx.context)</span>
<span class="gi">+            return default_any_type</span>
<span class="gi">+</span>
<span class="gi">+        if default_args:</span>
<span class="gi">+            default_type = ctx.arg_types[0][0]</span>
<span class="gi">+            default_arg = default_args[0]</span>
<span class="gi">+</span>
<span class="gi">+            # Fallback to default Any type if the field is required</span>
<span class="gi">+            if not isinstance(default_arg, EllipsisExpr):</span>
<span class="gi">+                return default_type</span>
<span class="gi">+</span>
<span class="gi">+        elif default_factory_args:</span>
<span class="gi">+            default_factory_type = ctx.arg_types[1][0]</span>
<span class="gi">+</span>
<span class="gi">+            # Functions which use `ParamSpec` can be overloaded, exposing the callable&#39;s types as a parameter</span>
<span class="gi">+            # Pydantic calls the default factory without any argument, so we retrieve the first item</span>
<span class="gi">+            if isinstance(default_factory_type, Overloaded):</span>
<span class="gi">+                default_factory_type = default_factory_type.items[0]</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(default_factory_type, CallableType):</span>
<span class="gi">+                ret_type = default_factory_type.ret_type</span>
<span class="gi">+                # mypy doesn&#39;t think `ret_type` has `args`, you&#39;d think mypy should know,</span>
<span class="gi">+                # add this check in case it varies by version</span>
<span class="gi">+                args = getattr(ret_type, &#39;args&#39;, None)</span>
<span class="gi">+                if args:</span>
<span class="gi">+                    if all(isinstance(arg, TypeVarType) for arg in args):</span>
<span class="gi">+                        # Looks like the default factory is a type like `list` or `dict`, replace all args with `Any`</span>
<span class="gi">+                        ret_type.args = tuple(default_any_type for _ in args)  # type: ignore[attr-defined]</span>
<span class="gi">+                return ret_type</span>
<span class="gi">+</span>
<span class="gi">+        return default_any_type</span>


<span class="w"> </span>class PydanticPluginConfig:
<span class="gu">@@ -134,50 +255,79 @@ class PydanticPluginConfig:</span>
<span class="w"> </span>        debug_dataclass_transform: Whether to not reset `dataclass_transform_spec` attribute
<span class="w"> </span>            of `ModelMetaclass` for testing purposes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;init_forbid_extra&#39;, &#39;init_typed&#39;,</span>
<span class="gd">-        &#39;warn_required_dynamic_aliases&#39;, &#39;debug_dataclass_transform&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;init_forbid_extra&#39;,</span>
<span class="gi">+        &#39;init_typed&#39;,</span>
<span class="gi">+        &#39;warn_required_dynamic_aliases&#39;,</span>
<span class="gi">+        &#39;debug_dataclass_transform&#39;,</span>
<span class="gi">+    )</span>
<span class="w"> </span>    init_forbid_extra: bool
<span class="w"> </span>    init_typed: bool
<span class="w"> </span>    warn_required_dynamic_aliases: bool
<span class="gd">-    debug_dataclass_transform: bool</span>
<span class="gi">+    debug_dataclass_transform: bool  # undocumented</span>

<span class="gd">-    def __init__(self, options: Options) -&gt;None:</span>
<span class="gd">-        if options.config_file is None:</span>
<span class="gi">+    def __init__(self, options: Options) -&gt; None:</span>
<span class="gi">+        if options.config_file is None:  # pragma: no cover</span>
<span class="w"> </span>            return
<span class="gi">+</span>
<span class="w"> </span>        toml_config = parse_toml(options.config_file)
<span class="w"> </span>        if toml_config is not None:
<span class="w"> </span>            config = toml_config.get(&#39;tool&#39;, {}).get(&#39;pydantic-mypy&#39;, {})
<span class="w"> </span>            for key in self.__slots__:
<span class="w"> </span>                setting = config.get(key, False)
<span class="w"> </span>                if not isinstance(setting, bool):
<span class="gd">-                    raise ValueError(</span>
<span class="gd">-                        f&#39;Configuration value must be a boolean for key: {key}&#39;</span>
<span class="gd">-                        )</span>
<span class="gi">+                    raise ValueError(f&#39;Configuration value must be a boolean for key: {key}&#39;)</span>
<span class="w"> </span>                setattr(self, key, setting)
<span class="w"> </span>        else:
<span class="w"> </span>            plugin_config = ConfigParser()
<span class="w"> </span>            plugin_config.read(options.config_file)
<span class="w"> </span>            for key in self.__slots__:
<span class="gd">-                setting = plugin_config.getboolean(CONFIGFILE_KEY, key,</span>
<span class="gd">-                    fallback=False)</span>
<span class="gi">+                setting = plugin_config.getboolean(CONFIGFILE_KEY, key, fallback=False)</span>
<span class="w"> </span>                setattr(self, key, setting)

<span class="gd">-    def to_data(self) -&gt;dict[str, Any]:</span>
<span class="gi">+    def to_data(self) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a dict of config names to their values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {key: getattr(self, key) for key in self.__slots__}</span>


<span class="gd">-def from_attributes_callback(ctx: MethodContext) -&gt;Type:</span>
<span class="gi">+def from_attributes_callback(ctx: MethodContext) -&gt; Type:</span>
<span class="w"> </span>    &quot;&quot;&quot;Raise an error if from_attributes is not enabled.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    model_type: Instance</span>
<span class="gi">+    ctx_type = ctx.type</span>
<span class="gi">+    if isinstance(ctx_type, TypeType):</span>
<span class="gi">+        ctx_type = ctx_type.item</span>
<span class="gi">+    if isinstance(ctx_type, CallableType) and isinstance(ctx_type.ret_type, Instance):</span>
<span class="gi">+        model_type = ctx_type.ret_type  # called on the class</span>
<span class="gi">+    elif isinstance(ctx_type, Instance):</span>
<span class="gi">+        model_type = ctx_type  # called on an instance (unusual, but still valid)</span>
<span class="gi">+    else:  # pragma: no cover</span>
<span class="gi">+        detail = f&#39;ctx.type: {ctx_type} (of type {ctx_type.__class__.__name__})&#39;</span>
<span class="gi">+        error_unexpected_behavior(detail, ctx.api, ctx.context)</span>
<span class="gi">+        return ctx.default_return_type</span>
<span class="gi">+    pydantic_metadata = model_type.type.metadata.get(METADATA_KEY)</span>
<span class="gi">+    if pydantic_metadata is None:</span>
<span class="gi">+        return ctx.default_return_type</span>
<span class="gi">+    from_attributes = pydantic_metadata.get(&#39;config&#39;, {}).get(&#39;from_attributes&#39;)</span>
<span class="gi">+    if from_attributes is not True:</span>
<span class="gi">+        error_from_attributes(model_type.type.name, ctx.api, ctx.context)</span>
<span class="gi">+    return ctx.default_return_type</span>


<span class="w"> </span>class PydanticModelField:
<span class="w"> </span>    &quot;&quot;&quot;Based on mypy.plugins.dataclasses.DataclassAttribute.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str, alias: (str | None), has_dynamic_alias:</span>
<span class="gd">-        bool, has_default: bool, line: int, column: int, type: (Type | None</span>
<span class="gd">-        ), info: TypeInfo):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        alias: str | None,</span>
<span class="gi">+        has_dynamic_alias: bool,</span>
<span class="gi">+        has_default: bool,</span>
<span class="gi">+        line: int,</span>
<span class="gi">+        column: int,</span>
<span class="gi">+        type: Type | None,</span>
<span class="gi">+        info: TypeInfo,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.alias = alias
<span class="w"> </span>        self.has_dynamic_alias = has_dynamic_alias
<span class="gu">@@ -187,41 +337,96 @@ class PydanticModelField:</span>
<span class="w"> </span>        self.type = type
<span class="w"> </span>        self.info = info

<span class="gd">-    def to_argument(self, current_info: TypeInfo, typed: bool,</span>
<span class="gd">-        force_optional: bool, use_alias: bool, api:</span>
<span class="gd">-        SemanticAnalyzerPluginInterface, force_typevars_invariant: bool</span>
<span class="gd">-        ) -&gt;Argument:</span>
<span class="gi">+    def to_argument(</span>
<span class="gi">+        self,</span>
<span class="gi">+        current_info: TypeInfo,</span>
<span class="gi">+        typed: bool,</span>
<span class="gi">+        force_optional: bool,</span>
<span class="gi">+        use_alias: bool,</span>
<span class="gi">+        api: SemanticAnalyzerPluginInterface,</span>
<span class="gi">+        force_typevars_invariant: bool,</span>
<span class="gi">+    ) -&gt; Argument:</span>
<span class="w"> </span>        &quot;&quot;&quot;Based on mypy.plugins.dataclasses.DataclassAttribute.to_argument.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def expand_type(self, current_info: TypeInfo, api:</span>
<span class="gd">-        SemanticAnalyzerPluginInterface, force_typevars_invariant: bool=False</span>
<span class="gd">-        ) -&gt;(Type | None):</span>
<span class="gi">+        variable = self.to_var(current_info, api, use_alias, force_typevars_invariant)</span>
<span class="gi">+        type_annotation = self.expand_type(current_info, api) if typed else AnyType(TypeOfAny.explicit)</span>
<span class="gi">+        return Argument(</span>
<span class="gi">+            variable=variable,</span>
<span class="gi">+            type_annotation=type_annotation,</span>
<span class="gi">+            initializer=None,</span>
<span class="gi">+            kind=ARG_NAMED_OPT if force_optional or self.has_default else ARG_NAMED,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def expand_type(</span>
<span class="gi">+        self, current_info: TypeInfo, api: SemanticAnalyzerPluginInterface, force_typevars_invariant: bool = False</span>
<span class="gi">+    ) -&gt; Type | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Based on mypy.plugins.dataclasses.DataclassAttribute.expand_type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def to_var(self, current_info: TypeInfo, api:</span>
<span class="gd">-        SemanticAnalyzerPluginInterface, use_alias: bool,</span>
<span class="gd">-        force_typevars_invariant: bool=False) -&gt;Var:</span>
<span class="gi">+        # The getattr in the next line is used to prevent errors in legacy versions of mypy without this attribute</span>
<span class="gi">+        if force_typevars_invariant:</span>
<span class="gi">+            # In some cases, mypy will emit an error &quot;Cannot use a covariant type variable as a parameter&quot;</span>
<span class="gi">+            # To prevent that, we add an option to replace typevars with invariant ones while building certain</span>
<span class="gi">+            # method signatures (in particular, `__init__`). There may be a better way to do this, if this causes</span>
<span class="gi">+            # us problems in the future, we should look into why the dataclasses plugin doesn&#39;t have this issue.</span>
<span class="gi">+            if isinstance(self.type, TypeVarType):</span>
<span class="gi">+                modified_type = self.type.copy_modified()</span>
<span class="gi">+                modified_type.variance = INVARIANT</span>
<span class="gi">+                self.type = modified_type</span>
<span class="gi">+</span>
<span class="gi">+        if self.type is not None and getattr(self.info, &#39;self_type&#39;, None) is not None:</span>
<span class="gi">+            # In general, it is not safe to call `expand_type()` during semantic analyzis,</span>
<span class="gi">+            # however this plugin is called very late, so all types should be fully ready.</span>
<span class="gi">+            # Also, it is tricky to avoid eager expansion of Self types here (e.g. because</span>
<span class="gi">+            # we serialize attributes).</span>
<span class="gi">+            with state.strict_optional_set(api.options.strict_optional):</span>
<span class="gi">+                filled_with_typevars = fill_typevars(current_info)</span>
<span class="gi">+                if force_typevars_invariant:</span>
<span class="gi">+                    for arg in filled_with_typevars.args:</span>
<span class="gi">+                        if isinstance(arg, TypeVarType):</span>
<span class="gi">+                            arg.variance = INVARIANT</span>
<span class="gi">+                return expand_type(self.type, {self.info.self_type.id: filled_with_typevars})</span>
<span class="gi">+        return self.type</span>
<span class="gi">+</span>
<span class="gi">+    def to_var(</span>
<span class="gi">+        self,</span>
<span class="gi">+        current_info: TypeInfo,</span>
<span class="gi">+        api: SemanticAnalyzerPluginInterface,</span>
<span class="gi">+        use_alias: bool,</span>
<span class="gi">+        force_typevars_invariant: bool = False,</span>
<span class="gi">+    ) -&gt; Var:</span>
<span class="w"> </span>        &quot;&quot;&quot;Based on mypy.plugins.dataclasses.DataclassAttribute.to_var.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if use_alias and self.alias is not None:</span>
<span class="gi">+            name = self.alias</span>
<span class="gi">+        else:</span>
<span class="gi">+            name = self.name</span>

<span class="gd">-    def serialize(self) -&gt;JsonDict:</span>
<span class="gi">+        return Var(name, self.expand_type(current_info, api, force_typevars_invariant))</span>
<span class="gi">+</span>
<span class="gi">+    def serialize(self) -&gt; JsonDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Based on mypy.plugins.dataclasses.DataclassAttribute.serialize.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.type</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;name&#39;: self.name,</span>
<span class="gi">+            &#39;alias&#39;: self.alias,</span>
<span class="gi">+            &#39;has_dynamic_alias&#39;: self.has_dynamic_alias,</span>
<span class="gi">+            &#39;has_default&#39;: self.has_default,</span>
<span class="gi">+            &#39;line&#39;: self.line,</span>
<span class="gi">+            &#39;column&#39;: self.column,</span>
<span class="gi">+            &#39;type&#39;: self.type.serialize(),</span>
<span class="gi">+        }</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def deserialize(cls, info: TypeInfo, data: JsonDict, api:</span>
<span class="gd">-        SemanticAnalyzerPluginInterface) -&gt;PydanticModelField:</span>
<span class="gi">+    def deserialize(cls, info: TypeInfo, data: JsonDict, api: SemanticAnalyzerPluginInterface) -&gt; PydanticModelField:</span>
<span class="w"> </span>        &quot;&quot;&quot;Based on mypy.plugins.dataclasses.DataclassAttribute.deserialize.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = data.copy()</span>
<span class="gi">+        typ = deserialize_and_fixup_type(data.pop(&#39;type&#39;), api)</span>
<span class="gi">+        return cls(type=typ, info=info, **data)</span>

<span class="gd">-    def expand_typevar_from_subtype(self, sub_type: TypeInfo, api:</span>
<span class="gd">-        SemanticAnalyzerPluginInterface) -&gt;None:</span>
<span class="gi">+    def expand_typevar_from_subtype(self, sub_type: TypeInfo, api: SemanticAnalyzerPluginInterface) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Expands type vars in the context of a subtype when an attribute is inherited
<span class="w"> </span>        from a generic super type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.type is not None:</span>
<span class="gi">+            with state.strict_optional_set(api.options.strict_optional):</span>
<span class="gi">+                self.type = map_type_from_supertype(self.type, sub_type, self.info)</span>


<span class="w"> </span>class PydanticModelClassVar:
<span class="gu">@@ -237,13 +442,16 @@ class PydanticModelClassVar:</span>
<span class="w"> </span>        self.name = name

<span class="w"> </span>    @classmethod
<span class="gd">-    def deserialize(cls, data: JsonDict) -&gt;PydanticModelClassVar:</span>
<span class="gi">+    def deserialize(cls, data: JsonDict) -&gt; PydanticModelClassVar:</span>
<span class="w"> </span>        &quot;&quot;&quot;Based on mypy.plugins.dataclasses.DataclassAttribute.deserialize.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = data.copy()</span>
<span class="gi">+        return cls(**data)</span>

<span class="gd">-    def serialize(self) -&gt;JsonDict:</span>
<span class="gi">+    def serialize(self) -&gt; JsonDict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Based on mypy.plugins.dataclasses.DataclassAttribute.serialize.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;name&#39;: self.name,</span>
<span class="gi">+        }</span>


<span class="w"> </span>class PydanticModelTransformer:
<span class="gu">@@ -252,18 +460,29 @@ class PydanticModelTransformer:</span>
<span class="w"> </span>    Attributes:
<span class="w"> </span>        tracked_config_fields: A set of field configs that the plugin has to track their value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    tracked_config_fields: set[str] = {&#39;extra&#39;, &#39;frozen&#39;, &#39;from_attributes&#39;,</span>
<span class="gd">-        &#39;populate_by_name&#39;, &#39;alias_generator&#39;}</span>

<span class="gd">-    def __init__(self, cls: ClassDef, reason: (Expression | Statement), api:</span>
<span class="gd">-        SemanticAnalyzerPluginInterface, plugin_config: PydanticPluginConfig</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    tracked_config_fields: set[str] = {</span>
<span class="gi">+        &#39;extra&#39;,</span>
<span class="gi">+        &#39;frozen&#39;,</span>
<span class="gi">+        &#39;from_attributes&#39;,</span>
<span class="gi">+        &#39;populate_by_name&#39;,</span>
<span class="gi">+        &#39;alias_generator&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        cls: ClassDef,</span>
<span class="gi">+        reason: Expression | Statement,</span>
<span class="gi">+        api: SemanticAnalyzerPluginInterface,</span>
<span class="gi">+        plugin_config: PydanticPluginConfig,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._cls = cls
<span class="w"> </span>        self._reason = reason
<span class="w"> </span>        self._api = api
<span class="gi">+</span>
<span class="w"> </span>        self.plugin_config = plugin_config

<span class="gd">-    def transform(self) -&gt;bool:</span>
<span class="gi">+    def transform(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Configures the BaseModel subclass according to the plugin settings.

<span class="w"> </span>        In particular:
<span class="gu">@@ -273,9 +492,34 @@ class PydanticModelTransformer:</span>
<span class="w"> </span>        * freezes the class if frozen = True
<span class="w"> </span>        * stores the fields, config, and if the class is settings in the mypy metadata for access by subclasses
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def adjust_decorator_signatures(self) -&gt;None:</span>
<span class="gi">+        info = self._cls.info</span>
<span class="gi">+        is_root_model = any(ROOT_MODEL_FULLNAME in base.fullname for base in info.mro[:-1])</span>
<span class="gi">+        config = self.collect_config()</span>
<span class="gi">+        fields, class_vars = self.collect_fields_and_class_vars(config, is_root_model)</span>
<span class="gi">+        if fields is None or class_vars is None:</span>
<span class="gi">+            # Some definitions are not ready. We need another pass.</span>
<span class="gi">+            return False</span>
<span class="gi">+        for field in fields:</span>
<span class="gi">+            if field.type is None:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        is_settings = any(base.fullname == BASESETTINGS_FULLNAME for base in info.mro[:-1])</span>
<span class="gi">+        self.add_initializer(fields, config, is_settings, is_root_model)</span>
<span class="gi">+        if not is_root_model:</span>
<span class="gi">+            self.add_model_construct_method(fields, config, is_settings)</span>
<span class="gi">+        self.set_frozen(fields, self._api, frozen=config.frozen is True)</span>
<span class="gi">+</span>
<span class="gi">+        self.adjust_decorator_signatures()</span>
<span class="gi">+</span>
<span class="gi">+        info.metadata[METADATA_KEY] = {</span>
<span class="gi">+            &#39;fields&#39;: {field.name: field.serialize() for field in fields},</span>
<span class="gi">+            &#39;class_vars&#39;: {class_var.name: class_var.serialize() for class_var in class_vars},</span>
<span class="gi">+            &#39;config&#39;: config.get_values_dict(),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def adjust_decorator_signatures(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;When we decorate a function `f` with `pydantic.validator(...)`, `pydantic.field_validator`
<span class="w"> </span>        or `pydantic.serializer(...)`, mypy sees `f` as a regular method taking a `self` instance,
<span class="w"> </span>        even though pydantic internally wraps `f` with `classmethod` if necessary.
<span class="gu">@@ -283,22 +527,183 @@ class PydanticModelTransformer:</span>
<span class="w"> </span>        Teach mypy this by marking any function whose outermost decorator is a `validator()`,
<span class="w"> </span>        `field_validator()` or `serializer()` call as a `classmethod`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, sym in self._cls.info.names.items():</span>
<span class="gi">+            if isinstance(sym.node, Decorator):</span>
<span class="gi">+                first_dec = sym.node.original_decorators[0]</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(first_dec, CallExpr)</span>
<span class="gi">+                    and isinstance(first_dec.callee, NameExpr)</span>
<span class="gi">+                    and first_dec.callee.fullname in DECORATOR_FULLNAMES</span>
<span class="gi">+                    # @model_validator(mode=&quot;after&quot;) is an exception, it expects a regular method</span>
<span class="gi">+                    and not (</span>
<span class="gi">+                        first_dec.callee.fullname == MODEL_VALIDATOR_FULLNAME</span>
<span class="gi">+                        and any(</span>
<span class="gi">+                            first_dec.arg_names[i] == &#39;mode&#39; and isinstance(arg, StrExpr) and arg.value == &#39;after&#39;</span>
<span class="gi">+                            for i, arg in enumerate(first_dec.args)</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # TODO: Only do this if the first argument of the decorated function is `cls`</span>
<span class="gi">+                    sym.node.func.is_class = True</span>

<span class="gd">-    def collect_config(self) -&gt;ModelConfigData:</span>
<span class="gi">+    def collect_config(self) -&gt; ModelConfigData:  # noqa: C901 (ignore complexity)</span>
<span class="w"> </span>        &quot;&quot;&quot;Collects the values of the config attributes that are used by the plugin, accounting for parent classes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def collect_fields_and_class_vars(self, model_config: ModelConfigData,</span>
<span class="gd">-        is_root_model: bool) -&gt;tuple[list[PydanticModelField] | None, list[</span>
<span class="gd">-        PydanticModelClassVar] | None]:</span>
<span class="gi">+        cls = self._cls</span>
<span class="gi">+        config = ModelConfigData()</span>
<span class="gi">+</span>
<span class="gi">+        has_config_kwargs = False</span>
<span class="gi">+        has_config_from_namespace = False</span>
<span class="gi">+</span>
<span class="gi">+        # Handle `class MyModel(BaseModel, &lt;name&gt;=&lt;expr&gt;, ...):`</span>
<span class="gi">+        for name, expr in cls.keywords.items():</span>
<span class="gi">+            config_data = self.get_config_update(name, expr)</span>
<span class="gi">+            if config_data:</span>
<span class="gi">+                has_config_kwargs = True</span>
<span class="gi">+                config.update(config_data)</span>
<span class="gi">+</span>
<span class="gi">+        # Handle `model_config`</span>
<span class="gi">+        stmt: Statement | None = None</span>
<span class="gi">+        for stmt in cls.defs.body:</span>
<span class="gi">+            if not isinstance(stmt, (AssignmentStmt, ClassDef)):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(stmt, AssignmentStmt):</span>
<span class="gi">+                lhs = stmt.lvalues[0]</span>
<span class="gi">+                if not isinstance(lhs, NameExpr) or lhs.name != &#39;model_config&#39;:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(stmt.rvalue, CallExpr):  # calls to `dict` or `ConfigDict`</span>
<span class="gi">+                    for arg_name, arg in zip(stmt.rvalue.arg_names, stmt.rvalue.args):</span>
<span class="gi">+                        if arg_name is None:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        config.update(self.get_config_update(arg_name, arg, lax_extra=True))</span>
<span class="gi">+                elif isinstance(stmt.rvalue, DictExpr):  # dict literals</span>
<span class="gi">+                    for key_expr, value_expr in stmt.rvalue.items:</span>
<span class="gi">+                        if not isinstance(key_expr, StrExpr):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        config.update(self.get_config_update(key_expr.value, value_expr))</span>
<span class="gi">+</span>
<span class="gi">+            elif isinstance(stmt, ClassDef):</span>
<span class="gi">+                if stmt.name != &#39;Config&#39;:  # &#39;deprecated&#39; Config-class</span>
<span class="gi">+                    continue</span>
<span class="gi">+                for substmt in stmt.defs.body:</span>
<span class="gi">+                    if not isinstance(substmt, AssignmentStmt):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    lhs = substmt.lvalues[0]</span>
<span class="gi">+                    if not isinstance(lhs, NameExpr):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    config.update(self.get_config_update(lhs.name, substmt.rvalue))</span>
<span class="gi">+</span>
<span class="gi">+            if has_config_kwargs:</span>
<span class="gi">+                self._api.fail(</span>
<span class="gi">+                    &#39;Specifying config in two places is ambiguous, use either Config attribute or class kwargs&#39;,</span>
<span class="gi">+                    cls,</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            has_config_from_namespace = True</span>
<span class="gi">+</span>
<span class="gi">+        if has_config_kwargs or has_config_from_namespace:</span>
<span class="gi">+            if (</span>
<span class="gi">+                stmt</span>
<span class="gi">+                and config.has_alias_generator</span>
<span class="gi">+                and not config.populate_by_name</span>
<span class="gi">+                and self.plugin_config.warn_required_dynamic_aliases</span>
<span class="gi">+            ):</span>
<span class="gi">+                error_required_dynamic_aliases(self._api, stmt)</span>
<span class="gi">+</span>
<span class="gi">+        for info in cls.info.mro[1:]:  # 0 is the current class</span>
<span class="gi">+            if METADATA_KEY not in info.metadata:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Each class depends on the set of fields in its ancestors</span>
<span class="gi">+            self._api.add_plugin_dependency(make_wildcard_trigger(info.fullname))</span>
<span class="gi">+            for name, value in info.metadata[METADATA_KEY][&#39;config&#39;].items():</span>
<span class="gi">+                config.setdefault(name, value)</span>
<span class="gi">+        return config</span>
<span class="gi">+</span>
<span class="gi">+    def collect_fields_and_class_vars(</span>
<span class="gi">+        self, model_config: ModelConfigData, is_root_model: bool</span>
<span class="gi">+    ) -&gt; tuple[list[PydanticModelField] | None, list[PydanticModelClassVar] | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Collects the fields for the model, accounting for parent classes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def collect_field_or_class_var_from_stmt(self, stmt: AssignmentStmt,</span>
<span class="gd">-        model_config: ModelConfigData, class_vars: dict[str,</span>
<span class="gd">-        PydanticModelClassVar]) -&gt;(PydanticModelField |</span>
<span class="gd">-        PydanticModelClassVar | None):</span>
<span class="gi">+        cls = self._cls</span>
<span class="gi">+</span>
<span class="gi">+        # First, collect fields and ClassVars belonging to any class in the MRO, ignoring duplicates.</span>
<span class="gi">+        #</span>
<span class="gi">+        # We iterate through the MRO in reverse because attrs defined in the parent must appear</span>
<span class="gi">+        # earlier in the attributes list than attrs defined in the child. See:</span>
<span class="gi">+        # https://docs.python.org/3/library/dataclasses.html#inheritance</span>
<span class="gi">+        #</span>
<span class="gi">+        # However, we also want fields defined in the subtype to override ones defined</span>
<span class="gi">+        # in the parent. We can implement this via a dict without disrupting the attr order</span>
<span class="gi">+        # because dicts preserve insertion order in Python 3.7+.</span>
<span class="gi">+        found_fields: dict[str, PydanticModelField] = {}</span>
<span class="gi">+        found_class_vars: dict[str, PydanticModelClassVar] = {}</span>
<span class="gi">+        for info in reversed(cls.info.mro[1:-1]):  # 0 is the current class, -2 is BaseModel, -1 is object</span>
<span class="gi">+            # if BASEMODEL_METADATA_TAG_KEY in info.metadata and BASEMODEL_METADATA_KEY not in info.metadata:</span>
<span class="gi">+            #     # We haven&#39;t processed the base class yet. Need another pass.</span>
<span class="gi">+            #     return None, None</span>
<span class="gi">+            if METADATA_KEY not in info.metadata:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Each class depends on the set of attributes in its dataclass ancestors.</span>
<span class="gi">+            self._api.add_plugin_dependency(make_wildcard_trigger(info.fullname))</span>
<span class="gi">+</span>
<span class="gi">+            for name, data in info.metadata[METADATA_KEY][&#39;fields&#39;].items():</span>
<span class="gi">+                field = PydanticModelField.deserialize(info, data, self._api)</span>
<span class="gi">+                # (The following comment comes directly from the dataclasses plugin)</span>
<span class="gi">+                # TODO: We shouldn&#39;t be performing type operations during the main</span>
<span class="gi">+                #       semantic analysis pass, since some TypeInfo attributes might</span>
<span class="gi">+                #       still be in flux. This should be performed in a later phase.</span>
<span class="gi">+                field.expand_typevar_from_subtype(cls.info, self._api)</span>
<span class="gi">+                found_fields[name] = field</span>
<span class="gi">+</span>
<span class="gi">+                sym_node = cls.info.names.get(name)</span>
<span class="gi">+                if sym_node and sym_node.node and not isinstance(sym_node.node, Var):</span>
<span class="gi">+                    self._api.fail(</span>
<span class="gi">+                        &#39;BaseModel field may only be overridden by another field&#39;,</span>
<span class="gi">+                        sym_node.node,</span>
<span class="gi">+                    )</span>
<span class="gi">+            # Collect ClassVars</span>
<span class="gi">+            for name, data in info.metadata[METADATA_KEY][&#39;class_vars&#39;].items():</span>
<span class="gi">+                found_class_vars[name] = PydanticModelClassVar.deserialize(data)</span>
<span class="gi">+</span>
<span class="gi">+        # Second, collect fields and ClassVars belonging to the current class.</span>
<span class="gi">+        current_field_names: set[str] = set()</span>
<span class="gi">+        current_class_vars_names: set[str] = set()</span>
<span class="gi">+        for stmt in self._get_assignment_statements_from_block(cls.defs):</span>
<span class="gi">+            maybe_field = self.collect_field_or_class_var_from_stmt(stmt, model_config, found_class_vars)</span>
<span class="gi">+            if isinstance(maybe_field, PydanticModelField):</span>
<span class="gi">+                lhs = stmt.lvalues[0]</span>
<span class="gi">+                if is_root_model and lhs.name != &#39;root&#39;:</span>
<span class="gi">+                    error_extra_fields_on_root_model(self._api, stmt)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    current_field_names.add(lhs.name)</span>
<span class="gi">+                    found_fields[lhs.name] = maybe_field</span>
<span class="gi">+            elif isinstance(maybe_field, PydanticModelClassVar):</span>
<span class="gi">+                lhs = stmt.lvalues[0]</span>
<span class="gi">+                current_class_vars_names.add(lhs.name)</span>
<span class="gi">+                found_class_vars[lhs.name] = maybe_field</span>
<span class="gi">+</span>
<span class="gi">+        return list(found_fields.values()), list(found_class_vars.values())</span>
<span class="gi">+</span>
<span class="gi">+    def _get_assignment_statements_from_if_statement(self, stmt: IfStmt) -&gt; Iterator[AssignmentStmt]:</span>
<span class="gi">+        for body in stmt.body:</span>
<span class="gi">+            if not body.is_unreachable:</span>
<span class="gi">+                yield from self._get_assignment_statements_from_block(body)</span>
<span class="gi">+        if stmt.else_body is not None and not stmt.else_body.is_unreachable:</span>
<span class="gi">+            yield from self._get_assignment_statements_from_block(stmt.else_body)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_assignment_statements_from_block(self, block: Block) -&gt; Iterator[AssignmentStmt]:</span>
<span class="gi">+        for stmt in block.body:</span>
<span class="gi">+            if isinstance(stmt, AssignmentStmt):</span>
<span class="gi">+                yield stmt</span>
<span class="gi">+            elif isinstance(stmt, IfStmt):</span>
<span class="gi">+                yield from self._get_assignment_statements_from_if_statement(stmt)</span>
<span class="gi">+</span>
<span class="gi">+    def collect_field_or_class_var_from_stmt(  # noqa C901</span>
<span class="gi">+        self, stmt: AssignmentStmt, model_config: ModelConfigData, class_vars: dict[str, PydanticModelClassVar]</span>
<span class="gi">+    ) -&gt; PydanticModelField | PydanticModelClassVar | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get pydantic model field from statement.

<span class="w"> </span>        Args:
<span class="gu">@@ -309,189 +714,600 @@ class PydanticModelTransformer:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A pydantic model field if it could find the field in statement. Otherwise, `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _infer_dataclass_attr_init_type(self, sym: SymbolTableNode, name:</span>
<span class="gd">-        str, context: Context) -&gt;(Type | None):</span>
<span class="gi">+        cls = self._cls</span>
<span class="gi">+</span>
<span class="gi">+        lhs = stmt.lvalues[0]</span>
<span class="gi">+        if not isinstance(lhs, NameExpr) or not _fields.is_valid_field_name(lhs.name) or lhs.name == &#39;model_config&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if not stmt.new_syntax:</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(stmt.rvalue, CallExpr)</span>
<span class="gi">+                and isinstance(stmt.rvalue.callee, CallExpr)</span>
<span class="gi">+                and isinstance(stmt.rvalue.callee.callee, NameExpr)</span>
<span class="gi">+                and stmt.rvalue.callee.callee.fullname in DECORATOR_FULLNAMES</span>
<span class="gi">+            ):</span>
<span class="gi">+                # This is a (possibly-reused) validator or serializer, not a field</span>
<span class="gi">+                # In particular, it looks something like: my_validator = validator(&#39;my_field&#39;)(f)</span>
<span class="gi">+                # Eventually, we may want to attempt to respect model_config[&#39;ignored_types&#39;]</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            if lhs.name in class_vars:</span>
<span class="gi">+                # Class vars are not fields and are not required to be annotated</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            # The assignment does not have an annotation, and it&#39;s not anything else we recognize</span>
<span class="gi">+            error_untyped_fields(self._api, stmt)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        lhs = stmt.lvalues[0]</span>
<span class="gi">+        if not isinstance(lhs, NameExpr):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if not _fields.is_valid_field_name(lhs.name) or lhs.name == &#39;model_config&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        sym = cls.info.names.get(lhs.name)</span>
<span class="gi">+        if sym is None:  # pragma: no cover</span>
<span class="gi">+            # This is likely due to a star import (see the dataclasses plugin for a more detailed explanation)</span>
<span class="gi">+            # This is the same logic used in the dataclasses plugin</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        node = sym.node</span>
<span class="gi">+        if isinstance(node, PlaceholderNode):  # pragma: no cover</span>
<span class="gi">+            # See the PlaceholderNode docstring for more detail about how this can occur</span>
<span class="gi">+            # Basically, it is an edge case when dealing with complex import logic</span>
<span class="gi">+</span>
<span class="gi">+            # The dataclasses plugin now asserts this cannot happen, but I&#39;d rather not error if it does..</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node, TypeAlias):</span>
<span class="gi">+            self._api.fail(</span>
<span class="gi">+                &#39;Type aliases inside BaseModel definitions are not supported at runtime&#39;,</span>
<span class="gi">+                node,</span>
<span class="gi">+            )</span>
<span class="gi">+            # Skip processing this node. This doesn&#39;t match the runtime behaviour,</span>
<span class="gi">+            # but the only alternative would be to modify the SymbolTable,</span>
<span class="gi">+            # and it&#39;s a little hairy to do that in a plugin.</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(node, Var):  # pragma: no cover</span>
<span class="gi">+            # Don&#39;t know if this edge case still happens with the `is_valid_field` check above</span>
<span class="gi">+            # but better safe than sorry</span>
<span class="gi">+</span>
<span class="gi">+            # The dataclasses plugin now asserts this cannot happen, but I&#39;d rather not error if it does..</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # x: ClassVar[int] is not a field</span>
<span class="gi">+        if node.is_classvar:</span>
<span class="gi">+            return PydanticModelClassVar(lhs.name)</span>
<span class="gi">+</span>
<span class="gi">+        # x: InitVar[int] is not supported in BaseModel</span>
<span class="gi">+        node_type = get_proper_type(node.type)</span>
<span class="gi">+        if isinstance(node_type, Instance) and node_type.type.fullname == &#39;dataclasses.InitVar&#39;:</span>
<span class="gi">+            self._api.fail(</span>
<span class="gi">+                &#39;InitVar is not supported in BaseModel&#39;,</span>
<span class="gi">+                node,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        has_default = self.get_has_default(stmt)</span>
<span class="gi">+</span>
<span class="gi">+        if sym.type is None and node.is_final and node.is_inferred:</span>
<span class="gi">+            # This follows the logic from the dataclasses plugin. The following comment is taken verbatim:</span>
<span class="gi">+            #</span>
<span class="gi">+            # This is a special case, assignment like x: Final = 42 is classified</span>
<span class="gi">+            # annotated above, but mypy strips the `Final` turning it into x = 42.</span>
<span class="gi">+            # We do not support inferred types in dataclasses, so we can try inferring</span>
<span class="gi">+            # type for simple literals, and otherwise require an explicit type</span>
<span class="gi">+            # argument for Final[...].</span>
<span class="gi">+            typ = self._api.analyze_simple_literal_type(stmt.rvalue, is_final=True)</span>
<span class="gi">+            if typ:</span>
<span class="gi">+                node.type = typ</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._api.fail(</span>
<span class="gi">+                    &#39;Need type argument for Final[...] with non-literal default in BaseModel&#39;,</span>
<span class="gi">+                    stmt,</span>
<span class="gi">+                )</span>
<span class="gi">+                node.type = AnyType(TypeOfAny.from_error)</span>
<span class="gi">+</span>
<span class="gi">+        alias, has_dynamic_alias = self.get_alias_info(stmt)</span>
<span class="gi">+        if has_dynamic_alias and not model_config.populate_by_name and self.plugin_config.warn_required_dynamic_aliases:</span>
<span class="gi">+            error_required_dynamic_aliases(self._api, stmt)</span>
<span class="gi">+</span>
<span class="gi">+        init_type = self._infer_dataclass_attr_init_type(sym, lhs.name, stmt)</span>
<span class="gi">+        return PydanticModelField(</span>
<span class="gi">+            name=lhs.name,</span>
<span class="gi">+            has_dynamic_alias=has_dynamic_alias,</span>
<span class="gi">+            has_default=has_default,</span>
<span class="gi">+            alias=alias,</span>
<span class="gi">+            line=stmt.line,</span>
<span class="gi">+            column=stmt.column,</span>
<span class="gi">+            type=init_type,</span>
<span class="gi">+            info=cls.info,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _infer_dataclass_attr_init_type(self, sym: SymbolTableNode, name: str, context: Context) -&gt; Type | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Infer __init__ argument type for an attribute.

<span class="w"> </span>        In particular, possibly use the signature of __set__.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_initializer(self, fields: list[PydanticModelField], config:</span>
<span class="gd">-        ModelConfigData, is_settings: bool, is_root_model: bool) -&gt;None:</span>
<span class="gi">+        default = sym.type</span>
<span class="gi">+        if sym.implicit:</span>
<span class="gi">+            return default</span>
<span class="gi">+        t = get_proper_type(sym.type)</span>
<span class="gi">+</span>
<span class="gi">+        # Perform a simple-minded inference from the signature of __set__, if present.</span>
<span class="gi">+        # We can&#39;t use mypy.checkmember here, since this plugin runs before type checking.</span>
<span class="gi">+        # We only support some basic scanerios here, which is hopefully sufficient for</span>
<span class="gi">+        # the vast majority of use cases.</span>
<span class="gi">+        if not isinstance(t, Instance):</span>
<span class="gi">+            return default</span>
<span class="gi">+        setter = t.type.get(&#39;__set__&#39;)</span>
<span class="gi">+        if setter:</span>
<span class="gi">+            if isinstance(setter.node, FuncDef):</span>
<span class="gi">+                super_info = t.type.get_containing_type_info(&#39;__set__&#39;)</span>
<span class="gi">+                assert super_info</span>
<span class="gi">+                if setter.type:</span>
<span class="gi">+                    setter_type = get_proper_type(map_type_from_supertype(setter.type, t.type, super_info))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return AnyType(TypeOfAny.unannotated)</span>
<span class="gi">+                if isinstance(setter_type, CallableType) and setter_type.arg_kinds == [</span>
<span class="gi">+                    ARG_POS,</span>
<span class="gi">+                    ARG_POS,</span>
<span class="gi">+                    ARG_POS,</span>
<span class="gi">+                ]:</span>
<span class="gi">+                    return expand_type_by_instance(setter_type.arg_types[2], t)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._api.fail(f&#39;Unsupported signature for &quot;__set__&quot; in &quot;{t.type.name}&quot;&#39;, context)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._api.fail(f&#39;Unsupported &quot;__set__&quot; in &quot;{t.type.name}&quot;&#39;, context)</span>
<span class="gi">+</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    def add_initializer(</span>
<span class="gi">+        self, fields: list[PydanticModelField], config: ModelConfigData, is_settings: bool, is_root_model: bool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a fields-aware `__init__` method to the class.

<span class="w"> </span>        The added `__init__` will be annotated with types vs. all `Any` depending on the plugin settings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_model_construct_method(self, fields: list[PydanticModelField],</span>
<span class="gd">-        config: ModelConfigData, is_settings: bool) -&gt;None:</span>
<span class="gi">+        if &#39;__init__&#39; in self._cls.info.names and not self._cls.info.names[&#39;__init__&#39;].plugin_generated:</span>
<span class="gi">+            return  # Don&#39;t generate an __init__ if one already exists</span>
<span class="gi">+</span>
<span class="gi">+        typed = self.plugin_config.init_typed</span>
<span class="gi">+        use_alias = config.populate_by_name is not True</span>
<span class="gi">+        requires_dynamic_aliases = bool(config.has_alias_generator and not config.populate_by_name)</span>
<span class="gi">+        args = self.get_field_arguments(</span>
<span class="gi">+            fields,</span>
<span class="gi">+            typed=typed,</span>
<span class="gi">+            requires_dynamic_aliases=requires_dynamic_aliases,</span>
<span class="gi">+            use_alias=use_alias,</span>
<span class="gi">+            is_settings=is_settings,</span>
<span class="gi">+            force_typevars_invariant=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if is_root_model and MYPY_VERSION_TUPLE &lt;= (1, 0, 1):</span>
<span class="gi">+            # convert root argument to positional argument</span>
<span class="gi">+            # This is needed because mypy support for `dataclass_transform` isn&#39;t complete on 1.0.1</span>
<span class="gi">+            args[0].kind = ARG_POS if args[0].kind == ARG_NAMED else ARG_OPT</span>
<span class="gi">+</span>
<span class="gi">+        if is_settings:</span>
<span class="gi">+            base_settings_node = self._api.lookup_fully_qualified(BASESETTINGS_FULLNAME).node</span>
<span class="gi">+            if &#39;__init__&#39; in base_settings_node.names:</span>
<span class="gi">+                base_settings_init_node = base_settings_node.names[&#39;__init__&#39;].node</span>
<span class="gi">+                if base_settings_init_node is not None and base_settings_init_node.type is not None:</span>
<span class="gi">+                    func_type = base_settings_init_node.type</span>
<span class="gi">+                    for arg_idx, arg_name in enumerate(func_type.arg_names):</span>
<span class="gi">+                        if arg_name.startswith(&#39;__&#39;) or not arg_name.startswith(&#39;_&#39;):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        analyzed_variable_type = self._api.anal_type(func_type.arg_types[arg_idx])</span>
<span class="gi">+                        variable = Var(arg_name, analyzed_variable_type)</span>
<span class="gi">+                        args.append(Argument(variable, analyzed_variable_type, None, ARG_OPT))</span>
<span class="gi">+</span>
<span class="gi">+        if not self.should_init_forbid_extra(fields, config):</span>
<span class="gi">+            var = Var(&#39;kwargs&#39;)</span>
<span class="gi">+            args.append(Argument(var, AnyType(TypeOfAny.explicit), None, ARG_STAR2))</span>
<span class="gi">+</span>
<span class="gi">+        add_method(self._api, self._cls, &#39;__init__&#39;, args=args, return_type=NoneType())</span>
<span class="gi">+</span>
<span class="gi">+    def add_model_construct_method(</span>
<span class="gi">+        self, fields: list[PydanticModelField], config: ModelConfigData, is_settings: bool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a fully typed `model_construct` classmethod to the class.

<span class="w"> </span>        Similar to the fields-aware __init__ method, but always uses the field names (not aliases),
<span class="w"> </span>        and does not treat settings fields as optional.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_frozen(self, fields: list[PydanticModelField], api:</span>
<span class="gd">-        SemanticAnalyzerPluginInterface, frozen: bool) -&gt;None:</span>
<span class="gi">+        set_str = self._api.named_type(f&#39;{BUILTINS_NAME}.set&#39;, [self._api.named_type(f&#39;{BUILTINS_NAME}.str&#39;)])</span>
<span class="gi">+        optional_set_str = UnionType([set_str, NoneType()])</span>
<span class="gi">+        fields_set_argument = Argument(Var(&#39;_fields_set&#39;, optional_set_str), optional_set_str, None, ARG_OPT)</span>
<span class="gi">+        with state.strict_optional_set(self._api.options.strict_optional):</span>
<span class="gi">+            args = self.get_field_arguments(</span>
<span class="gi">+                fields, typed=True, requires_dynamic_aliases=False, use_alias=False, is_settings=is_settings</span>
<span class="gi">+            )</span>
<span class="gi">+        if not self.should_init_forbid_extra(fields, config):</span>
<span class="gi">+            var = Var(&#39;kwargs&#39;)</span>
<span class="gi">+            args.append(Argument(var, AnyType(TypeOfAny.explicit), None, ARG_STAR2))</span>
<span class="gi">+</span>
<span class="gi">+        args = [fields_set_argument] + args</span>
<span class="gi">+</span>
<span class="gi">+        add_method(</span>
<span class="gi">+            self._api,</span>
<span class="gi">+            self._cls,</span>
<span class="gi">+            &#39;model_construct&#39;,</span>
<span class="gi">+            args=args,</span>
<span class="gi">+            return_type=fill_typevars(self._cls.info),</span>
<span class="gi">+            is_classmethod=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def set_frozen(self, fields: list[PydanticModelField], api: SemanticAnalyzerPluginInterface, frozen: bool) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Marks all fields as properties so that attempts to set them trigger mypy errors.

<span class="w"> </span>        This is the same approach used by the attrs and dataclasses plugins.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_config_update(self, name: str, arg: Expression, lax_extra: bool</span>
<span class="gd">-        =False) -&gt;(ModelConfigData | None):</span>
<span class="gi">+        info = self._cls.info</span>
<span class="gi">+        for field in fields:</span>
<span class="gi">+            sym_node = info.names.get(field.name)</span>
<span class="gi">+            if sym_node is not None:</span>
<span class="gi">+                var = sym_node.node</span>
<span class="gi">+                if isinstance(var, Var):</span>
<span class="gi">+                    var.is_property = frozen</span>
<span class="gi">+                elif isinstance(var, PlaceholderNode) and not self._api.final_iteration:</span>
<span class="gi">+                    # See https://github.com/pydantic/pydantic/issues/5191 to hit this branch for test coverage</span>
<span class="gi">+                    self._api.defer()</span>
<span class="gi">+                else:  # pragma: no cover</span>
<span class="gi">+                    # I don&#39;t know whether it&#39;s possible to hit this branch, but I&#39;ve added it for safety</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        var_str = str(var)</span>
<span class="gi">+                    except TypeError:</span>
<span class="gi">+                        # This happens for PlaceholderNode; perhaps it will happen for other types in the future..</span>
<span class="gi">+                        var_str = repr(var)</span>
<span class="gi">+                    detail = f&#39;sym_node.node: {var_str} (of type {var.__class__})&#39;</span>
<span class="gi">+                    error_unexpected_behavior(detail, self._api, self._cls)</span>
<span class="gi">+            else:</span>
<span class="gi">+                var = field.to_var(info, api, use_alias=False)</span>
<span class="gi">+                var.info = info</span>
<span class="gi">+                var.is_property = frozen</span>
<span class="gi">+                var._fullname = info.fullname + &#39;.&#39; + var.name</span>
<span class="gi">+                info.names[var.name] = SymbolTableNode(MDEF, var)</span>
<span class="gi">+</span>
<span class="gi">+    def get_config_update(self, name: str, arg: Expression, lax_extra: bool = False) -&gt; ModelConfigData | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Determines the config update due to a single kwarg in the ConfigDict definition.

<span class="w"> </span>        Warns if a tracked config attribute is set to a value the plugin doesn&#39;t know how to interpret (e.g., an int)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name not in self.tracked_config_fields:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if name == &#39;extra&#39;:</span>
<span class="gi">+            if isinstance(arg, StrExpr):</span>
<span class="gi">+                forbid_extra = arg.value == &#39;forbid&#39;</span>
<span class="gi">+            elif isinstance(arg, MemberExpr):</span>
<span class="gi">+                forbid_extra = arg.name == &#39;forbid&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not lax_extra:</span>
<span class="gi">+                    # Only emit an error for other types of `arg` (e.g., `NameExpr`, `ConditionalExpr`, etc.) when</span>
<span class="gi">+                    # reading from a config class, etc. If a ConfigDict is used, then we don&#39;t want to emit an error</span>
<span class="gi">+                    # because you&#39;ll get type checking from the ConfigDict itself.</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # It would be nice if we could introspect the types better otherwise, but I don&#39;t know what the API</span>
<span class="gi">+                    # is to evaluate an expr into its type and then check if that type is compatible with the expected</span>
<span class="gi">+                    # type. Note that you can still get proper type checking via: `model_config = ConfigDict(...)`, just</span>
<span class="gi">+                    # if you don&#39;t use an explicit string, the plugin won&#39;t be able to infer whether extra is forbidden.</span>
<span class="gi">+                    error_invalid_config_value(name, self._api, arg)</span>
<span class="gi">+                return None</span>
<span class="gi">+            return ModelConfigData(forbid_extra=forbid_extra)</span>
<span class="gi">+        if name == &#39;alias_generator&#39;:</span>
<span class="gi">+            has_alias_generator = True</span>
<span class="gi">+            if isinstance(arg, NameExpr) and arg.fullname == &#39;builtins.None&#39;:</span>
<span class="gi">+                has_alias_generator = False</span>
<span class="gi">+            return ModelConfigData(has_alias_generator=has_alias_generator)</span>
<span class="gi">+        if isinstance(arg, NameExpr) and arg.fullname in (&#39;builtins.True&#39;, &#39;builtins.False&#39;):</span>
<span class="gi">+            return ModelConfigData(**{name: arg.fullname == &#39;builtins.True&#39;})</span>
<span class="gi">+        error_invalid_config_value(name, self._api, arg)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def get_has_default(stmt: AssignmentStmt) -&gt;bool:</span>
<span class="gi">+    def get_has_default(stmt: AssignmentStmt) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a boolean indicating whether the field defined in `stmt` is a required field.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expr = stmt.rvalue</span>
<span class="gi">+        if isinstance(expr, TempNode):</span>
<span class="gi">+            # TempNode means annotation-only, so has no default</span>
<span class="gi">+            return False</span>
<span class="gi">+        if isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr) and expr.callee.fullname == FIELD_FULLNAME:</span>
<span class="gi">+            # The &quot;default value&quot; is a call to `Field`; at this point, the field has a default if and only if:</span>
<span class="gi">+            # * there is a positional argument that is not `...`</span>
<span class="gi">+            # * there is a keyword argument named &quot;default&quot; that is not `...`</span>
<span class="gi">+            # * there is a &quot;default_factory&quot; that is not `None`</span>
<span class="gi">+            for arg, name in zip(expr.args, expr.arg_names):</span>
<span class="gi">+                # If name is None, then this arg is the default because it is the only positional argument.</span>
<span class="gi">+                if name is None or name == &#39;default&#39;:</span>
<span class="gi">+                    return arg.__class__ is not EllipsisExpr</span>
<span class="gi">+                if name == &#39;default_factory&#39;:</span>
<span class="gi">+                    return not (isinstance(arg, NameExpr) and arg.fullname == &#39;builtins.None&#39;)</span>
<span class="gi">+            return False</span>
<span class="gi">+        # Has no default if the &quot;default value&quot; is Ellipsis (i.e., `field_name: Annotation = ...`)</span>
<span class="gi">+        return not isinstance(expr, EllipsisExpr)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def get_alias_info(stmt: AssignmentStmt) -&gt;tuple[str | None, bool]:</span>
<span class="gi">+    def get_alias_info(stmt: AssignmentStmt) -&gt; tuple[str | None, bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a pair (alias, has_dynamic_alias), extracted from the declaration of the field defined in `stmt`.

<span class="w"> </span>        `has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal.
<span class="w"> </span>        If `has_dynamic_alias` is True, `alias` will be None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_field_arguments(self, fields: list[PydanticModelField], typed:</span>
<span class="gd">-        bool, use_alias: bool, requires_dynamic_aliases: bool, is_settings:</span>
<span class="gd">-        bool, force_typevars_invariant: bool=False) -&gt;list[Argument]:</span>
<span class="gi">+        expr = stmt.rvalue</span>
<span class="gi">+        if isinstance(expr, TempNode):</span>
<span class="gi">+            # TempNode means annotation-only</span>
<span class="gi">+            return None, False</span>
<span class="gi">+</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr) and expr.callee.fullname == FIELD_FULLNAME</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Assigned value is not a call to pydantic.fields.Field</span>
<span class="gi">+            return None, False</span>
<span class="gi">+</span>
<span class="gi">+        for i, arg_name in enumerate(expr.arg_names):</span>
<span class="gi">+            if arg_name != &#39;alias&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            arg = expr.args[i]</span>
<span class="gi">+            if isinstance(arg, StrExpr):</span>
<span class="gi">+                return arg.value, False</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None, True</span>
<span class="gi">+        return None, False</span>
<span class="gi">+</span>
<span class="gi">+    def get_field_arguments(</span>
<span class="gi">+        self,</span>
<span class="gi">+        fields: list[PydanticModelField],</span>
<span class="gi">+        typed: bool,</span>
<span class="gi">+        use_alias: bool,</span>
<span class="gi">+        requires_dynamic_aliases: bool,</span>
<span class="gi">+        is_settings: bool,</span>
<span class="gi">+        force_typevars_invariant: bool = False,</span>
<span class="gi">+    ) -&gt; list[Argument]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Helper function used during the construction of the `__init__` and `model_construct` method signatures.

<span class="w"> </span>        Returns a list of mypy Argument instances for use in the generated signatures.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def should_init_forbid_extra(self, fields: list[PydanticModelField],</span>
<span class="gd">-        config: ModelConfigData) -&gt;bool:</span>
<span class="gi">+        info = self._cls.info</span>
<span class="gi">+        arguments = [</span>
<span class="gi">+            field.to_argument(</span>
<span class="gi">+                info,</span>
<span class="gi">+                typed=typed,</span>
<span class="gi">+                force_optional=requires_dynamic_aliases or is_settings,</span>
<span class="gi">+                use_alias=use_alias,</span>
<span class="gi">+                api=self._api,</span>
<span class="gi">+                force_typevars_invariant=force_typevars_invariant,</span>
<span class="gi">+            )</span>
<span class="gi">+            for field in fields</span>
<span class="gi">+            if not (use_alias and field.has_dynamic_alias)</span>
<span class="gi">+        ]</span>
<span class="gi">+        return arguments</span>
<span class="gi">+</span>
<span class="gi">+    def should_init_forbid_extra(self, fields: list[PydanticModelField], config: ModelConfigData) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Indicates whether the generated `__init__` should get a `**kwargs` at the end of its signature.

<span class="w"> </span>        We disallow arbitrary kwargs if the extra config setting is &quot;forbid&quot;, or if the plugin config says to,
<span class="w"> </span>        *unless* a required dynamic alias is present (since then we can&#39;t determine a valid signature).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not config.populate_by_name:</span>
<span class="gi">+            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):</span>
<span class="gi">+                return False</span>
<span class="gi">+        if config.forbid_extra:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return self.plugin_config.init_forbid_extra</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def is_dynamic_alias_present(fields: list[PydanticModelField],</span>
<span class="gd">-        has_alias_generator: bool) -&gt;bool:</span>
<span class="gi">+    def is_dynamic_alias_present(fields: list[PydanticModelField], has_alias_generator: bool) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns whether any fields on the model have a &quot;dynamic alias&quot;, i.e., an alias that cannot be
<span class="w"> </span>        determined during static analysis.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for field in fields:</span>
<span class="gi">+            if field.has_dynamic_alias:</span>
<span class="gi">+                return True</span>
<span class="gi">+        if has_alias_generator:</span>
<span class="gi">+            for field in fields:</span>
<span class="gi">+                if field.alias is None:</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return False</span>


<span class="w"> </span>class ModelConfigData:
<span class="w"> </span>    &quot;&quot;&quot;Pydantic mypy plugin model config class.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, forbid_extra: (bool | None)=None, frozen: (bool |</span>
<span class="gd">-        None)=None, from_attributes: (bool | None)=None, populate_by_name:</span>
<span class="gd">-        (bool | None)=None, has_alias_generator: (bool | None)=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        forbid_extra: bool | None = None,</span>
<span class="gi">+        frozen: bool | None = None,</span>
<span class="gi">+        from_attributes: bool | None = None,</span>
<span class="gi">+        populate_by_name: bool | None = None,</span>
<span class="gi">+        has_alias_generator: bool | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.forbid_extra = forbid_extra
<span class="w"> </span>        self.frozen = frozen
<span class="w"> </span>        self.from_attributes = from_attributes
<span class="w"> </span>        self.populate_by_name = populate_by_name
<span class="w"> </span>        self.has_alias_generator = has_alias_generator

<span class="gd">-    def get_values_dict(self) -&gt;dict[str, Any]:</span>
<span class="gi">+    def get_values_dict(self) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a dict of Pydantic model config names to their values.

<span class="w"> </span>        It includes the config if config value is not `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {k: v for k, v in self.__dict__.items() if v is not None}</span>

<span class="gd">-    def update(self, config: (ModelConfigData | None)) -&gt;None:</span>
<span class="gi">+    def update(self, config: ModelConfigData | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update Pydantic model config values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if config is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        for k, v in config.get_values_dict().items():</span>
<span class="gi">+            setattr(self, k, v)</span>

<span class="gd">-    def setdefault(self, key: str, value: Any) -&gt;None:</span>
<span class="gi">+    def setdefault(self, key: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set default value for Pydantic model config if config value is `None`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if getattr(self, key) is None:</span>
<span class="gi">+            setattr(self, key, value)</span>


<span class="gd">-ERROR_ORM = ErrorCode(&#39;pydantic-orm&#39;, &#39;Invalid from_attributes call&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gi">+ERROR_ORM = ErrorCode(&#39;pydantic-orm&#39;, &#39;Invalid from_attributes call&#39;, &#39;Pydantic&#39;)</span>
<span class="w"> </span>ERROR_CONFIG = ErrorCode(&#39;pydantic-config&#39;, &#39;Invalid config value&#39;, &#39;Pydantic&#39;)
<span class="gd">-ERROR_ALIAS = ErrorCode(&#39;pydantic-alias&#39;, &#39;Dynamic alias disallowed&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gd">-ERROR_UNEXPECTED = ErrorCode(&#39;pydantic-unexpected&#39;, &#39;Unexpected behavior&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gd">-ERROR_UNTYPED = ErrorCode(&#39;pydantic-field&#39;, &#39;Untyped field disallowed&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gd">-ERROR_FIELD_DEFAULTS = ErrorCode(&#39;pydantic-field&#39;, &#39;Invalid Field defaults&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gd">-ERROR_EXTRA_FIELD_ROOT_MODEL = ErrorCode(&#39;pydantic-field&#39;,</span>
<span class="gd">-    &#39;Extra field on RootModel subclass&#39;, &#39;Pydantic&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def error_from_attributes(model_name: str, api: CheckerPluginInterface,</span>
<span class="gd">-    context: Context) -&gt;None:</span>
<span class="gi">+ERROR_ALIAS = ErrorCode(&#39;pydantic-alias&#39;, &#39;Dynamic alias disallowed&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+ERROR_UNEXPECTED = ErrorCode(&#39;pydantic-unexpected&#39;, &#39;Unexpected behavior&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+ERROR_UNTYPED = ErrorCode(&#39;pydantic-field&#39;, &#39;Untyped field disallowed&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+ERROR_FIELD_DEFAULTS = ErrorCode(&#39;pydantic-field&#39;, &#39;Invalid Field defaults&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+ERROR_EXTRA_FIELD_ROOT_MODEL = ErrorCode(&#39;pydantic-field&#39;, &#39;Extra field on RootModel subclass&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_from_attributes(model_name: str, api: CheckerPluginInterface, context: Context) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Emits an error when the model does not have `from_attributes=True`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    api.fail(f&#39;&quot;{model_name}&quot; does not have from_attributes=True&#39;, context, code=ERROR_ORM)</span>


<span class="gd">-def error_invalid_config_value(name: str, api:</span>
<span class="gd">-    SemanticAnalyzerPluginInterface, context: Context) -&gt;None:</span>
<span class="gi">+def error_invalid_config_value(name: str, api: SemanticAnalyzerPluginInterface, context: Context) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Emits an error when the config value is invalid.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    api.fail(f&#39;Invalid value for &quot;Config.{name}&quot;&#39;, context, code=ERROR_CONFIG)</span>


<span class="gd">-def error_required_dynamic_aliases(api: SemanticAnalyzerPluginInterface,</span>
<span class="gd">-    context: Context) -&gt;None:</span>
<span class="gi">+def error_required_dynamic_aliases(api: SemanticAnalyzerPluginInterface, context: Context) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Emits required dynamic aliases error.

<span class="w"> </span>    This will be called when `warn_required_dynamic_aliases=True`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    api.fail(&#39;Required dynamic aliases disallowed&#39;, context, code=ERROR_ALIAS)</span>


<span class="gd">-def error_unexpected_behavior(detail: str, api: (CheckerPluginInterface |</span>
<span class="gd">-    SemanticAnalyzerPluginInterface), context: Context) -&gt;None:</span>
<span class="gi">+def error_unexpected_behavior(</span>
<span class="gi">+    detail: str, api: CheckerPluginInterface | SemanticAnalyzerPluginInterface, context: Context</span>
<span class="gi">+) -&gt; None:  # pragma: no cover</span>
<span class="w"> </span>    &quot;&quot;&quot;Emits unexpected behavior error.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Can&#39;t think of a good way to test this, but I confirmed it renders as desired by adding to a non-error path</span>
<span class="gi">+    link = &#39;https://github.com/pydantic/pydantic/issues/new/choose&#39;</span>
<span class="gi">+    full_message = f&#39;The pydantic mypy plugin ran into unexpected behavior: {detail}\n&#39;</span>
<span class="gi">+    full_message += f&#39;Please consider reporting this bug at {link} so we can try to fix it!&#39;</span>
<span class="gi">+    api.fail(full_message, context, code=ERROR_UNEXPECTED)</span>


<span class="gd">-def error_untyped_fields(api: SemanticAnalyzerPluginInterface, context: Context</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+def error_untyped_fields(api: SemanticAnalyzerPluginInterface, context: Context) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Emits an error when there is an untyped field in the model.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    api.fail(&#39;Untyped fields disallowed&#39;, context, code=ERROR_UNTYPED)</span>


<span class="gd">-def error_extra_fields_on_root_model(api: CheckerPluginInterface, context:</span>
<span class="gd">-    Context) -&gt;None:</span>
<span class="gi">+def error_extra_fields_on_root_model(api: CheckerPluginInterface, context: Context) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Emits an error when there is more than just a root field defined for a subclass of RootModel.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    api.fail(&#39;Only `root` is allowed as a field of a `RootModel`&#39;, context, code=ERROR_EXTRA_FIELD_ROOT_MODEL)</span>


<span class="gd">-def error_default_and_default_factory_specified(api: CheckerPluginInterface,</span>
<span class="gd">-    context: Context) -&gt;None:</span>
<span class="gi">+def error_default_and_default_factory_specified(api: CheckerPluginInterface, context: Context) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Emits an error when `Field` has both `default` and `default_factory` together.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def add_method(api: (SemanticAnalyzerPluginInterface |</span>
<span class="gd">-    CheckerPluginInterface), cls: ClassDef, name: str, args: list[Argument],</span>
<span class="gd">-    return_type: Type, self_type: (Type | None)=None, tvar_def: (TypeVarDef |</span>
<span class="gd">-    None)=None, is_classmethod: bool=False) -&gt;None:</span>
<span class="gi">+    api.fail(&#39;Field default and default_factory cannot be specified together&#39;, context, code=ERROR_FIELD_DEFAULTS)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add_method(</span>
<span class="gi">+    api: SemanticAnalyzerPluginInterface | CheckerPluginInterface,</span>
<span class="gi">+    cls: ClassDef,</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    args: list[Argument],</span>
<span class="gi">+    return_type: Type,</span>
<span class="gi">+    self_type: Type | None = None,</span>
<span class="gi">+    tvar_def: TypeVarDef | None = None,</span>
<span class="gi">+    is_classmethod: bool = False,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Very closely related to `mypy.plugins.common.add_method_to_class`, with a few pydantic-specific changes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_toml(config_file: str) -&gt;(dict[str, Any] | None):</span>
<span class="gi">+    info = cls.info</span>
<span class="gi">+</span>
<span class="gi">+    # First remove any previously generated methods with the same name</span>
<span class="gi">+    # to avoid clashes and problems in the semantic analyzer.</span>
<span class="gi">+    if name in info.names:</span>
<span class="gi">+        sym = info.names[name]</span>
<span class="gi">+        if sym.plugin_generated and isinstance(sym.node, FuncDef):</span>
<span class="gi">+            cls.defs.body.remove(sym.node)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(api, SemanticAnalyzerPluginInterface):</span>
<span class="gi">+        function_type = api.named_type(&#39;builtins.function&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        function_type = api.named_generic_type(&#39;builtins.function&#39;, [])</span>
<span class="gi">+</span>
<span class="gi">+    if is_classmethod:</span>
<span class="gi">+        self_type = self_type or TypeType(fill_typevars(info))</span>
<span class="gi">+        first = [Argument(Var(&#39;_cls&#39;), self_type, None, ARG_POS, True)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        self_type = self_type or fill_typevars(info)</span>
<span class="gi">+        # `self` is positional *ONLY* here, but this can&#39;t be expressed</span>
<span class="gi">+        # fully in the mypy internal API. ARG_POS is the closest we can get.</span>
<span class="gi">+        # Using ARG_POS will, however, give mypy errors if a `self` field</span>
<span class="gi">+        # is present on a model:</span>
<span class="gi">+        #</span>
<span class="gi">+        #     Name &quot;self&quot; already defined (possibly by an import)  [no-redef]</span>
<span class="gi">+        #</span>
<span class="gi">+        # As a workaround, we give this argument a name that will</span>
<span class="gi">+        # never conflict. By its positional nature, this name will not</span>
<span class="gi">+        # be used or exposed to users.</span>
<span class="gi">+        first = [Argument(Var(&#39;__pydantic_self__&#39;), self_type, None, ARG_POS)]</span>
<span class="gi">+    args = first + args</span>
<span class="gi">+</span>
<span class="gi">+    arg_types, arg_names, arg_kinds = [], [], []</span>
<span class="gi">+    for arg in args:</span>
<span class="gi">+        assert arg.type_annotation, &#39;All arguments must be fully typed.&#39;</span>
<span class="gi">+        arg_types.append(arg.type_annotation)</span>
<span class="gi">+        arg_names.append(arg.variable.name)</span>
<span class="gi">+        arg_kinds.append(arg.kind)</span>
<span class="gi">+</span>
<span class="gi">+    signature = CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)</span>
<span class="gi">+    if tvar_def:</span>
<span class="gi">+        signature.variables = [tvar_def]</span>
<span class="gi">+</span>
<span class="gi">+    func = FuncDef(name, args, Block([PassStmt()]))</span>
<span class="gi">+    func.info = info</span>
<span class="gi">+    func.type = set_callable_name(signature, func)</span>
<span class="gi">+    func.is_class = is_classmethod</span>
<span class="gi">+    func._fullname = info.fullname + &#39;.&#39; + name</span>
<span class="gi">+    func.line = info.line</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: we would like the plugin generated node to dominate, but we still</span>
<span class="gi">+    # need to keep any existing definitions so they get semantically analyzed.</span>
<span class="gi">+    if name in info.names:</span>
<span class="gi">+        # Get a nice unique name instead.</span>
<span class="gi">+        r_name = get_unique_redefinition_name(name, info.names)</span>
<span class="gi">+        info.names[r_name] = info.names[name]</span>
<span class="gi">+</span>
<span class="gi">+    # Add decorator for is_classmethod</span>
<span class="gi">+    # The dataclasses plugin claims this is unnecessary for classmethods, but not including it results in a</span>
<span class="gi">+    # signature incompatible with the superclass, which causes mypy errors to occur for every subclass of BaseModel.</span>
<span class="gi">+    if is_classmethod:</span>
<span class="gi">+        func.is_decorated = True</span>
<span class="gi">+        v = Var(name, func.type)</span>
<span class="gi">+        v.info = info</span>
<span class="gi">+        v._fullname = func._fullname</span>
<span class="gi">+        v.is_classmethod = True</span>
<span class="gi">+        dec = Decorator(func, [NameExpr(&#39;classmethod&#39;)], v)</span>
<span class="gi">+        dec.line = info.line</span>
<span class="gi">+        sym = SymbolTableNode(MDEF, dec)</span>
<span class="gi">+    else:</span>
<span class="gi">+        sym = SymbolTableNode(MDEF, func)</span>
<span class="gi">+    sym.plugin_generated = True</span>
<span class="gi">+    info.names[name] = sym</span>
<span class="gi">+</span>
<span class="gi">+    info.defn.defs.body.append(func)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_toml(config_file: str) -&gt; dict[str, Any] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a dict of config keys to values.

<span class="w"> </span>    It reads configs from toml file and returns `None` if the file is not a toml file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not config_file.endswith(&#39;.toml&#39;):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if sys.version_info &gt;= (3, 11):</span>
<span class="gi">+        import tomllib as toml_</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            import tomli as toml_</span>
<span class="gi">+        except ImportError:  # pragma: no cover</span>
<span class="gi">+            import warnings</span>
<span class="gi">+</span>
<span class="gi">+            warnings.warn(&#39;No TOML parser installed, cannot read configuration from `pyproject.toml`.&#39;)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    with open(config_file, &#39;rb&#39;) as rf:</span>
<span class="gi">+        return toml_.load(rf)</span>
<span class="gh">diff --git a/pydantic/networks.py b/pydantic/networks.py</span>
<span class="gh">index ae44dc9a8..830ab3992 100644</span>
<span class="gd">--- a/pydantic/networks.py</span>
<span class="gi">+++ b/pydantic/networks.py</span>
<span class="gu">@@ -1,28 +1,56 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The networks module contains types for common network-related fields.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses as _dataclasses
<span class="w"> </span>import re
<span class="w"> </span>from importlib.metadata import version
<span class="w"> </span>from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import MultiHostUrl, PydanticCustomError, Url, core_schema
<span class="w"> </span>from typing_extensions import Annotated, Self, TypeAlias
<span class="gi">+</span>
<span class="w"> </span>from ._internal import _fields, _repr, _schema_generation_shared
<span class="w"> </span>from ._migration import getattr_migration
<span class="w"> </span>from .annotated_handlers import GetCoreSchemaHandler
<span class="w"> </span>from .json_schema import JsonSchemaValue
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    import email_validator
<span class="gd">-    NetworkType: TypeAlias = (</span>
<span class="gd">-        &#39;str | bytes | int | tuple[str | bytes | int, str | int]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    NetworkType: TypeAlias = &#39;str | bytes | int | tuple[str | bytes | int, str | int]&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    email_validator = None
<span class="gd">-__all__ = [&#39;AnyUrl&#39;, &#39;AnyHttpUrl&#39;, &#39;FileUrl&#39;, &#39;FtpUrl&#39;, &#39;HttpUrl&#39;,</span>
<span class="gd">-    &#39;WebsocketUrl&#39;, &#39;AnyWebsocketUrl&#39;, &#39;UrlConstraints&#39;, &#39;EmailStr&#39;,</span>
<span class="gd">-    &#39;NameEmail&#39;, &#39;IPvAnyAddress&#39;, &#39;IPvAnyInterface&#39;, &#39;IPvAnyNetwork&#39;,</span>
<span class="gd">-    &#39;PostgresDsn&#39;, &#39;CockroachDsn&#39;, &#39;AmqpDsn&#39;, &#39;RedisDsn&#39;, &#39;MongoDsn&#39;,</span>
<span class="gd">-    &#39;KafkaDsn&#39;, &#39;NatsDsn&#39;, &#39;validate_email&#39;, &#39;MySQLDsn&#39;, &#39;MariaDBDsn&#39;,</span>
<span class="gd">-    &#39;ClickHouseDsn&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &#39;AnyUrl&#39;,</span>
<span class="gi">+    &#39;AnyHttpUrl&#39;,</span>
<span class="gi">+    &#39;FileUrl&#39;,</span>
<span class="gi">+    &#39;FtpUrl&#39;,</span>
<span class="gi">+    &#39;HttpUrl&#39;,</span>
<span class="gi">+    &#39;WebsocketUrl&#39;,</span>
<span class="gi">+    &#39;AnyWebsocketUrl&#39;,</span>
<span class="gi">+    &#39;UrlConstraints&#39;,</span>
<span class="gi">+    &#39;EmailStr&#39;,</span>
<span class="gi">+    &#39;NameEmail&#39;,</span>
<span class="gi">+    &#39;IPvAnyAddress&#39;,</span>
<span class="gi">+    &#39;IPvAnyInterface&#39;,</span>
<span class="gi">+    &#39;IPvAnyNetwork&#39;,</span>
<span class="gi">+    &#39;PostgresDsn&#39;,</span>
<span class="gi">+    &#39;CockroachDsn&#39;,</span>
<span class="gi">+    &#39;AmqpDsn&#39;,</span>
<span class="gi">+    &#39;RedisDsn&#39;,</span>
<span class="gi">+    &#39;MongoDsn&#39;,</span>
<span class="gi">+    &#39;KafkaDsn&#39;,</span>
<span class="gi">+    &#39;NatsDsn&#39;,</span>
<span class="gi">+    &#39;validate_email&#39;,</span>
<span class="gi">+    &#39;MySQLDsn&#39;,</span>
<span class="gi">+    &#39;MariaDBDsn&#39;,</span>
<span class="gi">+    &#39;ClickHouseDsn&#39;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@_dataclasses.dataclass
<span class="gu">@@ -37,6 +65,7 @@ class UrlConstraints(_fields.PydanticMetadata):</span>
<span class="w"> </span>        default_port: The default port. Defaults to `None`.
<span class="w"> </span>        default_path: The default path. Defaults to `None`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    max_length: int | None = None
<span class="w"> </span>    allowed_schemes: list[str] | None = None
<span class="w"> </span>    host_required: bool | None = None
<span class="gu">@@ -44,10 +73,17 @@ class UrlConstraints(_fields.PydanticMetadata):</span>
<span class="w"> </span>    default_port: int | None = None
<span class="w"> </span>    default_path: str | None = None

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.max_length, tuple(self.allowed_schemes) if self.</span>
<span class="gd">-            allowed_schemes is not None else None, self.host_required, self</span>
<span class="gd">-            .default_host, self.default_port, self.default_path))</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash(</span>
<span class="gi">+            (</span>
<span class="gi">+                self.max_length,</span>
<span class="gi">+                tuple(self.allowed_schemes) if self.allowed_schemes is not None else None,</span>
<span class="gi">+                self.host_required,</span>
<span class="gi">+                self.default_host,</span>
<span class="gi">+                self.default_port,</span>
<span class="gi">+                self.default_path,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>


<span class="w"> </span>AnyUrl = Url
<span class="gu">@@ -75,8 +111,7 @@ AnyHttpUrl = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;http&#39;, &#39;https&#39;])]</span>
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-HttpUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=[</span>
<span class="gd">-    &#39;http&#39;, &#39;https&#39;])]</span>
<span class="gi">+HttpUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=[&#39;http&#39;, &#39;https&#39;])]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any http or https URL.

<span class="w"> </span>* TLD not required
<span class="gu">@@ -159,8 +194,7 @@ AnyWebsocketUrl = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;ws&#39;, &#39;wss&#39;])]</span>
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-WebsocketUrl = Annotated[Url, UrlConstraints(max_length=2083,</span>
<span class="gd">-    allowed_schemes=[&#39;ws&#39;, &#39;wss&#39;])]</span>
<span class="gi">+WebsocketUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=[&#39;ws&#39;, &#39;wss&#39;])]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any ws or wss URL.

<span class="w"> </span>* TLD not required
<span class="gu">@@ -178,11 +212,23 @@ FtpUrl = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;ftp&#39;])]</span>
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-PostgresDsn = Annotated[MultiHostUrl, UrlConstraints(host_required=True,</span>
<span class="gd">-    allowed_schemes=[&#39;postgres&#39;, &#39;postgresql&#39;, &#39;postgresql+asyncpg&#39;,</span>
<span class="gd">-    &#39;postgresql+pg8000&#39;, &#39;postgresql+psycopg&#39;, &#39;postgresql+psycopg2&#39;,</span>
<span class="gd">-    &#39;postgresql+psycopg2cffi&#39;, &#39;postgresql+py-postgresql&#39;,</span>
<span class="gd">-    &#39;postgresql+pygresql&#39;])]</span>
<span class="gi">+PostgresDsn = Annotated[</span>
<span class="gi">+    MultiHostUrl,</span>
<span class="gi">+    UrlConstraints(</span>
<span class="gi">+        host_required=True,</span>
<span class="gi">+        allowed_schemes=[</span>
<span class="gi">+            &#39;postgres&#39;,</span>
<span class="gi">+            &#39;postgresql&#39;,</span>
<span class="gi">+            &#39;postgresql+asyncpg&#39;,</span>
<span class="gi">+            &#39;postgresql+pg8000&#39;,</span>
<span class="gi">+            &#39;postgresql+psycopg&#39;,</span>
<span class="gi">+            &#39;postgresql+psycopg2&#39;,</span>
<span class="gi">+            &#39;postgresql+psycopg2cffi&#39;,</span>
<span class="gi">+            &#39;postgresql+py-postgresql&#39;,</span>
<span class="gi">+            &#39;postgresql+pygresql&#39;,</span>
<span class="gi">+        ],</span>
<span class="gi">+    ),</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any Postgres DSN.

<span class="w"> </span>* User info required
<span class="gu">@@ -241,9 +287,18 @@ except ValidationError as e:</span>
<span class="w"> </span>    &#39;&#39;&#39;
<span class="w"> </span>```
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-CockroachDsn = Annotated[Url, UrlConstraints(host_required=True,</span>
<span class="gd">-    allowed_schemes=[&#39;cockroachdb&#39;, &#39;cockroachdb+psycopg2&#39;,</span>
<span class="gd">-    &#39;cockroachdb+asyncpg&#39;])]</span>
<span class="gi">+</span>
<span class="gi">+CockroachDsn = Annotated[</span>
<span class="gi">+    Url,</span>
<span class="gi">+    UrlConstraints(</span>
<span class="gi">+        host_required=True,</span>
<span class="gi">+        allowed_schemes=[</span>
<span class="gi">+            &#39;cockroachdb&#39;,</span>
<span class="gi">+            &#39;cockroachdb+psycopg2&#39;,</span>
<span class="gi">+            &#39;cockroachdb+asyncpg&#39;,</span>
<span class="gi">+        ],</span>
<span class="gi">+    ),</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any Cockroach DSN.

<span class="w"> </span>* User info required
<span class="gu">@@ -257,16 +312,17 @@ AmqpDsn = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;amqp&#39;, &#39;amqps&#39;])]</span>
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-RedisDsn = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;redis&#39;, &#39;rediss&#39;</span>
<span class="gd">-    ], default_host=&#39;localhost&#39;, default_port=6379, default_path=&#39;/0&#39;)]</span>
<span class="gi">+RedisDsn = Annotated[</span>
<span class="gi">+    Url,</span>
<span class="gi">+    UrlConstraints(allowed_schemes=[&#39;redis&#39;, &#39;rediss&#39;], default_host=&#39;localhost&#39;, default_port=6379, default_path=&#39;/0&#39;),</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any Redis DSN.

<span class="w"> </span>* User info required
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required (e.g., `rediss://:pass@localhost`)
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-MongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=[</span>
<span class="gd">-    &#39;mongodb&#39;, &#39;mongodb+srv&#39;], default_port=27017)]</span>
<span class="gi">+MongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=[&#39;mongodb&#39;, &#39;mongodb+srv&#39;], default_port=27017)]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any MongoDB DSN.

<span class="w"> </span>* User info not required
<span class="gu">@@ -274,16 +330,16 @@ MongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=[</span>
<span class="w"> </span>* Port not required
<span class="w"> </span>* User info may be passed without user part (e.g., `mongodb://mongodb0.example.com:27017`).
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-KafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;kafka&#39;],</span>
<span class="gd">-    default_host=&#39;localhost&#39;, default_port=9092)]</span>
<span class="gi">+KafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;kafka&#39;], default_host=&#39;localhost&#39;, default_port=9092)]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any Kafka DSN.

<span class="w"> </span>* User info required
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-NatsDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=[&#39;nats&#39;,</span>
<span class="gd">-    &#39;tls&#39;, &#39;ws&#39;], default_host=&#39;localhost&#39;, default_port=4222)]</span>
<span class="gi">+NatsDsn = Annotated[</span>
<span class="gi">+    MultiHostUrl, UrlConstraints(allowed_schemes=[&#39;nats&#39;, &#39;tls&#39;, &#39;ws&#39;], default_host=&#39;localhost&#39;, default_port=4222)</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any NATS DSN.

<span class="w"> </span>NATS is a connective technology built for the ever increasingly hyper-connected world.
<span class="gu">@@ -291,38 +347,71 @@ It is a single technology that enables applications to securely communicate acro</span>
<span class="w"> </span>any combination of cloud vendors, on-premise, edge, web and mobile, and devices.
<span class="w"> </span>More: https://nats.io
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-MySQLDsn = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;mysql&#39;,</span>
<span class="gd">-    &#39;mysql+mysqlconnector&#39;, &#39;mysql+aiomysql&#39;, &#39;mysql+asyncmy&#39;,</span>
<span class="gd">-    &#39;mysql+mysqldb&#39;, &#39;mysql+pymysql&#39;, &#39;mysql+cymysql&#39;, &#39;mysql+pyodbc&#39;],</span>
<span class="gd">-    default_port=3306)]</span>
<span class="gi">+MySQLDsn = Annotated[</span>
<span class="gi">+    Url,</span>
<span class="gi">+    UrlConstraints(</span>
<span class="gi">+        allowed_schemes=[</span>
<span class="gi">+            &#39;mysql&#39;,</span>
<span class="gi">+            &#39;mysql+mysqlconnector&#39;,</span>
<span class="gi">+            &#39;mysql+aiomysql&#39;,</span>
<span class="gi">+            &#39;mysql+asyncmy&#39;,</span>
<span class="gi">+            &#39;mysql+mysqldb&#39;,</span>
<span class="gi">+            &#39;mysql+pymysql&#39;,</span>
<span class="gi">+            &#39;mysql+cymysql&#39;,</span>
<span class="gi">+            &#39;mysql+pyodbc&#39;,</span>
<span class="gi">+        ],</span>
<span class="gi">+        default_port=3306,</span>
<span class="gi">+    ),</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any MySQL DSN.

<span class="w"> </span>* User info required
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-MariaDBDsn = Annotated[Url, UrlConstraints(allowed_schemes=[&#39;mariadb&#39;,</span>
<span class="gd">-    &#39;mariadb+mariadbconnector&#39;, &#39;mariadb+pymysql&#39;], default_port=3306)]</span>
<span class="gi">+MariaDBDsn = Annotated[</span>
<span class="gi">+    Url,</span>
<span class="gi">+    UrlConstraints(</span>
<span class="gi">+        allowed_schemes=[&#39;mariadb&#39;, &#39;mariadb+mariadbconnector&#39;, &#39;mariadb+pymysql&#39;],</span>
<span class="gi">+        default_port=3306,</span>
<span class="gi">+    ),</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any MariaDB DSN.

<span class="w"> </span>* User info required
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-ClickHouseDsn = Annotated[Url, UrlConstraints(allowed_schemes=[</span>
<span class="gd">-    &#39;clickhouse+native&#39;, &#39;clickhouse+asynch&#39;], default_host=&#39;localhost&#39;,</span>
<span class="gd">-    default_port=9000)]</span>
<span class="gi">+ClickHouseDsn = Annotated[</span>
<span class="gi">+    Url,</span>
<span class="gi">+    UrlConstraints(</span>
<span class="gi">+        allowed_schemes=[&#39;clickhouse+native&#39;, &#39;clickhouse+asynch&#39;],</span>
<span class="gi">+        default_host=&#39;localhost&#39;,</span>
<span class="gi">+        default_port=9000,</span>
<span class="gi">+    ),</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;A type that will accept any ClickHouse DSN.

<span class="w"> </span>* User info required
<span class="w"> </span>* TLD not required
<span class="w"> </span>* Host required
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def import_email_validator() -&gt; None:</span>
<span class="gi">+    global email_validator</span>
<span class="gi">+    try:</span>
<span class="gi">+        import email_validator</span>
<span class="gi">+    except ImportError as e:</span>
<span class="gi">+        raise ImportError(&#39;email-validator is not installed, run `pip install pydantic[email]`&#39;) from e</span>
<span class="gi">+    if not version(&#39;email-validator&#39;).partition(&#39;.&#39;)[0] == &#39;2&#39;:</span>
<span class="gi">+        raise ImportError(&#39;email-validator version &gt;= 2.0 required, run pip install -U email-validator&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    EmailStr = Annotated[str, ...]
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class EmailStr:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Info:
<span class="gu">@@ -344,23 +433,29 @@ else:</span>
<span class="w"> </span>        print(Model(email=&#39;contact@mail.com&#39;))
<span class="w"> </span>        #&gt; email=&#39;contact@mail.com&#39;
<span class="w"> </span>        ```
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &quot;&quot;&quot;  # noqa: D212</span>

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, _source: type[Any], _handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            _source: type[Any],</span>
<span class="gi">+            _handler: GetCoreSchemaHandler,</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            import_email_validator()
<span class="gd">-            return core_schema.no_info_after_validator_function(cls.</span>
<span class="gd">-                _validate, core_schema.str_schema())</span>
<span class="gi">+            return core_schema.no_info_after_validator_function(cls._validate, core_schema.str_schema())</span>

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_json_schema__(cls, core_schema: core_schema.</span>
<span class="gd">-            CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gd">-            ) -&gt;JsonSchemaValue:</span>
<span class="gi">+        def __get_pydantic_json_schema__(</span>
<span class="gi">+            cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gi">+        ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>            field_schema = handler(core_schema)
<span class="w"> </span>            field_schema.update(type=&#39;string&#39;, format=&#39;email&#39;)
<span class="w"> </span>            return field_schema

<span class="gi">+        @classmethod</span>
<span class="gi">+        def _validate(cls, input_value: str, /) -&gt; str:</span>
<span class="gi">+            return validate_email(input_value)[1]</span>
<span class="gi">+</span>

<span class="w"> </span>class NameEmail(_repr.Representation):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -396,40 +491,58 @@ class NameEmail(_repr.Representation):</span>
<span class="w"> </span>    print(user.email.name)
<span class="w"> </span>    #&gt; fred.bloggs
<span class="w"> </span>    ```
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;  # noqa: D212</span>
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = &#39;name&#39;, &#39;email&#39;

<span class="w"> </span>    def __init__(self, name: str, email: str):
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.email = email

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, NameEmail) and (self.name, self.email) == (</span>
<span class="gd">-            other.name, other.email)</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, NameEmail) and (self.name, self.email) == (other.name, other.email)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_json_schema__(cls, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        field_schema = handler(core_schema)
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;name-email&#39;)
<span class="w"> </span>        return field_schema

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, _source: type[Any], _handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        _source: type[Any],</span>
<span class="gi">+        _handler: GetCoreSchemaHandler,</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        import_email_validator()
<span class="gd">-        return core_schema.no_info_after_validator_function(cls._validate,</span>
<span class="gd">-            core_schema.json_or_python_schema(json_schema=core_schema.</span>
<span class="gd">-            str_schema(), python_schema=core_schema.union_schema([</span>
<span class="gd">-            core_schema.is_instance_schema(cls), core_schema.str_schema()],</span>
<span class="gd">-            custom_error_type=&#39;name_email_type&#39;, custom_error_message=</span>
<span class="gd">-            &#39;Input is not a valid NameEmail&#39;), serialization=core_schema.</span>
<span class="gd">-            to_string_ser_schema()))</span>
<span class="gd">-</span>
<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+        return core_schema.no_info_after_validator_function(</span>
<span class="gi">+            cls._validate,</span>
<span class="gi">+            core_schema.json_or_python_schema(</span>
<span class="gi">+                json_schema=core_schema.str_schema(),</span>
<span class="gi">+                python_schema=core_schema.union_schema(</span>
<span class="gi">+                    [core_schema.is_instance_schema(cls), core_schema.str_schema()],</span>
<span class="gi">+                    custom_error_type=&#39;name_email_type&#39;,</span>
<span class="gi">+                    custom_error_message=&#39;Input is not a valid NameEmail&#39;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                serialization=core_schema.to_string_ser_schema(),</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _validate(cls, input_value: Self | str, /) -&gt; Self:</span>
<span class="gi">+        if isinstance(input_value, str):</span>
<span class="gi">+            name, email = validate_email(input_value)</span>
<span class="gi">+            return cls(name, email)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return input_value</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        if &#39;@&#39; in self.name:
<span class="w"> </span>            return f&#39;&quot;{self.name}&quot; &lt;{self.email}&gt;&#39;
<span class="gi">+</span>
<span class="w"> </span>        return f&#39;{self.name} &lt;{self.email}&gt;&#39;


<span class="gu">@@ -462,109 +575,149 @@ class IPvAnyAddress:</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="gd">-    def __new__(cls, value: Any) -&gt;(IPv4Address | IPv6Address):</span>
<span class="gi">+    def __new__(cls, value: Any) -&gt; IPv4Address | IPv6Address:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate an IPv4 or IPv6 address.&quot;&quot;&quot;
<span class="w"> </span>        try:
<span class="w"> </span>            return IPv4Address(value)
<span class="w"> </span>        except ValueError:
<span class="w"> </span>            pass
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return IPv6Address(value)
<span class="w"> </span>        except ValueError:
<span class="gd">-            raise PydanticCustomError(&#39;ip_any_address&#39;,</span>
<span class="gd">-                &#39;value is not a valid IPv4 or IPv6 address&#39;)</span>
<span class="gi">+            raise PydanticCustomError(&#39;ip_any_address&#39;, &#39;value is not a valid IPv4 or IPv6 address&#39;)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_json_schema__(cls, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        field_schema = {}
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;ipvanyaddress&#39;)
<span class="w"> </span>        return field_schema

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, _source: type[Any], _handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        return core_schema.no_info_plain_validator_function(cls._validate,</span>
<span class="gd">-            serialization=core_schema.to_string_ser_schema())</span>
<span class="gi">+    def __get_pydantic_core_schema__(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        _source: type[Any],</span>
<span class="gi">+        _handler: GetCoreSchemaHandler,</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.no_info_plain_validator_function(</span>
<span class="gi">+            cls._validate, serialization=core_schema.to_string_ser_schema()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _validate(cls, input_value: Any, /) -&gt; IPv4Address | IPv6Address:</span>
<span class="gi">+        return cls(input_value)  # type: ignore[return-value]</span>


<span class="w"> </span>class IPvAnyInterface:
<span class="w"> </span>    &quot;&quot;&quot;Validate an IPv4 or IPv6 interface.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="gd">-    def __new__(cls, value: NetworkType) -&gt;(IPv4Interface | IPv6Interface):</span>
<span class="gi">+    def __new__(cls, value: NetworkType) -&gt; IPv4Interface | IPv6Interface:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate an IPv4 or IPv6 interface.&quot;&quot;&quot;
<span class="w"> </span>        try:
<span class="w"> </span>            return IPv4Interface(value)
<span class="w"> </span>        except ValueError:
<span class="w"> </span>            pass
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return IPv6Interface(value)
<span class="w"> </span>        except ValueError:
<span class="gd">-            raise PydanticCustomError(&#39;ip_any_interface&#39;,</span>
<span class="gd">-                &#39;value is not a valid IPv4 or IPv6 interface&#39;)</span>
<span class="gi">+            raise PydanticCustomError(&#39;ip_any_interface&#39;, &#39;value is not a valid IPv4 or IPv6 interface&#39;)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_json_schema__(cls, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gd">-        ) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        field_schema = {}
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;ipvanyinterface&#39;)
<span class="w"> </span>        return field_schema

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, _source: type[Any], _handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        return core_schema.no_info_plain_validator_function(cls._validate,</span>
<span class="gd">-            serialization=core_schema.to_string_ser_schema())</span>
<span class="gi">+    def __get_pydantic_core_schema__(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        _source: type[Any],</span>
<span class="gi">+        _handler: GetCoreSchemaHandler,</span>
<span class="gi">+    ) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.no_info_plain_validator_function(</span>
<span class="gi">+            cls._validate, serialization=core_schema.to_string_ser_schema()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _validate(cls, input_value: NetworkType, /) -&gt; IPv4Interface | IPv6Interface:</span>
<span class="gi">+        return cls(input_value)  # type: ignore[return-value]</span>


<span class="w"> </span>IPvAnyNetworkType: TypeAlias = &#39;IPv4Network | IPv6Network&#39;
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    IPvAnyNetwork = IPvAnyNetworkType
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class IPvAnyNetwork:
<span class="w"> </span>        &quot;&quot;&quot;Validate an IPv4 or IPv6 network.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        __slots__ = ()

<span class="gd">-        def __new__(cls, value: NetworkType) -&gt;IPvAnyNetworkType:</span>
<span class="gi">+        def __new__(cls, value: NetworkType) -&gt; IPvAnyNetworkType:</span>
<span class="w"> </span>            &quot;&quot;&quot;Validate an IPv4 or IPv6 network.&quot;&quot;&quot;
<span class="gi">+            # Assume IP Network is defined with a default value for `strict` argument.</span>
<span class="gi">+            # Define your own class if you want to specify network address check strictness.</span>
<span class="w"> </span>            try:
<span class="w"> </span>                return IPv4Network(value)
<span class="w"> </span>            except ValueError:
<span class="w"> </span>                pass
<span class="gi">+</span>
<span class="w"> </span>            try:
<span class="w"> </span>                return IPv6Network(value)
<span class="w"> </span>            except ValueError:
<span class="gd">-                raise PydanticCustomError(&#39;ip_any_network&#39;,</span>
<span class="gd">-                    &#39;value is not a valid IPv4 or IPv6 network&#39;)</span>
<span class="gi">+                raise PydanticCustomError(&#39;ip_any_network&#39;, &#39;value is not a valid IPv4 or IPv6 network&#39;)</span>

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_json_schema__(cls, core_schema: core_schema.</span>
<span class="gd">-            CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gd">-            ) -&gt;JsonSchemaValue:</span>
<span class="gi">+        def __get_pydantic_json_schema__(</span>
<span class="gi">+            cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler</span>
<span class="gi">+        ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>            field_schema = {}
<span class="w"> </span>            field_schema.update(type=&#39;string&#39;, format=&#39;ipvanynetwork&#39;)
<span class="w"> </span>            return field_schema

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, _source: type[Any], _handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-            return core_schema.no_info_plain_validator_function(cls.</span>
<span class="gd">-                _validate, serialization=core_schema.to_string_ser_schema())</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            _source: type[Any],</span>
<span class="gi">+            _handler: GetCoreSchemaHandler,</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+            return core_schema.no_info_plain_validator_function(</span>
<span class="gi">+                cls._validate, serialization=core_schema.to_string_ser_schema()</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        @classmethod</span>
<span class="gi">+        def _validate(cls, input_value: NetworkType, /) -&gt; IPvAnyNetworkType:</span>
<span class="gi">+            return cls(input_value)  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _build_pretty_email_regex() -&gt; re.Pattern[str]:</span>
<span class="gi">+    name_chars = r&#39;[\w!#$%&amp;\&#39;*+\-/=?^_`{|}~]&#39;</span>
<span class="gi">+    unquoted_name_group = rf&#39;((?:{name_chars}+\s+)*{name_chars}+)&#39;</span>
<span class="gi">+    quoted_name_group = r&#39;&quot;((?:[^&quot;]|\&quot;)+)&quot;&#39;</span>
<span class="gi">+    email_group = r&#39;&lt;\s*(.+)\s*&gt;&#39;</span>
<span class="gi">+    return re.compile(rf&#39;\s*(?:{unquoted_name_group}|{quoted_name_group})?\s*{email_group}\s*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>pretty_email_regex = _build_pretty_email_regex()
<span class="gi">+</span>
<span class="w"> </span>MAX_EMAIL_LENGTH = 2048
<span class="w"> </span>&quot;&quot;&quot;Maximum length for an email.
<span class="w"> </span>A somewhat arbitrary but very generous number compared to what is allowed by most implementations.
<span class="w"> </span>&quot;&quot;&quot;


<span class="gd">-def validate_email(value: str) -&gt;tuple[str, str]:</span>
<span class="gi">+def validate_email(value: str) -&gt; tuple[str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Email address validation using [email-validator](https://pypi.org/project/email-validator/).

<span class="w"> </span>    Note:
<span class="gu">@@ -574,7 +727,35 @@ def validate_email(value: str) -&gt;tuple[str, str]:</span>
<span class="w"> </span>        * `&quot;John Doe &lt;local_part@domain.com&gt;&quot;` style &quot;pretty&quot; email addresses are processed.
<span class="w"> </span>        * Spaces are striped from the beginning and end of addresses, but no error is raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if email_validator is None:</span>
<span class="gi">+        import_email_validator()</span>
<span class="gi">+</span>
<span class="gi">+    if len(value) &gt; MAX_EMAIL_LENGTH:</span>
<span class="gi">+        raise PydanticCustomError(</span>
<span class="gi">+            &#39;value_error&#39;,</span>
<span class="gi">+            &#39;value is not a valid email address: {reason}&#39;,</span>
<span class="gi">+            {&#39;reason&#39;: f&#39;Length must not exceed {MAX_EMAIL_LENGTH} characters&#39;},</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    m = pretty_email_regex.fullmatch(value)</span>
<span class="gi">+    name: str | None = None</span>
<span class="gi">+    if m:</span>
<span class="gi">+        unquoted_name, quoted_name, value = m.groups()</span>
<span class="gi">+        name = unquoted_name or quoted_name</span>
<span class="gi">+</span>
<span class="gi">+    email = value.strip()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        parts = email_validator.validate_email(email, check_deliverability=False)</span>
<span class="gi">+    except email_validator.EmailNotValidError as e:</span>
<span class="gi">+        raise PydanticCustomError(</span>
<span class="gi">+            &#39;value_error&#39;, &#39;value is not a valid email address: {reason}&#39;, {&#39;reason&#39;: str(e.args[0])}</span>
<span class="gi">+        ) from e</span>
<span class="gi">+</span>
<span class="gi">+    email = parts.normalized</span>
<span class="gi">+    assert email is not None</span>
<span class="gi">+    name = name or parts.local_part</span>
<span class="gi">+    return name, email</span>


<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/parse.py b/pydantic/parse.py</span>
<span class="gh">index 43b80835b..68b7f0464 100644</span>
<span class="gd">--- a/pydantic/parse.py</span>
<span class="gi">+++ b/pydantic/parse.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `parse` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/plugin/_loader.py b/pydantic/plugin/_loader.py</span>
<span class="gh">index 9e984adf4..2f90dc541 100644</span>
<span class="gd">--- a/pydantic/plugin/_loader.py</span>
<span class="gi">+++ b/pydantic/plugin/_loader.py</span>
<span class="gu">@@ -1,18 +1,56 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import importlib.metadata as importlib_metadata
<span class="w"> </span>import os
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import TYPE_CHECKING, Final, Iterable
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from . import PydanticPluginProtocol
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>PYDANTIC_ENTRY_POINT_GROUP: Final[str] = &#39;pydantic&#39;
<span class="gi">+</span>
<span class="gi">+# cache of plugins</span>
<span class="w"> </span>_plugins: dict[str, PydanticPluginProtocol] | None = None
<span class="gi">+# return no plugins while loading plugins to avoid recursion and errors while import plugins</span>
<span class="gi">+# this means that if plugins use pydantic</span>
<span class="w"> </span>_loading_plugins: bool = False


<span class="gd">-def get_plugins() -&gt;Iterable[PydanticPluginProtocol]:</span>
<span class="gi">+def get_plugins() -&gt; Iterable[PydanticPluginProtocol]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Load plugins for Pydantic.

<span class="w"> </span>    Inspired by: https://github.com/pytest-dev/pluggy/blob/1.3.0/src/pluggy/_manager.py#L376-L402
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    disabled_plugins = os.getenv(&#39;PYDANTIC_DISABLE_PLUGINS&#39;)</span>
<span class="gi">+    global _plugins, _loading_plugins</span>
<span class="gi">+    if _loading_plugins:</span>
<span class="gi">+        # this happens when plugins themselves use pydantic, we return no plugins</span>
<span class="gi">+        return ()</span>
<span class="gi">+    elif disabled_plugins in (&#39;__all__&#39;, &#39;1&#39;, &#39;true&#39;):</span>
<span class="gi">+        return ()</span>
<span class="gi">+    elif _plugins is None:</span>
<span class="gi">+        _plugins = {}</span>
<span class="gi">+        # set _loading_plugins so any plugins that use pydantic don&#39;t themselves use plugins</span>
<span class="gi">+        _loading_plugins = True</span>
<span class="gi">+        try:</span>
<span class="gi">+            for dist in importlib_metadata.distributions():</span>
<span class="gi">+                for entry_point in dist.entry_points:</span>
<span class="gi">+                    if entry_point.group != PYDANTIC_ENTRY_POINT_GROUP:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if entry_point.value in _plugins:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if disabled_plugins is not None and entry_point.name in disabled_plugins.split(&#39;,&#39;):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        _plugins[entry_point.value] = entry_point.load()</span>
<span class="gi">+                    except (ImportError, AttributeError) as e:</span>
<span class="gi">+                        warnings.warn(</span>
<span class="gi">+                            f&#39;{e.__class__.__name__} while loading the `{entry_point.name}` Pydantic plugin, &#39;</span>
<span class="gi">+                            f&#39;this plugin will not be installed.\n\n{e!r}&#39;</span>
<span class="gi">+                        )</span>
<span class="gi">+        finally:</span>
<span class="gi">+            _loading_plugins = False</span>
<span class="gi">+</span>
<span class="gi">+    return _plugins.values()</span>
<span class="gh">diff --git a/pydantic/plugin/_schema_validator.py b/pydantic/plugin/_schema_validator.py</span>
<span class="gh">index cc46fbe15..21287f445 100644</span>
<span class="gd">--- a/pydantic/plugin/_schema_validator.py</span>
<span class="gi">+++ b/pydantic/plugin/_schema_validator.py</span>
<span class="gu">@@ -1,71 +1,139 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Pluggable schema validator for pydantic.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Iterable, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import CoreConfig, CoreSchema, SchemaValidator, ValidationError
<span class="w"> </span>from typing_extensions import Literal, ParamSpec
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from . import BaseValidateHandlerProtocol, PydanticPluginProtocol, SchemaKind, SchemaTypePath
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>P = ParamSpec(&#39;P&#39;)
<span class="w"> </span>R = TypeVar(&#39;R&#39;)
<span class="gd">-Event = Literal[&#39;on_validate_python&#39;, &#39;on_validate_json&#39;, &#39;on_validate_strings&#39;</span>
<span class="gd">-    ]</span>
<span class="gd">-events: list[Event] = list(Event.__args__)</span>
<span class="gi">+Event = Literal[&#39;on_validate_python&#39;, &#39;on_validate_json&#39;, &#39;on_validate_strings&#39;]</span>
<span class="gi">+events: list[Event] = list(Event.__args__)  # type: ignore</span>


<span class="gd">-def create_schema_validator(schema: CoreSchema, schema_type: Any,</span>
<span class="gd">-    schema_type_module: str, schema_type_name: str, schema_kind: SchemaKind,</span>
<span class="gd">-    config: (CoreConfig | None)=None, plugin_settings: (dict[str, Any] |</span>
<span class="gd">-    None)=None) -&gt;(SchemaValidator | PluggableSchemaValidator):</span>
<span class="gi">+def create_schema_validator(</span>
<span class="gi">+    schema: CoreSchema,</span>
<span class="gi">+    schema_type: Any,</span>
<span class="gi">+    schema_type_module: str,</span>
<span class="gi">+    schema_type_name: str,</span>
<span class="gi">+    schema_kind: SchemaKind,</span>
<span class="gi">+    config: CoreConfig | None = None,</span>
<span class="gi">+    plugin_settings: dict[str, Any] | None = None,</span>
<span class="gi">+) -&gt; SchemaValidator | PluggableSchemaValidator:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a `SchemaValidator` or `PluggableSchemaValidator` if plugins are installed.

<span class="w"> </span>    Returns:
<span class="w"> </span>        If plugins are installed then return `PluggableSchemaValidator`, otherwise return `SchemaValidator`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from . import SchemaTypePath</span>
<span class="gi">+    from ._loader import get_plugins</span>
<span class="gi">+</span>
<span class="gi">+    plugins = get_plugins()</span>
<span class="gi">+    if plugins:</span>
<span class="gi">+        return PluggableSchemaValidator(</span>
<span class="gi">+            schema,</span>
<span class="gi">+            schema_type,</span>
<span class="gi">+            SchemaTypePath(schema_type_module, schema_type_name),</span>
<span class="gi">+            schema_kind,</span>
<span class="gi">+            config,</span>
<span class="gi">+            plugins,</span>
<span class="gi">+            plugin_settings or {},</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        return SchemaValidator(schema, config)</span>


<span class="w"> </span>class PluggableSchemaValidator:
<span class="w"> </span>    &quot;&quot;&quot;Pluggable schema validator.&quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;_schema_validator&#39;, &#39;validate_json&#39;, &#39;validate_python&#39;,</span>
<span class="gd">-        &#39;validate_strings&#39;)</span>

<span class="gd">-    def __init__(self, schema: CoreSchema, schema_type: Any,</span>
<span class="gd">-        schema_type_path: SchemaTypePath, schema_kind: SchemaKind, config:</span>
<span class="gd">-        (CoreConfig | None), plugins: Iterable[PydanticPluginProtocol],</span>
<span class="gd">-        plugin_settings: dict[str, Any]) -&gt;None:</span>
<span class="gi">+    __slots__ = &#39;_schema_validator&#39;, &#39;validate_json&#39;, &#39;validate_python&#39;, &#39;validate_strings&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        schema: CoreSchema,</span>
<span class="gi">+        schema_type: Any,</span>
<span class="gi">+        schema_type_path: SchemaTypePath,</span>
<span class="gi">+        schema_kind: SchemaKind,</span>
<span class="gi">+        config: CoreConfig | None,</span>
<span class="gi">+        plugins: Iterable[PydanticPluginProtocol],</span>
<span class="gi">+        plugin_settings: dict[str, Any],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._schema_validator = SchemaValidator(schema, config)
<span class="gi">+</span>
<span class="w"> </span>        python_event_handlers: list[BaseValidateHandlerProtocol] = []
<span class="w"> </span>        json_event_handlers: list[BaseValidateHandlerProtocol] = []
<span class="w"> </span>        strings_event_handlers: list[BaseValidateHandlerProtocol] = []
<span class="w"> </span>        for plugin in plugins:
<span class="w"> </span>            try:
<span class="gd">-                p, j, s = plugin.new_schema_validator(schema, schema_type,</span>
<span class="gd">-                    schema_type_path, schema_kind, config, plugin_settings)</span>
<span class="gd">-            except TypeError as e:</span>
<span class="gd">-                raise TypeError(</span>
<span class="gd">-                    f&#39;Error using plugin `{plugin.__module__}:{plugin.__class__.__name__}`: {e}&#39;</span>
<span class="gd">-                    ) from e</span>
<span class="gi">+                p, j, s = plugin.new_schema_validator(</span>
<span class="gi">+                    schema, schema_type, schema_type_path, schema_kind, config, plugin_settings</span>
<span class="gi">+                )</span>
<span class="gi">+            except TypeError as e:  # pragma: no cover</span>
<span class="gi">+                raise TypeError(f&#39;Error using plugin `{plugin.__module__}:{plugin.__class__.__name__}`: {e}&#39;) from e</span>
<span class="w"> </span>            if p is not None:
<span class="w"> </span>                python_event_handlers.append(p)
<span class="w"> </span>            if j is not None:
<span class="w"> </span>                json_event_handlers.append(j)
<span class="w"> </span>            if s is not None:
<span class="w"> </span>                strings_event_handlers.append(s)
<span class="gd">-        self.validate_python = build_wrapper(self._schema_validator.</span>
<span class="gd">-            validate_python, python_event_handlers)</span>
<span class="gd">-        self.validate_json = build_wrapper(self._schema_validator.</span>
<span class="gd">-            validate_json, json_event_handlers)</span>
<span class="gd">-        self.validate_strings = build_wrapper(self._schema_validator.</span>
<span class="gd">-            validate_strings, strings_event_handlers)</span>
<span class="gd">-</span>
<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+</span>
<span class="gi">+        self.validate_python = build_wrapper(self._schema_validator.validate_python, python_event_handlers)</span>
<span class="gi">+        self.validate_json = build_wrapper(self._schema_validator.validate_json, json_event_handlers)</span>
<span class="gi">+        self.validate_strings = build_wrapper(self._schema_validator.validate_strings, strings_event_handlers)</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        return getattr(self._schema_validator, name)


<span class="gd">-def filter_handlers(handler_cls: BaseValidateHandlerProtocol, method_name: str</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def build_wrapper(func: Callable[P, R], event_handlers: list[BaseValidateHandlerProtocol]) -&gt; Callable[P, R]:</span>
<span class="gi">+    if not event_handlers:</span>
<span class="gi">+        return func</span>
<span class="gi">+    else:</span>
<span class="gi">+        on_enters = tuple(h.on_enter for h in event_handlers if filter_handlers(h, &#39;on_enter&#39;))</span>
<span class="gi">+        on_successes = tuple(h.on_success for h in event_handlers if filter_handlers(h, &#39;on_success&#39;))</span>
<span class="gi">+        on_errors = tuple(h.on_error for h in event_handlers if filter_handlers(h, &#39;on_error&#39;))</span>
<span class="gi">+        on_exceptions = tuple(h.on_exception for h in event_handlers if filter_handlers(h, &#39;on_exception&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        @functools.wraps(func)</span>
<span class="gi">+        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:</span>
<span class="gi">+            for on_enter_handler in on_enters:</span>
<span class="gi">+                on_enter_handler(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                result = func(*args, **kwargs)</span>
<span class="gi">+            except ValidationError as error:</span>
<span class="gi">+                for on_error_handler in on_errors:</span>
<span class="gi">+                    on_error_handler(error)</span>
<span class="gi">+                raise</span>
<span class="gi">+            except Exception as exception:</span>
<span class="gi">+                for on_exception_handler in on_exceptions:</span>
<span class="gi">+                    on_exception_handler(exception)</span>
<span class="gi">+                raise</span>
<span class="gi">+            else:</span>
<span class="gi">+                for on_success_handler in on_successes:</span>
<span class="gi">+                    on_success_handler(result)</span>
<span class="gi">+                return result</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def filter_handlers(handler_cls: BaseValidateHandlerProtocol, method_name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Filter out handler methods which are not implemented by the plugin directly - e.g. are missing
<span class="w"> </span>    or are inherited from the protocol.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    handler = getattr(handler_cls, method_name, None)</span>
<span class="gi">+    if handler is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    elif handler.__module__ == &#39;pydantic.plugin&#39;:</span>
<span class="gi">+        # this is the original handler, from the protocol due to runtime inheritance</span>
<span class="gi">+        # we don&#39;t want to call it</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/pydantic/root_model.py b/pydantic/root_model.py</span>
<span class="gh">index 199c196de..b07363103 100644</span>
<span class="gd">--- a/pydantic/root_model.py</span>
<span class="gi">+++ b/pydantic/root_model.py</span>
<span class="gu">@@ -1,30 +1,38 @@</span>
<span class="w"> </span>&quot;&quot;&quot;RootModel class and type definitions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>from copy import copy, deepcopy
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import PydanticUndefined
<span class="gi">+</span>
<span class="w"> </span>from . import PydanticUserError
<span class="w"> </span>from ._internal import _model_construction, _repr
<span class="w"> </span>from .main import BaseModel, _object_setattr
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>    from typing_extensions import Literal, Self, dataclass_transform
<span class="gi">+</span>
<span class="w"> </span>    from .fields import Field as PydanticModelField
<span class="w"> </span>    from .fields import PrivateAttr as PydanticModelPrivateAttr

<span class="gd">-</span>
<span class="gd">-    @dataclass_transform(kw_only_default=False, field_specifiers=(</span>
<span class="gd">-        PydanticModelField, PydanticModelPrivateAttr))</span>
<span class="gd">-    class _RootModelMetaclass(_model_construction.ModelMetaclass):</span>
<span class="gd">-        ...</span>
<span class="gi">+    # dataclass_transform could be applied to RootModel directly, but `ModelMetaclass`&#39;s dataclass_transform</span>
<span class="gi">+    # takes priority (at least with pyright). We trick type checkers into thinking we apply dataclass_transform</span>
<span class="gi">+    # on a new metaclass.</span>
<span class="gi">+    @dataclass_transform(kw_only_default=False, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr))</span>
<span class="gi">+    class _RootModelMetaclass(_model_construction.ModelMetaclass): ...</span>
<span class="w"> </span>else:
<span class="w"> </span>    _RootModelMetaclass = _model_construction.ModelMetaclass
<span class="gd">-__all__ = &#39;RootModel&#39;,</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;RootModel&#39;,)</span>
<span class="gi">+</span>
<span class="w"> </span>RootModelRootType = typing.TypeVar(&#39;RootModelRootType&#39;)


<span class="gd">-class RootModel(BaseModel, typing.Generic[RootModelRootType], metaclass=</span>
<span class="gd">-    _RootModelMetaclass):</span>
<span class="gi">+class RootModel(BaseModel, typing.Generic[RootModelRootType], metaclass=_RootModelMetaclass):</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/models/#rootmodel-and-custom-root-types

<span class="w"> </span>    A Pydantic `BaseModel` for the root object of the model.
<span class="gu">@@ -36,34 +44,35 @@ class RootModel(BaseModel, typing.Generic[RootModelRootType], metaclass=</span>
<span class="w"> </span>        __pydantic_extra__: Extra fields in the model.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __pydantic_root_model__ = True
<span class="w"> </span>    __pydantic_private__ = None
<span class="w"> </span>    __pydantic_extra__ = None
<span class="gi">+</span>
<span class="w"> </span>    root: RootModelRootType

<span class="w"> </span>    def __init_subclass__(cls, **kwargs):
<span class="w"> </span>        extra = cls.model_config.get(&#39;extra&#39;)
<span class="w"> </span>        if extra is not None:
<span class="w"> </span>            raise PydanticUserError(
<span class="gd">-                &quot;`RootModel` does not support setting `model_config[&#39;extra&#39;]`&quot;,</span>
<span class="gd">-                code=&#39;root-model-extra&#39;)</span>
<span class="gi">+                &quot;`RootModel` does not support setting `model_config[&#39;extra&#39;]`&quot;, code=&#39;root-model-extra&#39;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        super().__init_subclass__(**kwargs)

<span class="gd">-    def __init__(self, /, root: RootModelRootType=PydanticUndefined, **data</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, /, root: RootModelRootType = PydanticUndefined, **data) -&gt; None:  # type: ignore</span>
<span class="w"> </span>        __tracebackhide__ = True
<span class="w"> </span>        if data:
<span class="w"> </span>            if root is not PydanticUndefined:
<span class="w"> </span>                raise ValueError(
<span class="w"> </span>                    &#39;&quot;RootModel.__init__&quot; accepts either a single positional argument or arbitrary keyword arguments&#39;
<span class="gd">-                    )</span>
<span class="gd">-            root = data</span>
<span class="gi">+                )</span>
<span class="gi">+            root = data  # type: ignore</span>
<span class="w"> </span>        self.__pydantic_validator__.validate_python(root, self_instance=self)
<span class="gd">-    __init__.__pydantic_base_init__ = True</span>
<span class="gi">+</span>
<span class="gi">+    __init__.__pydantic_base_init__ = True  # pyright: ignore[reportFunctionMemberAccess]</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def model_construct(cls, root: RootModelRootType, _fields_set: (set[str</span>
<span class="gd">-        ] | None)=None) -&gt;Self:</span>
<span class="gi">+    def model_construct(cls, root: RootModelRootType, _fields_set: set[str] | None = None) -&gt; Self:  # type: ignore</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new model using the provided root object and update fields set.

<span class="w"> </span>        Args:
<span class="gu">@@ -76,42 +85,53 @@ class RootModel(BaseModel, typing.Generic[RootModelRootType], metaclass=</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            NotImplemented: If the model is not a subclass of `RootModel`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return super().model_construct(root=root, _fields_set=_fields_set)</span>

<span class="gd">-    def __getstate__(self) -&gt;dict[Any, Any]:</span>
<span class="gd">-        return {&#39;__dict__&#39;: self.__dict__, &#39;__pydantic_fields_set__&#39;: self.</span>
<span class="gd">-            __pydantic_fields_set__}</span>
<span class="gi">+    def __getstate__(self) -&gt; dict[Any, Any]:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;__dict__&#39;: self.__dict__,</span>
<span class="gi">+            &#39;__pydantic_fields_set__&#39;: self.__pydantic_fields_set__,</span>
<span class="gi">+        }</span>

<span class="gd">-    def __setstate__(self, state: dict[Any, Any]) -&gt;None:</span>
<span class="gd">-        _object_setattr(self, &#39;__pydantic_fields_set__&#39;, state[</span>
<span class="gd">-            &#39;__pydantic_fields_set__&#39;])</span>
<span class="gi">+    def __setstate__(self, state: dict[Any, Any]) -&gt; None:</span>
<span class="gi">+        _object_setattr(self, &#39;__pydantic_fields_set__&#39;, state[&#39;__pydantic_fields_set__&#39;])</span>
<span class="w"> </span>        _object_setattr(self, &#39;__dict__&#39;, state[&#39;__dict__&#39;])

<span class="gd">-    def __copy__(self) -&gt;Self:</span>
<span class="gi">+    def __copy__(self) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a shallow copy of the model.&quot;&quot;&quot;
<span class="w"> </span>        cls = type(self)
<span class="w"> </span>        m = cls.__new__(cls)
<span class="w"> </span>        _object_setattr(m, &#39;__dict__&#39;, copy(self.__dict__))
<span class="gd">-        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, copy(self.</span>
<span class="gd">-            __pydantic_fields_set__))</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, copy(self.__pydantic_fields_set__))</span>
<span class="w"> </span>        return m

<span class="gd">-    def __deepcopy__(self, memo: (dict[int, Any] | None)=None) -&gt;Self:</span>
<span class="gi">+    def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a deep copy of the model.&quot;&quot;&quot;
<span class="w"> </span>        cls = type(self)
<span class="w"> </span>        m = cls.__new__(cls)
<span class="w"> </span>        _object_setattr(m, &#39;__dict__&#39;, deepcopy(self.__dict__, memo=memo))
<span class="gd">-        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, copy(self.</span>
<span class="gd">-            __pydantic_fields_set__))</span>
<span class="gi">+        # This next line doesn&#39;t need a deepcopy because __pydantic_fields_set__ is a set[str],</span>
<span class="gi">+        # and attempting a deepcopy would be marginally slower.</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, copy(self.__pydantic_fields_set__))</span>
<span class="w"> </span>        return m
<span class="gi">+</span>
<span class="w"> </span>    if typing.TYPE_CHECKING:

<span class="gd">-        def model_dump(self, *, mode: (Literal[&#39;json&#39;, &#39;python&#39;] | str)=</span>
<span class="gd">-            &#39;python&#39;, include: Any=None, exclude: Any=None, context: (dict[</span>
<span class="gd">-            str, Any] | None)=None, by_alias: bool=False, exclude_unset:</span>
<span class="gd">-            bool=False, exclude_defaults: bool=False, exclude_none: bool=</span>
<span class="gd">-            False, round_trip: bool=False, warnings: (bool | Literal[&#39;none&#39;,</span>
<span class="gd">-            &#39;warn&#39;, &#39;error&#39;])=True, serialize_as_any: bool=False) -&gt;Any:</span>
<span class="gi">+        def model_dump(  # type: ignore</span>
<span class="gi">+            self,</span>
<span class="gi">+            *,</span>
<span class="gi">+            mode: Literal[&#39;json&#39;, &#39;python&#39;] | str = &#39;python&#39;,</span>
<span class="gi">+            include: Any = None,</span>
<span class="gi">+            exclude: Any = None,</span>
<span class="gi">+            context: dict[str, Any] | None = None,</span>
<span class="gi">+            by_alias: bool = False,</span>
<span class="gi">+            exclude_unset: bool = False,</span>
<span class="gi">+            exclude_defaults: bool = False,</span>
<span class="gi">+            exclude_none: bool = False,</span>
<span class="gi">+            round_trip: bool = False,</span>
<span class="gi">+            warnings: bool | Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;] = True,</span>
<span class="gi">+            serialize_as_any: bool = False,</span>
<span class="gi">+        ) -&gt; Any:</span>
<span class="w"> </span>            &quot;&quot;&quot;This method is included just to get a more accurate return type for type checkers.
<span class="w"> </span>            It is included in this `if TYPE_CHECKING:` block since no override is actually necessary.

<span class="gu">@@ -123,13 +143,12 @@ class RootModel(BaseModel, typing.Generic[RootModelRootType], metaclass=</span>
<span class="w"> </span>            even be something different, in the case of a custom serializer.
<span class="w"> </span>            Thus, `Any` is used here to catch all of these cases.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            ...</span>

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, RootModel):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self.model_fields[&#39;root&#39;].annotation == other.model_fields[</span>
<span class="gd">-            &#39;root&#39;].annotation and super().__eq__(other)</span>
<span class="gi">+        return self.model_fields[&#39;root&#39;].annotation == other.model_fields[&#39;root&#39;].annotation and super().__eq__(other)</span>

<span class="gd">-    def __repr_args__(self) -&gt;_repr.ReprArgs:</span>
<span class="gi">+    def __repr_args__(self) -&gt; _repr.ReprArgs:</span>
<span class="w"> </span>        yield &#39;root&#39;, self.root
<span class="gh">diff --git a/pydantic/schema.py b/pydantic/schema.py</span>
<span class="gh">index 563310b07..a3245a61a 100644</span>
<span class="gd">--- a/pydantic/schema.py</span>
<span class="gi">+++ b/pydantic/schema.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `schema` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/tools.py b/pydantic/tools.py</span>
<span class="gh">index adfc56c85..fdc68c4f4 100644</span>
<span class="gd">--- a/pydantic/tools.py</span>
<span class="gi">+++ b/pydantic/tools.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `tools` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/type_adapter.py b/pydantic/type_adapter.py</span>
<span class="gh">index fc7ff2ab0..d6001df0f 100644</span>
<span class="gd">--- a/pydantic/type_adapter.py</span>
<span class="gi">+++ b/pydantic/type_adapter.py</span>
<span class="gu">@@ -1,28 +1,57 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Type adapter specification.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from dataclasses import is_dataclass
<span class="w"> </span>from functools import cached_property, wraps
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, Dict, Generic, Iterable, Iterator, Literal, Set, TypeVar, Union, cast, final, overload</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    Literal,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    final,</span>
<span class="gi">+    overload,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator, Some
<span class="w"> </span>from typing_extensions import Concatenate, ParamSpec, is_typeddict
<span class="gi">+</span>
<span class="w"> </span>from pydantic.errors import PydanticUserError
<span class="w"> </span>from pydantic.main import BaseModel
<span class="gi">+</span>
<span class="w"> </span>from ._internal import _config, _generate_schema, _mock_val_ser, _typing_extra, _utils
<span class="w"> </span>from .config import ConfigDict
<span class="gd">-from .json_schema import DEFAULT_REF_TEMPLATE, GenerateJsonSchema, JsonSchemaKeyT, JsonSchemaMode, JsonSchemaValue</span>
<span class="gi">+from .json_schema import (</span>
<span class="gi">+    DEFAULT_REF_TEMPLATE,</span>
<span class="gi">+    GenerateJsonSchema,</span>
<span class="gi">+    JsonSchemaKeyT,</span>
<span class="gi">+    JsonSchemaMode,</span>
<span class="gi">+    JsonSchemaValue,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .plugin._schema_validator import PluggableSchemaValidator, create_schema_validator
<span class="gi">+</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)
<span class="w"> </span>R = TypeVar(&#39;R&#39;)
<span class="w"> </span>P = ParamSpec(&#39;P&#39;)
<span class="w"> </span>TypeAdapterT = TypeVar(&#39;TypeAdapterT&#39;, bound=&#39;TypeAdapter&#39;)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gi">+    # should be `set[int] | set[str] | dict[int, IncEx] | dict[str, IncEx] | None`, but mypy can&#39;t cope</span>
<span class="w"> </span>    IncEx = Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any]]


<span class="gd">-def _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper,</span>
<span class="gd">-    parent_depth: int) -&gt;CoreSchema:</span>
<span class="gi">+def _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper, parent_depth: int) -&gt; CoreSchema:</span>
<span class="w"> </span>    &quot;&quot;&quot;`BaseModel` uses its own `__module__` to find out where it was defined
<span class="w"> </span>    and then looks for symbols to resolve forward references in those globals.
<span class="w"> </span>    On the other hand this function can be called with arbitrary objects,
<span class="gu">@@ -66,17 +95,55 @@ def _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper,</span>

<span class="w"> </span>    But at the very least this behavior is _subtly_ different from `BaseModel`&#39;s.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    local_ns = _typing_extra.parent_frame_namespace(parent_depth=parent_depth)</span>
<span class="gi">+    global_ns = sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()</span>
<span class="gi">+    global_ns.update(local_ns or {})</span>
<span class="gi">+    gen = _generate_schema.GenerateSchema(config_wrapper, types_namespace=global_ns, typevars_map={})</span>
<span class="gi">+    schema = gen.generate_schema(type_)</span>
<span class="gi">+    schema = gen.clean_schema(schema)</span>
<span class="gi">+    return schema</span>


<span class="gd">-def _getattr_no_parents(obj: Any, attribute: str) -&gt;Any:</span>
<span class="gi">+def _getattr_no_parents(obj: Any, attribute: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the attribute value without attempting to look up attributes from parent types.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(obj, &#39;__dict__&#39;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return obj.__dict__[attribute]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>

<span class="gi">+    slots = getattr(obj, &#39;__slots__&#39;, None)</span>
<span class="gi">+    if slots is not None and attribute in slots:</span>
<span class="gi">+        return getattr(obj, attribute)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise AttributeError(attribute)</span>

<span class="gd">-def _type_has_config(type_: Any) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def _type_has_config(type_: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns whether the type has config.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    type_ = _typing_extra.annotated_type(type_) or type_</span>
<span class="gi">+    try:</span>
<span class="gi">+        return issubclass(type_, BaseModel) or is_dataclass(type_) or is_typeddict(type_)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        # type is not a class</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This is keeping track of the frame depth for the TypeAdapter functions. This is required for _parent_depth used for</span>
<span class="gi">+# ForwardRef resolution. We may enter the TypeAdapter schema building via different TypeAdapter functions. Hence, we</span>
<span class="gi">+# need to keep track of the frame depth relative to the originally provided _parent_depth.</span>
<span class="gi">+def _frame_depth(</span>
<span class="gi">+    depth: int,</span>
<span class="gi">+) -&gt; Callable[[Callable[Concatenate[TypeAdapterT, P], R]], Callable[Concatenate[TypeAdapterT, P], R]]:</span>
<span class="gi">+    def wrapper(func: Callable[Concatenate[TypeAdapterT, P], R]) -&gt; Callable[Concatenate[TypeAdapterT, P], R]:</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapped(self: TypeAdapterT, *args: P.args, **kwargs: P.kwargs) -&gt; R:</span>
<span class="gi">+            with self._with_frame_depth(depth + 1):  # depth + 1 for the wrapper function</span>
<span class="gi">+                return func(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return wrapped</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>@final
<span class="gu">@@ -104,17 +171,36 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @overload
<span class="gd">-    def __init__(self, type: type[T], *, config: (ConfigDict | None)=...,</span>
<span class="gd">-        _parent_depth: int=..., module: (str | None)=...) -&gt;None:</span>
<span class="gd">-        ...</span>
<span class="gd">-</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        type: type[T],</span>
<span class="gi">+        *,</span>
<span class="gi">+        config: ConfigDict | None = ...,</span>
<span class="gi">+        _parent_depth: int = ...,</span>
<span class="gi">+        module: str | None = ...,</span>
<span class="gi">+    ) -&gt; None: ...</span>
<span class="gi">+</span>
<span class="gi">+    # This second overload is for unsupported special forms (such as Annotated, Union, etc.)</span>
<span class="gi">+    # Currently there is no way to type this correctly</span>
<span class="gi">+    # See https://github.com/python/typing/pull/1618</span>
<span class="w"> </span>    @overload
<span class="gd">-    def __init__(self, type: Any, *, config: (ConfigDict | None)=...,</span>
<span class="gd">-        _parent_depth: int=..., module: (str | None)=...) -&gt;None:</span>
<span class="gd">-        ...</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, type: Any, *, config: (ConfigDict | None)=None,</span>
<span class="gd">-        _parent_depth: int=2, module: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        type: Any,</span>
<span class="gi">+        *,</span>
<span class="gi">+        config: ConfigDict | None = ...,</span>
<span class="gi">+        _parent_depth: int = ...,</span>
<span class="gi">+        module: str | None = ...,</span>
<span class="gi">+    ) -&gt; None: ...</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        type: Any,</span>
<span class="gi">+        *,</span>
<span class="gi">+        config: ConfigDict | None = None,</span>
<span class="gi">+        _parent_depth: int = 2,</span>
<span class="gi">+        module: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initializes the TypeAdapter object.

<span class="w"> </span>        Args:
<span class="gu">@@ -150,8 +236,13 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if _type_has_config(type) and config is not None:
<span class="w"> </span>            raise PydanticUserError(
<span class="gd">-                &#39;Cannot use `config` when the type is a BaseModel, dataclass or TypedDict. These types can have their own config and setting the config via the `config` parameter to TypeAdapter will not override it, thus the `config` you passed to TypeAdapter becomes meaningless, which is probably not what you want.&#39;</span>
<span class="gd">-                , code=&#39;type-adapter-config-unused&#39;)</span>
<span class="gi">+                &#39;Cannot use `config` when the type is a BaseModel, dataclass or TypedDict.&#39;</span>
<span class="gi">+                &#39; These types can have their own config and setting the config via the `config`&#39;</span>
<span class="gi">+                &#39; parameter to TypeAdapter will not override it, thus the `config` you passed to&#39;</span>
<span class="gi">+                &#39; TypeAdapter becomes meaningless, which is probably not what you want.&#39;,</span>
<span class="gi">+                code=&#39;type-adapter-config-unused&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self._type = type
<span class="w"> </span>        self._config = config
<span class="w"> </span>        self._parent_depth = _parent_depth
<span class="gu">@@ -160,36 +251,110 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>            self._module_name = cast(str, f.f_globals.get(&#39;__name__&#39;, &#39;&#39;))
<span class="w"> </span>        else:
<span class="w"> </span>            self._module_name = module
<span class="gi">+</span>
<span class="w"> </span>        self._core_schema: CoreSchema | None = None
<span class="gd">-        (self._validator: SchemaValidator | PluggableSchemaValidator | None</span>
<span class="gd">-            ) = None</span>
<span class="gi">+        self._validator: SchemaValidator | PluggableSchemaValidator | None = None</span>
<span class="w"> </span>        self._serializer: SchemaSerializer | None = None
<span class="gi">+</span>
<span class="w"> </span>        if not self._defer_build():
<span class="gd">-            with self._with_frame_depth(1):</span>
<span class="gi">+            # Immediately initialize the core schema, validator and serializer</span>
<span class="gi">+            with self._with_frame_depth(1):  # +1 frame depth for this __init__</span>
<span class="gi">+                # Model itself may be using deferred building. For backward compatibility we don&#39;t rebuild model mocks</span>
<span class="gi">+                # here as part of __init__ even though TypeAdapter itself is not using deferred building.</span>
<span class="w"> </span>                self._init_core_attrs(rebuild_mocks=False)

<span class="gi">+    @contextmanager</span>
<span class="gi">+    def _with_frame_depth(self, depth: int) -&gt; Iterator[None]:</span>
<span class="gi">+        self._parent_depth += depth</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._parent_depth -= depth</span>
<span class="gi">+</span>
<span class="gi">+    @_frame_depth(1)</span>
<span class="gi">+    def _init_core_attrs(self, rebuild_mocks: bool) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._core_schema = _getattr_no_parents(self._type, &#39;__pydantic_core_schema__&#39;)</span>
<span class="gi">+            self._validator = _getattr_no_parents(self._type, &#39;__pydantic_validator__&#39;)</span>
<span class="gi">+            self._serializer = _getattr_no_parents(self._type, &#39;__pydantic_serializer__&#39;)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            config_wrapper = _config.ConfigWrapper(self._config)</span>
<span class="gi">+            core_config = config_wrapper.core_config(None)</span>
<span class="gi">+</span>
<span class="gi">+            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)</span>
<span class="gi">+            self._validator = create_schema_validator(</span>
<span class="gi">+                schema=self._core_schema,</span>
<span class="gi">+                schema_type=self._type,</span>
<span class="gi">+                schema_type_module=self._module_name,</span>
<span class="gi">+                schema_type_name=str(self._type),</span>
<span class="gi">+                schema_kind=&#39;TypeAdapter&#39;,</span>
<span class="gi">+                config=core_config,</span>
<span class="gi">+                plugin_settings=config_wrapper.plugin_settings,</span>
<span class="gi">+            )</span>
<span class="gi">+            self._serializer = SchemaSerializer(self._core_schema, core_config)</span>
<span class="gi">+</span>
<span class="gi">+        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):</span>
<span class="gi">+            self._core_schema.rebuild()</span>
<span class="gi">+            self._init_core_attrs(rebuild_mocks=False)</span>
<span class="gi">+            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)</span>
<span class="gi">+            assert not isinstance(self._validator, _mock_val_ser.MockValSer)</span>
<span class="gi">+            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)</span>
<span class="gi">+</span>
<span class="w"> </span>    @cached_property
<span class="gd">-    @_frame_depth(2)</span>
<span class="gd">-    def core_schema(self) -&gt;CoreSchema:</span>
<span class="gi">+    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)</span>
<span class="gi">+    def core_schema(self) -&gt; CoreSchema:</span>
<span class="w"> </span>        &quot;&quot;&quot;The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):</span>
<span class="gi">+            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function</span>
<span class="gi">+        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)</span>
<span class="gi">+        return self._core_schema</span>

<span class="w"> </span>    @cached_property
<span class="gd">-    @_frame_depth(2)</span>
<span class="gd">-    def validator(self) -&gt;(SchemaValidator | PluggableSchemaValidator):</span>
<span class="gi">+    @_frame_depth(2)  # +2 for @cached_property + validator(self)</span>
<span class="gi">+    def validator(self) -&gt; SchemaValidator | PluggableSchemaValidator:</span>
<span class="w"> </span>        &quot;&quot;&quot;The pydantic-core SchemaValidator used to validate instances of the model.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):</span>
<span class="gi">+            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function</span>
<span class="gi">+        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))</span>
<span class="gi">+        return self._validator</span>

<span class="w"> </span>    @cached_property
<span class="gd">-    @_frame_depth(2)</span>
<span class="gd">-    def serializer(self) -&gt;SchemaSerializer:</span>
<span class="gi">+    @_frame_depth(2)  # +2 for @cached_property + serializer(self)</span>
<span class="gi">+    def serializer(self) -&gt; SchemaSerializer:</span>
<span class="w"> </span>        &quot;&quot;&quot;The pydantic-core SchemaSerializer used to dump instances of the model.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(self._serializer, SchemaSerializer):</span>
<span class="gi">+            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function</span>
<span class="gi">+        assert isinstance(self._serializer, SchemaSerializer)</span>
<span class="gi">+        return self._serializer</span>
<span class="gi">+</span>
<span class="gi">+    def _defer_build(self) -&gt; bool:</span>
<span class="gi">+        config = self._config if self._config is not None else self._model_config()</span>
<span class="gi">+        return self._is_defer_build_config(config) if config is not None else False</span>
<span class="gi">+</span>
<span class="gi">+    def _model_config(self) -&gt; ConfigDict | None:</span>
<span class="gi">+        type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated</span>
<span class="gi">+        if _utils.lenient_issubclass(type_, BaseModel):</span>
<span class="gi">+            return type_.model_config</span>
<span class="gi">+        return getattr(type_, &#39;__pydantic_config__&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_defer_build_config(config: ConfigDict) -&gt; bool:</span>
<span class="gi">+        # TODO reevaluate this logic when we have a better understanding of how defer_build should work with TypeAdapter</span>
<span class="gi">+        # Should we drop the special experimental_defer_build_mode check?</span>
<span class="gi">+        return config.get(&#39;defer_build&#39;, False) is True and &#39;type_adapter&#39; in config.get(</span>
<span class="gi">+            &#39;experimental_defer_build_mode&#39;, tuple()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="gd">-    def validate_python(self, object: Any, /, *, strict: (bool | None)=None,</span>
<span class="gd">-        from_attributes: (bool | None)=None, context: (dict[str, Any] |</span>
<span class="gd">-        None)=None) -&gt;T:</span>
<span class="gi">+    def validate_python(</span>
<span class="gi">+        self,</span>
<span class="gi">+        object: Any,</span>
<span class="gi">+        /,</span>
<span class="gi">+        *,</span>
<span class="gi">+        strict: bool | None = None,</span>
<span class="gi">+        from_attributes: bool | None = None,</span>
<span class="gi">+        context: dict[str, Any] | None = None,</span>
<span class="gi">+    ) -&gt; T:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate a Python object against the model.

<span class="w"> </span>        Args:
<span class="gu">@@ -205,11 +370,12 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The validated object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.validator.validate_python(object, strict=strict, from_attributes=from_attributes, context=context)</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="gd">-    def validate_json(self, data: (str | bytes), /, *, strict: (bool | None</span>
<span class="gd">-        )=None, context: (dict[str, Any] | None)=None) -&gt;T:</span>
<span class="gi">+    def validate_json(</span>
<span class="gi">+        self, data: str | bytes, /, *, strict: bool | None = None, context: dict[str, Any] | None = None</span>
<span class="gi">+    ) -&gt; T:</span>
<span class="w"> </span>        &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/json/#json-parsing

<span class="w"> </span>        Validate a JSON string or bytes against the model.
<span class="gu">@@ -222,11 +388,10 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The validated object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.validator.validate_json(data, strict=strict, context=context)</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="gd">-    def validate_strings(self, obj: Any, /, *, strict: (bool | None)=None,</span>
<span class="gd">-        context: (dict[str, Any] | None)=None) -&gt;T:</span>
<span class="gi">+    def validate_strings(self, obj: Any, /, *, strict: bool | None = None, context: dict[str, Any] | None = None) -&gt; T:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate object contains string data against the model.

<span class="w"> </span>        Args:
<span class="gu">@@ -237,11 +402,10 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The validated object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.validator.validate_strings(obj, strict=strict, context=context)</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="gd">-    def get_default_value(self, *, strict: (bool | None)=None, context: (</span>
<span class="gd">-        dict[str, Any] | None)=None) -&gt;(Some[T] | None):</span>
<span class="gi">+    def get_default_value(self, *, strict: bool | None = None, context: dict[str, Any] | None = None) -&gt; Some[T] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the default value for the wrapped type.

<span class="w"> </span>        Args:
<span class="gu">@@ -251,16 +415,26 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The default value wrapped in a `Some` if there is one or None if not.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.validator.get_default_value(strict=strict, context=context)</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="gd">-    def dump_python(self, instance: T, /, *, mode: Literal[&#39;json&#39;, &#39;python&#39;</span>
<span class="gd">-        ]=&#39;python&#39;, include: (IncEx | None)=None, exclude: (IncEx | None)=</span>
<span class="gd">-        None, by_alias: bool=False, exclude_unset: bool=False,</span>
<span class="gd">-        exclude_defaults: bool=False, exclude_none: bool=False, round_trip:</span>
<span class="gd">-        bool=False, warnings: (bool | Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;])=</span>
<span class="gd">-        True, serialize_as_any: bool=False, context: (dict[str, Any] | None</span>
<span class="gd">-        )=None) -&gt;Any:</span>
<span class="gi">+    def dump_python(</span>
<span class="gi">+        self,</span>
<span class="gi">+        instance: T,</span>
<span class="gi">+        /,</span>
<span class="gi">+        *,</span>
<span class="gi">+        mode: Literal[&#39;json&#39;, &#39;python&#39;] = &#39;python&#39;,</span>
<span class="gi">+        include: IncEx | None = None,</span>
<span class="gi">+        exclude: IncEx | None = None,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+        round_trip: bool = False,</span>
<span class="gi">+        warnings: bool | Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;] = True,</span>
<span class="gi">+        serialize_as_any: bool = False,</span>
<span class="gi">+        context: dict[str, Any] | None = None,</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Dump an instance of the adapted type to a Python object.

<span class="w"> </span>        Args:
<span class="gu">@@ -281,16 +455,39 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The serialized object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.serializer.to_python(</span>
<span class="gi">+            instance,</span>
<span class="gi">+            mode=mode,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none,</span>
<span class="gi">+            round_trip=round_trip,</span>
<span class="gi">+            warnings=warnings,</span>
<span class="gi">+            serialize_as_any=serialize_as_any,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="gd">-    def dump_json(self, instance: T, /, *, indent: (int | None)=None,</span>
<span class="gd">-        include: (IncEx | None)=None, exclude: (IncEx | None)=None,</span>
<span class="gd">-        by_alias: bool=False, exclude_unset: bool=False, exclude_defaults:</span>
<span class="gd">-        bool=False, exclude_none: bool=False, round_trip: bool=False,</span>
<span class="gd">-        warnings: (bool | Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;])=True,</span>
<span class="gd">-        serialize_as_any: bool=False, context: (dict[str, Any] | None)=None</span>
<span class="gd">-        ) -&gt;bytes:</span>
<span class="gi">+    def dump_json(</span>
<span class="gi">+        self,</span>
<span class="gi">+        instance: T,</span>
<span class="gi">+        /,</span>
<span class="gi">+        *,</span>
<span class="gi">+        indent: int | None = None,</span>
<span class="gi">+        include: IncEx | None = None,</span>
<span class="gi">+        exclude: IncEx | None = None,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+        round_trip: bool = False,</span>
<span class="gi">+        warnings: bool | Literal[&#39;none&#39;, &#39;warn&#39;, &#39;error&#39;] = True,</span>
<span class="gi">+        serialize_as_any: bool = False,</span>
<span class="gi">+        context: dict[str, Any] | None = None,</span>
<span class="gi">+    ) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/json/#json-serialization

<span class="w"> </span>        Serialize an instance of the adapted type to JSON.
<span class="gu">@@ -313,13 +510,30 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The JSON representation of the given instance as bytes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.serializer.to_json(</span>
<span class="gi">+            instance,</span>
<span class="gi">+            indent=indent,</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none,</span>
<span class="gi">+            round_trip=round_trip,</span>
<span class="gi">+            warnings=warnings,</span>
<span class="gi">+            serialize_as_any=serialize_as_any,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="gd">-    def json_schema(self, *, by_alias: bool=True, ref_template: str=</span>
<span class="gd">-        DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema]=</span>
<span class="gd">-        GenerateJsonSchema, mode: JsonSchemaMode=&#39;validation&#39;) -&gt;dict[str, Any</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def json_schema(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        by_alias: bool = True,</span>
<span class="gi">+        ref_template: str = DEFAULT_REF_TEMPLATE,</span>
<span class="gi">+        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,</span>
<span class="gi">+        mode: JsonSchemaMode = &#39;validation&#39;,</span>
<span class="gi">+    ) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a JSON schema for the adapted type.

<span class="w"> </span>        Args:
<span class="gu">@@ -331,15 +545,20 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The JSON schema for the model as a dictionary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)</span>
<span class="gi">+        return schema_generator_instance.generate(self.core_schema, mode=mode)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def json_schemas(inputs: Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode,</span>
<span class="gd">-        TypeAdapter[Any]]], /, *, by_alias: bool=True, title: (str | None)=</span>
<span class="gd">-        None, description: (str | None)=None, ref_template: str=</span>
<span class="gd">-        DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema]=</span>
<span class="gd">-        GenerateJsonSchema) -&gt;tuple[dict[tuple[JsonSchemaKeyT,</span>
<span class="gd">-        JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:</span>
<span class="gi">+    def json_schemas(</span>
<span class="gi">+        inputs: Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]],</span>
<span class="gi">+        /,</span>
<span class="gi">+        *,</span>
<span class="gi">+        by_alias: bool = True,</span>
<span class="gi">+        title: str | None = None,</span>
<span class="gi">+        description: str | None = None,</span>
<span class="gi">+        ref_template: str = DEFAULT_REF_TEMPLATE,</span>
<span class="gi">+        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,</span>
<span class="gi">+    ) -&gt; tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a JSON schema including definitions from multiple type adapters.

<span class="w"> </span>        Args:
<span class="gu">@@ -362,4 +581,21 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>                    element, along with the optional title and description keys.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)</span>
<span class="gi">+</span>
<span class="gi">+        inputs_ = []</span>
<span class="gi">+        for key, mode, adapter in inputs:</span>
<span class="gi">+            with adapter._with_frame_depth(1):  # +1 for json_schemas staticmethod</span>
<span class="gi">+                inputs_.append((key, mode, adapter.core_schema))</span>
<span class="gi">+</span>
<span class="gi">+        json_schemas_map, definitions = schema_generator_instance.generate_definitions(inputs_)</span>
<span class="gi">+</span>
<span class="gi">+        json_schema: dict[str, Any] = {}</span>
<span class="gi">+        if definitions:</span>
<span class="gi">+            json_schema[&#39;$defs&#39;] = definitions</span>
<span class="gi">+        if title:</span>
<span class="gi">+            json_schema[&#39;title&#39;] = title</span>
<span class="gi">+        if description:</span>
<span class="gi">+            json_schema[&#39;description&#39;] = description</span>
<span class="gi">+</span>
<span class="gi">+        return json_schemas_map, json_schema</span>
<span class="gh">diff --git a/pydantic/types.py b/pydantic/types.py</span>
<span class="gh">index 48f11cb49..50f397e85 100644</span>
<span class="gd">--- a/pydantic/types.py</span>
<span class="gi">+++ b/pydantic/types.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The types module contains custom types used by pydantic.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import dataclasses as _dataclasses
<span class="w"> </span>import re
<span class="gu">@@ -8,32 +10,110 @@ from decimal import Decimal</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from types import ModuleType
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, ClassVar, Dict, FrozenSet, Generic, Hashable, Iterator, List, Pattern, Set, TypeVar, Union, cast, get_args, get_origin</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    ClassVar,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    FrozenSet,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Hashable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    get_args,</span>
<span class="gi">+    get_origin,</span>
<span class="gi">+)</span>
<span class="w"> </span>from uuid import UUID
<span class="gi">+</span>
<span class="w"> </span>import annotated_types
<span class="w"> </span>from annotated_types import BaseMetadata, MaxLen, MinLen
<span class="w"> </span>from pydantic_core import CoreSchema, PydanticCustomError, core_schema
<span class="w"> </span>from typing_extensions import Annotated, Literal, Protocol, TypeAlias, TypeAliasType, deprecated
<span class="gd">-from ._internal import _core_utils, _fields, _internal_dataclass, _typing_extra, _utils, _validators</span>
<span class="gi">+</span>
<span class="gi">+from ._internal import (</span>
<span class="gi">+    _core_utils,</span>
<span class="gi">+    _fields,</span>
<span class="gi">+    _internal_dataclass,</span>
<span class="gi">+    _typing_extra,</span>
<span class="gi">+    _utils,</span>
<span class="gi">+    _validators,</span>
<span class="gi">+)</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="w"> </span>from .annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler
<span class="w"> </span>from .errors import PydanticUserError
<span class="w"> </span>from .json_schema import JsonSchemaValue
<span class="w"> </span>from .warnings import PydanticDeprecatedSince20
<span class="gd">-__all__ = (&#39;Strict&#39;, &#39;StrictStr&#39;, &#39;conbytes&#39;, &#39;conlist&#39;, &#39;conset&#39;,</span>
<span class="gd">-    &#39;confrozenset&#39;, &#39;constr&#39;, &#39;ImportString&#39;, &#39;conint&#39;, &#39;PositiveInt&#39;,</span>
<span class="gd">-    &#39;NegativeInt&#39;, &#39;NonNegativeInt&#39;, &#39;NonPositiveInt&#39;, &#39;confloat&#39;,</span>
<span class="gd">-    &#39;PositiveFloat&#39;, &#39;NegativeFloat&#39;, &#39;NonNegativeFloat&#39;,</span>
<span class="gd">-    &#39;NonPositiveFloat&#39;, &#39;FiniteFloat&#39;, &#39;condecimal&#39;, &#39;UUID1&#39;, &#39;UUID3&#39;,</span>
<span class="gd">-    &#39;UUID4&#39;, &#39;UUID5&#39;, &#39;FilePath&#39;, &#39;DirectoryPath&#39;, &#39;NewPath&#39;, &#39;Json&#39;,</span>
<span class="gd">-    &#39;Secret&#39;, &#39;SecretStr&#39;, &#39;SecretBytes&#39;, &#39;StrictBool&#39;, &#39;StrictBytes&#39;,</span>
<span class="gd">-    &#39;StrictInt&#39;, &#39;StrictFloat&#39;, &#39;PaymentCardNumber&#39;, &#39;ByteSize&#39;, &#39;PastDate&#39;,</span>
<span class="gd">-    &#39;FutureDate&#39;, &#39;PastDatetime&#39;, &#39;FutureDatetime&#39;, &#39;condate&#39;,</span>
<span class="gd">-    &#39;AwareDatetime&#39;, &#39;NaiveDatetime&#39;, &#39;AllowInfNan&#39;, &#39;EncoderProtocol&#39;,</span>
<span class="gd">-    &#39;EncodedBytes&#39;, &#39;EncodedStr&#39;, &#39;Base64Encoder&#39;, &#39;Base64Bytes&#39;,</span>
<span class="gd">-    &#39;Base64Str&#39;, &#39;Base64UrlBytes&#39;, &#39;Base64UrlStr&#39;, &#39;GetPydanticSchema&#39;,</span>
<span class="gd">-    &#39;StringConstraints&#39;, &#39;Tag&#39;, &#39;Discriminator&#39;, &#39;JsonValue&#39;, &#39;OnErrorOmit&#39;,</span>
<span class="gd">-    &#39;FailFast&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &#39;Strict&#39;,</span>
<span class="gi">+    &#39;StrictStr&#39;,</span>
<span class="gi">+    &#39;conbytes&#39;,</span>
<span class="gi">+    &#39;conlist&#39;,</span>
<span class="gi">+    &#39;conset&#39;,</span>
<span class="gi">+    &#39;confrozenset&#39;,</span>
<span class="gi">+    &#39;constr&#39;,</span>
<span class="gi">+    &#39;ImportString&#39;,</span>
<span class="gi">+    &#39;conint&#39;,</span>
<span class="gi">+    &#39;PositiveInt&#39;,</span>
<span class="gi">+    &#39;NegativeInt&#39;,</span>
<span class="gi">+    &#39;NonNegativeInt&#39;,</span>
<span class="gi">+    &#39;NonPositiveInt&#39;,</span>
<span class="gi">+    &#39;confloat&#39;,</span>
<span class="gi">+    &#39;PositiveFloat&#39;,</span>
<span class="gi">+    &#39;NegativeFloat&#39;,</span>
<span class="gi">+    &#39;NonNegativeFloat&#39;,</span>
<span class="gi">+    &#39;NonPositiveFloat&#39;,</span>
<span class="gi">+    &#39;FiniteFloat&#39;,</span>
<span class="gi">+    &#39;condecimal&#39;,</span>
<span class="gi">+    &#39;UUID1&#39;,</span>
<span class="gi">+    &#39;UUID3&#39;,</span>
<span class="gi">+    &#39;UUID4&#39;,</span>
<span class="gi">+    &#39;UUID5&#39;,</span>
<span class="gi">+    &#39;FilePath&#39;,</span>
<span class="gi">+    &#39;DirectoryPath&#39;,</span>
<span class="gi">+    &#39;NewPath&#39;,</span>
<span class="gi">+    &#39;Json&#39;,</span>
<span class="gi">+    &#39;Secret&#39;,</span>
<span class="gi">+    &#39;SecretStr&#39;,</span>
<span class="gi">+    &#39;SecretBytes&#39;,</span>
<span class="gi">+    &#39;StrictBool&#39;,</span>
<span class="gi">+    &#39;StrictBytes&#39;,</span>
<span class="gi">+    &#39;StrictInt&#39;,</span>
<span class="gi">+    &#39;StrictFloat&#39;,</span>
<span class="gi">+    &#39;PaymentCardNumber&#39;,</span>
<span class="gi">+    &#39;ByteSize&#39;,</span>
<span class="gi">+    &#39;PastDate&#39;,</span>
<span class="gi">+    &#39;FutureDate&#39;,</span>
<span class="gi">+    &#39;PastDatetime&#39;,</span>
<span class="gi">+    &#39;FutureDatetime&#39;,</span>
<span class="gi">+    &#39;condate&#39;,</span>
<span class="gi">+    &#39;AwareDatetime&#39;,</span>
<span class="gi">+    &#39;NaiveDatetime&#39;,</span>
<span class="gi">+    &#39;AllowInfNan&#39;,</span>
<span class="gi">+    &#39;EncoderProtocol&#39;,</span>
<span class="gi">+    &#39;EncodedBytes&#39;,</span>
<span class="gi">+    &#39;EncodedStr&#39;,</span>
<span class="gi">+    &#39;Base64Encoder&#39;,</span>
<span class="gi">+    &#39;Base64Bytes&#39;,</span>
<span class="gi">+    &#39;Base64Str&#39;,</span>
<span class="gi">+    &#39;Base64UrlBytes&#39;,</span>
<span class="gi">+    &#39;Base64UrlStr&#39;,</span>
<span class="gi">+    &#39;GetPydanticSchema&#39;,</span>
<span class="gi">+    &#39;StringConstraints&#39;,</span>
<span class="gi">+    &#39;Tag&#39;,</span>
<span class="gi">+    &#39;Discriminator&#39;,</span>
<span class="gi">+    &#39;JsonValue&#39;,</span>
<span class="gi">+    &#39;OnErrorOmit&#39;,</span>
<span class="gi">+    &#39;FailFast&#39;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)


<span class="gu">@@ -55,19 +135,30 @@ class Strict(_fields.PydanticMetadata, BaseMetadata):</span>
<span class="w"> </span>        StrictBool = Annotated[bool, Strict()]
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    strict: bool = True

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.strict)


<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BOOLEAN TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="w"> </span>StrictBool = Annotated[bool, Strict()]
<span class="w"> </span>&quot;&quot;&quot;A boolean that must be either ``True`` or ``False``.&quot;&quot;&quot;

<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INTEGER TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>

<span class="gd">-def conint(*, strict: (bool | None)=None, gt: (int | None)=None, ge: (int |</span>
<span class="gd">-    None)=None, lt: (int | None)=None, le: (int | None)=None, multiple_of:</span>
<span class="gd">-    (int | None)=None) -&gt;type[int]:</span>
<span class="gi">+def conint(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strict: bool | None = None,</span>
<span class="gi">+    gt: int | None = None,</span>
<span class="gi">+    ge: int | None = None,</span>
<span class="gi">+    lt: int | None = None,</span>
<span class="gi">+    le: int | None = None,</span>
<span class="gi">+    multiple_of: int | None = None,</span>
<span class="gi">+) -&gt; type[int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    !!! warning &quot;Discouraged&quot;
<span class="w"> </span>        This function is **discouraged** in favor of using
<span class="gu">@@ -137,8 +228,13 @@ def conint(*, strict: (bool | None)=None, gt: (int | None)=None, ge: (int |</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;  # noqa: D212</span>
<span class="gi">+    return Annotated[  # pyright: ignore[reportReturnType]</span>
<span class="gi">+        int,</span>
<span class="gi">+        Strict(strict) if strict is not None else None,</span>
<span class="gi">+        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),</span>
<span class="gi">+        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,</span>
<span class="gi">+    ]</span>


<span class="w"> </span>PositiveInt = Annotated[int, annotated_types.Gt(0)]
<span class="gu">@@ -286,20 +382,29 @@ except ValidationError as e:</span>
<span class="w"> </span>```
<span class="w"> </span>&quot;&quot;&quot;

<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FLOAT TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>

<span class="w"> </span>@_dataclasses.dataclass
<span class="w"> </span>class AllowInfNan(_fields.PydanticMetadata):
<span class="w"> </span>    &quot;&quot;&quot;A field metadata class to indicate that a field should allow ``-inf``, ``inf``, and ``nan``.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    allow_inf_nan: bool = True

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.allow_inf_nan)


<span class="gd">-def confloat(*, strict: (bool | None)=None, gt: (float | None)=None, ge: (</span>
<span class="gd">-    float | None)=None, lt: (float | None)=None, le: (float | None)=None,</span>
<span class="gd">-    multiple_of: (float | None)=None, allow_inf_nan: (bool | None)=None</span>
<span class="gd">-    ) -&gt;type[float]:</span>
<span class="gi">+def confloat(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strict: bool | None = None,</span>
<span class="gi">+    gt: float | None = None,</span>
<span class="gi">+    ge: float | None = None,</span>
<span class="gi">+    lt: float | None = None,</span>
<span class="gi">+    le: float | None = None,</span>
<span class="gi">+    multiple_of: float | None = None,</span>
<span class="gi">+    allow_inf_nan: bool | None = None,</span>
<span class="gi">+) -&gt; type[float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    !!! warning &quot;Discouraged&quot;
<span class="w"> </span>        This function is **discouraged** in favor of using
<span class="gu">@@ -369,8 +474,14 @@ def confloat(*, strict: (bool | None)=None, gt: (float | None)=None, ge: (</span>
<span class="w"> </span>        ]
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;  # noqa: D212</span>
<span class="gi">+    return Annotated[  # pyright: ignore[reportReturnType]</span>
<span class="gi">+        float,</span>
<span class="gi">+        Strict(strict) if strict is not None else None,</span>
<span class="gi">+        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),</span>
<span class="gi">+        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,</span>
<span class="gi">+        AllowInfNan(allow_inf_nan) if allow_inf_nan is not None else None,</span>
<span class="gi">+    ]</span>


<span class="w"> </span>PositiveFloat = Annotated[float, annotated_types.Gt(0)]
<span class="gu">@@ -533,8 +644,15 @@ print(m)</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gd">-def conbytes(*, min_length: (int | None)=None, max_length: (int | None)=</span>
<span class="gd">-    None, strict: (bool | None)=None) -&gt;type[bytes]:</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTES TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def conbytes(</span>
<span class="gi">+    *,</span>
<span class="gi">+    min_length: int | None = None,</span>
<span class="gi">+    max_length: int | None = None,</span>
<span class="gi">+    strict: bool | None = None,</span>
<span class="gi">+) -&gt; type[bytes]:</span>
<span class="w"> </span>    &quot;&quot;&quot;A wrapper around `bytes` that allows for additional constraints.

<span class="w"> </span>    Args:
<span class="gu">@@ -545,13 +663,20 @@ def conbytes(*, min_length: (int | None)=None, max_length: (int | None)=</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The wrapped bytes type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Annotated[  # pyright: ignore[reportReturnType]</span>
<span class="gi">+        bytes,</span>
<span class="gi">+        Strict(strict) if strict is not None else None,</span>
<span class="gi">+        annotated_types.Len(min_length or 0, max_length),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>StrictBytes = Annotated[bytes, Strict()]
<span class="w"> </span>&quot;&quot;&quot;A bytes that must be validated in strict mode.&quot;&quot;&quot;


<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ STRING TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@_dataclasses.dataclass(frozen=True)
<span class="w"> </span>class StringConstraints(annotated_types.GroupedMetadata):
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/fields/#string-constraints
<span class="gu">@@ -567,6 +692,7 @@ class StringConstraints(annotated_types.GroupedMetadata):</span>
<span class="w"> </span>        max_length: The maximum length of the string.
<span class="w"> </span>        pattern: A regex pattern that the string must match.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    strip_whitespace: bool | None = None
<span class="w"> </span>    to_upper: bool | None = None
<span class="w"> </span>    to_lower: bool | None = None
<span class="gu">@@ -575,24 +701,37 @@ class StringConstraints(annotated_types.GroupedMetadata):</span>
<span class="w"> </span>    max_length: int | None = None
<span class="w"> </span>    pattern: str | Pattern[str] | None = None

<span class="gd">-    def __iter__(self) -&gt;Iterator[BaseMetadata]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[BaseMetadata]:</span>
<span class="w"> </span>        if self.min_length is not None:
<span class="w"> </span>            yield MinLen(self.min_length)
<span class="w"> </span>        if self.max_length is not None:
<span class="w"> </span>            yield MaxLen(self.max_length)
<span class="w"> </span>        if self.strict is not None:
<span class="w"> </span>            yield Strict(self.strict)
<span class="gd">-        if (self.strip_whitespace is not None or self.pattern is not None or</span>
<span class="gd">-            self.to_lower is not None or self.to_upper is not None):</span>
<span class="gd">-            yield _fields.pydantic_general_metadata(strip_whitespace=self.</span>
<span class="gd">-                strip_whitespace, to_upper=self.to_upper, to_lower=self.</span>
<span class="gd">-                to_lower, pattern=self.pattern)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def constr(*, strip_whitespace: (bool | None)=None, to_upper: (bool | None)</span>
<span class="gd">-    =None, to_lower: (bool | None)=None, strict: (bool | None)=None,</span>
<span class="gd">-    min_length: (int | None)=None, max_length: (int | None)=None, pattern:</span>
<span class="gd">-    (str | Pattern[str] | None)=None) -&gt;type[str]:</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.strip_whitespace is not None</span>
<span class="gi">+            or self.pattern is not None</span>
<span class="gi">+            or self.to_lower is not None</span>
<span class="gi">+            or self.to_upper is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            yield _fields.pydantic_general_metadata(</span>
<span class="gi">+                strip_whitespace=self.strip_whitespace,</span>
<span class="gi">+                to_upper=self.to_upper,</span>
<span class="gi">+                to_lower=self.to_lower,</span>
<span class="gi">+                pattern=self.pattern,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constr(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strip_whitespace: bool | None = None,</span>
<span class="gi">+    to_upper: bool | None = None,</span>
<span class="gi">+    to_lower: bool | None = None,</span>
<span class="gi">+    strict: bool | None = None,</span>
<span class="gi">+    min_length: int | None = None,</span>
<span class="gi">+    max_length: int | None = None,</span>
<span class="gi">+    pattern: str | Pattern[str] | None = None,</span>
<span class="gi">+) -&gt; type[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    !!! warning &quot;Discouraged&quot;
<span class="w"> </span>        This function is **discouraged** in favor of using
<span class="gu">@@ -646,17 +785,32 @@ def constr(*, strip_whitespace: (bool | None)=None, to_upper: (bool | None)</span>

<span class="w"> </span>    Returns:
<span class="w"> </span>        The wrapped string type.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;  # noqa: D212</span>
<span class="gi">+    return Annotated[  # pyright: ignore[reportReturnType]</span>
<span class="gi">+        str,</span>
<span class="gi">+        StringConstraints(</span>
<span class="gi">+            strip_whitespace=strip_whitespace,</span>
<span class="gi">+            to_upper=to_upper,</span>
<span class="gi">+            to_lower=to_lower,</span>
<span class="gi">+            strict=strict,</span>
<span class="gi">+            min_length=min_length,</span>
<span class="gi">+            max_length=max_length,</span>
<span class="gi">+            pattern=pattern,</span>
<span class="gi">+        ),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>StrictStr = Annotated[str, Strict()]
<span class="w"> </span>&quot;&quot;&quot;A string that must be validated in strict mode.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~ COLLECTION TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="w"> </span>HashableItemType = TypeVar(&#39;HashableItemType&#39;, bound=Hashable)


<span class="gd">-def conset(item_type: type[HashableItemType], *, min_length: (int | None)=</span>
<span class="gd">-    None, max_length: (int | None)=None) -&gt;type[set[HashableItemType]]:</span>
<span class="gi">+def conset(</span>
<span class="gi">+    item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None</span>
<span class="gi">+) -&gt; type[set[HashableItemType]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;A wrapper around `typing.Set` that allows for additional constraints.

<span class="w"> </span>    Args:
<span class="gu">@@ -667,12 +821,12 @@ def conset(item_type: type[HashableItemType], *, min_length: (int | None)=</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The wrapped set type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Annotated[Set[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]</span>


<span class="gd">-def confrozenset(item_type: type[HashableItemType], *, min_length: (int |</span>
<span class="gd">-    None)=None, max_length: (int | None)=None) -&gt;type[frozenset[</span>
<span class="gd">-    HashableItemType]]:</span>
<span class="gi">+def confrozenset(</span>
<span class="gi">+    item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None</span>
<span class="gi">+) -&gt; type[frozenset[HashableItemType]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;A wrapper around `typing.FrozenSet` that allows for additional constraints.

<span class="w"> </span>    Args:
<span class="gu">@@ -683,15 +837,19 @@ def confrozenset(item_type: type[HashableItemType], *, min_length: (int |</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The wrapped frozenset type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Annotated[FrozenSet[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]</span>


<span class="w"> </span>AnyItemType = TypeVar(&#39;AnyItemType&#39;)


<span class="gd">-def conlist(item_type: type[AnyItemType], *, min_length: (int | None)=None,</span>
<span class="gd">-    max_length: (int | None)=None, unique_items: (bool | None)=None) -&gt;type[</span>
<span class="gd">-    list[AnyItemType]]:</span>
<span class="gi">+def conlist(</span>
<span class="gi">+    item_type: type[AnyItemType],</span>
<span class="gi">+    *,</span>
<span class="gi">+    min_length: int | None = None,</span>
<span class="gi">+    max_length: int | None = None,</span>
<span class="gi">+    unique_items: bool | None = None,</span>
<span class="gi">+) -&gt; type[list[AnyItemType]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;A wrapper around typing.List that adds validation.

<span class="w"> </span>    Args:
<span class="gu">@@ -706,15 +864,24 @@ def conlist(item_type: type[AnyItemType], *, min_length: (int | None)=None,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The wrapped list type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if unique_items is not None:</span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            (</span>
<span class="gi">+                &#39;`unique_items` is removed, use `Set` instead&#39;</span>
<span class="gi">+                &#39;(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)&#39;</span>
<span class="gi">+            ),</span>
<span class="gi">+            code=&#39;removed-kwargs&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+    return Annotated[List[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]</span>
<span class="gi">+</span>

<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~ IMPORT STRING TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="w"> </span>AnyType = TypeVar(&#39;AnyType&#39;)
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    ImportString = Annotated[AnyType, ...]
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class ImportString:
<span class="w"> </span>        &quot;&quot;&quot;A type that can be used to import a type from a string.

<span class="gu">@@ -807,36 +974,56 @@ else:</span>
<span class="w"> </span>        &quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __class_getitem__(cls, item: AnyType) -&gt;AnyType:</span>
<span class="gi">+        def __class_getitem__(cls, item: AnyType) -&gt; AnyType:</span>
<span class="w"> </span>            return Annotated[item, cls()]

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-            serializer = core_schema.plain_serializer_function_ser_schema(cls</span>
<span class="gd">-                ._serialize, when_used=&#39;json&#39;)</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls, source: type[Any], handler: GetCoreSchemaHandler</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+            serializer = core_schema.plain_serializer_function_ser_schema(cls._serialize, when_used=&#39;json&#39;)</span>
<span class="w"> </span>            if cls is source:
<span class="gd">-                return core_schema.no_info_plain_validator_function(function</span>
<span class="gd">-                    =_validators.import_string, serialization=serializer)</span>
<span class="gi">+                # Treat bare usage of ImportString (`schema is None`) as the same as ImportString[Any]</span>
<span class="gi">+                return core_schema.no_info_plain_validator_function(</span>
<span class="gi">+                    function=_validators.import_string, serialization=serializer</span>
<span class="gi">+                )</span>
<span class="w"> </span>            else:
<span class="gd">-                return core_schema.no_info_before_validator_function(function</span>
<span class="gd">-                    =_validators.import_string, schema=handler(source),</span>
<span class="gd">-                    serialization=serializer)</span>
<span class="gi">+                return core_schema.no_info_before_validator_function(</span>
<span class="gi">+                    function=_validators.import_string, schema=handler(source), serialization=serializer</span>
<span class="gi">+                )</span>

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_json_schema__(cls, cs: CoreSchema, handler:</span>
<span class="gd">-            GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+        def __get_pydantic_json_schema__(cls, cs: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>            return handler(core_schema.str_schema())

<span class="gd">-        def __repr__(self) -&gt;str:</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def _serialize(v: Any) -&gt; str:</span>
<span class="gi">+            if isinstance(v, ModuleType):</span>
<span class="gi">+                return v.__name__</span>
<span class="gi">+            elif hasattr(v, &#39;__module__&#39;) and hasattr(v, &#39;__name__&#39;):</span>
<span class="gi">+                return f&#39;{v.__module__}.{v.__name__}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return v</span>
<span class="gi">+</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="w"> </span>            return &#39;ImportString&#39;


<span class="gd">-def condecimal(*, strict: (bool | None)=None, gt: (int | Decimal | None)=</span>
<span class="gd">-    None, ge: (int | Decimal | None)=None, lt: (int | Decimal | None)=None,</span>
<span class="gd">-    le: (int | Decimal | None)=None, multiple_of: (int | Decimal | None)=</span>
<span class="gd">-    None, max_digits: (int | None)=None, decimal_places: (int | None)=None,</span>
<span class="gd">-    allow_inf_nan: (bool | None)=None) -&gt;type[Decimal]:</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DECIMAL TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def condecimal(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strict: bool | None = None,</span>
<span class="gi">+    gt: int | Decimal | None = None,</span>
<span class="gi">+    ge: int | Decimal | None = None,</span>
<span class="gi">+    lt: int | Decimal | None = None,</span>
<span class="gi">+    le: int | Decimal | None = None,</span>
<span class="gi">+    multiple_of: int | Decimal | None = None,</span>
<span class="gi">+    max_digits: int | None = None,</span>
<span class="gi">+    decimal_places: int | None = None,</span>
<span class="gi">+    allow_inf_nan: bool | None = None,</span>
<span class="gi">+) -&gt; type[Decimal]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    !!! warning &quot;Discouraged&quot;
<span class="w"> </span>        This function is **discouraged** in favor of using
<span class="gu">@@ -909,34 +1096,46 @@ def condecimal(*, strict: (bool | None)=None, gt: (int | Decimal | None)=</span>
<span class="w"> </span>        ]
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;  # noqa: D212</span>
<span class="gi">+    return Annotated[  # pyright: ignore[reportReturnType]</span>
<span class="gi">+        Decimal,</span>
<span class="gi">+        Strict(strict) if strict is not None else None,</span>
<span class="gi">+        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),</span>
<span class="gi">+        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,</span>
<span class="gi">+        _fields.pydantic_general_metadata(max_digits=max_digits, decimal_places=decimal_places),</span>
<span class="gi">+        AllowInfNan(allow_inf_nan) if allow_inf_nan is not None else None,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UUID TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>


<span class="w"> </span>@_dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="w"> </span>class UuidVersion:
<span class="w"> </span>    &quot;&quot;&quot;A field metadata class to indicate a [UUID](https://docs.python.org/3/library/uuid.html) version.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    uuid_version: Literal[1, 3, 4, 5]

<span class="gd">-    def __get_pydantic_json_schema__(self, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        field_schema = handler(core_schema)
<span class="gd">-        field_schema.pop(&#39;anyOf&#39;, None)</span>
<span class="gi">+        field_schema.pop(&#39;anyOf&#39;, None)  # remove the bytes/str union</span>
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=f&#39;uuid{self.uuid_version}&#39;)
<span class="w"> </span>        return field_schema

<span class="gd">-    def __get_pydantic_core_schema__(self, source: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        if isinstance(self, source):
<span class="gi">+            # used directly as a type</span>
<span class="w"> </span>            return core_schema.uuid_schema(version=self.uuid_version)
<span class="w"> </span>        else:
<span class="gi">+            # update existing schema with self.uuid_version</span>
<span class="w"> </span>            schema = handler(source)
<span class="gd">-            _check_annotated_type(schema[&#39;type&#39;], &#39;uuid&#39;, self.__class__.</span>
<span class="gd">-                __name__)</span>
<span class="gd">-            schema[&#39;version&#39;] = self.uuid_version</span>
<span class="gi">+            _check_annotated_type(schema[&#39;type&#39;], &#39;uuid&#39;, self.__class__.__name__)</span>
<span class="gi">+            schema[&#39;version&#39;] = self.uuid_version  # type: ignore</span>
<span class="w"> </span>            return schema

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(type(self.uuid_version))


<span class="gu">@@ -998,29 +1197,57 @@ Model(uuid5=uuid.uuid5(uuid.NAMESPACE_DNS, &#39;pydantic.org&#39;))</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PATH TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@_dataclasses.dataclass
<span class="w"> </span>class PathType:
<span class="w"> </span>    path_type: Literal[&#39;file&#39;, &#39;dir&#39;, &#39;new&#39;]

<span class="gd">-    def __get_pydantic_json_schema__(self, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        field_schema = handler(core_schema)
<span class="w"> </span>        format_conversion = {&#39;file&#39;: &#39;file-path&#39;, &#39;dir&#39;: &#39;directory-path&#39;}
<span class="gd">-        field_schema.update(format=format_conversion.get(self.path_type,</span>
<span class="gd">-            &#39;path&#39;), type=&#39;string&#39;)</span>
<span class="gi">+        field_schema.update(format=format_conversion.get(self.path_type, &#39;path&#39;), type=&#39;string&#39;)</span>
<span class="w"> </span>        return field_schema

<span class="gd">-    def __get_pydantic_core_schema__(self, source: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        function_lookup = {&#39;file&#39;: cast(core_schema.</span>
<span class="gd">-            WithInfoValidatorFunction, self.validate_file), &#39;dir&#39;: cast(</span>
<span class="gd">-            core_schema.WithInfoValidatorFunction, self.validate_directory),</span>
<span class="gd">-            &#39;new&#39;: cast(core_schema.WithInfoValidatorFunction, self.</span>
<span class="gd">-            validate_new)}</span>
<span class="gd">-        return core_schema.with_info_after_validator_function(function_lookup</span>
<span class="gd">-            [self.path_type], handler(source))</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        function_lookup = {</span>
<span class="gi">+            &#39;file&#39;: cast(core_schema.WithInfoValidatorFunction, self.validate_file),</span>
<span class="gi">+            &#39;dir&#39;: cast(core_schema.WithInfoValidatorFunction, self.validate_directory),</span>
<span class="gi">+            &#39;new&#39;: cast(core_schema.WithInfoValidatorFunction, self.validate_new),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return core_schema.with_info_after_validator_function(</span>
<span class="gi">+            function_lookup[self.path_type],</span>
<span class="gi">+            handler(source),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def validate_file(path: Path, _: core_schema.ValidationInfo) -&gt; Path:</span>
<span class="gi">+        if path.is_file():</span>
<span class="gi">+            return path</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticCustomError(&#39;path_not_file&#39;, &#39;Path does not point to a file&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def validate_directory(path: Path, _: core_schema.ValidationInfo) -&gt; Path:</span>
<span class="gi">+        if path.is_dir():</span>
<span class="gi">+            return path</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticCustomError(&#39;path_not_directory&#39;, &#39;Path does not point to a directory&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def validate_new(path: Path, _: core_schema.ValidationInfo) -&gt; Path:</span>
<span class="gi">+        if path.exists():</span>
<span class="gi">+            raise PydanticCustomError(&#39;path_exists&#39;, &#39;Path already exists&#39;)</span>
<span class="gi">+        elif not path.parent.exists():</span>
<span class="gi">+            raise PydanticCustomError(&#39;parent_does_not_exist&#39;, &#39;Parent directory does not exist&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return path</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(type(self.path_type))


<span class="gu">@@ -1110,10 +1337,15 @@ except ValidationError as e:</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>NewPath = Annotated[Path, PathType(&#39;new&#39;)]
<span class="w"> </span>&quot;&quot;&quot;A path for a new file or directory that must not already exist. The parent directory must already exist.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ JSON TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gi">+    # Json[list[str]] will be recognized by type checkers as list[str]</span>
<span class="w"> </span>    Json = Annotated[AnyType, ...]
<span class="gd">-else:</span>

<span class="gi">+else:</span>

<span class="w"> </span>    class Json:
<span class="w"> </span>        &quot;&quot;&quot;A special type wrapper which loads JSON before parsing.
<span class="gu">@@ -1196,54 +1428,58 @@ else:</span>
<span class="w"> </span>        &quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __class_getitem__(cls, item: AnyType) -&gt;AnyType:</span>
<span class="gi">+        def __class_getitem__(cls, item: AnyType) -&gt; AnyType:</span>
<span class="w"> </span>            return Annotated[item, cls()]

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: Any, handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            if cls is source:
<span class="w"> </span>                return core_schema.json_schema(None)
<span class="w"> </span>            else:
<span class="w"> </span>                return core_schema.json_schema(handler(source))

<span class="gd">-        def __repr__(self) -&gt;str:</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="w"> </span>            return &#39;Json&#39;

<span class="gd">-        def __hash__(self) -&gt;int:</span>
<span class="gi">+        def __hash__(self) -&gt; int:</span>
<span class="w"> </span>            return hash(type(self))

<span class="gd">-        def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gi">+        def __eq__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>            return type(other) == type(self)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SECRET TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="w"> </span>SecretType = TypeVar(&#39;SecretType&#39;)


<span class="w"> </span>class _SecretBase(Generic[SecretType]):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, secret_value: SecretType) -&gt;None:</span>
<span class="gi">+    def __init__(self, secret_value: SecretType) -&gt; None:</span>
<span class="w"> </span>        self._secret_value: SecretType = secret_value

<span class="gd">-    def get_secret_value(self) -&gt;SecretType:</span>
<span class="gi">+    def get_secret_value(self) -&gt; SecretType:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the secret value.

<span class="w"> </span>        Returns:
<span class="w"> </span>            The secret value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._secret_value</span>

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, self.__class__) and self.get_secret_value(</span>
<span class="gd">-            ) == other.get_secret_value()</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.get_secret_value())

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self._display())

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;{self.__class__.__name__}({self._display()!r})&#39;

<span class="gi">+    def _display(self) -&gt; str | bytes:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>

<span class="w"> </span>class Secret(_SecretBase[SecretType]):
<span class="w"> </span>    &quot;&quot;&quot;A generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.
<span class="gu">@@ -1301,44 +1537,58 @@ class Secret(_SecretBase[SecretType]):</span>
<span class="w"> </span>    The value returned by the `_display` method will be used for `repr()` and `str()`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def _display(self) -&gt; str | bytes:</span>
<span class="gi">+        return &#39;**********&#39; if self.get_secret_value() else &#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>        inner_type = None
<span class="gi">+        # if origin_type is Secret, then cls is a GenericAlias, and we can extract the inner type directly</span>
<span class="w"> </span>        origin_type = get_origin(source)
<span class="w"> </span>        if origin_type is not None:
<span class="w"> </span>            inner_type = get_args(source)[0]
<span class="gi">+        # otherwise, we need to get the inner type from the base class</span>
<span class="w"> </span>        else:
<span class="gd">-            bases = getattr(cls, &#39;__orig_bases__&#39;, getattr(cls, &#39;__bases__&#39;,</span>
<span class="gd">-                []))</span>
<span class="gi">+            bases = getattr(cls, &#39;__orig_bases__&#39;, getattr(cls, &#39;__bases__&#39;, []))</span>
<span class="w"> </span>            for base in bases:
<span class="w"> </span>                if get_origin(base) is Secret:
<span class="w"> </span>                    inner_type = get_args(base)[0]
<span class="w"> </span>            if bases == [] or inner_type is None:
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    f&quot;Can&#39;t get secret type from {cls.__name__}. Please use Secret[&lt;type&gt;], or subclass from Secret[&lt;type&gt;] instead.&quot;</span>
<span class="gd">-                    )</span>
<span class="gd">-        inner_schema = handler.generate_schema(inner_type)</span>
<span class="gi">+                    f&quot;Can&#39;t get secret type from {cls.__name__}. &quot;</span>
<span class="gi">+                    &#39;Please use Secret[&lt;type&gt;], or subclass from Secret[&lt;type&gt;] instead.&#39;</span>
<span class="gi">+                )</span>

<span class="gd">-        def validate_secret_value(value, handler) -&gt;Secret[SecretType]:</span>
<span class="gi">+        inner_schema = handler.generate_schema(inner_type)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        def validate_secret_value(value, handler) -&gt; Secret[SecretType]:</span>
<span class="w"> </span>            if isinstance(value, Secret):
<span class="w"> </span>                value = value.get_secret_value()
<span class="w"> </span>            validated_inner = handler(value)
<span class="w"> </span>            return cls(validated_inner)

<span class="gd">-        def serialize(value: Secret[SecretType], info: core_schema.</span>
<span class="gd">-            SerializationInfo) -&gt;(str | Secret[SecretType]):</span>
<span class="gi">+        def serialize(value: Secret[SecretType], info: core_schema.SerializationInfo) -&gt; str | Secret[SecretType]:</span>
<span class="w"> </span>            if info.mode == &#39;json&#39;:
<span class="w"> </span>                return str(value)
<span class="w"> </span>            else:
<span class="w"> </span>                return value
<span class="gd">-        return core_schema.json_or_python_schema(python_schema=core_schema.</span>
<span class="gd">-            no_info_wrap_validator_function(validate_secret_value,</span>
<span class="gd">-            inner_schema), json_schema=core_schema.</span>
<span class="gd">-            no_info_after_validator_function(lambda x: cls(x), inner_schema</span>
<span class="gd">-            ), serialization=core_schema.</span>
<span class="gd">-            plain_serializer_function_ser_schema(serialize, info_arg=True,</span>
<span class="gd">-            when_used=&#39;always&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        return core_schema.json_or_python_schema(</span>
<span class="gi">+            python_schema=core_schema.no_info_wrap_validator_function(</span>
<span class="gi">+                validate_secret_value,</span>
<span class="gi">+                inner_schema,</span>
<span class="gi">+            ),</span>
<span class="gi">+            json_schema=core_schema.no_info_after_validator_function(lambda x: cls(x), inner_schema),</span>
<span class="gi">+            serialization=core_schema.plain_serializer_function_ser_schema(</span>
<span class="gi">+                serialize,</span>
<span class="gi">+                info_arg=True,</span>
<span class="gi">+                when_used=&#39;always&#39;,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _secret_display(value: SecretType) -&gt; str:  # type: ignore</span>
<span class="gi">+    return &#39;**********&#39; if value else &#39;&#39;</span>


<span class="w"> </span>class _SecretField(_SecretBase[SecretType]):
<span class="gu">@@ -1346,37 +1596,56 @@ class _SecretField(_SecretBase[SecretType]):</span>
<span class="w"> </span>    _error_kind: ClassVar[str]

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-</span>
<span class="gd">-        def serialize(value: _SecretField[SecretType], info: core_schema.</span>
<span class="gd">-            SerializationInfo) -&gt;(str | _SecretField[SecretType]):</span>
<span class="gi">+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        def serialize(</span>
<span class="gi">+            value: _SecretField[SecretType], info: core_schema.SerializationInfo</span>
<span class="gi">+        ) -&gt; str | _SecretField[SecretType]:</span>
<span class="w"> </span>            if info.mode == &#39;json&#39;:
<span class="gi">+                # we want the output to always be string without the `b&#39;` prefix for bytes,</span>
<span class="gi">+                # hence we just use `secret_display`</span>
<span class="w"> </span>                return _secret_display(value.get_secret_value())
<span class="w"> </span>            else:
<span class="w"> </span>                return value

<span class="gd">-        def get_json_schema(_core_schema: core_schema.CoreSchema, handler:</span>
<span class="gd">-            GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+        def get_json_schema(_core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>            json_schema = handler(cls._inner_schema)
<span class="gd">-            _utils.update_not_none(json_schema, type=&#39;string&#39;, writeOnly=</span>
<span class="gd">-                True, format=&#39;password&#39;)</span>
<span class="gi">+            _utils.update_not_none(</span>
<span class="gi">+                json_schema,</span>
<span class="gi">+                type=&#39;string&#39;,</span>
<span class="gi">+                writeOnly=True,</span>
<span class="gi">+                format=&#39;password&#39;,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            return json_schema
<span class="gd">-        json_schema = core_schema.no_info_after_validator_function(source,</span>
<span class="gd">-            cls._inner_schema)</span>
<span class="gd">-</span>
<span class="gd">-        def get_secret_schema(strict: bool) -&gt;CoreSchema:</span>
<span class="gd">-            return core_schema.json_or_python_schema(python_schema=</span>
<span class="gd">-                core_schema.union_schema([core_schema.is_instance_schema(</span>
<span class="gd">-                source), json_schema], custom_error_type=cls._error_kind,</span>
<span class="gd">-                strict=strict), json_schema=json_schema, serialization=</span>
<span class="gd">-                core_schema.plain_serializer_function_ser_schema(serialize,</span>
<span class="gd">-                info_arg=True, return_schema=core_schema.str_schema(),</span>
<span class="gd">-                when_used=&#39;json&#39;))</span>
<span class="gd">-        return core_schema.lax_or_strict_schema(lax_schema=</span>
<span class="gd">-            get_secret_schema(strict=False), strict_schema=</span>
<span class="gd">-            get_secret_schema(strict=True), metadata={</span>
<span class="gd">-            &#39;pydantic_js_functions&#39;: [get_json_schema]})</span>
<span class="gi">+</span>
<span class="gi">+        json_schema = core_schema.no_info_after_validator_function(</span>
<span class="gi">+            source,  # construct the type</span>
<span class="gi">+            cls._inner_schema,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def get_secret_schema(strict: bool) -&gt; CoreSchema:</span>
<span class="gi">+            return core_schema.json_or_python_schema(</span>
<span class="gi">+                python_schema=core_schema.union_schema(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        core_schema.is_instance_schema(source),</span>
<span class="gi">+                        json_schema,</span>
<span class="gi">+                    ],</span>
<span class="gi">+                    custom_error_type=cls._error_kind,</span>
<span class="gi">+                    strict=strict,</span>
<span class="gi">+                ),</span>
<span class="gi">+                json_schema=json_schema,</span>
<span class="gi">+                serialization=core_schema.plain_serializer_function_ser_schema(</span>
<span class="gi">+                    serialize,</span>
<span class="gi">+                    info_arg=True,</span>
<span class="gi">+                    return_schema=core_schema.str_schema(),</span>
<span class="gi">+                    when_used=&#39;json&#39;,</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return core_schema.lax_or_strict_schema(</span>
<span class="gi">+            lax_schema=get_secret_schema(strict=False),</span>
<span class="gi">+            strict_schema=get_secret_schema(strict=True),</span>
<span class="gi">+            metadata={&#39;pydantic_js_functions&#39;: [get_json_schema]},</span>
<span class="gi">+        )</span>


<span class="w"> </span>class SecretStr(_SecretField[str]):
<span class="gu">@@ -1402,12 +1671,16 @@ class SecretStr(_SecretField[str]):</span>
<span class="w"> </span>    #&gt; (SecretStr(&#39;**********&#39;), SecretStr(&#39;&#39;))
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _inner_schema: ClassVar[CoreSchema] = core_schema.str_schema()
<span class="w"> </span>    _error_kind: ClassVar[str] = &#39;string_type&#39;

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._secret_value)

<span class="gi">+    def _display(self) -&gt; str:</span>
<span class="gi">+        return _secret_display(self._secret_value)</span>
<span class="gi">+</span>

<span class="w"> </span>class SecretBytes(_SecretField[bytes]):
<span class="w"> </span>    &quot;&quot;&quot;A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.
<span class="gu">@@ -1431,12 +1704,19 @@ class SecretBytes(_SecretField[bytes]):</span>
<span class="w"> </span>    #&gt; (SecretBytes(b&#39;**********&#39;), SecretBytes(b&#39;&#39;))
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _inner_schema: ClassVar[CoreSchema] = core_schema.bytes_schema()
<span class="w"> </span>    _error_kind: ClassVar[str] = &#39;bytes_type&#39;

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._secret_value)

<span class="gi">+    def _display(self) -&gt; bytes:</span>
<span class="gi">+        return _secret_display(self._secret_value).encode()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PAYMENT CARD TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>

<span class="w"> </span>class PaymentCardBrand(str, Enum):
<span class="w"> </span>    amex = &#39;American Express&#39;
<span class="gu">@@ -1444,15 +1724,18 @@ class PaymentCardBrand(str, Enum):</span>
<span class="w"> </span>    visa = &#39;Visa&#39;
<span class="w"> </span>    other = &#39;other&#39;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.value


<span class="w"> </span>@deprecated(
<span class="gd">-    &#39;The `PaymentCardNumber` class is deprecated, use `pydantic_extra_types` instead. See https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.&#39;</span>
<span class="gd">-    , category=PydanticDeprecatedSince20)</span>
<span class="gi">+    &#39;The `PaymentCardNumber` class is deprecated, use `pydantic_extra_types` instead. &#39;</span>
<span class="gi">+    &#39;See https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.&#39;,</span>
<span class="gi">+    category=PydanticDeprecatedSince20,</span>
<span class="gi">+)</span>
<span class="w"> </span>class PaymentCardNumber(str):
<span class="w"> </span>    &quot;&quot;&quot;Based on: https://en.wikipedia.org/wiki/Payment_card_number.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    strip_whitespace: ClassVar[bool] = True
<span class="w"> </span>    min_length: ClassVar[int] = 12
<span class="w"> </span>    max_length: ClassVar[int] = 19
<span class="gu">@@ -1462,49 +1745,98 @@ class PaymentCardNumber(str):</span>

<span class="w"> </span>    def __init__(self, card_number: str):
<span class="w"> </span>        self.validate_digits(card_number)
<span class="gi">+</span>
<span class="w"> </span>        card_number = self.validate_luhn_check_digit(card_number)
<span class="gi">+</span>
<span class="w"> </span>        self.bin = card_number[:6]
<span class="w"> </span>        self.last4 = card_number[-4:]
<span class="w"> </span>        self.brand = self.validate_brand(card_number)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        return core_schema.with_info_after_validator_function(cls.validate,</span>
<span class="gd">-            core_schema.str_schema(min_length=cls.min_length, max_length=</span>
<span class="gd">-            cls.max_length, strip_whitespace=cls.strip_whitespace))</span>
<span class="gi">+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.with_info_after_validator_function(</span>
<span class="gi">+            cls.validate,</span>
<span class="gi">+            core_schema.str_schema(</span>
<span class="gi">+                min_length=cls.min_length, max_length=cls.max_length, strip_whitespace=cls.strip_whitespace</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def validate(cls, input_value: str, /, _: core_schema.ValidationInfo</span>
<span class="gd">-        ) -&gt;PaymentCardNumber:</span>
<span class="gi">+    def validate(cls, input_value: str, /, _: core_schema.ValidationInfo) -&gt; PaymentCardNumber:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate the card number and return a `PaymentCardNumber` instance.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(input_value)</span>

<span class="w"> </span>    @property
<span class="gd">-    def masked(self) -&gt;str:</span>
<span class="gi">+    def masked(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mask all but the last 4 digits of the card number.

<span class="w"> </span>        Returns:
<span class="w"> </span>            A masked card number string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        num_masked = len(self) - 10  # len(bin) + len(last4) == 10</span>
<span class="gi">+        return f&#39;{self.bin}{&quot;*&quot; * num_masked}{self.last4}&#39;</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def validate_digits(cls, card_number: str) -&gt;None:</span>
<span class="gi">+    def validate_digits(cls, card_number: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate that the card number is all digits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not card_number.isdigit():</span>
<span class="gi">+            raise PydanticCustomError(&#39;payment_card_number_digits&#39;, &#39;Card number is not all digits&#39;)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def validate_luhn_check_digit(cls, card_number: str) -&gt;str:</span>
<span class="gi">+    def validate_luhn_check_digit(cls, card_number: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sum_ = int(card_number[-1])</span>
<span class="gi">+        length = len(card_number)</span>
<span class="gi">+        parity = length % 2</span>
<span class="gi">+        for i in range(length - 1):</span>
<span class="gi">+            digit = int(card_number[i])</span>
<span class="gi">+            if i % 2 == parity:</span>
<span class="gi">+                digit *= 2</span>
<span class="gi">+            if digit &gt; 9:</span>
<span class="gi">+                digit -= 9</span>
<span class="gi">+            sum_ += digit</span>
<span class="gi">+        valid = sum_ % 10 == 0</span>
<span class="gi">+        if not valid:</span>
<span class="gi">+            raise PydanticCustomError(&#39;payment_card_number_luhn&#39;, &#39;Card number is not luhn valid&#39;)</span>
<span class="gi">+        return card_number</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def validate_brand(card_number: str) -&gt;PaymentCardBrand:</span>
<span class="gi">+    def validate_brand(card_number: str) -&gt; PaymentCardBrand:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate length based on BIN for major brands:
<span class="w"> </span>        https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if card_number[0] == &#39;4&#39;:</span>
<span class="gi">+            brand = PaymentCardBrand.visa</span>
<span class="gi">+        elif 51 &lt;= int(card_number[:2]) &lt;= 55:</span>
<span class="gi">+            brand = PaymentCardBrand.mastercard</span>
<span class="gi">+        elif card_number[:2] in {&#39;34&#39;, &#39;37&#39;}:</span>
<span class="gi">+            brand = PaymentCardBrand.amex</span>
<span class="gi">+        else:</span>
<span class="gi">+            brand = PaymentCardBrand.other</span>
<span class="gi">+</span>
<span class="gi">+        required_length: None | int | str = None</span>
<span class="gi">+        if brand in PaymentCardBrand.mastercard:</span>
<span class="gi">+            required_length = 16</span>
<span class="gi">+            valid = len(card_number) == required_length</span>
<span class="gi">+        elif brand == PaymentCardBrand.visa:</span>
<span class="gi">+            required_length = &#39;13, 16 or 19&#39;</span>
<span class="gi">+            valid = len(card_number) in {13, 16, 19}</span>
<span class="gi">+        elif brand == PaymentCardBrand.amex:</span>
<span class="gi">+            required_length = 15</span>
<span class="gi">+            valid = len(card_number) == required_length</span>
<span class="gi">+        else:</span>
<span class="gi">+            valid = True</span>
<span class="gi">+</span>
<span class="gi">+        if not valid:</span>
<span class="gi">+            raise PydanticCustomError(</span>
<span class="gi">+                &#39;payment_card_number_brand&#39;,</span>
<span class="gi">+                &#39;Length for a {brand} card must be {required_length}&#39;,</span>
<span class="gi">+                {&#39;brand&#39;: brand, &#39;required_length&#39;: required_length},</span>
<span class="gi">+            )</span>
<span class="gi">+        return brand</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTE SIZE TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>


<span class="w"> </span>class ByteSize(int):
<span class="gu">@@ -1543,31 +1875,80 @@ class ByteSize(int):</span>
<span class="w"> </span>    #&gt; 45474.73508864641
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    byte_sizes = {&#39;b&#39;: 1, &#39;kb&#39;: 10 ** 3, &#39;mb&#39;: 10 ** 6, &#39;gb&#39;: 10 ** 9, &#39;tb&#39;:</span>
<span class="gd">-        10 ** 12, &#39;pb&#39;: 10 ** 15, &#39;eb&#39;: 10 ** 18, &#39;kib&#39;: 2 ** 10, &#39;mib&#39;: 2 **</span>
<span class="gd">-        20, &#39;gib&#39;: 2 ** 30, &#39;tib&#39;: 2 ** 40, &#39;pib&#39;: 2 ** 50, &#39;eib&#39;: 2 ** 60,</span>
<span class="gd">-        &#39;bit&#39;: 1 / 8, &#39;kbit&#39;: 10 ** 3 / 8, &#39;mbit&#39;: 10 ** 6 / 8, &#39;gbit&#39;: 10 **</span>
<span class="gd">-        9 / 8, &#39;tbit&#39;: 10 ** 12 / 8, &#39;pbit&#39;: 10 ** 15 / 8, &#39;ebit&#39;: 10 ** 18 /</span>
<span class="gd">-        8, &#39;kibit&#39;: 2 ** 10 / 8, &#39;mibit&#39;: 2 ** 20 / 8, &#39;gibit&#39;: 2 ** 30 / 8,</span>
<span class="gd">-        &#39;tibit&#39;: 2 ** 40 / 8, &#39;pibit&#39;: 2 ** 50 / 8, &#39;eibit&#39;: 2 ** 60 / 8}</span>
<span class="gd">-    byte_sizes.update({k.lower()[0]: v for k, v in byte_sizes.items() if </span>
<span class="gd">-        &#39;i&#39; not in k})</span>
<span class="gd">-    byte_string_pattern = &#39;^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?&#39;</span>
<span class="gi">+</span>
<span class="gi">+    byte_sizes = {</span>
<span class="gi">+        &#39;b&#39;: 1,</span>
<span class="gi">+        &#39;kb&#39;: 10**3,</span>
<span class="gi">+        &#39;mb&#39;: 10**6,</span>
<span class="gi">+        &#39;gb&#39;: 10**9,</span>
<span class="gi">+        &#39;tb&#39;: 10**12,</span>
<span class="gi">+        &#39;pb&#39;: 10**15,</span>
<span class="gi">+        &#39;eb&#39;: 10**18,</span>
<span class="gi">+        &#39;kib&#39;: 2**10,</span>
<span class="gi">+        &#39;mib&#39;: 2**20,</span>
<span class="gi">+        &#39;gib&#39;: 2**30,</span>
<span class="gi">+        &#39;tib&#39;: 2**40,</span>
<span class="gi">+        &#39;pib&#39;: 2**50,</span>
<span class="gi">+        &#39;eib&#39;: 2**60,</span>
<span class="gi">+        &#39;bit&#39;: 1 / 8,</span>
<span class="gi">+        &#39;kbit&#39;: 10**3 / 8,</span>
<span class="gi">+        &#39;mbit&#39;: 10**6 / 8,</span>
<span class="gi">+        &#39;gbit&#39;: 10**9 / 8,</span>
<span class="gi">+        &#39;tbit&#39;: 10**12 / 8,</span>
<span class="gi">+        &#39;pbit&#39;: 10**15 / 8,</span>
<span class="gi">+        &#39;ebit&#39;: 10**18 / 8,</span>
<span class="gi">+        &#39;kibit&#39;: 2**10 / 8,</span>
<span class="gi">+        &#39;mibit&#39;: 2**20 / 8,</span>
<span class="gi">+        &#39;gibit&#39;: 2**30 / 8,</span>
<span class="gi">+        &#39;tibit&#39;: 2**40 / 8,</span>
<span class="gi">+        &#39;pibit&#39;: 2**50 / 8,</span>
<span class="gi">+        &#39;eibit&#39;: 2**60 / 8,</span>
<span class="gi">+    }</span>
<span class="gi">+    byte_sizes.update({k.lower()[0]: v for k, v in byte_sizes.items() if &#39;i&#39; not in k})</span>
<span class="gi">+</span>
<span class="gi">+    byte_string_pattern = r&#39;^\s*(\d*\.?\d+)\s*(\w+)?&#39;</span>
<span class="w"> </span>    byte_string_re = re.compile(byte_string_pattern, re.IGNORECASE)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        return core_schema.with_info_after_validator_function(function=cls.</span>
<span class="gd">-            _validate, schema=core_schema.union_schema([core_schema.</span>
<span class="gd">-            str_schema(pattern=cls.byte_string_pattern), core_schema.</span>
<span class="gd">-            int_schema(ge=0)], custom_error_type=&#39;byte_size&#39;,</span>
<span class="gd">-            custom_error_message=</span>
<span class="gd">-            &#39;could not parse value and unit from byte string&#39;),</span>
<span class="gi">+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.with_info_after_validator_function(</span>
<span class="gi">+            function=cls._validate,</span>
<span class="gi">+            schema=core_schema.union_schema(</span>
<span class="gi">+                [</span>
<span class="gi">+                    core_schema.str_schema(pattern=cls.byte_string_pattern),</span>
<span class="gi">+                    core_schema.int_schema(ge=0),</span>
<span class="gi">+                ],</span>
<span class="gi">+                custom_error_type=&#39;byte_size&#39;,</span>
<span class="gi">+                custom_error_message=&#39;could not parse value and unit from byte string&#39;,</span>
<span class="gi">+            ),</span>
<span class="w"> </span>            serialization=core_schema.plain_serializer_function_ser_schema(
<span class="gd">-            int, return_schema=core_schema.int_schema(ge=0)))</span>
<span class="gi">+                int, return_schema=core_schema.int_schema(ge=0)</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>

<span class="gd">-    def human_readable(self, decimal: bool=False, separator: str=&#39;&#39;) -&gt;str:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _validate(cls, input_value: Any, /, _: core_schema.ValidationInfo) -&gt; ByteSize:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return cls(int(input_value))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        str_match = cls.byte_string_re.match(str(input_value))</span>
<span class="gi">+        if str_match is None:</span>
<span class="gi">+            raise PydanticCustomError(&#39;byte_size&#39;, &#39;could not parse value and unit from byte string&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        scalar, unit = str_match.groups()</span>
<span class="gi">+        if unit is None:</span>
<span class="gi">+            unit = &#39;b&#39;</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            unit_mult = cls.byte_sizes[unit.lower()]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise PydanticCustomError(&#39;byte_size_unit&#39;, &#39;could not interpret byte unit: {unit}&#39;, {&#39;unit&#39;: unit})</span>
<span class="gi">+</span>
<span class="gi">+        return cls(int(float(scalar) * unit_mult))</span>
<span class="gi">+</span>
<span class="gi">+    def human_readable(self, decimal: bool = False, separator: str = &#39;&#39;) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts a byte size to a human readable string.

<span class="w"> </span>        Args:
<span class="gu">@@ -1578,9 +1959,27 @@ class ByteSize(int):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A human readable string representation of the byte size.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def to(self, unit: str) -&gt;float:</span>
<span class="gi">+        if decimal:</span>
<span class="gi">+            divisor = 1000</span>
<span class="gi">+            units = &#39;B&#39;, &#39;KB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;</span>
<span class="gi">+            final_unit = &#39;EB&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            divisor = 1024</span>
<span class="gi">+            units = &#39;B&#39;, &#39;KiB&#39;, &#39;MiB&#39;, &#39;GiB&#39;, &#39;TiB&#39;, &#39;PiB&#39;</span>
<span class="gi">+            final_unit = &#39;EiB&#39;</span>
<span class="gi">+</span>
<span class="gi">+        num = float(self)</span>
<span class="gi">+        for unit in units:</span>
<span class="gi">+            if abs(num) &lt; divisor:</span>
<span class="gi">+                if unit == &#39;B&#39;:</span>
<span class="gi">+                    return f&#39;{num:0.0f}{separator}{unit}&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return f&#39;{num:0.1f}{separator}{unit}&#39;</span>
<span class="gi">+            num /= divisor</span>
<span class="gi">+</span>
<span class="gi">+        return f&#39;{num:0.1f}{separator}{final_unit}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def to(self, unit: str) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts a byte size to another unit, including both byte and bit units.

<span class="w"> </span>        Args:
<span class="gu">@@ -1592,7 +1991,20 @@ class ByteSize(int):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The byte size in the new unit.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            unit_div = self.byte_sizes[unit.lower()]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise PydanticCustomError(&#39;byte_size_unit&#39;, &#39;Could not interpret byte unit: {unit}&#39;, {&#39;unit&#39;: unit})</span>
<span class="gi">+</span>
<span class="gi">+        return self / unit_div</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DATE TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_annotated_type(annotated_type: str, expected_type: str, annotation: str) -&gt; None:</span>
<span class="gi">+    if annotated_type != expected_type:</span>
<span class="gi">+        raise PydanticUserError(f&quot;&#39;{annotation}&#39; cannot annotate &#39;{annotated_type}&#39;.&quot;, code=&#39;invalid_annotated_type&#39;)</span>


<span class="w"> </span>if TYPE_CHECKING:
<span class="gu">@@ -1600,14 +2012,15 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    FutureDate = Annotated[date, ...]
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class PastDate:
<span class="w"> </span>        &quot;&quot;&quot;A date in the past.&quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls, source: type[Any], handler: GetCoreSchemaHandler</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            if cls is source:
<span class="gi">+                # used directly as a type</span>
<span class="w"> </span>                return core_schema.date_schema(now_op=&#39;past&#39;)
<span class="w"> </span>            else:
<span class="w"> </span>                schema = handler(source)
<span class="gu">@@ -1615,17 +2028,18 @@ else:</span>
<span class="w"> </span>                schema[&#39;now_op&#39;] = &#39;past&#39;
<span class="w"> </span>                return schema

<span class="gd">-        def __repr__(self) -&gt;str:</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="w"> </span>            return &#39;PastDate&#39;

<span class="gd">-</span>
<span class="w"> </span>    class FutureDate:
<span class="w"> </span>        &quot;&quot;&quot;A date in the future.&quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls, source: type[Any], handler: GetCoreSchemaHandler</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            if cls is source:
<span class="gi">+                # used directly as a type</span>
<span class="w"> </span>                return core_schema.date_schema(now_op=&#39;future&#39;)
<span class="w"> </span>            else:
<span class="w"> </span>                schema = handler(source)
<span class="gu">@@ -1633,13 +2047,18 @@ else:</span>
<span class="w"> </span>                schema[&#39;now_op&#39;] = &#39;future&#39;
<span class="w"> </span>                return schema

<span class="gd">-        def __repr__(self) -&gt;str:</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="w"> </span>            return &#39;FutureDate&#39;


<span class="gd">-def condate(*, strict: (bool | None)=None, gt: (date | None)=None, ge: (</span>
<span class="gd">-    date | None)=None, lt: (date | None)=None, le: (date | None)=None) -&gt;type[</span>
<span class="gd">-    date]:</span>
<span class="gi">+def condate(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strict: bool | None = None,</span>
<span class="gi">+    gt: date | None = None,</span>
<span class="gi">+    ge: date | None = None,</span>
<span class="gi">+    lt: date | None = None,</span>
<span class="gi">+    le: date | None = None,</span>
<span class="gi">+) -&gt; type[date]:</span>
<span class="w"> </span>    &quot;&quot;&quot;A wrapper for date that adds constraints.

<span class="w"> </span>    Args:
<span class="gu">@@ -1652,24 +2071,32 @@ def condate(*, strict: (bool | None)=None, gt: (date | None)=None, ge: (</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A date type with the specified constraints.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Annotated[  # pyright: ignore[reportReturnType]</span>
<span class="gi">+        date,</span>
<span class="gi">+        Strict(strict) if strict is not None else None,</span>
<span class="gi">+        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>

<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DATETIME TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    AwareDatetime = Annotated[datetime, ...]
<span class="w"> </span>    NaiveDatetime = Annotated[datetime, ...]
<span class="w"> </span>    PastDatetime = Annotated[datetime, ...]
<span class="w"> </span>    FutureDatetime = Annotated[datetime, ...]
<span class="gd">-else:</span>

<span class="gi">+else:</span>

<span class="w"> </span>    class AwareDatetime:
<span class="w"> </span>        &quot;&quot;&quot;A datetime that requires timezone info.&quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls, source: type[Any], handler: GetCoreSchemaHandler</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            if cls is source:
<span class="gi">+                # used directly as a type</span>
<span class="w"> </span>                return core_schema.datetime_schema(tz_constraint=&#39;aware&#39;)
<span class="w"> </span>            else:
<span class="w"> </span>                schema = handler(source)
<span class="gu">@@ -1677,17 +2104,18 @@ else:</span>
<span class="w"> </span>                schema[&#39;tz_constraint&#39;] = &#39;aware&#39;
<span class="w"> </span>                return schema

<span class="gd">-        def __repr__(self) -&gt;str:</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="w"> </span>            return &#39;AwareDatetime&#39;

<span class="gd">-</span>
<span class="w"> </span>    class NaiveDatetime:
<span class="w"> </span>        &quot;&quot;&quot;A datetime that doesn&#39;t require timezone info.&quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls, source: type[Any], handler: GetCoreSchemaHandler</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            if cls is source:
<span class="gi">+                # used directly as a type</span>
<span class="w"> </span>                return core_schema.datetime_schema(tz_constraint=&#39;naive&#39;)
<span class="w"> </span>            else:
<span class="w"> </span>                schema = handler(source)
<span class="gu">@@ -1695,17 +2123,18 @@ else:</span>
<span class="w"> </span>                schema[&#39;tz_constraint&#39;] = &#39;naive&#39;
<span class="w"> </span>                return schema

<span class="gd">-        def __repr__(self) -&gt;str:</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="w"> </span>            return &#39;NaiveDatetime&#39;

<span class="gd">-</span>
<span class="w"> </span>    class PastDatetime:
<span class="w"> </span>        &quot;&quot;&quot;A datetime that must be in the past.&quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls, source: type[Any], handler: GetCoreSchemaHandler</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            if cls is source:
<span class="gi">+                # used directly as a type</span>
<span class="w"> </span>                return core_schema.datetime_schema(now_op=&#39;past&#39;)
<span class="w"> </span>            else:
<span class="w"> </span>                schema = handler(source)
<span class="gu">@@ -1713,17 +2142,18 @@ else:</span>
<span class="w"> </span>                schema[&#39;now_op&#39;] = &#39;past&#39;
<span class="w"> </span>                return schema

<span class="gd">-        def __repr__(self) -&gt;str:</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="w"> </span>            return &#39;PastDatetime&#39;

<span class="gd">-</span>
<span class="w"> </span>    class FutureDatetime:
<span class="w"> </span>        &quot;&quot;&quot;A datetime that must be in the future.&quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_pydantic_core_schema__(cls, source: type[Any], handler:</span>
<span class="gd">-            GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gi">+        def __get_pydantic_core_schema__(</span>
<span class="gi">+            cls, source: type[Any], handler: GetCoreSchemaHandler</span>
<span class="gi">+        ) -&gt; core_schema.CoreSchema:</span>
<span class="w"> </span>            if cls is source:
<span class="gi">+                # used directly as a type</span>
<span class="w"> </span>                return core_schema.datetime_schema(now_op=&#39;future&#39;)
<span class="w"> </span>            else:
<span class="w"> </span>                schema = handler(source)
<span class="gu">@@ -1731,15 +2161,18 @@ else:</span>
<span class="w"> </span>                schema[&#39;now_op&#39;] = &#39;future&#39;
<span class="w"> </span>                return schema

<span class="gd">-        def __repr__(self) -&gt;str:</span>
<span class="gi">+        def __repr__(self) -&gt; str:</span>
<span class="w"> </span>            return &#39;FutureDatetime&#39;


<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Encoded TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class EncoderProtocol(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;Protocol for encoding and decoding data to and from bytes.&quot;&quot;&quot;

<span class="w"> </span>    @classmethod
<span class="gd">-    def decode(cls, data: bytes) -&gt;bytes:</span>
<span class="gi">+    def decode(cls, data: bytes) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decode the data using the encoder.

<span class="w"> </span>        Args:
<span class="gu">@@ -1748,10 +2181,10 @@ class EncoderProtocol(Protocol):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The decoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ...</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def encode(cls, value: bytes) -&gt;bytes:</span>
<span class="gi">+    def encode(cls, value: bytes) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode the data using the encoder.

<span class="w"> </span>        Args:
<span class="gu">@@ -1760,23 +2193,23 @@ class EncoderProtocol(Protocol):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The encoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ...</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_json_format(cls) -&gt;str:</span>
<span class="gi">+    def get_json_format(cls) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the JSON format for the encoded data.

<span class="w"> </span>        Returns:
<span class="w"> </span>            The JSON format for the encoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ...</span>


<span class="w"> </span>class Base64Encoder(EncoderProtocol):
<span class="w"> </span>    &quot;&quot;&quot;Standard (non-URL-safe) Base64 encoder.&quot;&quot;&quot;

<span class="w"> </span>    @classmethod
<span class="gd">-    def decode(cls, data: bytes) -&gt;bytes:</span>
<span class="gi">+    def decode(cls, data: bytes) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decode the data from base64 encoded bytes to original bytes data.

<span class="w"> </span>        Args:
<span class="gu">@@ -1785,10 +2218,13 @@ class Base64Encoder(EncoderProtocol):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The decoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return base64.decodebytes(data)</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise PydanticCustomError(&#39;base64_decode&#39;, &quot;Base64 decoding error: &#39;{error}&#39;&quot;, {&#39;error&#39;: str(e)})</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def encode(cls, value: bytes) -&gt;bytes:</span>
<span class="gi">+    def encode(cls, value: bytes) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode the data from bytes to a base64 encoded bytes.

<span class="w"> </span>        Args:
<span class="gu">@@ -1797,23 +2233,23 @@ class Base64Encoder(EncoderProtocol):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The encoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return base64.encodebytes(value)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_json_format(cls) -&gt;Literal[&#39;base64&#39;]:</span>
<span class="gi">+    def get_json_format(cls) -&gt; Literal[&#39;base64&#39;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the JSON format for the encoded data.

<span class="w"> </span>        Returns:
<span class="w"> </span>            The JSON format for the encoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;base64&#39;</span>


<span class="w"> </span>class Base64UrlEncoder(EncoderProtocol):
<span class="w"> </span>    &quot;&quot;&quot;URL-safe Base64 encoder.&quot;&quot;&quot;

<span class="w"> </span>    @classmethod
<span class="gd">-    def decode(cls, data: bytes) -&gt;bytes:</span>
<span class="gi">+    def decode(cls, data: bytes) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decode the data from base64 encoded bytes to original bytes data.

<span class="w"> </span>        Args:
<span class="gu">@@ -1822,10 +2258,13 @@ class Base64UrlEncoder(EncoderProtocol):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The decoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return base64.urlsafe_b64decode(data)</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise PydanticCustomError(&#39;base64_decode&#39;, &quot;Base64 decoding error: &#39;{error}&#39;&quot;, {&#39;error&#39;: str(e)})</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def encode(cls, value: bytes) -&gt;bytes:</span>
<span class="gi">+    def encode(cls, value: bytes) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode the data from bytes to a base64 encoded bytes.

<span class="w"> </span>        Args:
<span class="gu">@@ -1834,16 +2273,16 @@ class Base64UrlEncoder(EncoderProtocol):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The encoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return base64.urlsafe_b64encode(value)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_json_format(cls) -&gt;Literal[&#39;base64url&#39;]:</span>
<span class="gi">+    def get_json_format(cls) -&gt; Literal[&#39;base64url&#39;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the JSON format for the encoded data.

<span class="w"> </span>        Returns:
<span class="w"> </span>            The JSON format for the encoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;base64url&#39;</span>


<span class="w"> </span>@_dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -1900,23 +2339,24 @@ class EncodedBytes:</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    encoder: type[EncoderProtocol]

<span class="gd">-    def __get_pydantic_json_schema__(self, core_schema: core_schema.</span>
<span class="gd">-        CoreSchema, handler: GetJsonSchemaHandler) -&gt;JsonSchemaValue:</span>
<span class="gi">+    def __get_pydantic_json_schema__(</span>
<span class="gi">+        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler</span>
<span class="gi">+    ) -&gt; JsonSchemaValue:</span>
<span class="w"> </span>        field_schema = handler(core_schema)
<span class="gd">-        field_schema.update(type=&#39;string&#39;, format=self.encoder.</span>
<span class="gd">-            get_json_format())</span>
<span class="gi">+        field_schema.update(type=&#39;string&#39;, format=self.encoder.get_json_format())</span>
<span class="w"> </span>        return field_schema

<span class="gd">-    def __get_pydantic_core_schema__(self, source: type[Any], handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        return core_schema.with_info_after_validator_function(function=self</span>
<span class="gd">-            .decode, schema=core_schema.bytes_schema(), serialization=</span>
<span class="gd">-            core_schema.plain_serializer_function_ser_schema(function=self.</span>
<span class="gd">-            encode))</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.with_info_after_validator_function(</span>
<span class="gi">+            function=self.decode,</span>
<span class="gi">+            schema=core_schema.bytes_schema(),</span>
<span class="gi">+            serialization=core_schema.plain_serializer_function_ser_schema(function=self.encode),</span>
<span class="gi">+        )</span>

<span class="gd">-    def decode(self, data: bytes, _: core_schema.ValidationInfo) -&gt;bytes:</span>
<span class="gi">+    def decode(self, data: bytes, _: core_schema.ValidationInfo) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decode the data using the specified encoder.

<span class="w"> </span>        Args:
<span class="gu">@@ -1925,9 +2365,9 @@ class EncodedBytes:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The decoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.encoder.decode(data)</span>

<span class="gd">-    def encode(self, value: bytes) -&gt;bytes:</span>
<span class="gi">+    def encode(self, value: bytes) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode the data using the specified encoder.

<span class="w"> </span>        Args:
<span class="gu">@@ -1936,9 +2376,9 @@ class EncodedBytes:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The encoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.encoder.encode(value)</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.encoder)


<span class="gu">@@ -1997,15 +2437,14 @@ class EncodedStr(EncodedBytes):</span>
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __get_pydantic_core_schema__(self, source: type[Any], handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;core_schema.CoreSchema:</span>
<span class="gd">-        return core_schema.with_info_after_validator_function(function=self</span>
<span class="gd">-            .decode_str, schema=super(EncodedStr, self).</span>
<span class="gd">-            __get_pydantic_core_schema__(source=source, handler=handler),</span>
<span class="gd">-            serialization=core_schema.plain_serializer_function_ser_schema(</span>
<span class="gd">-            function=self.encode_str))</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:</span>
<span class="gi">+        return core_schema.with_info_after_validator_function(</span>
<span class="gi">+            function=self.decode_str,</span>
<span class="gi">+            schema=super(EncodedStr, self).__get_pydantic_core_schema__(source=source, handler=handler),  # noqa: UP008</span>
<span class="gi">+            serialization=core_schema.plain_serializer_function_ser_schema(function=self.encode_str),</span>
<span class="gi">+        )</span>

<span class="gd">-    def decode_str(self, data: bytes, _: core_schema.ValidationInfo) -&gt;str:</span>
<span class="gi">+    def decode_str(self, data: bytes, _: core_schema.ValidationInfo) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decode the data using the specified encoder.

<span class="w"> </span>        Args:
<span class="gu">@@ -2014,9 +2453,9 @@ class EncodedStr(EncodedBytes):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The decoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return data.decode()</span>

<span class="gd">-    def encode_str(self, value: str) -&gt;str:</span>
<span class="gi">+    def encode_str(self, value: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Encode the data using the specified encoder.

<span class="w"> </span>        Args:
<span class="gu">@@ -2025,9 +2464,9 @@ class EncodedStr(EncodedBytes):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The encoded data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return super(EncodedStr, self).encode(value=value.encode()).decode()  # noqa: UP008</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.encoder)


<span class="gu">@@ -2055,8 +2494,7 @@ print(m.base64_bytes)</span>

<span class="w"> </span># Serialize into the base64 form
<span class="w"> </span>print(m.model_dump())
<span class="gd">-#&gt; {&#39;base64_bytes&#39;: b&#39;VGhpcyBpcyB0aGUgd2F5</span>
<span class="gd">-&#39;}</span>
<span class="gi">+#&gt; {&#39;base64_bytes&#39;: b&#39;VGhpcyBpcyB0aGUgd2F5\n&#39;}</span>

<span class="w"> </span># Validate base64 data
<span class="w"> </span>try:
<span class="gu">@@ -2094,8 +2532,7 @@ print(m.base64_str)</span>

<span class="w"> </span># Serialize into the base64 form
<span class="w"> </span>print(m.model_dump())
<span class="gd">-#&gt; {&#39;base64_str&#39;: &#39;VGhlc2UgYXJlbid0IHRoZSBkcm9pZHMgeW91J3JlIGxvb2tpbmcgZm9y</span>
<span class="gd">-&#39;}</span>
<span class="gi">+#&gt; {&#39;base64_str&#39;: &#39;VGhlc2UgYXJlbid0IHRoZSBkcm9pZHMgeW91J3JlIGxvb2tpbmcgZm9y\n&#39;}</span>

<span class="w"> </span># Validate base64 data
<span class="w"> </span>try:
<span class="gu">@@ -2152,6 +2589,8 @@ print(m)</span>
<span class="w"> </span>#&gt; base64url_str=&#39;Hw?tw&gt;Mw&#39;
<span class="w"> </span>```
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)


<span class="gu">@@ -2181,21 +2620,25 @@ class GetPydanticSchema:</span>
<span class="w"> </span>    #&gt; &#39;abc&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    get_pydantic_core_schema: Callable[[Any, GetCoreSchemaHandler], CoreSchema</span>
<span class="gd">-        ] | None = None</span>
<span class="gd">-    get_pydantic_json_schema: Callable[[Any, GetJsonSchemaHandler],</span>
<span class="gd">-        JsonSchemaValue] | None = None</span>
<span class="gi">+</span>
<span class="gi">+    get_pydantic_core_schema: Callable[[Any, GetCoreSchemaHandler], CoreSchema] | None = None</span>
<span class="gi">+    get_pydantic_json_schema: Callable[[Any, GetJsonSchemaHandler], JsonSchemaValue] | None = None</span>
<span class="gi">+</span>
<span class="gi">+    # Note: we may want to consider adding a convenience staticmethod `def for_type(type_: Any) -&gt; GetPydanticSchema:`</span>
<span class="gi">+    #   which returns `GetPydanticSchema(lambda _s, h: h(type_))`</span>
<span class="gi">+</span>
<span class="w"> </span>    if not TYPE_CHECKING:
<span class="gi">+        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access</span>

<span class="gd">-        def __getattr__(self, item: str) -&gt;Any:</span>
<span class="gi">+        def __getattr__(self, item: str) -&gt; Any:</span>
<span class="w"> </span>            &quot;&quot;&quot;Use this rather than defining `__get_pydantic_core_schema__` etc. to reduce the number of nested calls.&quot;&quot;&quot;
<span class="gd">-            if (item == &#39;__get_pydantic_core_schema__&#39; and self.</span>
<span class="gd">-                get_pydantic_core_schema):</span>
<span class="gi">+            if item == &#39;__get_pydantic_core_schema__&#39; and self.get_pydantic_core_schema:</span>
<span class="w"> </span>                return self.get_pydantic_core_schema
<span class="w"> </span>            elif item == &#39;__get_pydantic_json_schema__&#39; and self.get_pydantic_json_schema:
<span class="w"> </span>                return self.get_pydantic_json_schema
<span class="w"> </span>            else:
<span class="w"> </span>                return object.__getattribute__(self, item)
<span class="gi">+</span>
<span class="w"> </span>    __hash__ = object.__hash__


<span class="gu">@@ -2276,10 +2719,10 @@ class Tag:</span>

<span class="w"> </span>    [Discriminated Unions]: ../concepts/unions.md#discriminated-unions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    tag: str

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:</span>
<span class="w"> </span>        schema = handler(source_type)
<span class="w"> </span>        metadata = schema.setdefault(&#39;metadata&#39;, {})
<span class="w"> </span>        assert isinstance(metadata, dict)
<span class="gu">@@ -2360,6 +2803,7 @@ class Discriminator:</span>

<span class="w"> </span>    [Discriminated Unions]: ../concepts/unions.md#discriminated-unions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    discriminator: str | Callable[[Any], Hashable]
<span class="w"> </span>    &quot;&quot;&quot;The callable or field name for discriminating the type in a tagged union.

<span class="gu">@@ -2375,38 +2819,113 @@ class Discriminator:</span>
<span class="w"> </span>    custom_error_context: dict[str, int | str | float] | None = None
<span class="w"> </span>    &quot;&quot;&quot;Context to use in custom errors.&quot;&quot;&quot;

<span class="gd">-    def __get_pydantic_core_schema__(self, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:</span>
<span class="w"> </span>        origin = _typing_extra.get_origin(source_type)
<span class="w"> </span>        if not origin or not _typing_extra.origin_is_union(origin):
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                f&#39;{type(self).__name__} must be used with a Union type, not {source_type}&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise TypeError(f&#39;{type(self).__name__} must be used with a Union type, not {source_type}&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(self.discriminator, str):
<span class="w"> </span>            from pydantic import Field
<span class="gd">-            return handler(Annotated[source_type, Field(discriminator=self.</span>
<span class="gd">-                discriminator)])</span>
<span class="gi">+</span>
<span class="gi">+            return handler(Annotated[source_type, Field(discriminator=self.discriminator)])</span>
<span class="w"> </span>        else:
<span class="w"> </span>            original_schema = handler(source_type)
<span class="w"> </span>            return self._convert_schema(original_schema)

<span class="gi">+    def _convert_schema(self, original_schema: core_schema.CoreSchema) -&gt; core_schema.TaggedUnionSchema:</span>
<span class="gi">+        if original_schema[&#39;type&#39;] != &#39;union&#39;:</span>
<span class="gi">+            # This likely indicates that the schema was a single-item union that was simplified.</span>
<span class="gi">+            # In this case, we do the same thing we do in</span>
<span class="gi">+            # `pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root`, namely,</span>
<span class="gi">+            # package the generated schema back into a single-item union.</span>
<span class="gi">+            original_schema = core_schema.union_schema([original_schema])</span>
<span class="gi">+</span>
<span class="gi">+        tagged_union_choices = {}</span>
<span class="gi">+        for i, choice in enumerate(original_schema[&#39;choices&#39;]):</span>
<span class="gi">+            tag = None</span>
<span class="gi">+            if isinstance(choice, tuple):</span>
<span class="gi">+                choice, tag = choice</span>
<span class="gi">+            metadata = choice.get(&#39;metadata&#39;)</span>
<span class="gi">+            if metadata is not None:</span>
<span class="gi">+                metadata_tag = metadata.get(_core_utils.TAGGED_UNION_TAG_KEY)</span>
<span class="gi">+                if metadata_tag is not None:</span>
<span class="gi">+                    tag = metadata_tag</span>
<span class="gi">+            if tag is None:</span>
<span class="gi">+                raise PydanticUserError(</span>
<span class="gi">+                    f&#39;`Tag` not provided for choice {choice} used with `Discriminator`&#39;,</span>
<span class="gi">+                    code=&#39;callable-discriminator-no-tag&#39;,</span>
<span class="gi">+                )</span>
<span class="gi">+            tagged_union_choices[tag] = choice</span>
<span class="gi">+</span>
<span class="gi">+        # Have to do these verbose checks to ensure falsy values (&#39;&#39; and {}) don&#39;t get ignored</span>
<span class="gi">+        custom_error_type = self.custom_error_type</span>
<span class="gi">+        if custom_error_type is None:</span>
<span class="gi">+            custom_error_type = original_schema.get(&#39;custom_error_type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        custom_error_message = self.custom_error_message</span>
<span class="gi">+        if custom_error_message is None:</span>
<span class="gi">+            custom_error_message = original_schema.get(&#39;custom_error_message&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        custom_error_context = self.custom_error_context</span>
<span class="gi">+        if custom_error_context is None:</span>
<span class="gi">+            custom_error_context = original_schema.get(&#39;custom_error_context&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        custom_error_type = original_schema.get(&#39;custom_error_type&#39;) if custom_error_type is None else custom_error_type</span>
<span class="gi">+        return core_schema.tagged_union_schema(</span>
<span class="gi">+            tagged_union_choices,</span>
<span class="gi">+            self.discriminator,</span>
<span class="gi">+            custom_error_type=custom_error_type,</span>
<span class="gi">+            custom_error_message=custom_error_message,</span>
<span class="gi">+            custom_error_context=custom_error_context,</span>
<span class="gi">+            strict=original_schema.get(&#39;strict&#39;),</span>
<span class="gi">+            ref=original_schema.get(&#39;ref&#39;),</span>
<span class="gi">+            metadata=original_schema.get(&#39;metadata&#39;),</span>
<span class="gi">+            serialization=original_schema.get(&#39;serialization&#39;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>_JSON_TYPES = {int, float, str, bool, list, dict, type(None)}


<span class="gd">-class _AllowAnyJson:</span>
<span class="gi">+def _get_type_name(x: Any) -&gt; str:</span>
<span class="gi">+    type_ = type(x)</span>
<span class="gi">+    if type_ in _JSON_TYPES:</span>
<span class="gi">+        return type_.__name__</span>
<span class="gi">+</span>
<span class="gi">+    # Handle proper subclasses; note we don&#39;t need to handle None or bool here</span>
<span class="gi">+    if isinstance(x, int):</span>
<span class="gi">+        return &#39;int&#39;</span>
<span class="gi">+    if isinstance(x, float):</span>
<span class="gi">+        return &#39;float&#39;</span>
<span class="gi">+    if isinstance(x, str):</span>
<span class="gi">+        return &#39;str&#39;</span>
<span class="gi">+    if isinstance(x, list):</span>
<span class="gi">+        return &#39;list&#39;</span>
<span class="gi">+    if isinstance(x, dict):</span>
<span class="gi">+        return &#39;dict&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Fail by returning the type&#39;s actual name</span>
<span class="gi">+    return getattr(type_, &#39;__name__&#39;, &#39;&lt;no type name&gt;&#39;)</span>

<span class="gi">+</span>
<span class="gi">+class _AllowAnyJson:</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;CoreSchema:</span>
<span class="gi">+    def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:</span>
<span class="w"> </span>        python_schema = handler(source_type)
<span class="gd">-        return core_schema.json_or_python_schema(json_schema=core_schema.</span>
<span class="gd">-            any_schema(), python_schema=python_schema)</span>
<span class="gi">+        return core_schema.json_or_python_schema(json_schema=core_schema.any_schema(), python_schema=python_schema)</span>


<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    JsonValue: TypeAlias = Union[List[&#39;JsonValue&#39;], Dict[str, &#39;JsonValue&#39;],</span>
<span class="gd">-        str, bool, int, float, None]</span>
<span class="gi">+    # This seems to only be necessary for mypy</span>
<span class="gi">+    JsonValue: TypeAlias = Union[</span>
<span class="gi">+        List[&#39;JsonValue&#39;],</span>
<span class="gi">+        Dict[str, &#39;JsonValue&#39;],</span>
<span class="gi">+        str,</span>
<span class="gi">+        bool,</span>
<span class="gi">+        int,</span>
<span class="gi">+        float,</span>
<span class="gi">+        None,</span>
<span class="gi">+    ]</span>
<span class="w"> </span>    &quot;&quot;&quot;A `JsonValue` is used to represent a value that can be serialized to JSON.

<span class="w"> </span>    It may be one of:
<span class="gu">@@ -2449,23 +2968,37 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gd">-    JsonValue = TypeAliasType(&#39;JsonValue&#39;, Annotated[Union[Annotated[List[</span>
<span class="gd">-        &#39;JsonValue&#39;], Tag(&#39;list&#39;)], Annotated[Dict[str, &#39;JsonValue&#39;], Tag(</span>
<span class="gd">-        &#39;dict&#39;)], Annotated[str, Tag(&#39;str&#39;)], Annotated[bool, Tag(&#39;bool&#39;)],</span>
<span class="gd">-        Annotated[int, Tag(&#39;int&#39;)], Annotated[float, Tag(&#39;float&#39;)],</span>
<span class="gd">-        Annotated[None, Tag(&#39;NoneType&#39;)]], Discriminator(_get_type_name,</span>
<span class="gd">-        custom_error_type=&#39;invalid-json-value&#39;, custom_error_message=</span>
<span class="gd">-        &#39;input was not a valid JSON value&#39;), _AllowAnyJson])</span>
<span class="gi">+    JsonValue = TypeAliasType(</span>
<span class="gi">+        &#39;JsonValue&#39;,</span>
<span class="gi">+        Annotated[</span>
<span class="gi">+            Union[</span>
<span class="gi">+                Annotated[List[&#39;JsonValue&#39;], Tag(&#39;list&#39;)],</span>
<span class="gi">+                Annotated[Dict[str, &#39;JsonValue&#39;], Tag(&#39;dict&#39;)],</span>
<span class="gi">+                Annotated[str, Tag(&#39;str&#39;)],</span>
<span class="gi">+                Annotated[bool, Tag(&#39;bool&#39;)],</span>
<span class="gi">+                Annotated[int, Tag(&#39;int&#39;)],</span>
<span class="gi">+                Annotated[float, Tag(&#39;float&#39;)],</span>
<span class="gi">+                Annotated[None, Tag(&#39;NoneType&#39;)],</span>
<span class="gi">+            ],</span>
<span class="gi">+            Discriminator(</span>
<span class="gi">+                _get_type_name,</span>
<span class="gi">+                custom_error_type=&#39;invalid-json-value&#39;,</span>
<span class="gi">+                custom_error_message=&#39;input was not a valid JSON value&#39;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            _AllowAnyJson,</span>
<span class="gi">+        ],</span>
<span class="gi">+    )</span>


<span class="w"> </span>class _OnErrorOmit:
<span class="gd">-</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_pydantic_core_schema__(cls, source_type: Any, handler:</span>
<span class="gd">-        GetCoreSchemaHandler) -&gt;CoreSchema:</span>
<span class="gd">-        return core_schema.with_default_schema(schema=handler(source_type),</span>
<span class="gd">-            on_error=&#39;omit&#39;)</span>
<span class="gi">+    def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:</span>
<span class="gi">+        # there is no actual default value here but we use with_default_schema since it already has the on_error</span>
<span class="gi">+        # behavior implemented and it would be no more efficient to implement it on every other validator</span>
<span class="gi">+        # or as a standalone validator</span>
<span class="gi">+        return core_schema.with_default_schema(schema=handler(source_type), on_error=&#39;omit&#39;)</span>


<span class="w"> </span>OnErrorOmit = Annotated[T, _OnErrorOmit]
<span class="gu">@@ -2506,4 +3039,5 @@ class FailFast(_fields.PydanticMetadata, BaseMetadata):</span>
<span class="w"> </span>        &#39;&#39;&#39;
<span class="w"> </span>    ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    fail_fast: bool = True
<span class="gh">diff --git a/pydantic/typing.py b/pydantic/typing.py</span>
<span class="gh">index 84690bc3e..0bda22d02 100644</span>
<span class="gd">--- a/pydantic/typing.py</span>
<span class="gi">+++ b/pydantic/typing.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;`typing` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/utils.py b/pydantic/utils.py</span>
<span class="gh">index fef150148..8d1e2a81c 100644</span>
<span class="gd">--- a/pydantic/utils.py</span>
<span class="gi">+++ b/pydantic/utils.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `utils` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/v1/_hypothesis_plugin.py b/pydantic/v1/_hypothesis_plugin.py</span>
<span class="gh">index 3ab0c72cd..b62234d50 100644</span>
<span class="gd">--- a/pydantic/v1/_hypothesis_plugin.py</span>
<span class="gi">+++ b/pydantic/v1/_hypothesis_plugin.py</span>
<span class="gu">@@ -21,6 +21,7 @@ This is because Hypothesis annotates `register_type_strategy()` with</span>
<span class="w"> </span>`(T, SearchStrategy[T])`, but in most cases we register e.g. `ConstrainedInt`
<span class="w"> </span>to generate instances of the builtin `int` type which match the constraints.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import datetime
<span class="w"> </span>import ipaddress
<span class="gu">@@ -28,61 +29,362 @@ import json</span>
<span class="w"> </span>import math
<span class="w"> </span>from fractions import Fraction
<span class="w"> </span>from typing import Callable, Dict, Type, Union, cast, overload
<span class="gi">+</span>
<span class="w"> </span>import hypothesis.strategies as st
<span class="gi">+</span>
<span class="w"> </span>import pydantic
<span class="w"> </span>import pydantic.color
<span class="w"> </span>import pydantic.types
<span class="w"> </span>from pydantic.v1.utils import lenient_issubclass
<span class="gi">+</span>
<span class="gi">+# FilePath and DirectoryPath are explicitly unsupported, as we&#39;d have to create</span>
<span class="gi">+# them on-disk, and that&#39;s unsafe in general without being told *where* to do so.</span>
<span class="gi">+#</span>
<span class="gi">+# URLs are unsupported because it&#39;s easy for users to define their own strategy for</span>
<span class="gi">+# &quot;normal&quot; URLs, and hard for us to define a general strategy which includes &quot;weird&quot;</span>
<span class="gi">+# URLs but doesn&#39;t also have unpredictable performance problems.</span>
<span class="gi">+#</span>
<span class="gi">+# conlist() and conset() are unsupported for now, because the workarounds for</span>
<span class="gi">+# Cython and Hypothesis to handle parametrized generic types are incompatible.</span>
<span class="gi">+# We are rethinking Hypothesis compatibility in Pydantic v2.</span>
<span class="gi">+</span>
<span class="gi">+# Emails</span>
<span class="w"> </span>try:
<span class="w"> </span>    import email_validator
<span class="gd">-except ImportError:</span>
<span class="gi">+except ImportError:  # pragma: no cover</span>
<span class="w"> </span>    pass
<span class="w"> </span>else:
<span class="gd">-    st.register_type_strategy(pydantic.EmailStr, st.emails().filter(</span>
<span class="gd">-        is_valid_email))</span>
<span class="gd">-    st.register_type_strategy(pydantic.NameEmail, st.builds(&#39;{} &lt;{}&gt;&#39;.</span>
<span class="gd">-        format, st.from_regex(&#39;[A-Za-z0-9_]+( [A-Za-z0-9_]+){0,5}&#39;,</span>
<span class="gd">-        fullmatch=True), st.emails().filter(is_valid_email)))</span>
<span class="gd">-st.register_type_strategy(pydantic.PyObject, st.sampled_from([cast(pydantic</span>
<span class="gd">-    .PyObject, f&#39;math.{name}&#39;) for name in sorted(vars(math)) if not name.</span>
<span class="gd">-    startswith(&#39;_&#39;)]))</span>
<span class="gd">-_color_regexes = &#39;|&#39;.join((pydantic.color.r_hex_short, pydantic.color.</span>
<span class="gd">-    r_hex_long, pydantic.color.r_rgb, pydantic.color.r_rgba, pydantic.color</span>
<span class="gd">-    .r_hsl, pydantic.color.r_hsla)).replace(pydantic.color._r_sl,</span>
<span class="gd">-    &#39;(?:(\\d\\d?(?:\\.\\d+)?|100(?:\\.0+)?)%)&#39;).replace(pydantic.color.</span>
<span class="gd">-    _r_alpha, &#39;(?:(0(?:\\.\\d+)?|1(?:\\.0+)?|\\.\\d+|\\d{1,2}%))&#39;).replace(</span>
<span class="gd">-    pydantic.color._r_255,</span>
<span class="gd">-    &#39;(?:((?:\\d|\\d\\d|[01]\\d\\d|2[0-4]\\d|25[0-4])(?:\\.\\d+)?|255(?:\\.0+)?))&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def is_valid_email(s: str) -&gt; bool:</span>
<span class="gi">+        # Hypothesis&#39; st.emails() occasionally generates emails like 0@A0--0.ac</span>
<span class="gi">+        # that are invalid according to email-validator, so we filter those out.</span>
<span class="gi">+        try:</span>
<span class="gi">+            email_validator.validate_email(s, check_deliverability=False)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except email_validator.EmailNotValidError:  # pragma: no cover</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    # Note that these strategies deliberately stay away from any tricky Unicode</span>
<span class="gi">+    # or other encoding issues; we&#39;re just trying to generate *something* valid.</span>
<span class="gi">+    st.register_type_strategy(pydantic.EmailStr, st.emails().filter(is_valid_email))  # type: ignore[arg-type]</span>
<span class="gi">+    st.register_type_strategy(</span>
<span class="gi">+        pydantic.NameEmail,</span>
<span class="gi">+        st.builds(</span>
<span class="gi">+            &#39;{} &lt;{}&gt;&#39;.format,  # type: ignore[arg-type]</span>
<span class="gi">+            st.from_regex(&#39;[A-Za-z0-9_]+( [A-Za-z0-9_]+){0,5}&#39;, fullmatch=True),</span>
<span class="gi">+            st.emails().filter(is_valid_email),</span>
<span class="gi">+        ),</span>
<span class="w"> </span>    )
<span class="gd">-st.register_type_strategy(pydantic.color.Color, st.one_of(st.sampled_from(</span>
<span class="gd">-    sorted(pydantic.color.COLORS_BY_NAME)), st.tuples(st.integers(0, 255),</span>
<span class="gd">-    st.integers(0, 255), st.integers(0, 255), st.none() | st.floats(0, 1) |</span>
<span class="gd">-    st.floats(0, 100).map(&#39;{}%&#39;.format)), st.from_regex(_color_regexes,</span>
<span class="gd">-    fullmatch=True)))</span>
<span class="gd">-card_patterns = (&#39;4[0-9]{14}&#39;, &#39;5[12345][0-9]{13}&#39;, &#39;3[47][0-9]{12}&#39;,</span>
<span class="gd">-    &#39;[0-26-9][0-9]{10,17}&#39;)</span>
<span class="gd">-st.register_type_strategy(pydantic.PaymentCardNumber, st.from_regex(&#39;|&#39;.</span>
<span class="gd">-    join(card_patterns), fullmatch=True).map(add_luhn_digit))</span>
<span class="gi">+</span>
<span class="gi">+# PyObject - dotted names, in this case taken from the math module.</span>
<span class="gi">+st.register_type_strategy(</span>
<span class="gi">+    pydantic.PyObject,  # type: ignore[arg-type]</span>
<span class="gi">+    st.sampled_from(</span>
<span class="gi">+        [cast(pydantic.PyObject, f&#39;math.{name}&#39;) for name in sorted(vars(math)) if not name.startswith(&#39;_&#39;)]</span>
<span class="gi">+    ),</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# CSS3 Colors; as name, hex, rgb(a) tuples or strings, or hsl strings</span>
<span class="gi">+_color_regexes = (</span>
<span class="gi">+    &#39;|&#39;.join(</span>
<span class="gi">+        (</span>
<span class="gi">+            pydantic.color.r_hex_short,</span>
<span class="gi">+            pydantic.color.r_hex_long,</span>
<span class="gi">+            pydantic.color.r_rgb,</span>
<span class="gi">+            pydantic.color.r_rgba,</span>
<span class="gi">+            pydantic.color.r_hsl,</span>
<span class="gi">+            pydantic.color.r_hsla,</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    # Use more precise regex patterns to avoid value-out-of-range errors</span>
<span class="gi">+    .replace(pydantic.color._r_sl, r&#39;(?:(\d\d?(?:\.\d+)?|100(?:\.0+)?)%)&#39;)</span>
<span class="gi">+    .replace(pydantic.color._r_alpha, r&#39;(?:(0(?:\.\d+)?|1(?:\.0+)?|\.\d+|\d{1,2}%))&#39;)</span>
<span class="gi">+    .replace(pydantic.color._r_255, r&#39;(?:((?:\d|\d\d|[01]\d\d|2[0-4]\d|25[0-4])(?:\.\d+)?|255(?:\.0+)?))&#39;)</span>
<span class="gi">+)</span>
<span class="gi">+st.register_type_strategy(</span>
<span class="gi">+    pydantic.color.Color,</span>
<span class="gi">+    st.one_of(</span>
<span class="gi">+        st.sampled_from(sorted(pydantic.color.COLORS_BY_NAME)),</span>
<span class="gi">+        st.tuples(</span>
<span class="gi">+            st.integers(0, 255),</span>
<span class="gi">+            st.integers(0, 255),</span>
<span class="gi">+            st.integers(0, 255),</span>
<span class="gi">+            st.none() | st.floats(0, 1) | st.floats(0, 100).map(&#39;{}%&#39;.format),</span>
<span class="gi">+        ),</span>
<span class="gi">+        st.from_regex(_color_regexes, fullmatch=True),</span>
<span class="gi">+    ),</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Card numbers, valid according to the Luhn algorithm</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add_luhn_digit(card_number: str) -&gt; str:</span>
<span class="gi">+    # See https://en.wikipedia.org/wiki/Luhn_algorithm</span>
<span class="gi">+    for digit in &#39;0123456789&#39;:</span>
<span class="gi">+        with contextlib.suppress(Exception):</span>
<span class="gi">+            pydantic.PaymentCardNumber.validate_luhn_check_digit(card_number + digit)</span>
<span class="gi">+            return card_number + digit</span>
<span class="gi">+    raise AssertionError(&#39;Unreachable&#39;)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+card_patterns = (</span>
<span class="gi">+    # Note that these patterns omit the Luhn check digit; that&#39;s added by the function above</span>
<span class="gi">+    &#39;4[0-9]{14}&#39;,  # Visa</span>
<span class="gi">+    &#39;5[12345][0-9]{13}&#39;,  # Mastercard</span>
<span class="gi">+    &#39;3[47][0-9]{12}&#39;,  # American Express</span>
<span class="gi">+    &#39;[0-26-9][0-9]{10,17}&#39;,  # other (incomplete to avoid overlap)</span>
<span class="gi">+)</span>
<span class="gi">+st.register_type_strategy(</span>
<span class="gi">+    pydantic.PaymentCardNumber,</span>
<span class="gi">+    st.from_regex(&#39;|&#39;.join(card_patterns), fullmatch=True).map(add_luhn_digit),  # type: ignore[arg-type]</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# UUIDs</span>
<span class="w"> </span>st.register_type_strategy(pydantic.UUID1, st.uuids(version=1))
<span class="w"> </span>st.register_type_strategy(pydantic.UUID3, st.uuids(version=3))
<span class="w"> </span>st.register_type_strategy(pydantic.UUID4, st.uuids(version=4))
<span class="w"> </span>st.register_type_strategy(pydantic.UUID5, st.uuids(version=5))
<span class="gd">-st.register_type_strategy(pydantic.SecretBytes, st.binary().map(pydantic.</span>
<span class="gd">-    SecretBytes))</span>
<span class="gd">-st.register_type_strategy(pydantic.SecretStr, st.text().map(pydantic.SecretStr)</span>
<span class="gd">-    )</span>
<span class="gd">-st.register_type_strategy(pydantic.IPvAnyAddress, st.ip_addresses())</span>
<span class="gd">-st.register_type_strategy(pydantic.IPvAnyInterface, st.from_type(ipaddress.</span>
<span class="gd">-    IPv4Interface) | st.from_type(ipaddress.IPv6Interface))</span>
<span class="gd">-st.register_type_strategy(pydantic.IPvAnyNetwork, st.from_type(ipaddress.</span>
<span class="gd">-    IPv4Network) | st.from_type(ipaddress.IPv6Network))</span>
<span class="gi">+</span>
<span class="gi">+# Secrets</span>
<span class="gi">+st.register_type_strategy(pydantic.SecretBytes, st.binary().map(pydantic.SecretBytes))</span>
<span class="gi">+st.register_type_strategy(pydantic.SecretStr, st.text().map(pydantic.SecretStr))</span>
<span class="gi">+</span>
<span class="gi">+# IP addresses, networks, and interfaces</span>
<span class="gi">+st.register_type_strategy(pydantic.IPvAnyAddress, st.ip_addresses())  # type: ignore[arg-type]</span>
<span class="gi">+st.register_type_strategy(</span>
<span class="gi">+    pydantic.IPvAnyInterface,</span>
<span class="gi">+    st.from_type(ipaddress.IPv4Interface) | st.from_type(ipaddress.IPv6Interface),  # type: ignore[arg-type]</span>
<span class="gi">+)</span>
<span class="gi">+st.register_type_strategy(</span>
<span class="gi">+    pydantic.IPvAnyNetwork,</span>
<span class="gi">+    st.from_type(ipaddress.IPv4Network) | st.from_type(ipaddress.IPv6Network),  # type: ignore[arg-type]</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# We hook into the con***() functions and the ConstrainedNumberMeta metaclass,</span>
<span class="gi">+# so here we only have to register subclasses for other constrained types which</span>
<span class="gi">+# don&#39;t go via those mechanisms.  Then there are the registration hooks below.</span>
<span class="w"> </span>st.register_type_strategy(pydantic.StrictBool, st.booleans())
<span class="w"> </span>st.register_type_strategy(pydantic.StrictStr, st.text())
<span class="gd">-st.register_type_strategy(pydantic.FutureDate, st.dates(min_value=datetime.</span>
<span class="gd">-    date.today() + datetime.timedelta(days=1)))</span>
<span class="gd">-st.register_type_strategy(pydantic.PastDate, st.dates(max_value=datetime.</span>
<span class="gd">-    date.today() - datetime.timedelta(days=1)))</span>
<span class="gd">-RESOLVERS: Dict[type, Callable[[type], st.SearchStrategy]] = {}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# FutureDate, PastDate</span>
<span class="gi">+st.register_type_strategy(pydantic.FutureDate, st.dates(min_value=datetime.date.today() + datetime.timedelta(days=1)))</span>
<span class="gi">+st.register_type_strategy(pydantic.PastDate, st.dates(max_value=datetime.date.today() - datetime.timedelta(days=1)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Constrained-type resolver functions</span>
<span class="gi">+#</span>
<span class="gi">+# For these ones, we actually want to inspect the type in order to work out a</span>
<span class="gi">+# satisfying strategy.  First up, the machinery for tracking resolver functions:</span>
<span class="gi">+</span>
<span class="gi">+RESOLVERS: Dict[type, Callable[[type], st.SearchStrategy]] = {}  # type: ignore[type-arg]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def _registered(typ: Type[pydantic.types.T]) -&gt; Type[pydantic.types.T]:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def _registered(typ: pydantic.types.ConstrainedNumberMeta) -&gt; pydantic.types.ConstrainedNumberMeta:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _registered(</span>
<span class="gi">+    typ: Union[Type[pydantic.types.T], pydantic.types.ConstrainedNumberMeta]</span>
<span class="gi">+) -&gt; Union[Type[pydantic.types.T], pydantic.types.ConstrainedNumberMeta]:</span>
<span class="gi">+    # This function replaces the version in `pydantic.types`, in order to</span>
<span class="gi">+    # effect the registration of new constrained types so that Hypothesis</span>
<span class="gi">+    # can generate valid examples.</span>
<span class="gi">+    pydantic.types._DEFINED_TYPES.add(typ)</span>
<span class="gi">+    for supertype, resolver in RESOLVERS.items():</span>
<span class="gi">+        if issubclass(typ, supertype):</span>
<span class="gi">+            st.register_type_strategy(typ, resolver(typ))  # type: ignore</span>
<span class="gi">+            return typ</span>
<span class="gi">+    raise NotImplementedError(f&#39;Unknown type {typ!r} has no resolver to register&#39;)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolves(</span>
<span class="gi">+    typ: Union[type, pydantic.types.ConstrainedNumberMeta]</span>
<span class="gi">+) -&gt; Callable[[Callable[..., st.SearchStrategy]], Callable[..., st.SearchStrategy]]:  # type: ignore[type-arg]</span>
<span class="gi">+    def inner(f):  # type: ignore</span>
<span class="gi">+        assert f not in RESOLVERS</span>
<span class="gi">+        RESOLVERS[typ] = f</span>
<span class="gi">+        return f</span>
<span class="gi">+</span>
<span class="gi">+    return inner</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Type-to-strategy resolver functions</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@resolves(pydantic.JsonWrapper)</span>
<span class="gi">+def resolve_json(cls):  # type: ignore[no-untyped-def]</span>
<span class="gi">+    try:</span>
<span class="gi">+        inner = st.none() if cls.inner_type is None else st.from_type(cls.inner_type)</span>
<span class="gi">+    except Exception:  # pragma: no cover</span>
<span class="gi">+        finite = st.floats(allow_infinity=False, allow_nan=False)</span>
<span class="gi">+        inner = st.recursive(</span>
<span class="gi">+            base=st.one_of(st.none(), st.booleans(), st.integers(), finite, st.text()),</span>
<span class="gi">+            extend=lambda x: st.lists(x) | st.dictionaries(st.text(), x),  # type: ignore</span>
<span class="gi">+        )</span>
<span class="gi">+    inner_type = getattr(cls, &#39;inner_type&#39;, None)</span>
<span class="gi">+    return st.builds(</span>
<span class="gi">+        cls.inner_type.json if lenient_issubclass(inner_type, pydantic.BaseModel) else json.dumps,</span>
<span class="gi">+        inner,</span>
<span class="gi">+        ensure_ascii=st.booleans(),</span>
<span class="gi">+        indent=st.none() | st.integers(0, 16),</span>
<span class="gi">+        sort_keys=st.booleans(),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@resolves(pydantic.ConstrainedBytes)</span>
<span class="gi">+def resolve_conbytes(cls):  # type: ignore[no-untyped-def]  # pragma: no cover</span>
<span class="gi">+    min_size = cls.min_length or 0</span>
<span class="gi">+    max_size = cls.max_length</span>
<span class="gi">+    if not cls.strip_whitespace:</span>
<span class="gi">+        return st.binary(min_size=min_size, max_size=max_size)</span>
<span class="gi">+    # Fun with regex to ensure we neither start nor end with whitespace</span>
<span class="gi">+    repeats = &#39;{{{},{}}}&#39;.format(</span>
<span class="gi">+        min_size - 2 if min_size &gt; 2 else 0,</span>
<span class="gi">+        max_size - 2 if (max_size or 0) &gt; 2 else &#39;&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+    if min_size &gt;= 2:</span>
<span class="gi">+        pattern = rf&#39;\W.{repeats}\W&#39;</span>
<span class="gi">+    elif min_size == 1:</span>
<span class="gi">+        pattern = rf&#39;\W(.{repeats}\W)?&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert min_size == 0</span>
<span class="gi">+        pattern = rf&#39;(\W(.{repeats}\W)?)?&#39;</span>
<span class="gi">+    return st.from_regex(pattern.encode(), fullmatch=True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@resolves(pydantic.ConstrainedDecimal)</span>
<span class="gi">+def resolve_condecimal(cls):  # type: ignore[no-untyped-def]</span>
<span class="gi">+    min_value = cls.ge</span>
<span class="gi">+    max_value = cls.le</span>
<span class="gi">+    if cls.gt is not None:</span>
<span class="gi">+        assert min_value is None, &#39;Set `gt` or `ge`, but not both&#39;</span>
<span class="gi">+        min_value = cls.gt</span>
<span class="gi">+    if cls.lt is not None:</span>
<span class="gi">+        assert max_value is None, &#39;Set `lt` or `le`, but not both&#39;</span>
<span class="gi">+        max_value = cls.lt</span>
<span class="gi">+    s = st.decimals(min_value, max_value, allow_nan=False, places=cls.decimal_places)</span>
<span class="gi">+    if cls.lt is not None:</span>
<span class="gi">+        s = s.filter(lambda d: d &lt; cls.lt)</span>
<span class="gi">+    if cls.gt is not None:</span>
<span class="gi">+        s = s.filter(lambda d: cls.gt &lt; d)</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@resolves(pydantic.ConstrainedFloat)</span>
<span class="gi">+def resolve_confloat(cls):  # type: ignore[no-untyped-def]</span>
<span class="gi">+    min_value = cls.ge</span>
<span class="gi">+    max_value = cls.le</span>
<span class="gi">+    exclude_min = False</span>
<span class="gi">+    exclude_max = False</span>
<span class="gi">+</span>
<span class="gi">+    if cls.gt is not None:</span>
<span class="gi">+        assert min_value is None, &#39;Set `gt` or `ge`, but not both&#39;</span>
<span class="gi">+        min_value = cls.gt</span>
<span class="gi">+        exclude_min = True</span>
<span class="gi">+    if cls.lt is not None:</span>
<span class="gi">+        assert max_value is None, &#39;Set `lt` or `le`, but not both&#39;</span>
<span class="gi">+        max_value = cls.lt</span>
<span class="gi">+        exclude_max = True</span>
<span class="gi">+</span>
<span class="gi">+    if cls.multiple_of is None:</span>
<span class="gi">+        return st.floats(min_value, max_value, exclude_min=exclude_min, exclude_max=exclude_max, allow_nan=False)</span>
<span class="gi">+</span>
<span class="gi">+    if min_value is not None:</span>
<span class="gi">+        min_value = math.ceil(min_value / cls.multiple_of)</span>
<span class="gi">+        if exclude_min:</span>
<span class="gi">+            min_value = min_value + 1</span>
<span class="gi">+    if max_value is not None:</span>
<span class="gi">+        assert max_value &gt;= cls.multiple_of, &#39;Cannot build model with max value smaller than multiple of&#39;</span>
<span class="gi">+        max_value = math.floor(max_value / cls.multiple_of)</span>
<span class="gi">+        if exclude_max:</span>
<span class="gi">+            max_value = max_value - 1</span>
<span class="gi">+</span>
<span class="gi">+    return st.integers(min_value, max_value).map(lambda x: x * cls.multiple_of)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@resolves(pydantic.ConstrainedInt)</span>
<span class="gi">+def resolve_conint(cls):  # type: ignore[no-untyped-def]</span>
<span class="gi">+    min_value = cls.ge</span>
<span class="gi">+    max_value = cls.le</span>
<span class="gi">+    if cls.gt is not None:</span>
<span class="gi">+        assert min_value is None, &#39;Set `gt` or `ge`, but not both&#39;</span>
<span class="gi">+        min_value = cls.gt + 1</span>
<span class="gi">+    if cls.lt is not None:</span>
<span class="gi">+        assert max_value is None, &#39;Set `lt` or `le`, but not both&#39;</span>
<span class="gi">+        max_value = cls.lt - 1</span>
<span class="gi">+</span>
<span class="gi">+    if cls.multiple_of is None or cls.multiple_of == 1:</span>
<span class="gi">+        return st.integers(min_value, max_value)</span>
<span class="gi">+</span>
<span class="gi">+    # These adjustments and the .map handle integer-valued multiples, while the</span>
<span class="gi">+    # .filter handles trickier cases as for confloat.</span>
<span class="gi">+    if min_value is not None:</span>
<span class="gi">+        min_value = math.ceil(Fraction(min_value) / Fraction(cls.multiple_of))</span>
<span class="gi">+    if max_value is not None:</span>
<span class="gi">+        max_value = math.floor(Fraction(max_value) / Fraction(cls.multiple_of))</span>
<span class="gi">+    return st.integers(min_value, max_value).map(lambda x: x * cls.multiple_of)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@resolves(pydantic.ConstrainedDate)</span>
<span class="gi">+def resolve_condate(cls):  # type: ignore[no-untyped-def]</span>
<span class="gi">+    if cls.ge is not None:</span>
<span class="gi">+        assert cls.gt is None, &#39;Set `gt` or `ge`, but not both&#39;</span>
<span class="gi">+        min_value = cls.ge</span>
<span class="gi">+    elif cls.gt is not None:</span>
<span class="gi">+        min_value = cls.gt + datetime.timedelta(days=1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        min_value = datetime.date.min</span>
<span class="gi">+    if cls.le is not None:</span>
<span class="gi">+        assert cls.lt is None, &#39;Set `lt` or `le`, but not both&#39;</span>
<span class="gi">+        max_value = cls.le</span>
<span class="gi">+    elif cls.lt is not None:</span>
<span class="gi">+        max_value = cls.lt - datetime.timedelta(days=1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        max_value = datetime.date.max</span>
<span class="gi">+    return st.dates(min_value, max_value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@resolves(pydantic.ConstrainedStr)</span>
<span class="gi">+def resolve_constr(cls):  # type: ignore[no-untyped-def]  # pragma: no cover</span>
<span class="gi">+    min_size = cls.min_length or 0</span>
<span class="gi">+    max_size = cls.max_length</span>
<span class="gi">+</span>
<span class="gi">+    if cls.regex is None and not cls.strip_whitespace:</span>
<span class="gi">+        return st.text(min_size=min_size, max_size=max_size)</span>
<span class="gi">+</span>
<span class="gi">+    if cls.regex is not None:</span>
<span class="gi">+        strategy = st.from_regex(cls.regex)</span>
<span class="gi">+        if cls.strip_whitespace:</span>
<span class="gi">+            strategy = strategy.filter(lambda s: s == s.strip())</span>
<span class="gi">+    elif cls.strip_whitespace:</span>
<span class="gi">+        repeats = &#39;{{{},{}}}&#39;.format(</span>
<span class="gi">+            min_size - 2 if min_size &gt; 2 else 0,</span>
<span class="gi">+            max_size - 2 if (max_size or 0) &gt; 2 else &#39;&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+        if min_size &gt;= 2:</span>
<span class="gi">+            strategy = st.from_regex(rf&#39;\W.{repeats}\W&#39;)</span>
<span class="gi">+        elif min_size == 1:</span>
<span class="gi">+            strategy = st.from_regex(rf&#39;\W(.{repeats}\W)?&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert min_size == 0</span>
<span class="gi">+            strategy = st.from_regex(rf&#39;(\W(.{repeats}\W)?)?&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if min_size == 0 and max_size is None:</span>
<span class="gi">+        return strategy</span>
<span class="gi">+    elif max_size is None:</span>
<span class="gi">+        return strategy.filter(lambda s: min_size &lt;= len(s))</span>
<span class="gi">+    return strategy.filter(lambda s: min_size &lt;= len(s) &lt;= max_size)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Finally, register all previously-defined types, and patch in our new function</span>
<span class="w"> </span>for typ in list(pydantic.types._DEFINED_TYPES):
<span class="w"> </span>    _registered(typ)
<span class="w"> </span>pydantic.types._registered = _registered
<span class="gh">diff --git a/pydantic/v1/annotated_types.py b/pydantic/v1/annotated_types.py</span>
<span class="gh">index 06d15ea97..d9eaaafd5 100644</span>
<span class="gd">--- a/pydantic/v1/annotated_types.py</span>
<span class="gi">+++ b/pydantic/v1/annotated_types.py</span>
<span class="gu">@@ -1,29 +1,72 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Dict, FrozenSet, NamedTuple, Type
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.fields import Required
<span class="w"> </span>from pydantic.v1.main import BaseModel, create_model
<span class="w"> </span>from pydantic.v1.typing import is_typeddict, is_typeddict_special
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import TypedDict
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 11):

<span class="gi">+    def is_legacy_typeddict(typeddict_cls: Type[&#39;TypedDict&#39;]) -&gt; bool:  # type: ignore[valid-type]</span>
<span class="gi">+        return is_typeddict(typeddict_cls) and type(typeddict_cls).__module__ == &#39;typing&#39;</span>
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    def is_legacy_typeddict(_: Any) -&gt; Any:</span>
<span class="gi">+        return False</span>

<span class="gd">-def create_model_from_typeddict(typeddict_cls: Type[&#39;TypedDict&#39;], **kwargs: Any</span>
<span class="gd">-    ) -&gt;Type[&#39;BaseModel&#39;]:</span>
<span class="gi">+</span>
<span class="gi">+def create_model_from_typeddict(</span>
<span class="gi">+    # Mypy bug: `Type[TypedDict]` is resolved as `Any` https://github.com/python/mypy/issues/11030</span>
<span class="gi">+    typeddict_cls: Type[&#39;TypedDict&#39;],  # type: ignore[valid-type]</span>
<span class="gi">+    **kwargs: Any,</span>
<span class="gi">+) -&gt; Type[&#39;BaseModel&#39;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a `BaseModel` based on the fields of a `TypedDict`.
<span class="w"> </span>    Since `typing.TypedDict` in Python 3.8 does not store runtime information about optional keys,
<span class="w"> </span>    we raise an error if this happens (see https://bugs.python.org/issue38834).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    field_definitions: Dict[str, Any]</span>
<span class="gi">+</span>
<span class="gi">+    # Best case scenario: with python 3.9+ or when `TypedDict` is imported from `typing_extensions`</span>
<span class="gi">+    if not hasattr(typeddict_cls, &#39;__required_keys__&#39;):</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            &#39;You should use `typing_extensions.TypedDict` instead of `typing.TypedDict` with Python &lt; 3.9.2. &#39;</span>
<span class="gi">+            &#39;Without it, there is no way to differentiate required and optional fields when subclassed.&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if is_legacy_typeddict(typeddict_cls) and any(</span>
<span class="gi">+        is_typeddict_special(t) for t in typeddict_cls.__annotations__.values()</span>
<span class="gi">+    ):</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            &#39;You should use `typing_extensions.TypedDict` instead of `typing.TypedDict` with Python &lt; 3.11. &#39;</span>
<span class="gi">+            &#39;Without it, there is no way to reflect Required/NotRequired keys.&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    required_keys: FrozenSet[str] = typeddict_cls.__required_keys__  # type: ignore[attr-defined]</span>
<span class="gi">+    field_definitions = {</span>
<span class="gi">+        field_name: (field_type, Required if field_name in required_keys else None)</span>
<span class="gi">+        for field_name, field_type in typeddict_cls.__annotations__.items()</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    return create_model(typeddict_cls.__name__, **kwargs, **field_definitions)</span>


<span class="gd">-def create_model_from_namedtuple(namedtuple_cls: Type[&#39;NamedTuple&#39;], **</span>
<span class="gd">-    kwargs: Any) -&gt;Type[&#39;BaseModel&#39;]:</span>
<span class="gi">+def create_model_from_namedtuple(namedtuple_cls: Type[&#39;NamedTuple&#39;], **kwargs: Any) -&gt; Type[&#39;BaseModel&#39;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a `BaseModel` based on the fields of a named tuple.
<span class="w"> </span>    A named tuple can be created with `typing.NamedTuple` and declared annotations
<span class="w"> </span>    but also with `collections.namedtuple`, in this case we consider all fields
<span class="w"> </span>    to have type `Any`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # With python 3.10+, `__annotations__` always exists but can be empty hence the `getattr... or...` logic</span>
<span class="gi">+    namedtuple_annotations: Dict[str, Type[Any]] = getattr(namedtuple_cls, &#39;__annotations__&#39;, None) or {</span>
<span class="gi">+        k: Any for k in namedtuple_cls._fields</span>
<span class="gi">+    }</span>
<span class="gi">+    field_definitions: Dict[str, Any] = {</span>
<span class="gi">+        field_name: (field_type, Required) for field_name, field_type in namedtuple_annotations.items()</span>
<span class="gi">+    }</span>
<span class="gi">+    return create_model(namedtuple_cls.__name__, **kwargs, **field_definitions)</span>
<span class="gh">diff --git a/pydantic/v1/class_validators.py b/pydantic/v1/class_validators.py</span>
<span class="gh">index c7c09f7cd..2f68fc860 100644</span>
<span class="gd">--- a/pydantic/v1/class_validators.py</span>
<span class="gi">+++ b/pydantic/v1/class_validators.py</span>
<span class="gu">@@ -4,20 +4,27 @@ from functools import partial, partialmethod, wraps</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from types import FunctionType
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Dict, Iterable, List, Optional, Set, Tuple, Type, Union, overload
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.errors import ConfigError
<span class="w"> </span>from pydantic.v1.typing import AnyCallable
<span class="w"> </span>from pydantic.v1.utils import ROOT_KEY, in_ipython
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.typing import AnyClassMethod


<span class="w"> </span>class Validator:
<span class="gd">-    __slots__ = (&#39;func&#39;, &#39;pre&#39;, &#39;each_item&#39;, &#39;always&#39;, &#39;check_fields&#39;,</span>
<span class="gd">-        &#39;skip_on_failure&#39;)</span>
<span class="gi">+    __slots__ = &#39;func&#39;, &#39;pre&#39;, &#39;each_item&#39;, &#39;always&#39;, &#39;check_fields&#39;, &#39;skip_on_failure&#39;</span>

<span class="gd">-    def __init__(self, func: AnyCallable, pre: bool=False, each_item: bool=</span>
<span class="gd">-        False, always: bool=False, check_fields: bool=False,</span>
<span class="gd">-        skip_on_failure: bool=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        func: AnyCallable,</span>
<span class="gi">+        pre: bool = False,</span>
<span class="gi">+        each_item: bool = False,</span>
<span class="gi">+        always: bool = False,</span>
<span class="gi">+        check_fields: bool = False,</span>
<span class="gi">+        skip_on_failure: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.func = func
<span class="w"> </span>        self.pre = pre
<span class="w"> </span>        self.each_item = each_item
<span class="gu">@@ -28,21 +35,29 @@ class Validator:</span>

<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from inspect import Signature
<span class="gi">+</span>
<span class="w"> </span>    from pydantic.v1.config import BaseConfig
<span class="w"> </span>    from pydantic.v1.fields import ModelField
<span class="w"> </span>    from pydantic.v1.types import ModelOrDc
<span class="gd">-    ValidatorCallable = Callable[[Optional[ModelOrDc], Any, Dict[str, Any],</span>
<span class="gd">-        ModelField, Type[BaseConfig]], Any]</span>
<span class="gi">+</span>
<span class="gi">+    ValidatorCallable = Callable[[Optional[ModelOrDc], Any, Dict[str, Any], ModelField, Type[BaseConfig]], Any]</span>
<span class="w"> </span>    ValidatorsList = List[ValidatorCallable]
<span class="w"> </span>    ValidatorListDict = Dict[str, List[Validator]]
<span class="gi">+</span>
<span class="w"> </span>_FUNCS: Set[str] = set()
<span class="w"> </span>VALIDATOR_CONFIG_KEY = &#39;__validator_config__&#39;
<span class="w"> </span>ROOT_VALIDATOR_CONFIG_KEY = &#39;__root_validator_config__&#39;


<span class="gd">-def validator(*fields: str, pre: bool=False, each_item: bool=False, always:</span>
<span class="gd">-    bool=False, check_fields: bool=True, whole: Optional[bool]=None,</span>
<span class="gd">-    allow_reuse: bool=False) -&gt;Callable[[AnyCallable], &#39;AnyClassMethod&#39;]:</span>
<span class="gi">+def validator(</span>
<span class="gi">+    *fields: str,</span>
<span class="gi">+    pre: bool = False,</span>
<span class="gi">+    each_item: bool = False,</span>
<span class="gi">+    always: bool = False,</span>
<span class="gi">+    check_fields: bool = True,</span>
<span class="gi">+    whole: Optional[bool] = None,</span>
<span class="gi">+    allow_reuse: bool = False,</span>
<span class="gi">+) -&gt; Callable[[AnyCallable], &#39;AnyClassMethod&#39;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Decorate methods on the class indicating that they should be used to validate fields
<span class="w"> </span>    :param fields: which field(s) the method should be called on
<span class="gu">@@ -53,36 +68,178 @@ def validator(*fields: str, pre: bool=False, each_item: bool=False, always:</span>
<span class="w"> </span>    :param check_fields: whether to check that the fields actually exist on the model
<span class="w"> </span>    :param allow_reuse: whether to track and raise an error if another validator refers to the decorated function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not fields:</span>
<span class="gi">+        raise ConfigError(&#39;validator with no fields specified&#39;)</span>
<span class="gi">+    elif isinstance(fields[0], FunctionType):</span>
<span class="gi">+        raise ConfigError(</span>
<span class="gi">+            &quot;validators should be used with fields and keyword arguments, not bare. &quot;  # noqa: Q000</span>
<span class="gi">+            &quot;E.g. usage should be `@validator(&#39;&lt;field_name&gt;&#39;, ...)`&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    elif not all(isinstance(field, str) for field in fields):</span>
<span class="gi">+        raise ConfigError(</span>
<span class="gi">+            &quot;validator fields should be passed as separate string args. &quot;  # noqa: Q000</span>
<span class="gi">+            &quot;E.g. usage should be `@validator(&#39;&lt;field_name_1&gt;&#39;, &#39;&lt;field_name_2&gt;&#39;, ...)`&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if whole is not None:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The &quot;whole&quot; keyword argument is deprecated, use &quot;each_item&quot; (inverse meaning, default False) instead&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+        )</span>
<span class="gi">+        assert each_item is False, &#39;&quot;each_item&quot; and &quot;whole&quot; conflict, remove &quot;whole&quot;&#39;</span>
<span class="gi">+        each_item = not whole</span>
<span class="gi">+</span>
<span class="gi">+    def dec(f: AnyCallable) -&gt; &#39;AnyClassMethod&#39;:</span>
<span class="gi">+        f_cls = _prepare_validator(f, allow_reuse)</span>
<span class="gi">+        setattr(</span>
<span class="gi">+            f_cls,</span>
<span class="gi">+            VALIDATOR_CONFIG_KEY,</span>
<span class="gi">+            (</span>
<span class="gi">+                fields,</span>
<span class="gi">+                Validator(func=f_cls.__func__, pre=pre, each_item=each_item, always=always, check_fields=check_fields),</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        return f_cls</span>
<span class="gi">+</span>
<span class="gi">+    return dec</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def root_validator(_func: AnyCallable) -&gt; &#39;AnyClassMethod&#39;:</span>
<span class="gi">+    ...</span>


<span class="gd">-def root_validator(_func: Optional[AnyCallable]=None, *, pre: bool=False,</span>
<span class="gd">-    allow_reuse: bool=False, skip_on_failure: bool=False) -&gt;Union[</span>
<span class="gd">-    &#39;AnyClassMethod&#39;, Callable[[AnyCallable], &#39;AnyClassMethod&#39;]]:</span>
<span class="gi">+@overload</span>
<span class="gi">+def root_validator(</span>
<span class="gi">+    *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False</span>
<span class="gi">+) -&gt; Callable[[AnyCallable], &#39;AnyClassMethod&#39;]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def root_validator(</span>
<span class="gi">+    _func: Optional[AnyCallable] = None, *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False</span>
<span class="gi">+) -&gt; Union[&#39;AnyClassMethod&#39;, Callable[[AnyCallable], &#39;AnyClassMethod&#39;]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Decorate methods on a model indicating that they should be used to validate (and perhaps modify) data either
<span class="w"> </span>    before or after standard model parsing/validation is performed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _func:</span>
<span class="gi">+        f_cls = _prepare_validator(_func, allow_reuse)</span>
<span class="gi">+        setattr(</span>
<span class="gi">+            f_cls, ROOT_VALIDATOR_CONFIG_KEY, Validator(func=f_cls.__func__, pre=pre, skip_on_failure=skip_on_failure)</span>
<span class="gi">+        )</span>
<span class="gi">+        return f_cls</span>
<span class="gi">+</span>
<span class="gi">+    def dec(f: AnyCallable) -&gt; &#39;AnyClassMethod&#39;:</span>
<span class="gi">+        f_cls = _prepare_validator(f, allow_reuse)</span>
<span class="gi">+        setattr(</span>
<span class="gi">+            f_cls, ROOT_VALIDATOR_CONFIG_KEY, Validator(func=f_cls.__func__, pre=pre, skip_on_failure=skip_on_failure)</span>
<span class="gi">+        )</span>
<span class="gi">+        return f_cls</span>

<span class="gi">+    return dec</span>

<span class="gd">-def _prepare_validator(function: AnyCallable, allow_reuse: bool</span>
<span class="gd">-    ) -&gt;&#39;AnyClassMethod&#39;:</span>
<span class="gi">+</span>
<span class="gi">+def _prepare_validator(function: AnyCallable, allow_reuse: bool) -&gt; &#39;AnyClassMethod&#39;:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Avoid validators with duplicated names since without this, validators can be overwritten silently
<span class="w"> </span>    which generally isn&#39;t the intended behaviour, don&#39;t run in ipython (see #312) or if allow_reuse is False.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f_cls = function if isinstance(function, classmethod) else classmethod(function)</span>
<span class="gi">+    if not in_ipython() and not allow_reuse:</span>
<span class="gi">+        ref = (</span>
<span class="gi">+            getattr(f_cls.__func__, &#39;__module__&#39;, &#39;&lt;No __module__&gt;&#39;)</span>
<span class="gi">+            + &#39;.&#39;</span>
<span class="gi">+            + getattr(f_cls.__func__, &#39;__qualname__&#39;, f&#39;&lt;No __qualname__: id:{id(f_cls.__func__)}&gt;&#39;)</span>
<span class="gi">+        )</span>
<span class="gi">+        if ref in _FUNCS:</span>
<span class="gi">+            raise ConfigError(f&#39;duplicate validator function &quot;{ref}&quot;; if this is intended, set `allow_reuse=True`&#39;)</span>
<span class="gi">+        _FUNCS.add(ref)</span>
<span class="gi">+    return f_cls</span>


<span class="w"> </span>class ValidatorGroup:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, validators: &#39;ValidatorListDict&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, validators: &#39;ValidatorListDict&#39;) -&gt; None:</span>
<span class="w"> </span>        self.validators = validators
<span class="w"> </span>        self.used_validators = {&#39;*&#39;}

<span class="gi">+    def get_validators(self, name: str) -&gt; Optional[Dict[str, Validator]]:</span>
<span class="gi">+        self.used_validators.add(name)</span>
<span class="gi">+        validators = self.validators.get(name, [])</span>
<span class="gi">+        if name != ROOT_KEY:</span>
<span class="gi">+            validators += self.validators.get(&#39;*&#39;, [])</span>
<span class="gi">+        if validators:</span>
<span class="gi">+            return {getattr(v.func, &#39;__name__&#39;, f&#39;&lt;No __name__: id:{id(v.func)}&gt;&#39;): v for v in validators}</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def check_for_unused(self) -&gt; None:</span>
<span class="gi">+        unused_validators = set(</span>
<span class="gi">+            chain.from_iterable(</span>
<span class="gi">+                (</span>
<span class="gi">+                    getattr(v.func, &#39;__name__&#39;, f&#39;&lt;No __name__: id:{id(v.func)}&gt;&#39;)</span>
<span class="gi">+                    for v in self.validators[f]</span>
<span class="gi">+                    if v.check_fields</span>
<span class="gi">+                )</span>
<span class="gi">+                for f in (self.validators.keys() - self.used_validators)</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        if unused_validators:</span>
<span class="gi">+            fn = &#39;, &#39;.join(unused_validators)</span>
<span class="gi">+            raise ConfigError(</span>
<span class="gi">+                f&quot;Validators defined with incorrect fields: {fn} &quot;  # noqa: Q000</span>
<span class="gi">+                f&quot;(use check_fields=False if you&#39;re inheriting from the model and intended this)&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_validators(namespace: Dict[str, Any]) -&gt; Dict[str, List[Validator]]:</span>
<span class="gi">+    validators: Dict[str, List[Validator]] = {}</span>
<span class="gi">+    for var_name, value in namespace.items():</span>
<span class="gi">+        validator_config = getattr(value, VALIDATOR_CONFIG_KEY, None)</span>
<span class="gi">+        if validator_config:</span>
<span class="gi">+            fields, v = validator_config</span>
<span class="gi">+            for field in fields:</span>
<span class="gi">+                if field in validators:</span>
<span class="gi">+                    validators[field].append(v)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    validators[field] = [v]</span>
<span class="gi">+    return validators</span>
<span class="gi">+</span>

<span class="gd">-def make_generic_validator(validator: AnyCallable) -&gt;&#39;ValidatorCallable&#39;:</span>
<span class="gi">+def extract_root_validators(namespace: Dict[str, Any]) -&gt; Tuple[List[AnyCallable], List[Tuple[bool, AnyCallable]]]:</span>
<span class="gi">+    from inspect import signature</span>
<span class="gi">+</span>
<span class="gi">+    pre_validators: List[AnyCallable] = []</span>
<span class="gi">+    post_validators: List[Tuple[bool, AnyCallable]] = []</span>
<span class="gi">+    for name, value in namespace.items():</span>
<span class="gi">+        validator_config: Optional[Validator] = getattr(value, ROOT_VALIDATOR_CONFIG_KEY, None)</span>
<span class="gi">+        if validator_config:</span>
<span class="gi">+            sig = signature(validator_config.func)</span>
<span class="gi">+            args = list(sig.parameters.keys())</span>
<span class="gi">+            if args[0] == &#39;self&#39;:</span>
<span class="gi">+                raise ConfigError(</span>
<span class="gi">+                    f&#39;Invalid signature for root validator {name}: {sig}, &quot;self&quot; not permitted as first argument, &#39;</span>
<span class="gi">+                    f&#39;should be: (cls, values).&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            if len(args) != 2:</span>
<span class="gi">+                raise ConfigError(f&#39;Invalid signature for root validator {name}: {sig}, should be: (cls, values).&#39;)</span>
<span class="gi">+            # check function signature</span>
<span class="gi">+            if validator_config.pre:</span>
<span class="gi">+                pre_validators.append(validator_config.func)</span>
<span class="gi">+            else:</span>
<span class="gi">+                post_validators.append((validator_config.skip_on_failure, validator_config.func))</span>
<span class="gi">+    return pre_validators, post_validators</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inherit_validators(base_validators: &#39;ValidatorListDict&#39;, validators: &#39;ValidatorListDict&#39;) -&gt; &#39;ValidatorListDict&#39;:</span>
<span class="gi">+    for field, field_validators in base_validators.items():</span>
<span class="gi">+        if field not in validators:</span>
<span class="gi">+            validators[field] = []</span>
<span class="gi">+        validators[field] += field_validators</span>
<span class="gi">+    return validators</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_generic_validator(validator: AnyCallable) -&gt; &#39;ValidatorCallable&#39;:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Make a generic function which calls a validator with the right arguments.

<span class="gu">@@ -92,7 +249,113 @@ def make_generic_validator(validator: AnyCallable) -&gt;&#39;ValidatorCallable&#39;:</span>
<span class="w"> </span>    It&#39;s done like this so validators don&#39;t all need **kwargs in their signature, eg. any combination of
<span class="w"> </span>    the arguments &quot;values&quot;, &quot;fields&quot; and/or &quot;config&quot; are permitted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from inspect import signature</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(validator, (partial, partialmethod)):</span>
<span class="gi">+        # This should be the default case, so overhead is reduced</span>
<span class="gi">+        sig = signature(validator)</span>
<span class="gi">+        args = list(sig.parameters.keys())</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Fix the generated argument lists of partial methods</span>
<span class="gi">+        sig = signature(validator.func)</span>
<span class="gi">+        args = [</span>
<span class="gi">+            k</span>
<span class="gi">+            for k in signature(validator.func).parameters.keys()</span>
<span class="gi">+            if k not in validator.args | validator.keywords.keys()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    first_arg = args.pop(0)</span>
<span class="gi">+    if first_arg == &#39;self&#39;:</span>
<span class="gi">+        raise ConfigError(</span>
<span class="gi">+            f&#39;Invalid signature for validator {validator}: {sig}, &quot;self&quot; not permitted as first argument, &#39;</span>
<span class="gi">+            f&#39;should be: (cls, value, values, config, field), &quot;values&quot;, &quot;config&quot; and &quot;field&quot; are all optional.&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+    elif first_arg == &#39;cls&#39;:</span>
<span class="gi">+        # assume the second argument is value</span>
<span class="gi">+        return wraps(validator)(_generic_validator_cls(validator, sig, set(args[1:])))</span>
<span class="gi">+    else:</span>
<span class="gi">+        # assume the first argument was value which has already been removed</span>
<span class="gi">+        return wraps(validator)(_generic_validator_basic(validator, sig, set(args)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def prep_validators(v_funcs: Iterable[AnyCallable]) -&gt; &#39;ValidatorsList&#39;:</span>
<span class="gi">+    return [make_generic_validator(f) for f in v_funcs if f]</span>


<span class="w"> </span>all_kwargs = {&#39;values&#39;, &#39;field&#39;, &#39;config&#39;}
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _generic_validator_cls(validator: AnyCallable, sig: &#39;Signature&#39;, args: Set[str]) -&gt; &#39;ValidatorCallable&#39;:</span>
<span class="gi">+    # assume the first argument is value</span>
<span class="gi">+    has_kwargs = False</span>
<span class="gi">+    if &#39;kwargs&#39; in args:</span>
<span class="gi">+        has_kwargs = True</span>
<span class="gi">+        args -= {&#39;kwargs&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    if not args.issubset(all_kwargs):</span>
<span class="gi">+        raise ConfigError(</span>
<span class="gi">+            f&#39;Invalid signature for validator {validator}: {sig}, should be: &#39;</span>
<span class="gi">+            f&#39;(cls, value, values, config, field), &quot;values&quot;, &quot;config&quot; and &quot;field&quot; are all optional.&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if has_kwargs:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v, values=values, field=field, config=config)</span>
<span class="gi">+    elif args == set():</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v)</span>
<span class="gi">+    elif args == {&#39;values&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v, values=values)</span>
<span class="gi">+    elif args == {&#39;field&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v, field=field)</span>
<span class="gi">+    elif args == {&#39;config&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v, config=config)</span>
<span class="gi">+    elif args == {&#39;values&#39;, &#39;field&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v, values=values, field=field)</span>
<span class="gi">+    elif args == {&#39;values&#39;, &#39;config&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v, values=values, config=config)</span>
<span class="gi">+    elif args == {&#39;field&#39;, &#39;config&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v, field=field, config=config)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # args == {&#39;values&#39;, &#39;field&#39;, &#39;config&#39;}</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(cls, v, values=values, field=field, config=config)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _generic_validator_basic(validator: AnyCallable, sig: &#39;Signature&#39;, args: Set[str]) -&gt; &#39;ValidatorCallable&#39;:</span>
<span class="gi">+    has_kwargs = False</span>
<span class="gi">+    if &#39;kwargs&#39; in args:</span>
<span class="gi">+        has_kwargs = True</span>
<span class="gi">+        args -= {&#39;kwargs&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    if not args.issubset(all_kwargs):</span>
<span class="gi">+        raise ConfigError(</span>
<span class="gi">+            f&#39;Invalid signature for validator {validator}: {sig}, should be: &#39;</span>
<span class="gi">+            f&#39;(value, values, config, field), &quot;values&quot;, &quot;config&quot; and &quot;field&quot; are all optional.&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if has_kwargs:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v, values=values, field=field, config=config)</span>
<span class="gi">+    elif args == set():</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v)</span>
<span class="gi">+    elif args == {&#39;values&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v, values=values)</span>
<span class="gi">+    elif args == {&#39;field&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v, field=field)</span>
<span class="gi">+    elif args == {&#39;config&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v, config=config)</span>
<span class="gi">+    elif args == {&#39;values&#39;, &#39;field&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v, values=values, field=field)</span>
<span class="gi">+    elif args == {&#39;values&#39;, &#39;config&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v, values=values, config=config)</span>
<span class="gi">+    elif args == {&#39;field&#39;, &#39;config&#39;}:</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v, field=field, config=config)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # args == {&#39;values&#39;, &#39;field&#39;, &#39;config&#39;}</span>
<span class="gi">+        return lambda cls, v, values, field, config: validator(v, values=values, field=field, config=config)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def gather_all_validators(type_: &#39;ModelOrDc&#39;) -&gt; Dict[str, &#39;AnyClassMethod&#39;]:</span>
<span class="gi">+    all_attributes = ChainMap(*[cls.__dict__ for cls in type_.__mro__])  # type: ignore[arg-type,var-annotated]</span>
<span class="gi">+    return {</span>
<span class="gi">+        k: v</span>
<span class="gi">+        for k, v in all_attributes.items()</span>
<span class="gi">+        if hasattr(v, VALIDATOR_CONFIG_KEY) or hasattr(v, ROOT_VALIDATOR_CONFIG_KEY)</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/pydantic/v1/color.py b/pydantic/v1/color.py</span>
<span class="gh">index 021245ab0..b0bbf78f4 100644</span>
<span class="gd">--- a/pydantic/v1/color.py</span>
<span class="gi">+++ b/pydantic/v1/color.py</span>
<span class="gu">@@ -11,20 +11,23 @@ import math</span>
<span class="w"> </span>import re
<span class="w"> </span>from colorsys import hls_to_rgb, rgb_to_hls
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union, cast
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.errors import ColorError
<span class="w"> </span>from pydantic.v1.utils import Representation, almost_equal_floats
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.typing import CallableGenerator, ReprArgs
<span class="gi">+</span>
<span class="w"> </span>ColorTuple = Union[Tuple[int, int, int], Tuple[int, int, int, float]]
<span class="w"> </span>ColorType = Union[ColorTuple, str]
<span class="gd">-HslColorTuple = Union[Tuple[float, float, float], Tuple[float, float, float,</span>
<span class="gd">-    float]]</span>
<span class="gi">+HslColorTuple = Union[Tuple[float, float, float], Tuple[float, float, float, float]]</span>


<span class="w"> </span>class RGBA:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Internal use only as a representation of a color.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = &#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;alpha&#39;, &#39;_tuple&#39;

<span class="w"> </span>    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):
<span class="gu">@@ -32,29 +35,27 @@ class RGBA:</span>
<span class="w"> </span>        self.g = g
<span class="w"> </span>        self.b = b
<span class="w"> </span>        self.alpha = alpha
<span class="gd">-        self._tuple: Tuple[float, float, float, Optional[float]] = (r, g, b,</span>
<span class="gd">-            alpha)</span>

<span class="gd">-    def __getitem__(self, item: Any) -&gt;Any:</span>
<span class="gi">+        self._tuple: Tuple[float, float, float, Optional[float]] = (r, g, b, alpha)</span>
<span class="gi">+</span>
<span class="gi">+    def __getitem__(self, item: Any) -&gt; Any:</span>
<span class="w"> </span>        return self._tuple[item]


<span class="gd">-r_hex_short = &#39;\\s*(?:#|0x)?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?\\s*&#39;</span>
<span class="gd">-r_hex_long = (</span>
<span class="gd">-    &#39;\\s*(?:#|0x)?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?\\s*&#39;)</span>
<span class="gd">-_r_255 = &#39;(\\d{1,3}(?:\\.\\d+)?)&#39;</span>
<span class="gd">-_r_comma = &#39;\\s*,\\s*&#39;</span>
<span class="gd">-r_rgb = f&#39;\\s*rgb\\(\\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}\\)\\s*&#39;</span>
<span class="gd">-_r_alpha = &#39;(\\d(?:\\.\\d+)?|\\.\\d+|\\d{1,2}%)&#39;</span>
<span class="gd">-r_rgba = (</span>
<span class="gd">-    f&#39;\\s*rgba\\(\\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_alpha}\\s*\\)\\s*&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-_r_h = &#39;(-?\\d+(?:\\.\\d+)?|-?\\.\\d+)(deg|rad|turn)?&#39;</span>
<span class="gd">-_r_sl = &#39;(\\d{1,3}(?:\\.\\d+)?)%&#39;</span>
<span class="gd">-r_hsl = f&#39;\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}\\s*\\)\\s*&#39;</span>
<span class="gd">-r_hsla = (</span>
<span class="gd">-    f&#39;\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}{_r_comma}{_r_alpha}\\s*\\)\\s*&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+# these are not compiled here to avoid import slowdown, they&#39;ll be compiled the first time they&#39;re used, then cached</span>
<span class="gi">+r_hex_short = r&#39;\s*(?:#|0x)?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?\s*&#39;</span>
<span class="gi">+r_hex_long = r&#39;\s*(?:#|0x)?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?\s*&#39;</span>
<span class="gi">+_r_255 = r&#39;(\d{1,3}(?:\.\d+)?)&#39;</span>
<span class="gi">+_r_comma = r&#39;\s*,\s*&#39;</span>
<span class="gi">+r_rgb = fr&#39;\s*rgb\(\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}\)\s*&#39;</span>
<span class="gi">+_r_alpha = r&#39;(\d(?:\.\d+)?|\.\d+|\d{1,2}%)&#39;</span>
<span class="gi">+r_rgba = fr&#39;\s*rgba\(\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_alpha}\s*\)\s*&#39;</span>
<span class="gi">+_r_h = r&#39;(-?\d+(?:\.\d+)?|-?\.\d+)(deg|rad|turn)?&#39;</span>
<span class="gi">+_r_sl = r&#39;(\d{1,3}(?:\.\d+)?)%&#39;</span>
<span class="gi">+r_hsl = fr&#39;\s*hsl\(\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}\s*\)\s*&#39;</span>
<span class="gi">+r_hsla = fr&#39;\s*hsl\(\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}{_r_comma}{_r_alpha}\s*\)\s*&#39;</span>
<span class="gi">+</span>
<span class="gi">+# colors where the two hex characters are the same, if all colors match this the short version of hex colors can be used</span>
<span class="w"> </span>repeat_colors = {int(c * 2, 16) for c in &#39;0123456789abcdef&#39;}
<span class="w"> </span>rads = 2 * math.pi

<span class="gu">@@ -62,7 +63,7 @@ rads = 2 * math.pi</span>
<span class="w"> </span>class Color(Representation):
<span class="w"> </span>    __slots__ = &#39;_original&#39;, &#39;_rgba&#39;

<span class="gd">-    def __init__(self, value: ColorType) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: ColorType) -&gt; None:</span>
<span class="w"> </span>        self._rgba: RGBA
<span class="w"> </span>        self._original: ColorType
<span class="w"> </span>        if isinstance(value, (tuple, list)):
<span class="gu">@@ -74,32 +75,60 @@ class Color(Representation):</span>
<span class="w"> </span>            value = value._original
<span class="w"> </span>        else:
<span class="w"> </span>            raise ColorError(reason=&#39;value must be a tuple, list or string&#39;)
<span class="gi">+</span>
<span class="gi">+        # if we&#39;ve got here value must be a valid color</span>
<span class="w"> </span>        self._original = value

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;color&#39;)

<span class="gd">-    def original(self) -&gt;ColorType:</span>
<span class="gi">+    def original(self) -&gt; ColorType:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Original value passed to Color
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._original</span>
<span class="gi">+</span>
<span class="gi">+    def as_named(self, *, fallback: bool = False) -&gt; str:</span>
<span class="gi">+        if self._rgba.alpha is None:</span>
<span class="gi">+            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())</span>
<span class="gi">+            try:</span>
<span class="gi">+                return COLORS_BY_VALUE[rgb]</span>
<span class="gi">+            except KeyError as e:</span>
<span class="gi">+                if fallback:</span>
<span class="gi">+                    return self.as_hex()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(&#39;no named color found, use fallback=True, as_hex() or as_rgb()&#39;) from e</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.as_hex()</span>

<span class="gd">-    def as_hex(self) -&gt;str:</span>
<span class="gi">+    def as_hex(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Hex string representing the color can be 3, 4, 6 or 8 characters depending on whether the string
<span class="w"> </span>        a &quot;short&quot; representation of the color is possible and whether there&#39;s an alpha channel.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        values = [float_to_255(c) for c in self._rgba[:3]]</span>
<span class="gi">+        if self._rgba.alpha is not None:</span>
<span class="gi">+            values.append(float_to_255(self._rgba.alpha))</span>
<span class="gi">+</span>
<span class="gi">+        as_hex = &#39;&#39;.join(f&#39;{v:02x}&#39; for v in values)</span>
<span class="gi">+        if all(c in repeat_colors for c in values):</span>
<span class="gi">+            as_hex = &#39;&#39;.join(as_hex[c] for c in range(0, len(as_hex), 2))</span>
<span class="gi">+        return &#39;#&#39; + as_hex</span>

<span class="gd">-    def as_rgb(self) -&gt;str:</span>
<span class="gi">+    def as_rgb(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Color as an rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;) or rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;) string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._rgba.alpha is None:</span>
<span class="gi">+            return f&#39;rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (</span>
<span class="gi">+                f&#39;rgba({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)}, &#39;</span>
<span class="gi">+                f&#39;{round(self._alpha_float(), 2)})&#39;</span>
<span class="gi">+            )</span>

<span class="gd">-    def as_rgb_tuple(self, *, alpha: Optional[bool]=None) -&gt;ColorTuple:</span>
<span class="gi">+    def as_rgb_tuple(self, *, alpha: Optional[bool] = None) -&gt; ColorTuple:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Color as an RGB or RGBA tuple; red, green and blue are in the range 0 to 255, alpha if included is
<span class="w"> </span>        in the range 0 to 1.
<span class="gu">@@ -109,15 +138,30 @@ class Color(Representation):</span>
<span class="w"> </span>          True - always include alpha,
<span class="w"> </span>          False - always omit alpha,
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        r, g, b = (float_to_255(c) for c in self._rgba[:3])</span>
<span class="gi">+        if alpha is None:</span>
<span class="gi">+            if self._rgba.alpha is None:</span>
<span class="gi">+                return r, g, b</span>
<span class="gi">+            else:</span>
<span class="gi">+                return r, g, b, self._alpha_float()</span>
<span class="gi">+        elif alpha:</span>
<span class="gi">+            return r, g, b, self._alpha_float()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # alpha is False</span>
<span class="gi">+            return r, g, b</span>

<span class="gd">-    def as_hsl(self) -&gt;str:</span>
<span class="gi">+    def as_hsl(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Color as an hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;) or hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;, &lt;a&gt;) string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._rgba.alpha is None:</span>
<span class="gi">+            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore</span>
<span class="gi">+            return f&#39;hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            h, s, li, a = self.as_hsl_tuple(alpha=True)  # type: ignore</span>
<span class="gi">+            return f&#39;hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%}, {round(a, 2)})&#39;</span>

<span class="gd">-    def as_hsl_tuple(self, *, alpha: Optional[bool]=None) -&gt;HslColorTuple:</span>
<span class="gi">+    def as_hsl_tuple(self, *, alpha: Optional[bool] = None) -&gt; HslColorTuple:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Color as an HSL or HSLA tuple, e.g. hue, saturation, lightness and optionally alpha; all elements are in
<span class="w"> </span>        the range 0 to 1.
<span class="gu">@@ -129,35 +173,53 @@ class Color(Representation):</span>
<span class="w"> </span>          True - always include alpha,
<span class="w"> </span>          False - always omit alpha,
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)</span>
<span class="gi">+        if alpha is None:</span>
<span class="gi">+            if self._rgba.alpha is None:</span>
<span class="gi">+                return h, s, l</span>
<span class="gi">+            else:</span>
<span class="gi">+                return h, s, l, self._alpha_float()</span>
<span class="gi">+        if alpha:</span>
<span class="gi">+            return h, s, l, self._alpha_float()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # alpha is False</span>
<span class="gi">+            return h, s, l</span>
<span class="gi">+</span>
<span class="gi">+    def _alpha_float(self) -&gt; float:</span>
<span class="gi">+        return 1 if self._rgba.alpha is None else self._rgba.alpha</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.as_named(fallback=True)

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gd">-        return [(None, self.as_named(fallback=True))] + [(&#39;rgb&#39;, self.</span>
<span class="gd">-            as_rgb_tuple())]</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="gi">+        return [(None, self.as_named(fallback=True))] + [(&#39;rgb&#39;, self.as_rgb_tuple())]  # type: ignore</span>

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, Color) and self.as_rgb_tuple(</span>
<span class="gd">-            ) == other.as_rgb_tuple()</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, Color) and self.as_rgb_tuple() == other.as_rgb_tuple()</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.as_rgb_tuple())


<span class="gd">-def parse_tuple(value: Tuple[Any, ...]) -&gt;RGBA:</span>
<span class="gi">+def parse_tuple(value: Tuple[Any, ...]) -&gt; RGBA:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a tuple or list as a color.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(value) == 3:</span>
<span class="gi">+        r, g, b = (parse_color_value(v) for v in value)</span>
<span class="gi">+        return RGBA(r, g, b, None)</span>
<span class="gi">+    elif len(value) == 4:</span>
<span class="gi">+        r, g, b = (parse_color_value(v) for v in value[:3])</span>
<span class="gi">+        return RGBA(r, g, b, parse_float_alpha(value[3]))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ColorError(reason=&#39;tuples must have length 3 or 4&#39;)</span>


<span class="gd">-def parse_str(value: str) -&gt;RGBA:</span>
<span class="gi">+def parse_str(value: str) -&gt; RGBA:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a string to an RGBA tuple, trying the following formats (in this order):
<span class="w"> </span>    * named color, see COLORS_BY_NAME below
<span class="gu">@@ -166,92 +228,267 @@ def parse_str(value: str) -&gt;RGBA:</span>
<span class="w"> </span>    * `rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;) `
<span class="w"> </span>    * `rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;)`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value_lower = value.lower()</span>
<span class="gi">+    try:</span>
<span class="gi">+        r, g, b = COLORS_BY_NAME[value_lower]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        return ints_to_rgba(r, g, b, None)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.fullmatch(r_hex_short, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        *rgb, a = m.groups()</span>
<span class="gi">+        r, g, b = (int(v * 2, 16) for v in rgb)</span>
<span class="gi">+        if a:</span>
<span class="gi">+            alpha: Optional[float] = int(a * 2, 16) / 255</span>
<span class="gi">+        else:</span>
<span class="gi">+            alpha = None</span>
<span class="gi">+        return ints_to_rgba(r, g, b, alpha)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.fullmatch(r_hex_long, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        *rgb, a = m.groups()</span>
<span class="gi">+        r, g, b = (int(v, 16) for v in rgb)</span>
<span class="gi">+        if a:</span>
<span class="gi">+            alpha = int(a, 16) / 255</span>
<span class="gi">+        else:</span>
<span class="gi">+            alpha = None</span>
<span class="gi">+        return ints_to_rgba(r, g, b, alpha)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.fullmatch(r_rgb, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        return ints_to_rgba(*m.groups(), None)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    m = re.fullmatch(r_rgba, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        return ints_to_rgba(*m.groups())  # type: ignore</span>

<span class="gi">+    m = re.fullmatch(r_hsl, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        h, h_units, s, l_ = m.groups()</span>
<span class="gi">+        return parse_hsl(h, h_units, s, l_)</span>

<span class="gd">-def parse_color_value(value: Union[int, str], max_val: int=255) -&gt;float:</span>
<span class="gi">+    m = re.fullmatch(r_hsla, value_lower)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        h, h_units, s, l_, a = m.groups()</span>
<span class="gi">+        return parse_hsl(h, h_units, s, l_, parse_float_alpha(a))</span>
<span class="gi">+</span>
<span class="gi">+    raise ColorError(reason=&#39;string not recognised as a valid color&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ints_to_rgba(r: Union[int, str], g: Union[int, str], b: Union[int, str], alpha: Optional[float]) -&gt; RGBA:</span>
<span class="gi">+    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_color_value(value: Union[int, str], max_val: int = 255) -&gt; float:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a value checking it&#39;s a valid int in the range 0 to max_val and divide by max_val to give a number
<span class="w"> </span>    in the range 0 to 1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        color = float(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ColorError(reason=&#39;color values must be a valid number&#39;)</span>
<span class="gi">+    if 0 &lt;= color &lt;= max_val:</span>
<span class="gi">+        return color / max_val</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ColorError(reason=f&#39;color values must be in the range 0 to {max_val}&#39;)</span>


<span class="gd">-def parse_float_alpha(value: Union[None, str, float, int]) -&gt;Optional[float]:</span>
<span class="gi">+def parse_float_alpha(value: Union[None, str, float, int]) -&gt; Optional[float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a value checking it&#39;s a valid float in the range 0 to 1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(value, str) and value.endswith(&#39;%&#39;):</span>
<span class="gi">+            alpha = float(value[:-1]) / 100</span>
<span class="gi">+        else:</span>
<span class="gi">+            alpha = float(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ColorError(reason=&#39;alpha values must be a valid float&#39;)</span>

<span class="gi">+    if almost_equal_floats(alpha, 1):</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif 0 &lt;= alpha &lt;= 1:</span>
<span class="gi">+        return alpha</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ColorError(reason=&#39;alpha values must be in the range 0 to 1&#39;)</span>

<span class="gd">-def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[</span>
<span class="gd">-    float]=None) -&gt;RGBA:</span>
<span class="gi">+</span>
<span class="gi">+def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[float] = None) -&gt; RGBA:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse raw hue, saturation, lightness and alpha values and convert to RGBA.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-COLORS_BY_NAME = {&#39;aliceblue&#39;: (240, 248, 255), &#39;antiquewhite&#39;: (250, 235, </span>
<span class="gd">-    215), &#39;aqua&#39;: (0, 255, 255), &#39;aquamarine&#39;: (127, 255, 212), &#39;azure&#39;: (</span>
<span class="gd">-    240, 255, 255), &#39;beige&#39;: (245, 245, 220), &#39;bisque&#39;: (255, 228, 196),</span>
<span class="gd">-    &#39;black&#39;: (0, 0, 0), &#39;blanchedalmond&#39;: (255, 235, 205), &#39;blue&#39;: (0, 0, </span>
<span class="gd">-    255), &#39;blueviolet&#39;: (138, 43, 226), &#39;brown&#39;: (165, 42, 42), &#39;burlywood&#39;:</span>
<span class="gd">-    (222, 184, 135), &#39;cadetblue&#39;: (95, 158, 160), &#39;chartreuse&#39;: (127, 255, </span>
<span class="gd">-    0), &#39;chocolate&#39;: (210, 105, 30), &#39;coral&#39;: (255, 127, 80),</span>
<span class="gd">-    &#39;cornflowerblue&#39;: (100, 149, 237), &#39;cornsilk&#39;: (255, 248, 220),</span>
<span class="gd">-    &#39;crimson&#39;: (220, 20, 60), &#39;cyan&#39;: (0, 255, 255), &#39;darkblue&#39;: (0, 0, 139</span>
<span class="gd">-    ), &#39;darkcyan&#39;: (0, 139, 139), &#39;darkgoldenrod&#39;: (184, 134, 11),</span>
<span class="gd">-    &#39;darkgray&#39;: (169, 169, 169), &#39;darkgreen&#39;: (0, 100, 0), &#39;darkgrey&#39;: (169,</span>
<span class="gd">-    169, 169), &#39;darkkhaki&#39;: (189, 183, 107), &#39;darkmagenta&#39;: (139, 0, 139),</span>
<span class="gd">-    &#39;darkolivegreen&#39;: (85, 107, 47), &#39;darkorange&#39;: (255, 140, 0),</span>
<span class="gd">-    &#39;darkorchid&#39;: (153, 50, 204), &#39;darkred&#39;: (139, 0, 0), &#39;darksalmon&#39;: (</span>
<span class="gd">-    233, 150, 122), &#39;darkseagreen&#39;: (143, 188, 143), &#39;darkslateblue&#39;: (72, </span>
<span class="gd">-    61, 139), &#39;darkslategray&#39;: (47, 79, 79), &#39;darkslategrey&#39;: (47, 79, 79),</span>
<span class="gd">-    &#39;darkturquoise&#39;: (0, 206, 209), &#39;darkviolet&#39;: (148, 0, 211), &#39;deeppink&#39;:</span>
<span class="gd">-    (255, 20, 147), &#39;deepskyblue&#39;: (0, 191, 255), &#39;dimgray&#39;: (105, 105, 105</span>
<span class="gd">-    ), &#39;dimgrey&#39;: (105, 105, 105), &#39;dodgerblue&#39;: (30, 144, 255),</span>
<span class="gd">-    &#39;firebrick&#39;: (178, 34, 34), &#39;floralwhite&#39;: (255, 250, 240),</span>
<span class="gd">-    &#39;forestgreen&#39;: (34, 139, 34), &#39;fuchsia&#39;: (255, 0, 255), &#39;gainsboro&#39;: (</span>
<span class="gd">-    220, 220, 220), &#39;ghostwhite&#39;: (248, 248, 255), &#39;gold&#39;: (255, 215, 0),</span>
<span class="gd">-    &#39;goldenrod&#39;: (218, 165, 32), &#39;gray&#39;: (128, 128, 128), &#39;green&#39;: (0, 128,</span>
<span class="gd">-    0), &#39;greenyellow&#39;: (173, 255, 47), &#39;grey&#39;: (128, 128, 128), &#39;honeydew&#39;:</span>
<span class="gd">-    (240, 255, 240), &#39;hotpink&#39;: (255, 105, 180), &#39;indianred&#39;: (205, 92, 92),</span>
<span class="gd">-    &#39;indigo&#39;: (75, 0, 130), &#39;ivory&#39;: (255, 255, 240), &#39;khaki&#39;: (240, 230, </span>
<span class="gd">-    140), &#39;lavender&#39;: (230, 230, 250), &#39;lavenderblush&#39;: (255, 240, 245),</span>
<span class="gd">-    &#39;lawngreen&#39;: (124, 252, 0), &#39;lemonchiffon&#39;: (255, 250, 205),</span>
<span class="gd">-    &#39;lightblue&#39;: (173, 216, 230), &#39;lightcoral&#39;: (240, 128, 128),</span>
<span class="gd">-    &#39;lightcyan&#39;: (224, 255, 255), &#39;lightgoldenrodyellow&#39;: (250, 250, 210),</span>
<span class="gd">-    &#39;lightgray&#39;: (211, 211, 211), &#39;lightgreen&#39;: (144, 238, 144),</span>
<span class="gd">-    &#39;lightgrey&#39;: (211, 211, 211), &#39;lightpink&#39;: (255, 182, 193),</span>
<span class="gd">-    &#39;lightsalmon&#39;: (255, 160, 122), &#39;lightseagreen&#39;: (32, 178, 170),</span>
<span class="gd">-    &#39;lightskyblue&#39;: (135, 206, 250), &#39;lightslategray&#39;: (119, 136, 153),</span>
<span class="gd">-    &#39;lightslategrey&#39;: (119, 136, 153), &#39;lightsteelblue&#39;: (176, 196, 222),</span>
<span class="gd">-    &#39;lightyellow&#39;: (255, 255, 224), &#39;lime&#39;: (0, 255, 0), &#39;limegreen&#39;: (50, </span>
<span class="gd">-    205, 50), &#39;linen&#39;: (250, 240, 230), &#39;magenta&#39;: (255, 0, 255), &#39;maroon&#39;:</span>
<span class="gd">-    (128, 0, 0), &#39;mediumaquamarine&#39;: (102, 205, 170), &#39;mediumblue&#39;: (0, 0, </span>
<span class="gd">-    205), &#39;mediumorchid&#39;: (186, 85, 211), &#39;mediumpurple&#39;: (147, 112, 219),</span>
<span class="gd">-    &#39;mediumseagreen&#39;: (60, 179, 113), &#39;mediumslateblue&#39;: (123, 104, 238),</span>
<span class="gd">-    &#39;mediumspringgreen&#39;: (0, 250, 154), &#39;mediumturquoise&#39;: (72, 209, 204),</span>
<span class="gd">-    &#39;mediumvioletred&#39;: (199, 21, 133), &#39;midnightblue&#39;: (25, 25, 112),</span>
<span class="gd">-    &#39;mintcream&#39;: (245, 255, 250), &#39;mistyrose&#39;: (255, 228, 225), &#39;moccasin&#39;:</span>
<span class="gd">-    (255, 228, 181), &#39;navajowhite&#39;: (255, 222, 173), &#39;navy&#39;: (0, 0, 128),</span>
<span class="gd">-    &#39;oldlace&#39;: (253, 245, 230), &#39;olive&#39;: (128, 128, 0), &#39;olivedrab&#39;: (107, </span>
<span class="gd">-    142, 35), &#39;orange&#39;: (255, 165, 0), &#39;orangered&#39;: (255, 69, 0), &#39;orchid&#39;:</span>
<span class="gd">-    (218, 112, 214), &#39;palegoldenrod&#39;: (238, 232, 170), &#39;palegreen&#39;: (152, </span>
<span class="gd">-    251, 152), &#39;paleturquoise&#39;: (175, 238, 238), &#39;palevioletred&#39;: (219, 112,</span>
<span class="gd">-    147), &#39;papayawhip&#39;: (255, 239, 213), &#39;peachpuff&#39;: (255, 218, 185),</span>
<span class="gd">-    &#39;peru&#39;: (205, 133, 63), &#39;pink&#39;: (255, 192, 203), &#39;plum&#39;: (221, 160, 221</span>
<span class="gd">-    ), &#39;powderblue&#39;: (176, 224, 230), &#39;purple&#39;: (128, 0, 128), &#39;red&#39;: (255,</span>
<span class="gd">-    0, 0), &#39;rosybrown&#39;: (188, 143, 143), &#39;royalblue&#39;: (65, 105, 225),</span>
<span class="gd">-    &#39;saddlebrown&#39;: (139, 69, 19), &#39;salmon&#39;: (250, 128, 114), &#39;sandybrown&#39;:</span>
<span class="gd">-    (244, 164, 96), &#39;seagreen&#39;: (46, 139, 87), &#39;seashell&#39;: (255, 245, 238),</span>
<span class="gd">-    &#39;sienna&#39;: (160, 82, 45), &#39;silver&#39;: (192, 192, 192), &#39;skyblue&#39;: (135, </span>
<span class="gd">-    206, 235), &#39;slateblue&#39;: (106, 90, 205), &#39;slategray&#39;: (112, 128, 144),</span>
<span class="gd">-    &#39;slategrey&#39;: (112, 128, 144), &#39;snow&#39;: (255, 250, 250), &#39;springgreen&#39;: (</span>
<span class="gd">-    0, 255, 127), &#39;steelblue&#39;: (70, 130, 180), &#39;tan&#39;: (210, 180, 140),</span>
<span class="gd">-    &#39;teal&#39;: (0, 128, 128), &#39;thistle&#39;: (216, 191, 216), &#39;tomato&#39;: (255, 99, </span>
<span class="gd">-    71), &#39;turquoise&#39;: (64, 224, 208), &#39;violet&#39;: (238, 130, 238), &#39;wheat&#39;: (</span>
<span class="gd">-    245, 222, 179), &#39;white&#39;: (255, 255, 255), &#39;whitesmoke&#39;: (245, 245, 245),</span>
<span class="gd">-    &#39;yellow&#39;: (255, 255, 0), &#39;yellowgreen&#39;: (154, 205, 50)}</span>
<span class="gi">+    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)</span>
<span class="gi">+</span>
<span class="gi">+    h_value = float(h)</span>
<span class="gi">+    if h_units in {None, &#39;deg&#39;}:</span>
<span class="gi">+        h_value = h_value % 360 / 360</span>
<span class="gi">+    elif h_units == &#39;rad&#39;:</span>
<span class="gi">+        h_value = h_value % rads / rads</span>
<span class="gi">+    else:</span>
<span class="gi">+        # turns</span>
<span class="gi">+        h_value = h_value % 1</span>
<span class="gi">+</span>
<span class="gi">+    r, g, b = hls_to_rgb(h_value, l_value, s_value)</span>
<span class="gi">+    return RGBA(r, g, b, alpha)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def float_to_255(c: float) -&gt; int:</span>
<span class="gi">+    return int(round(c * 255))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+COLORS_BY_NAME = {</span>
<span class="gi">+    &#39;aliceblue&#39;: (240, 248, 255),</span>
<span class="gi">+    &#39;antiquewhite&#39;: (250, 235, 215),</span>
<span class="gi">+    &#39;aqua&#39;: (0, 255, 255),</span>
<span class="gi">+    &#39;aquamarine&#39;: (127, 255, 212),</span>
<span class="gi">+    &#39;azure&#39;: (240, 255, 255),</span>
<span class="gi">+    &#39;beige&#39;: (245, 245, 220),</span>
<span class="gi">+    &#39;bisque&#39;: (255, 228, 196),</span>
<span class="gi">+    &#39;black&#39;: (0, 0, 0),</span>
<span class="gi">+    &#39;blanchedalmond&#39;: (255, 235, 205),</span>
<span class="gi">+    &#39;blue&#39;: (0, 0, 255),</span>
<span class="gi">+    &#39;blueviolet&#39;: (138, 43, 226),</span>
<span class="gi">+    &#39;brown&#39;: (165, 42, 42),</span>
<span class="gi">+    &#39;burlywood&#39;: (222, 184, 135),</span>
<span class="gi">+    &#39;cadetblue&#39;: (95, 158, 160),</span>
<span class="gi">+    &#39;chartreuse&#39;: (127, 255, 0),</span>
<span class="gi">+    &#39;chocolate&#39;: (210, 105, 30),</span>
<span class="gi">+    &#39;coral&#39;: (255, 127, 80),</span>
<span class="gi">+    &#39;cornflowerblue&#39;: (100, 149, 237),</span>
<span class="gi">+    &#39;cornsilk&#39;: (255, 248, 220),</span>
<span class="gi">+    &#39;crimson&#39;: (220, 20, 60),</span>
<span class="gi">+    &#39;cyan&#39;: (0, 255, 255),</span>
<span class="gi">+    &#39;darkblue&#39;: (0, 0, 139),</span>
<span class="gi">+    &#39;darkcyan&#39;: (0, 139, 139),</span>
<span class="gi">+    &#39;darkgoldenrod&#39;: (184, 134, 11),</span>
<span class="gi">+    &#39;darkgray&#39;: (169, 169, 169),</span>
<span class="gi">+    &#39;darkgreen&#39;: (0, 100, 0),</span>
<span class="gi">+    &#39;darkgrey&#39;: (169, 169, 169),</span>
<span class="gi">+    &#39;darkkhaki&#39;: (189, 183, 107),</span>
<span class="gi">+    &#39;darkmagenta&#39;: (139, 0, 139),</span>
<span class="gi">+    &#39;darkolivegreen&#39;: (85, 107, 47),</span>
<span class="gi">+    &#39;darkorange&#39;: (255, 140, 0),</span>
<span class="gi">+    &#39;darkorchid&#39;: (153, 50, 204),</span>
<span class="gi">+    &#39;darkred&#39;: (139, 0, 0),</span>
<span class="gi">+    &#39;darksalmon&#39;: (233, 150, 122),</span>
<span class="gi">+    &#39;darkseagreen&#39;: (143, 188, 143),</span>
<span class="gi">+    &#39;darkslateblue&#39;: (72, 61, 139),</span>
<span class="gi">+    &#39;darkslategray&#39;: (47, 79, 79),</span>
<span class="gi">+    &#39;darkslategrey&#39;: (47, 79, 79),</span>
<span class="gi">+    &#39;darkturquoise&#39;: (0, 206, 209),</span>
<span class="gi">+    &#39;darkviolet&#39;: (148, 0, 211),</span>
<span class="gi">+    &#39;deeppink&#39;: (255, 20, 147),</span>
<span class="gi">+    &#39;deepskyblue&#39;: (0, 191, 255),</span>
<span class="gi">+    &#39;dimgray&#39;: (105, 105, 105),</span>
<span class="gi">+    &#39;dimgrey&#39;: (105, 105, 105),</span>
<span class="gi">+    &#39;dodgerblue&#39;: (30, 144, 255),</span>
<span class="gi">+    &#39;firebrick&#39;: (178, 34, 34),</span>
<span class="gi">+    &#39;floralwhite&#39;: (255, 250, 240),</span>
<span class="gi">+    &#39;forestgreen&#39;: (34, 139, 34),</span>
<span class="gi">+    &#39;fuchsia&#39;: (255, 0, 255),</span>
<span class="gi">+    &#39;gainsboro&#39;: (220, 220, 220),</span>
<span class="gi">+    &#39;ghostwhite&#39;: (248, 248, 255),</span>
<span class="gi">+    &#39;gold&#39;: (255, 215, 0),</span>
<span class="gi">+    &#39;goldenrod&#39;: (218, 165, 32),</span>
<span class="gi">+    &#39;gray&#39;: (128, 128, 128),</span>
<span class="gi">+    &#39;green&#39;: (0, 128, 0),</span>
<span class="gi">+    &#39;greenyellow&#39;: (173, 255, 47),</span>
<span class="gi">+    &#39;grey&#39;: (128, 128, 128),</span>
<span class="gi">+    &#39;honeydew&#39;: (240, 255, 240),</span>
<span class="gi">+    &#39;hotpink&#39;: (255, 105, 180),</span>
<span class="gi">+    &#39;indianred&#39;: (205, 92, 92),</span>
<span class="gi">+    &#39;indigo&#39;: (75, 0, 130),</span>
<span class="gi">+    &#39;ivory&#39;: (255, 255, 240),</span>
<span class="gi">+    &#39;khaki&#39;: (240, 230, 140),</span>
<span class="gi">+    &#39;lavender&#39;: (230, 230, 250),</span>
<span class="gi">+    &#39;lavenderblush&#39;: (255, 240, 245),</span>
<span class="gi">+    &#39;lawngreen&#39;: (124, 252, 0),</span>
<span class="gi">+    &#39;lemonchiffon&#39;: (255, 250, 205),</span>
<span class="gi">+    &#39;lightblue&#39;: (173, 216, 230),</span>
<span class="gi">+    &#39;lightcoral&#39;: (240, 128, 128),</span>
<span class="gi">+    &#39;lightcyan&#39;: (224, 255, 255),</span>
<span class="gi">+    &#39;lightgoldenrodyellow&#39;: (250, 250, 210),</span>
<span class="gi">+    &#39;lightgray&#39;: (211, 211, 211),</span>
<span class="gi">+    &#39;lightgreen&#39;: (144, 238, 144),</span>
<span class="gi">+    &#39;lightgrey&#39;: (211, 211, 211),</span>
<span class="gi">+    &#39;lightpink&#39;: (255, 182, 193),</span>
<span class="gi">+    &#39;lightsalmon&#39;: (255, 160, 122),</span>
<span class="gi">+    &#39;lightseagreen&#39;: (32, 178, 170),</span>
<span class="gi">+    &#39;lightskyblue&#39;: (135, 206, 250),</span>
<span class="gi">+    &#39;lightslategray&#39;: (119, 136, 153),</span>
<span class="gi">+    &#39;lightslategrey&#39;: (119, 136, 153),</span>
<span class="gi">+    &#39;lightsteelblue&#39;: (176, 196, 222),</span>
<span class="gi">+    &#39;lightyellow&#39;: (255, 255, 224),</span>
<span class="gi">+    &#39;lime&#39;: (0, 255, 0),</span>
<span class="gi">+    &#39;limegreen&#39;: (50, 205, 50),</span>
<span class="gi">+    &#39;linen&#39;: (250, 240, 230),</span>
<span class="gi">+    &#39;magenta&#39;: (255, 0, 255),</span>
<span class="gi">+    &#39;maroon&#39;: (128, 0, 0),</span>
<span class="gi">+    &#39;mediumaquamarine&#39;: (102, 205, 170),</span>
<span class="gi">+    &#39;mediumblue&#39;: (0, 0, 205),</span>
<span class="gi">+    &#39;mediumorchid&#39;: (186, 85, 211),</span>
<span class="gi">+    &#39;mediumpurple&#39;: (147, 112, 219),</span>
<span class="gi">+    &#39;mediumseagreen&#39;: (60, 179, 113),</span>
<span class="gi">+    &#39;mediumslateblue&#39;: (123, 104, 238),</span>
<span class="gi">+    &#39;mediumspringgreen&#39;: (0, 250, 154),</span>
<span class="gi">+    &#39;mediumturquoise&#39;: (72, 209, 204),</span>
<span class="gi">+    &#39;mediumvioletred&#39;: (199, 21, 133),</span>
<span class="gi">+    &#39;midnightblue&#39;: (25, 25, 112),</span>
<span class="gi">+    &#39;mintcream&#39;: (245, 255, 250),</span>
<span class="gi">+    &#39;mistyrose&#39;: (255, 228, 225),</span>
<span class="gi">+    &#39;moccasin&#39;: (255, 228, 181),</span>
<span class="gi">+    &#39;navajowhite&#39;: (255, 222, 173),</span>
<span class="gi">+    &#39;navy&#39;: (0, 0, 128),</span>
<span class="gi">+    &#39;oldlace&#39;: (253, 245, 230),</span>
<span class="gi">+    &#39;olive&#39;: (128, 128, 0),</span>
<span class="gi">+    &#39;olivedrab&#39;: (107, 142, 35),</span>
<span class="gi">+    &#39;orange&#39;: (255, 165, 0),</span>
<span class="gi">+    &#39;orangered&#39;: (255, 69, 0),</span>
<span class="gi">+    &#39;orchid&#39;: (218, 112, 214),</span>
<span class="gi">+    &#39;palegoldenrod&#39;: (238, 232, 170),</span>
<span class="gi">+    &#39;palegreen&#39;: (152, 251, 152),</span>
<span class="gi">+    &#39;paleturquoise&#39;: (175, 238, 238),</span>
<span class="gi">+    &#39;palevioletred&#39;: (219, 112, 147),</span>
<span class="gi">+    &#39;papayawhip&#39;: (255, 239, 213),</span>
<span class="gi">+    &#39;peachpuff&#39;: (255, 218, 185),</span>
<span class="gi">+    &#39;peru&#39;: (205, 133, 63),</span>
<span class="gi">+    &#39;pink&#39;: (255, 192, 203),</span>
<span class="gi">+    &#39;plum&#39;: (221, 160, 221),</span>
<span class="gi">+    &#39;powderblue&#39;: (176, 224, 230),</span>
<span class="gi">+    &#39;purple&#39;: (128, 0, 128),</span>
<span class="gi">+    &#39;red&#39;: (255, 0, 0),</span>
<span class="gi">+    &#39;rosybrown&#39;: (188, 143, 143),</span>
<span class="gi">+    &#39;royalblue&#39;: (65, 105, 225),</span>
<span class="gi">+    &#39;saddlebrown&#39;: (139, 69, 19),</span>
<span class="gi">+    &#39;salmon&#39;: (250, 128, 114),</span>
<span class="gi">+    &#39;sandybrown&#39;: (244, 164, 96),</span>
<span class="gi">+    &#39;seagreen&#39;: (46, 139, 87),</span>
<span class="gi">+    &#39;seashell&#39;: (255, 245, 238),</span>
<span class="gi">+    &#39;sienna&#39;: (160, 82, 45),</span>
<span class="gi">+    &#39;silver&#39;: (192, 192, 192),</span>
<span class="gi">+    &#39;skyblue&#39;: (135, 206, 235),</span>
<span class="gi">+    &#39;slateblue&#39;: (106, 90, 205),</span>
<span class="gi">+    &#39;slategray&#39;: (112, 128, 144),</span>
<span class="gi">+    &#39;slategrey&#39;: (112, 128, 144),</span>
<span class="gi">+    &#39;snow&#39;: (255, 250, 250),</span>
<span class="gi">+    &#39;springgreen&#39;: (0, 255, 127),</span>
<span class="gi">+    &#39;steelblue&#39;: (70, 130, 180),</span>
<span class="gi">+    &#39;tan&#39;: (210, 180, 140),</span>
<span class="gi">+    &#39;teal&#39;: (0, 128, 128),</span>
<span class="gi">+    &#39;thistle&#39;: (216, 191, 216),</span>
<span class="gi">+    &#39;tomato&#39;: (255, 99, 71),</span>
<span class="gi">+    &#39;turquoise&#39;: (64, 224, 208),</span>
<span class="gi">+    &#39;violet&#39;: (238, 130, 238),</span>
<span class="gi">+    &#39;wheat&#39;: (245, 222, 179),</span>
<span class="gi">+    &#39;white&#39;: (255, 255, 255),</span>
<span class="gi">+    &#39;whitesmoke&#39;: (245, 245, 245),</span>
<span class="gi">+    &#39;yellow&#39;: (255, 255, 0),</span>
<span class="gi">+    &#39;yellowgreen&#39;: (154, 205, 50),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>COLORS_BY_VALUE = {v: k for k, v in COLORS_BY_NAME.items()}
<span class="gh">diff --git a/pydantic/v1/config.py b/pydantic/v1/config.py</span>
<span class="gh">index 5c249595b..18f7c999b 100644</span>
<span class="gd">--- a/pydantic/v1/config.py</span>
<span class="gi">+++ b/pydantic/v1/config.py</span>
<span class="gu">@@ -1,31 +1,34 @@</span>
<span class="w"> </span>import json
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Dict, ForwardRef, Optional, Tuple, Type, Union
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Literal, Protocol
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.typing import AnyArgTCallable, AnyCallable
<span class="w"> </span>from pydantic.v1.utils import GetterDict
<span class="w"> </span>from pydantic.v1.version import compiled
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import overload
<span class="gi">+</span>
<span class="w"> </span>    from pydantic.v1.fields import ModelField
<span class="w"> </span>    from pydantic.v1.main import BaseModel
<span class="gd">-    ConfigType = Type[&#39;BaseConfig&#39;]</span>

<span class="gi">+    ConfigType = Type[&#39;BaseConfig&#39;]</span>

<span class="w"> </span>    class SchemaExtraCallable(Protocol):
<span class="gd">-</span>
<span class="w"> </span>        @overload
<span class="gd">-        def __call__(self, schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+        def __call__(self, schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>            pass

<span class="w"> </span>        @overload
<span class="gd">-        def __call__(self, schema: Dict[str, Any], model_class: Type[BaseModel]</span>
<span class="gd">-            ) -&gt;None:</span>
<span class="gi">+        def __call__(self, schema: Dict[str, Any], model_class: Type[BaseModel]) -&gt; None:</span>
<span class="w"> </span>            pass
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    SchemaExtraCallable = Callable[..., None]
<span class="gd">-__all__ = (&#39;BaseConfig&#39;, &#39;ConfigDict&#39;, &#39;get_config&#39;, &#39;Extra&#39;,</span>
<span class="gd">-    &#39;inherit_config&#39;, &#39;prepare_config&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = &#39;BaseConfig&#39;, &#39;ConfigDict&#39;, &#39;get_config&#39;, &#39;Extra&#39;, &#39;inherit_config&#39;, &#39;prepare_config&#39;</span>


<span class="w"> </span>class Extra(str, Enum):
<span class="gu">@@ -34,11 +37,13 @@ class Extra(str, Enum):</span>
<span class="w"> </span>    forbid = &#39;forbid&#39;


<span class="gi">+# https://github.com/cython/cython/issues/4003</span>
<span class="gi">+# Fixed in Cython 3 and Pydantic v1 won&#39;t support Cython 3.</span>
<span class="gi">+# Pydantic v2 doesn&#39;t depend on Cython at all.</span>
<span class="w"> </span>if not compiled:
<span class="w"> </span>    from typing_extensions import TypedDict

<span class="gd">-</span>
<span class="gd">-    class ConfigDict(TypedDict, total=(False)):</span>
<span class="gi">+    class ConfigDict(TypedDict, total=False):</span>
<span class="w"> </span>        title: Optional[str]
<span class="w"> </span>        anystr_lower: bool
<span class="w"> </span>        anystr_strip_whitespace: bool
<span class="gu">@@ -65,9 +70,11 @@ if not compiled:</span>
<span class="w"> </span>        underscore_attrs_are_private: bool
<span class="w"> </span>        allow_inf_nan: bool
<span class="w"> </span>        copy_on_model_validation: Literal[&#39;none&#39;, &#39;deep&#39;, &#39;shallow&#39;]
<span class="gi">+        # whether dataclass `__post_init__` should be run after validation</span>
<span class="w"> </span>        post_init_call: Literal[&#39;before_validation&#39;, &#39;after_validation&#39;]
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gd">-    ConfigDict = dict</span>
<span class="gi">+    ConfigDict = dict  # type: ignore</span>


<span class="w"> </span>class BaseConfig:
<span class="gu">@@ -97,21 +104,88 @@ class BaseConfig:</span>
<span class="w"> </span>    json_encoders: Dict[Union[Type[Any], str, ForwardRef], AnyCallable] = {}
<span class="w"> </span>    underscore_attrs_are_private: bool = False
<span class="w"> </span>    allow_inf_nan: bool = True
<span class="gi">+</span>
<span class="gi">+    # whether inherited models as fields should be reconstructed as base model,</span>
<span class="gi">+    # and whether such a copy should be shallow or deep</span>
<span class="w"> </span>    copy_on_model_validation: Literal[&#39;none&#39;, &#39;deep&#39;, &#39;shallow&#39;] = &#39;shallow&#39;
<span class="gi">+</span>
<span class="gi">+    # whether `Union` should check all allowed types before even trying to coerce</span>
<span class="w"> </span>    smart_union: bool = False
<span class="gd">-    post_init_call: Literal[&#39;before_validation&#39;, &#39;after_validation&#39;</span>
<span class="gd">-        ] = &#39;before_validation&#39;</span>
<span class="gi">+    # whether dataclass `__post_init__` should be run before or after validation</span>
<span class="gi">+    post_init_call: Literal[&#39;before_validation&#39;, &#39;after_validation&#39;] = &#39;before_validation&#39;</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def get_field_info(cls, name: str) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def get_field_info(cls, name: str) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get properties of FieldInfo from the `fields` property of the config class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        fields_value = cls.fields.get(name)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(fields_value, str):</span>
<span class="gi">+            field_info: Dict[str, Any] = {&#39;alias&#39;: fields_value}</span>
<span class="gi">+        elif isinstance(fields_value, dict):</span>
<span class="gi">+            field_info = fields_value</span>
<span class="gi">+        else:</span>
<span class="gi">+            field_info = {}</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;alias&#39; in field_info:</span>
<span class="gi">+            field_info.setdefault(&#39;alias_priority&#39;, 2)</span>
<span class="gi">+</span>
<span class="gi">+        if field_info.get(&#39;alias_priority&#39;, 0) &lt;= 1 and cls.alias_generator:</span>
<span class="gi">+            alias = cls.alias_generator(name)</span>
<span class="gi">+            if not isinstance(alias, str):</span>
<span class="gi">+                raise TypeError(f&#39;Config.alias_generator must return str, not {alias.__class__}&#39;)</span>
<span class="gi">+            field_info.update(alias=alias, alias_priority=1)</span>
<span class="gi">+        return field_info</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def prepare_field(cls, field: &#39;ModelField&#39;) -&gt;None:</span>
<span class="gi">+    def prepare_field(cls, field: &#39;ModelField&#39;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Optional hook to check or modify fields during model creation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_config(config: Union[ConfigDict, Type[object], None]) -&gt; Type[BaseConfig]:</span>
<span class="gi">+    if config is None:</span>
<span class="gi">+        return BaseConfig</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        config_dict = (</span>
<span class="gi">+            config</span>
<span class="gi">+            if isinstance(config, dict)</span>
<span class="gi">+            else {k: getattr(config, k) for k in dir(config) if not k.startswith(&#39;__&#39;)}</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        class Config(BaseConfig):</span>
<span class="gi">+            ...</span>
<span class="gi">+</span>
<span class="gi">+        for k, v in config_dict.items():</span>
<span class="gi">+            setattr(Config, k, v)</span>
<span class="gi">+        return Config</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inherit_config(self_config: &#39;ConfigType&#39;, parent_config: &#39;ConfigType&#39;, **namespace: Any) -&gt; &#39;ConfigType&#39;:</span>
<span class="gi">+    if not self_config:</span>
<span class="gi">+        base_classes: Tuple[&#39;ConfigType&#39;, ...] = (parent_config,)</span>
<span class="gi">+    elif self_config == parent_config:</span>
<span class="gi">+        base_classes = (self_config,)</span>
<span class="gi">+    else:</span>
<span class="gi">+        base_classes = self_config, parent_config</span>
<span class="gi">+</span>
<span class="gi">+    namespace[&#39;json_encoders&#39;] = {</span>
<span class="gi">+        **getattr(parent_config, &#39;json_encoders&#39;, {}),</span>
<span class="gi">+        **getattr(self_config, &#39;json_encoders&#39;, {}),</span>
<span class="gi">+        **namespace.get(&#39;json_encoders&#39;, {}),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    return type(&#39;Config&#39;, base_classes, namespace)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def prepare_config(config: Type[BaseConfig], cls_name: str) -&gt; None:</span>
<span class="gi">+    if not isinstance(config.extra, Extra):</span>
<span class="gi">+        try:</span>
<span class="gi">+            config.extra = Extra(config.extra)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise ValueError(f&#39;&quot;{cls_name}&quot;: {config.extra} is not a valid value for &quot;extra&quot;&#39;)</span>
<span class="gh">diff --git a/pydantic/v1/dataclasses.py b/pydantic/v1/dataclasses.py</span>
<span class="gh">index 91caa9b02..bd1670291 100644</span>
<span class="gd">--- a/pydantic/v1/dataclasses.py</span>
<span class="gi">+++ b/pydantic/v1/dataclasses.py</span>
<span class="gu">@@ -36,12 +36,17 @@ import dataclasses</span>
<span class="w"> </span>import sys
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from functools import wraps
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from functools import cached_property
<span class="w"> </span>except ImportError:
<span class="gi">+    # cached_property available only for python3.8+</span>
<span class="w"> </span>    pass
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, ClassVar, Dict, Generator, Optional, Type, TypeVar, Union, overload
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import dataclass_transform
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.class_validators import gather_all_validators
<span class="w"> </span>from pydantic.v1.config import BaseConfig, ConfigDict, Extra, get_config
<span class="w"> </span>from pydantic.v1.error_wrappers import ValidationError
<span class="gu">@@ -49,97 +54,415 @@ from pydantic.v1.errors import DataclassTypeError</span>
<span class="w"> </span>from pydantic.v1.fields import Field, FieldInfo, Required, Undefined
<span class="w"> </span>from pydantic.v1.main import create_model, validate_model
<span class="w"> </span>from pydantic.v1.utils import ClassAttribute
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.main import BaseModel
<span class="w"> </span>    from pydantic.v1.typing import CallableGenerator, NoArgAnyCallable
<span class="gi">+</span>
<span class="w"> </span>    DataclassT = TypeVar(&#39;DataclassT&#39;, bound=&#39;Dataclass&#39;)
<span class="gd">-    DataclassClassOrWrapper = Union[Type[&#39;Dataclass&#39;], &#39;DataclassProxy&#39;]</span>

<span class="gi">+    DataclassClassOrWrapper = Union[Type[&#39;Dataclass&#39;], &#39;DataclassProxy&#39;]</span>

<span class="w"> </span>    class Dataclass:
<span class="gi">+        # stdlib attributes</span>
<span class="w"> </span>        __dataclass_fields__: ClassVar[Dict[str, Any]]
<span class="gd">-        __dataclass_params__: ClassVar[Any]</span>
<span class="gi">+        __dataclass_params__: ClassVar[Any]  # in reality `dataclasses._DataclassParams`</span>
<span class="w"> </span>        __post_init__: ClassVar[Callable[..., None]]
<span class="gi">+</span>
<span class="gi">+        # Added by pydantic</span>
<span class="w"> </span>        __pydantic_run_validation__: ClassVar[bool]
<span class="w"> </span>        __post_init_post_parse__: ClassVar[Callable[..., None]]
<span class="w"> </span>        __pydantic_initialised__: ClassVar[bool]
<span class="w"> </span>        __pydantic_model__: ClassVar[Type[BaseModel]]
<span class="w"> </span>        __pydantic_validate_values__: ClassVar[Callable[[&#39;Dataclass&#39;], None]]
<span class="gd">-        __pydantic_has_field_info_default__: ClassVar[bool]</span>
<span class="gi">+        __pydantic_has_field_info_default__: ClassVar[bool]  # whether a `pydantic.Field` is used as default value</span>

<span class="gd">-        def __init__(self, *args: object, **kwargs: object) -&gt;None:</span>
<span class="gi">+        def __init__(self, *args: object, **kwargs: object) -&gt; None:</span>
<span class="w"> </span>            pass

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_validators__(cls: Type[&#39;Dataclass&#39;]) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+        def __get_validators__(cls: Type[&#39;Dataclass&#39;]) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>            pass

<span class="w"> </span>        @classmethod
<span class="gd">-        def __validate__(cls: Type[&#39;DataclassT&#39;], v: Any) -&gt;&#39;DataclassT&#39;:</span>
<span class="gi">+        def __validate__(cls: Type[&#39;DataclassT&#39;], v: Any) -&gt; &#39;DataclassT&#39;:</span>
<span class="w"> </span>            pass
<span class="gd">-__all__ = [&#39;dataclass&#39;, &#39;set_validation&#39;,</span>
<span class="gd">-    &#39;create_pydantic_model_from_dataclass&#39;, &#39;is_builtin_dataclass&#39;,</span>
<span class="gd">-    &#39;make_dataclass_validator&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &#39;dataclass&#39;,</span>
<span class="gi">+    &#39;set_validation&#39;,</span>
<span class="gi">+    &#39;create_pydantic_model_from_dataclass&#39;,</span>
<span class="gi">+    &#39;is_builtin_dataclass&#39;,</span>
<span class="gi">+    &#39;make_dataclass_validator&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>_T = TypeVar(&#39;_T&#39;)
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):

<span class="gi">+    @dataclass_transform(field_specifiers=(dataclasses.field, Field))</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def dataclass(</span>
<span class="gi">+        *,</span>
<span class="gi">+        init: bool = True,</span>
<span class="gi">+        repr: bool = True,</span>
<span class="gi">+        eq: bool = True,</span>
<span class="gi">+        order: bool = False,</span>
<span class="gi">+        unsafe_hash: bool = False,</span>
<span class="gi">+        frozen: bool = False,</span>
<span class="gi">+        config: Union[ConfigDict, Type[object], None] = None,</span>
<span class="gi">+        validate_on_init: Optional[bool] = None,</span>
<span class="gi">+        use_proxy: Optional[bool] = None,</span>
<span class="gi">+        kw_only: bool = ...,</span>
<span class="gi">+    ) -&gt; Callable[[Type[_T]], &#39;DataclassClassOrWrapper&#39;]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @dataclass_transform(field_specifiers=(dataclasses.field, Field))</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def dataclass(</span>
<span class="gi">+        _cls: Type[_T],</span>
<span class="gi">+        *,</span>
<span class="gi">+        init: bool = True,</span>
<span class="gi">+        repr: bool = True,</span>
<span class="gi">+        eq: bool = True,</span>
<span class="gi">+        order: bool = False,</span>
<span class="gi">+        unsafe_hash: bool = False,</span>
<span class="gi">+        frozen: bool = False,</span>
<span class="gi">+        config: Union[ConfigDict, Type[object], None] = None,</span>
<span class="gi">+        validate_on_init: Optional[bool] = None,</span>
<span class="gi">+        use_proxy: Optional[bool] = None,</span>
<span class="gi">+        kw_only: bool = ...,</span>
<span class="gi">+    ) -&gt; &#39;DataclassClassOrWrapper&#39;:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    @dataclass_transform(field_specifiers=(dataclasses.field, Field))</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def dataclass(</span>
<span class="gi">+        *,</span>
<span class="gi">+        init: bool = True,</span>
<span class="gi">+        repr: bool = True,</span>
<span class="gi">+        eq: bool = True,</span>
<span class="gi">+        order: bool = False,</span>
<span class="gi">+        unsafe_hash: bool = False,</span>
<span class="gi">+        frozen: bool = False,</span>
<span class="gi">+        config: Union[ConfigDict, Type[object], None] = None,</span>
<span class="gi">+        validate_on_init: Optional[bool] = None,</span>
<span class="gi">+        use_proxy: Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; Callable[[Type[_T]], &#39;DataclassClassOrWrapper&#39;]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @dataclass_transform(field_specifiers=(dataclasses.field, Field))</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def dataclass(</span>
<span class="gi">+        _cls: Type[_T],</span>
<span class="gi">+        *,</span>
<span class="gi">+        init: bool = True,</span>
<span class="gi">+        repr: bool = True,</span>
<span class="gi">+        eq: bool = True,</span>
<span class="gi">+        order: bool = False,</span>
<span class="gi">+        unsafe_hash: bool = False,</span>
<span class="gi">+        frozen: bool = False,</span>
<span class="gi">+        config: Union[ConfigDict, Type[object], None] = None,</span>
<span class="gi">+        validate_on_init: Optional[bool] = None,</span>
<span class="gi">+        use_proxy: Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; &#39;DataclassClassOrWrapper&#39;:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>

<span class="w"> </span>@dataclass_transform(field_specifiers=(dataclasses.field, Field))
<span class="gd">-def dataclass(_cls: Optional[Type[_T]]=None, *, init: bool=True, repr: bool</span>
<span class="gd">-    =True, eq: bool=True, order: bool=False, unsafe_hash: bool=False,</span>
<span class="gd">-    frozen: bool=False, config: Union[ConfigDict, Type[object], None]=None,</span>
<span class="gd">-    validate_on_init: Optional[bool]=None, use_proxy: Optional[bool]=None,</span>
<span class="gd">-    kw_only: bool=False) -&gt;Union[Callable[[Type[_T]],</span>
<span class="gd">-    &#39;DataclassClassOrWrapper&#39;], &#39;DataclassClassOrWrapper&#39;]:</span>
<span class="gi">+def dataclass(</span>
<span class="gi">+    _cls: Optional[Type[_T]] = None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    init: bool = True,</span>
<span class="gi">+    repr: bool = True,</span>
<span class="gi">+    eq: bool = True,</span>
<span class="gi">+    order: bool = False,</span>
<span class="gi">+    unsafe_hash: bool = False,</span>
<span class="gi">+    frozen: bool = False,</span>
<span class="gi">+    config: Union[ConfigDict, Type[object], None] = None,</span>
<span class="gi">+    validate_on_init: Optional[bool] = None,</span>
<span class="gi">+    use_proxy: Optional[bool] = None,</span>
<span class="gi">+    kw_only: bool = False,</span>
<span class="gi">+) -&gt; Union[Callable[[Type[_T]], &#39;DataclassClassOrWrapper&#39;], &#39;DataclassClassOrWrapper&#39;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Like the python standard lib dataclasses but with type validation.
<span class="w"> </span>    The result is either a pydantic dataclass that will validate input data
<span class="w"> </span>    or a wrapper that will trigger validation around a stdlib dataclass
<span class="w"> </span>    to avoid modifying it directly
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    the_config = get_config(config)</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(cls: Type[Any]) -&gt; &#39;DataclassClassOrWrapper&#39;:</span>
<span class="gi">+        should_use_proxy = (</span>
<span class="gi">+            use_proxy</span>
<span class="gi">+            if use_proxy is not None</span>
<span class="gi">+            else (</span>
<span class="gi">+                is_builtin_dataclass(cls)</span>
<span class="gi">+                and (cls.__bases__[0] is object or set(dir(cls)) == set(dir(cls.__bases__[0])))</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        if should_use_proxy:</span>
<span class="gi">+            dc_cls_doc = &#39;&#39;</span>
<span class="gi">+            dc_cls = DataclassProxy(cls)</span>
<span class="gi">+            default_validate_on_init = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            dc_cls_doc = cls.__doc__ or &#39;&#39;  # needs to be done before generating dataclass</span>
<span class="gi">+            if sys.version_info &gt;= (3, 10):</span>
<span class="gi">+                dc_cls = dataclasses.dataclass(</span>
<span class="gi">+                    cls,</span>
<span class="gi">+                    init=init,</span>
<span class="gi">+                    repr=repr,</span>
<span class="gi">+                    eq=eq,</span>
<span class="gi">+                    order=order,</span>
<span class="gi">+                    unsafe_hash=unsafe_hash,</span>
<span class="gi">+                    frozen=frozen,</span>
<span class="gi">+                    kw_only=kw_only,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                dc_cls = dataclasses.dataclass(  # type: ignore</span>
<span class="gi">+                    cls, init=init, repr=repr, eq=eq, order=order, unsafe_hash=unsafe_hash, frozen=frozen</span>
<span class="gi">+                )</span>
<span class="gi">+            default_validate_on_init = True</span>
<span class="gi">+</span>
<span class="gi">+        should_validate_on_init = default_validate_on_init if validate_on_init is None else validate_on_init</span>
<span class="gi">+        _add_pydantic_validation_attributes(cls, the_config, should_validate_on_init, dc_cls_doc)</span>
<span class="gi">+        dc_cls.__pydantic_model__.__try_update_forward_refs__(**{cls.__name__: cls})</span>
<span class="gi">+        return dc_cls</span>
<span class="gi">+</span>
<span class="gi">+    if _cls is None:</span>
<span class="gi">+        return wrap</span>
<span class="gi">+</span>
<span class="gi">+    return wrap(_cls)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextmanager</span>
<span class="gi">+def set_validation(cls: Type[&#39;DataclassT&#39;], value: bool) -&gt; Generator[Type[&#39;DataclassT&#39;], None, None]:</span>
<span class="gi">+    original_run_validation = cls.__pydantic_run_validation__</span>
<span class="gi">+    try:</span>
<span class="gi">+        cls.__pydantic_run_validation__ = value</span>
<span class="gi">+        yield cls</span>
<span class="gi">+    finally:</span>
<span class="gi">+        cls.__pydantic_run_validation__ = original_run_validation</span>


<span class="w"> </span>class DataclassProxy:
<span class="w"> </span>    __slots__ = &#39;__dataclass__&#39;

<span class="gd">-    def __init__(self, dc_cls: Type[&#39;Dataclass&#39;]) -&gt;None:</span>
<span class="gi">+    def __init__(self, dc_cls: Type[&#39;Dataclass&#39;]) -&gt; None:</span>
<span class="w"> </span>        object.__setattr__(self, &#39;__dataclass__&#39;, dc_cls)

<span class="gd">-    def __call__(self, *args: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gi">+    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="w"> </span>        with set_validation(self.__dataclass__, True):
<span class="w"> </span>            return self.__dataclass__(*args, **kwargs)

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        return getattr(self.__dataclass__, name)

<span class="gd">-    def __setattr__(self, __name: str, __value: Any) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, __name: str, __value: Any) -&gt; None:</span>
<span class="w"> </span>        return setattr(self.__dataclass__, __name, __value)

<span class="gd">-    def __instancecheck__(self, instance: Any) -&gt;bool:</span>
<span class="gi">+    def __instancecheck__(self, instance: Any) -&gt; bool:</span>
<span class="w"> </span>        return isinstance(instance, self.__dataclass__)

<span class="gd">-    def __copy__(self) -&gt;&#39;DataclassProxy&#39;:</span>
<span class="gi">+    def __copy__(self) -&gt; &#39;DataclassProxy&#39;:</span>
<span class="w"> </span>        return DataclassProxy(copy.copy(self.__dataclass__))

<span class="gd">-    def __deepcopy__(self, memo: Any) -&gt;&#39;DataclassProxy&#39;:</span>
<span class="gi">+    def __deepcopy__(self, memo: Any) -&gt; &#39;DataclassProxy&#39;:</span>
<span class="w"> </span>        return DataclassProxy(copy.deepcopy(self.__dataclass__, memo))


<span class="gd">-def _add_pydantic_validation_attributes(dc_cls: Type[&#39;Dataclass&#39;], config:</span>
<span class="gd">-    Type[BaseConfig], validate_on_init: bool, dc_cls_doc: str) -&gt;None:</span>
<span class="gi">+def _add_pydantic_validation_attributes(  # noqa: C901 (ignore complexity)</span>
<span class="gi">+    dc_cls: Type[&#39;Dataclass&#39;],</span>
<span class="gi">+    config: Type[BaseConfig],</span>
<span class="gi">+    validate_on_init: bool,</span>
<span class="gi">+    dc_cls_doc: str,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    We need to replace the right method. If no `__post_init__` has been set in the stdlib dataclass
<span class="w"> </span>    it won&#39;t even exist (code is generated on the fly by `dataclasses`)
<span class="w"> </span>    By default, we run validation after `__init__` or `__post_init__` if defined
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    init = dc_cls.__init__</span>
<span class="gi">+</span>
<span class="gi">+    @wraps(init)</span>
<span class="gi">+    def handle_extra_init(self: &#39;Dataclass&#39;, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        if config.extra == Extra.ignore:</span>
<span class="gi">+            init(self, *args, **{k: v for k, v in kwargs.items() if k in self.__dataclass_fields__})</span>
<span class="gi">+</span>
<span class="gi">+        elif config.extra == Extra.allow:</span>
<span class="gi">+            for k, v in kwargs.items():</span>
<span class="gi">+                self.__dict__.setdefault(k, v)</span>
<span class="gi">+            init(self, *args, **{k: v for k, v in kwargs.items() if k in self.__dataclass_fields__})</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            init(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(dc_cls, &#39;__post_init__&#39;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            post_init = dc_cls.__post_init__.__wrapped__  # type: ignore[attr-defined]</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            post_init = dc_cls.__post_init__</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(post_init)</span>
<span class="gi">+        def new_post_init(self: &#39;Dataclass&#39;, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+            if config.post_init_call == &#39;before_validation&#39;:</span>
<span class="gi">+                post_init(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            if self.__class__.__pydantic_run_validation__:</span>
<span class="gi">+                self.__pydantic_validate_values__()</span>
<span class="gi">+                if hasattr(self, &#39;__post_init_post_parse__&#39;):</span>
<span class="gi">+                    self.__post_init_post_parse__(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            if config.post_init_call == &#39;after_validation&#39;:</span>
<span class="gi">+                post_init(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        setattr(dc_cls, &#39;__init__&#39;, handle_extra_init)</span>
<span class="gi">+        setattr(dc_cls, &#39;__post_init__&#39;, new_post_init)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(init)</span>
<span class="gi">+        def new_init(self: &#39;Dataclass&#39;, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+            handle_extra_init(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            if self.__class__.__pydantic_run_validation__:</span>
<span class="gi">+                self.__pydantic_validate_values__()</span>
<span class="gi">+</span>
<span class="gi">+            if hasattr(self, &#39;__post_init_post_parse__&#39;):</span>
<span class="gi">+                # We need to find again the initvars. To do that we use `__dataclass_fields__` instead of</span>
<span class="gi">+                # public method `dataclasses.fields`</span>
<span class="gi">+</span>
<span class="gi">+                # get all initvars and their default values</span>
<span class="gi">+                initvars_and_values: Dict[str, Any] = {}</span>
<span class="gi">+                for i, f in enumerate(self.__class__.__dataclass_fields__.values()):</span>
<span class="gi">+                    if f._field_type is dataclasses._FIELD_INITVAR:  # type: ignore[attr-defined]</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            # set arg value by default</span>
<span class="gi">+                            initvars_and_values[f.name] = args[i]</span>
<span class="gi">+                        except IndexError:</span>
<span class="gi">+                            initvars_and_values[f.name] = kwargs.get(f.name, f.default)</span>
<span class="gi">+</span>
<span class="gi">+                self.__post_init_post_parse__(**initvars_and_values)</span>
<span class="gi">+</span>
<span class="gi">+        setattr(dc_cls, &#39;__init__&#39;, new_init)</span>
<span class="gi">+</span>
<span class="gi">+    setattr(dc_cls, &#39;__pydantic_run_validation__&#39;, ClassAttribute(&#39;__pydantic_run_validation__&#39;, validate_on_init))</span>
<span class="gi">+    setattr(dc_cls, &#39;__pydantic_initialised__&#39;, False)</span>
<span class="gi">+    setattr(dc_cls, &#39;__pydantic_model__&#39;, create_pydantic_model_from_dataclass(dc_cls, config, dc_cls_doc))</span>
<span class="gi">+    setattr(dc_cls, &#39;__pydantic_validate_values__&#39;, _dataclass_validate_values)</span>
<span class="gi">+    setattr(dc_cls, &#39;__validate__&#39;, classmethod(_validate_dataclass))</span>
<span class="gi">+    setattr(dc_cls, &#39;__get_validators__&#39;, classmethod(_get_validators))</span>
<span class="gi">+</span>
<span class="gi">+    if dc_cls.__pydantic_model__.__config__.validate_assignment and not dc_cls.__dataclass_params__.frozen:</span>
<span class="gi">+        setattr(dc_cls, &#39;__setattr__&#39;, _dataclass_validate_assignment_setattr)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_validators(cls: &#39;DataclassClassOrWrapper&#39;) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="gi">+    yield cls.__validate__</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_dataclass(cls: Type[&#39;DataclassT&#39;], v: Any) -&gt; &#39;DataclassT&#39;:</span>
<span class="gi">+    with set_validation(cls, True):</span>
<span class="gi">+        if isinstance(v, cls):</span>
<span class="gi">+            v.__pydantic_validate_values__()</span>
<span class="gi">+            return v</span>
<span class="gi">+        elif isinstance(v, (list, tuple)):</span>
<span class="gi">+            return cls(*v)</span>
<span class="gi">+        elif isinstance(v, dict):</span>
<span class="gi">+            return cls(**v)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise DataclassTypeError(class_name=cls.__name__)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_pydantic_model_from_dataclass(</span>
<span class="gi">+    dc_cls: Type[&#39;Dataclass&#39;],</span>
<span class="gi">+    config: Type[Any] = BaseConfig,</span>
<span class="gi">+    dc_cls_doc: Optional[str] = None,</span>
<span class="gi">+) -&gt; Type[&#39;BaseModel&#39;]:</span>
<span class="gi">+    field_definitions: Dict[str, Any] = {}</span>
<span class="gi">+    for field in dataclasses.fields(dc_cls):</span>
<span class="gi">+        default: Any = Undefined</span>
<span class="gi">+        default_factory: Optional[&#39;NoArgAnyCallable&#39;] = None</span>
<span class="gi">+        field_info: FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+        if field.default is not dataclasses.MISSING:</span>
<span class="gi">+            default = field.default</span>
<span class="gi">+        elif field.default_factory is not dataclasses.MISSING:</span>
<span class="gi">+            default_factory = field.default_factory</span>
<span class="gi">+        else:</span>
<span class="gi">+            default = Required</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(default, FieldInfo):</span>
<span class="gi">+            field_info = default</span>
<span class="gi">+            dc_cls.__pydantic_has_field_info_default__ = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            field_info = Field(default=default, default_factory=default_factory, **field.metadata)</span>
<span class="gi">+</span>
<span class="gi">+        field_definitions[field.name] = (field.type, field_info)</span>
<span class="gi">+</span>
<span class="gi">+    validators = gather_all_validators(dc_cls)</span>
<span class="gi">+    model: Type[&#39;BaseModel&#39;] = create_model(</span>
<span class="gi">+        dc_cls.__name__,</span>
<span class="gi">+        __config__=config,</span>
<span class="gi">+        __module__=dc_cls.__module__,</span>
<span class="gi">+        __validators__=validators,</span>
<span class="gi">+        __cls_kwargs__={&#39;__resolve_forward_refs__&#39;: False},</span>
<span class="gi">+        **field_definitions,</span>
<span class="gi">+    )</span>
<span class="gi">+    model.__doc__ = dc_cls_doc if dc_cls_doc is not None else dc_cls.__doc__ or &#39;&#39;</span>
<span class="gi">+    return model</span>


<span class="w"> </span>if sys.version_info &gt;= (3, 8):

<span class="gd">-</span>
<span class="gd">-def is_builtin_dataclass(_cls: Type[Any]) -&gt;bool:</span>
<span class="gi">+    def _is_field_cached_property(obj: &#39;Dataclass&#39;, k: str) -&gt; bool:</span>
<span class="gi">+        return isinstance(getattr(type(obj), k, None), cached_property)</span>
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    def _is_field_cached_property(obj: &#39;Dataclass&#39;, k: str) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dataclass_validate_values(self: &#39;Dataclass&#39;) -&gt; None:</span>
<span class="gi">+    # validation errors can occur if this function is called twice on an already initialised dataclass.</span>
<span class="gi">+    # for example if Extra.forbid is enabled, it would consider __pydantic_initialised__ an invalid extra property</span>
<span class="gi">+    if getattr(self, &#39;__pydantic_initialised__&#39;):</span>
<span class="gi">+        return</span>
<span class="gi">+    if getattr(self, &#39;__pydantic_has_field_info_default__&#39;, False):</span>
<span class="gi">+        # We need to remove `FieldInfo` values since they are not valid as input</span>
<span class="gi">+        # It&#39;s ok to do that because they are obviously the default values!</span>
<span class="gi">+        input_data = {</span>
<span class="gi">+            k: v</span>
<span class="gi">+            for k, v in self.__dict__.items()</span>
<span class="gi">+            if not (isinstance(v, FieldInfo) or _is_field_cached_property(self, k))</span>
<span class="gi">+        }</span>
<span class="gi">+    else:</span>
<span class="gi">+        input_data = {k: v for k, v in self.__dict__.items() if not _is_field_cached_property(self, k)}</span>
<span class="gi">+    d, _, validation_error = validate_model(self.__pydantic_model__, input_data, cls=self.__class__)</span>
<span class="gi">+    if validation_error:</span>
<span class="gi">+        raise validation_error</span>
<span class="gi">+    self.__dict__.update(d)</span>
<span class="gi">+    object.__setattr__(self, &#39;__pydantic_initialised__&#39;, True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dataclass_validate_assignment_setattr(self: &#39;Dataclass&#39;, name: str, value: Any) -&gt; None:</span>
<span class="gi">+    if self.__pydantic_initialised__:</span>
<span class="gi">+        d = dict(self.__dict__)</span>
<span class="gi">+        d.pop(name, None)</span>
<span class="gi">+        known_field = self.__pydantic_model__.__fields__.get(name, None)</span>
<span class="gi">+        if known_field:</span>
<span class="gi">+            value, error_ = known_field.validate(value, d, loc=name, cls=self.__class__)</span>
<span class="gi">+            if error_:</span>
<span class="gi">+                raise ValidationError([error_], self.__class__)</span>
<span class="gi">+</span>
<span class="gi">+    object.__setattr__(self, name, value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_builtin_dataclass(_cls: Type[Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Whether a class is a stdlib dataclass
<span class="w"> </span>    (useful to discriminated a pydantic dataclass that is actually a wrapper around a stdlib dataclass)
<span class="gu">@@ -161,14 +484,17 @@ def is_builtin_dataclass(_cls: Type[Any]) -&gt;bool:</span>
<span class="w"> </span>    In this case, when we first check `B`, we make an extra check and look at the annotations (&#39;y&#39;),
<span class="w"> </span>    which won&#39;t be a superset of all the dataclass fields (only the stdlib fields i.e. &#39;x&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        dataclasses.is_dataclass(_cls)</span>
<span class="gi">+        and not hasattr(_cls, &#39;__pydantic_model__&#39;)</span>
<span class="gi">+        and set(_cls.__dataclass_fields__).issuperset(set(getattr(_cls, &#39;__annotations__&#39;, {})))</span>
<span class="gi">+    )</span>


<span class="gd">-def make_dataclass_validator(dc_cls: Type[&#39;Dataclass&#39;], config: Type[</span>
<span class="gd">-    BaseConfig]) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+def make_dataclass_validator(dc_cls: Type[&#39;Dataclass&#39;], config: Type[BaseConfig]) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a pydantic.dataclass from a builtin dataclass to add type validation
<span class="w"> </span>    and yield the validators
<span class="w"> </span>    It retrieves the parameters of the dataclass and forwards them to the newly created dataclass
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield from _get_validators(dataclass(dc_cls, config=config, use_proxy=True))</span>
<span class="gh">diff --git a/pydantic/v1/datetime_parse.py b/pydantic/v1/datetime_parse.py</span>
<span class="gh">index 82d98b484..a7598fc6c 100644</span>
<span class="gd">--- a/pydantic/v1/datetime_parse.py</span>
<span class="gi">+++ b/pydantic/v1/datetime_parse.py</span>
<span class="gu">@@ -17,47 +17,162 @@ Changed to:</span>
<span class="w"> </span>import re
<span class="w"> </span>from datetime import date, datetime, time, timedelta, timezone
<span class="w"> </span>from typing import Dict, Optional, Type, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1 import errors
<span class="gd">-date_expr = &#39;(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{1,2})-(?P&lt;day&gt;\\d{1,2})&#39;</span>
<span class="gi">+</span>
<span class="gi">+date_expr = r&#39;(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{1,2})-(?P&lt;day&gt;\d{1,2})&#39;</span>
<span class="w"> </span>time_expr = (
<span class="gd">-    &#39;(?P&lt;hour&gt;\\d{1,2}):(?P&lt;minute&gt;\\d{1,2})(?::(?P&lt;second&gt;\\d{1,2})(?:\\.(?P&lt;microsecond&gt;\\d{1,6})\\d{0,6})?)?(?P&lt;tzinfo&gt;Z|[+-]\\d{2}(?::?\\d{2})?)?$&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    r&#39;(?P&lt;hour&gt;\d{1,2}):(?P&lt;minute&gt;\d{1,2})&#39;</span>
<span class="gi">+    r&#39;(?::(?P&lt;second&gt;\d{1,2})(?:\.(?P&lt;microsecond&gt;\d{1,6})\d{0,6})?)?&#39;</span>
<span class="gi">+    r&#39;(?P&lt;tzinfo&gt;Z|[+-]\d{2}(?::?\d{2})?)?$&#39;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>date_re = re.compile(f&#39;{date_expr}$&#39;)
<span class="w"> </span>time_re = re.compile(time_expr)
<span class="w"> </span>datetime_re = re.compile(f&#39;{date_expr}[T ]{time_expr}&#39;)
<span class="gi">+</span>
<span class="w"> </span>standard_duration_re = re.compile(
<span class="gd">-    &#39;^(?:(?P&lt;days&gt;-?\\d+) (days?, )?)?((?:(?P&lt;hours&gt;-?\\d+):)(?=\\d+:\\d+))?(?:(?P&lt;minutes&gt;-?\\d+):)?(?P&lt;seconds&gt;-?\\d+)(?:\\.(?P&lt;microseconds&gt;\\d{1,6})\\d{0,6})?$&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    r&#39;^&#39;</span>
<span class="gi">+    r&#39;(?:(?P&lt;days&gt;-?\d+) (days?, )?)?&#39;</span>
<span class="gi">+    r&#39;((?:(?P&lt;hours&gt;-?\d+):)(?=\d+:\d+))?&#39;</span>
<span class="gi">+    r&#39;(?:(?P&lt;minutes&gt;-?\d+):)?&#39;</span>
<span class="gi">+    r&#39;(?P&lt;seconds&gt;-?\d+)&#39;</span>
<span class="gi">+    r&#39;(?:\.(?P&lt;microseconds&gt;\d{1,6})\d{0,6})?&#39;</span>
<span class="gi">+    r&#39;$&#39;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# Support the sections of ISO 8601 date representation that are accepted by timedelta</span>
<span class="w"> </span>iso8601_duration_re = re.compile(
<span class="gd">-    &#39;^(?P&lt;sign&gt;[-+]?)P(?:(?P&lt;days&gt;\\d+(.\\d+)?)D)?(?:T(?:(?P&lt;hours&gt;\\d+(.\\d+)?)H)?(?:(?P&lt;minutes&gt;\\d+(.\\d+)?)M)?(?:(?P&lt;seconds&gt;\\d+(.\\d+)?)S)?)?$&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    r&#39;^(?P&lt;sign&gt;[-+]?)&#39;</span>
<span class="gi">+    r&#39;P&#39;</span>
<span class="gi">+    r&#39;(?:(?P&lt;days&gt;\d+(.\d+)?)D)?&#39;</span>
<span class="gi">+    r&#39;(?:T&#39;</span>
<span class="gi">+    r&#39;(?:(?P&lt;hours&gt;\d+(.\d+)?)H)?&#39;</span>
<span class="gi">+    r&#39;(?:(?P&lt;minutes&gt;\d+(.\d+)?)M)?&#39;</span>
<span class="gi">+    r&#39;(?:(?P&lt;seconds&gt;\d+(.\d+)?)S)?&#39;</span>
<span class="gi">+    r&#39;)?&#39;</span>
<span class="gi">+    r&#39;$&#39;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>EPOCH = datetime(1970, 1, 1)
<span class="gd">-MS_WATERSHED = int(20000000000.0)</span>
<span class="gd">-MAX_NUMBER = int(3e+20)</span>
<span class="gi">+# if greater than this, the number is in ms, if less than or equal it&#39;s in seconds</span>
<span class="gi">+# (in seconds this is 11th October 2603, in ms it&#39;s 20th August 1970)</span>
<span class="gi">+MS_WATERSHED = int(2e10)</span>
<span class="gi">+# slightly more than datetime.max in ns - (datetime.max - EPOCH).total_seconds() * 1e9</span>
<span class="gi">+MAX_NUMBER = int(3e20)</span>
<span class="w"> </span>StrBytesIntFloat = Union[str, bytes, int, float]


<span class="gd">-def parse_date(value: Union[date, StrBytesIntFloat]) -&gt;date:</span>
<span class="gi">+def get_numeric(value: StrBytesIntFloat, native_expected_type: str) -&gt; Union[None, int, float]:</span>
<span class="gi">+    if isinstance(value, (int, float)):</span>
<span class="gi">+        return value</span>
<span class="gi">+    try:</span>
<span class="gi">+        return float(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        raise TypeError(f&#39;invalid type; expected {native_expected_type}, string, bytes, int or float&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_unix_seconds(seconds: Union[int, float]) -&gt; datetime:</span>
<span class="gi">+    if seconds &gt; MAX_NUMBER:</span>
<span class="gi">+        return datetime.max</span>
<span class="gi">+    elif seconds &lt; -MAX_NUMBER:</span>
<span class="gi">+        return datetime.min</span>
<span class="gi">+</span>
<span class="gi">+    while abs(seconds) &gt; MS_WATERSHED:</span>
<span class="gi">+        seconds /= 1000</span>
<span class="gi">+    dt = EPOCH + timedelta(seconds=seconds)</span>
<span class="gi">+    return dt.replace(tzinfo=timezone.utc)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_timezone(value: Optional[str], error: Type[Exception]) -&gt; Union[None, int, timezone]:</span>
<span class="gi">+    if value == &#39;Z&#39;:</span>
<span class="gi">+        return timezone.utc</span>
<span class="gi">+    elif value is not None:</span>
<span class="gi">+        offset_mins = int(value[-2:]) if len(value) &gt; 3 else 0</span>
<span class="gi">+        offset = 60 * int(value[1:3]) + offset_mins</span>
<span class="gi">+        if value[0] == &#39;-&#39;:</span>
<span class="gi">+            offset = -offset</span>
<span class="gi">+        try:</span>
<span class="gi">+            return timezone(timedelta(minutes=offset))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise error()</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_date(value: Union[date, StrBytesIntFloat]) -&gt; date:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a date/int/float/string and return a datetime.date.

<span class="w"> </span>    Raise ValueError if the input is well formatted but not a valid date.
<span class="w"> </span>    Raise ValueError if the input isn&#39;t well formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, date):</span>
<span class="gi">+        if isinstance(value, datetime):</span>
<span class="gi">+            return value.date()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+    number = get_numeric(value, &#39;date&#39;)</span>
<span class="gi">+    if number is not None:</span>
<span class="gi">+        return from_unix_seconds(number).date()</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode()</span>
<span class="gi">+</span>
<span class="gi">+    match = date_re.match(value)  # type: ignore</span>
<span class="gi">+    if match is None:</span>
<span class="gi">+        raise errors.DateError()</span>

<span class="gi">+    kw = {k: int(v) for k, v in match.groupdict().items()}</span>

<span class="gd">-def parse_time(value: Union[time, StrBytesIntFloat]) -&gt;time:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return date(**kw)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.DateError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_time(value: Union[time, StrBytesIntFloat]) -&gt; time:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a time/string and return a datetime.time.

<span class="w"> </span>    Raise ValueError if the input is well formatted but not a valid time.
<span class="w"> </span>    Raise ValueError if the input isn&#39;t well formatted, in particular if it contains an offset.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, time):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    number = get_numeric(value, &#39;time&#39;)</span>
<span class="gi">+    if number is not None:</span>
<span class="gi">+        if number &gt;= 86400:</span>
<span class="gi">+            # doesn&#39;t make sense since the time time loop back around to 0</span>
<span class="gi">+            raise errors.TimeError()</span>
<span class="gi">+        return (datetime.min + timedelta(seconds=number)).time()</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode()</span>
<span class="gi">+</span>
<span class="gi">+    match = time_re.match(value)  # type: ignore</span>
<span class="gi">+    if match is None:</span>
<span class="gi">+        raise errors.TimeError()</span>
<span class="gi">+</span>
<span class="gi">+    kw = match.groupdict()</span>
<span class="gi">+    if kw[&#39;microsecond&#39;]:</span>
<span class="gi">+        kw[&#39;microsecond&#39;] = kw[&#39;microsecond&#39;].ljust(6, &#39;0&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    tzinfo = _parse_timezone(kw.pop(&#39;tzinfo&#39;), errors.TimeError)</span>
<span class="gi">+    kw_: Dict[str, Union[None, int, timezone]] = {k: int(v) for k, v in kw.items() if v is not None}</span>
<span class="gi">+    kw_[&#39;tzinfo&#39;] = tzinfo</span>

<span class="gi">+    try:</span>
<span class="gi">+        return time(**kw_)  # type: ignore</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.TimeError()</span>

<span class="gd">-def parse_datetime(value: Union[datetime, StrBytesIntFloat]) -&gt;datetime:</span>
<span class="gi">+</span>
<span class="gi">+def parse_datetime(value: Union[datetime, StrBytesIntFloat]) -&gt; datetime:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a datetime/int/float/string and return a datetime.datetime.

<span class="gu">@@ -67,10 +182,35 @@ def parse_datetime(value: Union[datetime, StrBytesIntFloat]) -&gt;datetime:</span>
<span class="w"> </span>    Raise ValueError if the input is well formatted but not a valid datetime.
<span class="w"> </span>    Raise ValueError if the input isn&#39;t well formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, datetime):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    number = get_numeric(value, &#39;datetime&#39;)</span>
<span class="gi">+    if number is not None:</span>
<span class="gi">+        return from_unix_seconds(number)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode()</span>
<span class="gi">+</span>
<span class="gi">+    match = datetime_re.match(value)  # type: ignore</span>
<span class="gi">+    if match is None:</span>
<span class="gi">+        raise errors.DateTimeError()</span>
<span class="gi">+</span>
<span class="gi">+    kw = match.groupdict()</span>
<span class="gi">+    if kw[&#39;microsecond&#39;]:</span>
<span class="gi">+        kw[&#39;microsecond&#39;] = kw[&#39;microsecond&#39;].ljust(6, &#39;0&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    tzinfo = _parse_timezone(kw.pop(&#39;tzinfo&#39;), errors.DateTimeError)</span>
<span class="gi">+    kw_: Dict[str, Union[None, int, timezone]] = {k: int(v) for k, v in kw.items() if v is not None}</span>
<span class="gi">+    kw_[&#39;tzinfo&#39;] = tzinfo</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return datetime(**kw_)  # type: ignore</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.DateTimeError()</span>


<span class="gd">-def parse_duration(value: StrBytesIntFloat) -&gt;timedelta:</span>
<span class="gi">+def parse_duration(value: StrBytesIntFloat) -&gt; timedelta:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a duration int/float/string and return a datetime.timedelta.

<span class="gu">@@ -78,4 +218,31 @@ def parse_duration(value: StrBytesIntFloat) -&gt;timedelta:</span>

<span class="w"> </span>    Also supports ISO 8601 representation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, timedelta):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, (int, float)):</span>
<span class="gi">+        # below code requires a string</span>
<span class="gi">+        value = f&#39;{value:f}&#39;</span>
<span class="gi">+    elif isinstance(value, bytes):</span>
<span class="gi">+        value = value.decode()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        match = standard_duration_re.match(value) or iso8601_duration_re.match(value)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        raise TypeError(&#39;invalid type; expected timedelta, string, bytes, int or float&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise errors.DurationError()</span>
<span class="gi">+</span>
<span class="gi">+    kw = match.groupdict()</span>
<span class="gi">+    sign = -1 if kw.pop(&#39;sign&#39;, &#39;+&#39;) == &#39;-&#39; else 1</span>
<span class="gi">+    if kw.get(&#39;microseconds&#39;):</span>
<span class="gi">+        kw[&#39;microseconds&#39;] = kw[&#39;microseconds&#39;].ljust(6, &#39;0&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if kw.get(&#39;seconds&#39;) and kw.get(&#39;microseconds&#39;) and kw[&#39;seconds&#39;].startswith(&#39;-&#39;):</span>
<span class="gi">+        kw[&#39;microseconds&#39;] = &#39;-&#39; + kw[&#39;microseconds&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    kw_ = {k: float(v) for k, v in kw.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+    return sign * timedelta(**kw_)</span>
<span class="gh">diff --git a/pydantic/v1/decorator.py b/pydantic/v1/decorator.py</span>
<span class="gh">index 55a4b3c36..2c7c2c2ff 100644</span>
<span class="gd">--- a/pydantic/v1/decorator.py</span>
<span class="gi">+++ b/pydantic/v1/decorator.py</span>
<span class="gu">@@ -1,24 +1,54 @@</span>
<span class="w"> </span>from functools import wraps
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, overload
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1 import validator
<span class="w"> </span>from pydantic.v1.config import Extra
<span class="w"> </span>from pydantic.v1.errors import ConfigError
<span class="w"> </span>from pydantic.v1.main import BaseModel, create_model
<span class="w"> </span>from pydantic.v1.typing import get_all_type_hints
<span class="w"> </span>from pydantic.v1.utils import to_camel
<span class="gd">-__all__ = &#39;validate_arguments&#39;,</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;validate_arguments&#39;,)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.typing import AnyCallable
<span class="gi">+</span>
<span class="w"> </span>    AnyCallableT = TypeVar(&#39;AnyCallableT&#39;, bound=AnyCallable)
<span class="w"> </span>    ConfigType = Union[None, Type[Any], Dict[str, Any]]


<span class="gd">-def validate_arguments(func: Optional[&#39;AnyCallableT&#39;]=None, *, config:</span>
<span class="gd">-    &#39;ConfigType&#39;=None) -&gt;Any:</span>
<span class="gi">+@overload</span>
<span class="gi">+def validate_arguments(func: None = None, *, config: &#39;ConfigType&#39; = None) -&gt; Callable[[&#39;AnyCallableT&#39;], &#39;AnyCallableT&#39;]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def validate_arguments(func: &#39;AnyCallableT&#39;) -&gt; &#39;AnyCallableT&#39;:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_arguments(func: Optional[&#39;AnyCallableT&#39;] = None, *, config: &#39;ConfigType&#39; = None) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Decorator to validate the arguments passed to a function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def validate(_func: &#39;AnyCallable&#39;) -&gt; &#39;AnyCallable&#39;:</span>
<span class="gi">+        vd = ValidatedFunction(_func, config)</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(_func)</span>
<span class="gi">+        def wrapper_function(*args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+            return vd.call(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        wrapper_function.vd = vd  # type: ignore</span>
<span class="gi">+        wrapper_function.validate = vd.init_model_instance  # type: ignore</span>
<span class="gi">+        wrapper_function.raw_function = vd.raw_function  # type: ignore</span>
<span class="gi">+        wrapper_function.model = vd.model  # type: ignore</span>
<span class="gi">+        return wrapper_function</span>
<span class="gi">+</span>
<span class="gi">+    if func:</span>
<span class="gi">+        return validate(func)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return validate</span>


<span class="w"> </span>ALT_V_ARGS = &#39;v__args&#39;
<span class="gu">@@ -28,20 +58,23 @@ V_DUPLICATE_KWARGS = &#39;v__duplicate_kwargs&#39;</span>


<span class="w"> </span>class ValidatedFunction:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, function: &#39;AnyCallableT&#39;, config: &#39;ConfigType&#39;):</span>
<span class="gi">+    def __init__(self, function: &#39;AnyCallableT&#39;, config: &#39;ConfigType&#39;):  # noqa C901</span>
<span class="w"> </span>        from inspect import Parameter, signature
<span class="gi">+</span>
<span class="w"> </span>        parameters: Mapping[str, Parameter] = signature(function).parameters
<span class="gd">-        if parameters.keys() &amp; {ALT_V_ARGS, ALT_V_KWARGS,</span>
<span class="gd">-            V_POSITIONAL_ONLY_NAME, V_DUPLICATE_KWARGS}:</span>
<span class="gi">+</span>
<span class="gi">+        if parameters.keys() &amp; {ALT_V_ARGS, ALT_V_KWARGS, V_POSITIONAL_ONLY_NAME, V_DUPLICATE_KWARGS}:</span>
<span class="w"> </span>            raise ConfigError(
<span class="gd">-                f&#39;&quot;{ALT_V_ARGS}&quot;, &quot;{ALT_V_KWARGS}&quot;, &quot;{V_POSITIONAL_ONLY_NAME}&quot; and &quot;{V_DUPLICATE_KWARGS}&quot; are not permitted as argument names when using the &quot;{validate_arguments.__name__}&quot; decorator&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&#39;&quot;{ALT_V_ARGS}&quot;, &quot;{ALT_V_KWARGS}&quot;, &quot;{V_POSITIONAL_ONLY_NAME}&quot; and &quot;{V_DUPLICATE_KWARGS}&quot; &#39;</span>
<span class="gi">+                f&#39;are not permitted as argument names when using the &quot;{validate_arguments.__name__}&quot; decorator&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.raw_function = function
<span class="w"> </span>        self.arg_mapping: Dict[int, str] = {}
<span class="w"> </span>        self.positional_only_args = set()
<span class="w"> </span>        self.v_args_name = &#39;args&#39;
<span class="w"> </span>        self.v_kwargs_name = &#39;kwargs&#39;
<span class="gi">+</span>
<span class="w"> </span>        type_hints = get_all_type_hints(function)
<span class="w"> </span>        takes_args = False
<span class="w"> </span>        takes_kwargs = False
<span class="gu">@@ -51,6 +84,7 @@ class ValidatedFunction:</span>
<span class="w"> </span>                annotation = Any
<span class="w"> </span>            else:
<span class="w"> </span>                annotation = type_hints[name]
<span class="gi">+</span>
<span class="w"> </span>            default = ... if p.default is p.empty else p.default
<span class="w"> </span>            if p.kind == Parameter.POSITIONAL_ONLY:
<span class="w"> </span>                self.arg_mapping[i] = name
<span class="gu">@@ -70,14 +104,161 @@ class ValidatedFunction:</span>
<span class="w"> </span>            else:
<span class="w"> </span>                assert p.kind == Parameter.VAR_KEYWORD, p.kind
<span class="w"> </span>                self.v_kwargs_name = name
<span class="gd">-                fields[name] = Dict[str, annotation], None</span>
<span class="gi">+                fields[name] = Dict[str, annotation], None  # type: ignore</span>
<span class="w"> </span>                takes_kwargs = True
<span class="gi">+</span>
<span class="gi">+        # these checks avoid a clash between &quot;args&quot; and a field with that name</span>
<span class="w"> </span>        if not takes_args and self.v_args_name in fields:
<span class="w"> </span>            self.v_args_name = ALT_V_ARGS
<span class="gi">+</span>
<span class="gi">+        # same with &quot;kwargs&quot;</span>
<span class="w"> </span>        if not takes_kwargs and self.v_kwargs_name in fields:
<span class="w"> </span>            self.v_kwargs_name = ALT_V_KWARGS
<span class="gi">+</span>
<span class="w"> </span>        if not takes_args:
<span class="gi">+            # we add the field so validation below can raise the correct exception</span>
<span class="w"> </span>            fields[self.v_args_name] = List[Any], None
<span class="gi">+</span>
<span class="w"> </span>        if not takes_kwargs:
<span class="gi">+            # same with kwargs</span>
<span class="w"> </span>            fields[self.v_kwargs_name] = Dict[Any, Any], None
<span class="gi">+</span>
<span class="w"> </span>        self.create_model(fields, takes_args, takes_kwargs, config)
<span class="gi">+</span>
<span class="gi">+    def init_model_instance(self, *args: Any, **kwargs: Any) -&gt; BaseModel:</span>
<span class="gi">+        values = self.build_values(args, kwargs)</span>
<span class="gi">+        return self.model(**values)</span>
<span class="gi">+</span>
<span class="gi">+    def call(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+        m = self.init_model_instance(*args, **kwargs)</span>
<span class="gi">+        return self.execute(m)</span>
<span class="gi">+</span>
<span class="gi">+    def build_values(self, args: Tuple[Any, ...], kwargs: Dict[str, Any]) -&gt; Dict[str, Any]:</span>
<span class="gi">+        values: Dict[str, Any] = {}</span>
<span class="gi">+        if args:</span>
<span class="gi">+            arg_iter = enumerate(args)</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    i, a = next(arg_iter)</span>
<span class="gi">+                except StopIteration:</span>
<span class="gi">+                    break</span>
<span class="gi">+                arg_name = self.arg_mapping.get(i)</span>
<span class="gi">+                if arg_name is not None:</span>
<span class="gi">+                    values[arg_name] = a</span>
<span class="gi">+                else:</span>
<span class="gi">+                    values[self.v_args_name] = [a] + [a for _, a in arg_iter]</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        var_kwargs: Dict[str, Any] = {}</span>
<span class="gi">+        wrong_positional_args = []</span>
<span class="gi">+        duplicate_kwargs = []</span>
<span class="gi">+        fields_alias = [</span>
<span class="gi">+            field.alias</span>
<span class="gi">+            for name, field in self.model.__fields__.items()</span>
<span class="gi">+            if name not in (self.v_args_name, self.v_kwargs_name)</span>
<span class="gi">+        ]</span>
<span class="gi">+        non_var_fields = set(self.model.__fields__) - {self.v_args_name, self.v_kwargs_name}</span>
<span class="gi">+        for k, v in kwargs.items():</span>
<span class="gi">+            if k in non_var_fields or k in fields_alias:</span>
<span class="gi">+                if k in self.positional_only_args:</span>
<span class="gi">+                    wrong_positional_args.append(k)</span>
<span class="gi">+                if k in values:</span>
<span class="gi">+                    duplicate_kwargs.append(k)</span>
<span class="gi">+                values[k] = v</span>
<span class="gi">+            else:</span>
<span class="gi">+                var_kwargs[k] = v</span>
<span class="gi">+</span>
<span class="gi">+        if var_kwargs:</span>
<span class="gi">+            values[self.v_kwargs_name] = var_kwargs</span>
<span class="gi">+        if wrong_positional_args:</span>
<span class="gi">+            values[V_POSITIONAL_ONLY_NAME] = wrong_positional_args</span>
<span class="gi">+        if duplicate_kwargs:</span>
<span class="gi">+            values[V_DUPLICATE_KWARGS] = duplicate_kwargs</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    def execute(self, m: BaseModel) -&gt; Any:</span>
<span class="gi">+        d = {k: v for k, v in m._iter() if k in m.__fields_set__ or m.__fields__[k].default_factory}</span>
<span class="gi">+        var_kwargs = d.pop(self.v_kwargs_name, {})</span>
<span class="gi">+</span>
<span class="gi">+        if self.v_args_name in d:</span>
<span class="gi">+            args_: List[Any] = []</span>
<span class="gi">+            in_kwargs = False</span>
<span class="gi">+            kwargs = {}</span>
<span class="gi">+            for name, value in d.items():</span>
<span class="gi">+                if in_kwargs:</span>
<span class="gi">+                    kwargs[name] = value</span>
<span class="gi">+                elif name == self.v_args_name:</span>
<span class="gi">+                    args_ += value</span>
<span class="gi">+                    in_kwargs = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    args_.append(value)</span>
<span class="gi">+            return self.raw_function(*args_, **kwargs, **var_kwargs)</span>
<span class="gi">+        elif self.positional_only_args:</span>
<span class="gi">+            args_ = []</span>
<span class="gi">+            kwargs = {}</span>
<span class="gi">+            for name, value in d.items():</span>
<span class="gi">+                if name in self.positional_only_args:</span>
<span class="gi">+                    args_.append(value)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    kwargs[name] = value</span>
<span class="gi">+            return self.raw_function(*args_, **kwargs, **var_kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.raw_function(**d, **var_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def create_model(self, fields: Dict[str, Any], takes_args: bool, takes_kwargs: bool, config: &#39;ConfigType&#39;) -&gt; None:</span>
<span class="gi">+        pos_args = len(self.arg_mapping)</span>
<span class="gi">+</span>
<span class="gi">+        class CustomConfig:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        if not TYPE_CHECKING:  # pragma: no branch</span>
<span class="gi">+            if isinstance(config, dict):</span>
<span class="gi">+                CustomConfig = type(&#39;Config&#39;, (), config)  # noqa: F811</span>
<span class="gi">+            elif config is not None:</span>
<span class="gi">+                CustomConfig = config  # noqa: F811</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(CustomConfig, &#39;fields&#39;) or hasattr(CustomConfig, &#39;alias_generator&#39;):</span>
<span class="gi">+            raise ConfigError(</span>
<span class="gi">+                &#39;Setting the &quot;fields&quot; and &quot;alias_generator&quot; property on custom Config for &#39;</span>
<span class="gi">+                &#39;@validate_arguments is not yet supported, please remove.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        class DecoratorBaseModel(BaseModel):</span>
<span class="gi">+            @validator(self.v_args_name, check_fields=False, allow_reuse=True)</span>
<span class="gi">+            def check_args(cls, v: Optional[List[Any]]) -&gt; Optional[List[Any]]:</span>
<span class="gi">+                if takes_args or v is None:</span>
<span class="gi">+                    return v</span>
<span class="gi">+</span>
<span class="gi">+                raise TypeError(f&#39;{pos_args} positional arguments expected but {pos_args + len(v)} given&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            @validator(self.v_kwargs_name, check_fields=False, allow_reuse=True)</span>
<span class="gi">+            def check_kwargs(cls, v: Optional[Dict[str, Any]]) -&gt; Optional[Dict[str, Any]]:</span>
<span class="gi">+                if takes_kwargs or v is None:</span>
<span class="gi">+                    return v</span>
<span class="gi">+</span>
<span class="gi">+                plural = &#39;&#39; if len(v) == 1 else &#39;s&#39;</span>
<span class="gi">+                keys = &#39;, &#39;.join(map(repr, v.keys()))</span>
<span class="gi">+                raise TypeError(f&#39;unexpected keyword argument{plural}: {keys}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            @validator(V_POSITIONAL_ONLY_NAME, check_fields=False, allow_reuse=True)</span>
<span class="gi">+            def check_positional_only(cls, v: Optional[List[str]]) -&gt; None:</span>
<span class="gi">+                if v is None:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                plural = &#39;&#39; if len(v) == 1 else &#39;s&#39;</span>
<span class="gi">+                keys = &#39;, &#39;.join(map(repr, v))</span>
<span class="gi">+                raise TypeError(f&#39;positional-only argument{plural} passed as keyword argument{plural}: {keys}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            @validator(V_DUPLICATE_KWARGS, check_fields=False, allow_reuse=True)</span>
<span class="gi">+            def check_duplicate_kwargs(cls, v: Optional[List[str]]) -&gt; None:</span>
<span class="gi">+                if v is None:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                plural = &#39;&#39; if len(v) == 1 else &#39;s&#39;</span>
<span class="gi">+                keys = &#39;, &#39;.join(map(repr, v))</span>
<span class="gi">+                raise TypeError(f&#39;multiple values for argument{plural}: {keys}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            class Config(CustomConfig):</span>
<span class="gi">+                extra = getattr(CustomConfig, &#39;extra&#39;, Extra.forbid)</span>
<span class="gi">+</span>
<span class="gi">+        self.model = create_model(to_camel(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)</span>
<span class="gh">diff --git a/pydantic/v1/env_settings.py b/pydantic/v1/env_settings.py</span>
<span class="gh">index 8ef7409b0..5f6f21750 100644</span>
<span class="gd">--- a/pydantic/v1/env_settings.py</span>
<span class="gi">+++ b/pydantic/v1/env_settings.py</span>
<span class="gu">@@ -2,13 +2,16 @@ import os</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import AbstractSet, Any, Callable, ClassVar, Dict, List, Mapping, Optional, Tuple, Type, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.config import BaseConfig, Extra
<span class="w"> </span>from pydantic.v1.fields import ModelField
<span class="w"> </span>from pydantic.v1.main import BaseModel
<span class="w"> </span>from pydantic.v1.types import JsonWrapper
<span class="w"> </span>from pydantic.v1.typing import StrPath, display_as_type, get_origin, is_union
<span class="w"> </span>from pydantic.v1.utils import deep_update, lenient_issubclass, path_type, sequence_like
<span class="gi">+</span>
<span class="w"> </span>env_file_sentinel = str(object())
<span class="gi">+</span>
<span class="w"> </span>SettingsSourceCallable = Callable[[&#39;BaseSettings&#39;], Dict[str, Any]]
<span class="w"> </span>DotenvType = Union[StrPath, List[StrPath], Tuple[StrPath, ...]]

<span class="gu">@@ -25,15 +28,56 @@ class BaseSettings(BaseModel):</span>
<span class="w"> </span>    Heroku and any 12 factor app design.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(__pydantic_self__, _env_file: Optional[DotenvType]=</span>
<span class="gd">-        env_file_sentinel, _env_file_encoding: Optional[str]=None,</span>
<span class="gd">-        _env_nested_delimiter: Optional[str]=None, _secrets_dir: Optional[</span>
<span class="gd">-        StrPath]=None, **values: Any) -&gt;None:</span>
<span class="gd">-        super().__init__(**__pydantic_self__._build_values(values,</span>
<span class="gd">-            _env_file=_env_file, _env_file_encoding=_env_file_encoding,</span>
<span class="gd">-            _env_nested_delimiter=_env_nested_delimiter, _secrets_dir=</span>
<span class="gd">-            _secrets_dir))</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        __pydantic_self__,</span>
<span class="gi">+        _env_file: Optional[DotenvType] = env_file_sentinel,</span>
<span class="gi">+        _env_file_encoding: Optional[str] = None,</span>
<span class="gi">+        _env_nested_delimiter: Optional[str] = None,</span>
<span class="gi">+        _secrets_dir: Optional[StrPath] = None,</span>
<span class="gi">+        **values: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Uses something other than `self` the first arg to allow &quot;self&quot; as a settable attribute</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            **__pydantic_self__._build_values(</span>
<span class="gi">+                values,</span>
<span class="gi">+                _env_file=_env_file,</span>
<span class="gi">+                _env_file_encoding=_env_file_encoding,</span>
<span class="gi">+                _env_nested_delimiter=_env_nested_delimiter,</span>
<span class="gi">+                _secrets_dir=_secrets_dir,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>

<span class="gi">+    def _build_values(</span>
<span class="gi">+        self,</span>
<span class="gi">+        init_kwargs: Dict[str, Any],</span>
<span class="gi">+        _env_file: Optional[DotenvType] = None,</span>
<span class="gi">+        _env_file_encoding: Optional[str] = None,</span>
<span class="gi">+        _env_nested_delimiter: Optional[str] = None,</span>
<span class="gi">+        _secrets_dir: Optional[StrPath] = None,</span>
<span class="gi">+    ) -&gt; Dict[str, Any]:</span>
<span class="gi">+        # Configure built-in sources</span>
<span class="gi">+        init_settings = InitSettingsSource(init_kwargs=init_kwargs)</span>
<span class="gi">+        env_settings = EnvSettingsSource(</span>
<span class="gi">+            env_file=(_env_file if _env_file != env_file_sentinel else self.__config__.env_file),</span>
<span class="gi">+            env_file_encoding=(</span>
<span class="gi">+                _env_file_encoding if _env_file_encoding is not None else self.__config__.env_file_encoding</span>
<span class="gi">+            ),</span>
<span class="gi">+            env_nested_delimiter=(</span>
<span class="gi">+                _env_nested_delimiter if _env_nested_delimiter is not None else self.__config__.env_nested_delimiter</span>
<span class="gi">+            ),</span>
<span class="gi">+            env_prefix_len=len(self.__config__.env_prefix),</span>
<span class="gi">+        )</span>
<span class="gi">+        file_secret_settings = SecretsSettingsSource(secrets_dir=_secrets_dir or self.__config__.secrets_dir)</span>
<span class="gi">+        # Provide a hook to set built-in sources priority and add / remove sources</span>
<span class="gi">+        sources = self.__config__.customise_sources(</span>
<span class="gi">+            init_settings=init_settings, env_settings=env_settings, file_secret_settings=file_secret_settings</span>
<span class="gi">+        )</span>
<span class="gi">+        if sources:</span>
<span class="gi">+            return deep_update(*reversed([source(self) for source in sources]))</span>
<span class="gi">+        else:</span>
<span class="gi">+            # no one should mean to do this, but I think returning an empty dict is marginally preferable</span>
<span class="gi">+            # to an informative error and much better than a confusing error</span>
<span class="gi">+            return {}</span>

<span class="w"> </span>    class Config(BaseConfig):
<span class="w"> </span>        env_prefix: str = &#39;&#39;
<span class="gu">@@ -45,146 +89,262 @@ class BaseSettings(BaseModel):</span>
<span class="w"> </span>        extra: Extra = Extra.forbid
<span class="w"> </span>        arbitrary_types_allowed: bool = True
<span class="w"> </span>        case_sensitive: bool = False
<span class="gi">+</span>
<span class="gi">+        @classmethod</span>
<span class="gi">+        def prepare_field(cls, field: ModelField) -&gt; None:</span>
<span class="gi">+            env_names: Union[List[str], AbstractSet[str]]</span>
<span class="gi">+            field_info_from_config = cls.get_field_info(field.name)</span>
<span class="gi">+</span>
<span class="gi">+            env = field_info_from_config.get(&#39;env&#39;) or field.field_info.extra.get(&#39;env&#39;)</span>
<span class="gi">+            if env is None:</span>
<span class="gi">+                if field.has_alias:</span>
<span class="gi">+                    warnings.warn(</span>
<span class="gi">+                        &#39;aliases are no longer used by BaseSettings to define which environment variables to read. &#39;</span>
<span class="gi">+                        &#39;Instead use the &quot;env&quot; field setting. &#39;</span>
<span class="gi">+                        &#39;See https://pydantic-docs.helpmanual.io/usage/settings/#environment-variable-names&#39;,</span>
<span class="gi">+                        FutureWarning,</span>
<span class="gi">+                    )</span>
<span class="gi">+                env_names = {cls.env_prefix + field.name}</span>
<span class="gi">+            elif isinstance(env, str):</span>
<span class="gi">+                env_names = {env}</span>
<span class="gi">+            elif isinstance(env, (set, frozenset)):</span>
<span class="gi">+                env_names = env</span>
<span class="gi">+            elif sequence_like(env):</span>
<span class="gi">+                env_names = list(env)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(f&#39;invalid field env: {env!r} ({display_as_type(env)}); should be string, list or set&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if not cls.case_sensitive:</span>
<span class="gi">+                env_names = env_names.__class__(n.lower() for n in env_names)</span>
<span class="gi">+            field.field_info.extra[&#39;env_names&#39;] = env_names</span>
<span class="gi">+</span>
<span class="gi">+        @classmethod</span>
<span class="gi">+        def customise_sources(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            init_settings: SettingsSourceCallable,</span>
<span class="gi">+            env_settings: SettingsSourceCallable,</span>
<span class="gi">+            file_secret_settings: SettingsSourceCallable,</span>
<span class="gi">+        ) -&gt; Tuple[SettingsSourceCallable, ...]:</span>
<span class="gi">+            return init_settings, env_settings, file_secret_settings</span>
<span class="gi">+</span>
<span class="gi">+        @classmethod</span>
<span class="gi">+        def parse_env_var(cls, field_name: str, raw_val: str) -&gt; Any:</span>
<span class="gi">+            return cls.json_loads(raw_val)</span>
<span class="gi">+</span>
<span class="gi">+    # populated by the metaclass using the Config class defined above, annotated here to help IDEs only</span>
<span class="w"> </span>    __config__: ClassVar[Type[Config]]


<span class="w"> </span>class InitSettingsSource:
<span class="gd">-    __slots__ = &#39;init_kwargs&#39;,</span>
<span class="gi">+    __slots__ = (&#39;init_kwargs&#39;,)</span>

<span class="w"> </span>    def __init__(self, init_kwargs: Dict[str, Any]):
<span class="w"> </span>        self.init_kwargs = init_kwargs

<span class="gd">-    def __call__(self, settings: BaseSettings) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def __call__(self, settings: BaseSettings) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        return self.init_kwargs

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;InitSettingsSource(init_kwargs={self.init_kwargs!r})&#39;


<span class="w"> </span>class EnvSettingsSource:
<span class="gd">-    __slots__ = (&#39;env_file&#39;, &#39;env_file_encoding&#39;, &#39;env_nested_delimiter&#39;,</span>
<span class="gd">-        &#39;env_prefix_len&#39;)</span>
<span class="gi">+    __slots__ = (&#39;env_file&#39;, &#39;env_file_encoding&#39;, &#39;env_nested_delimiter&#39;, &#39;env_prefix_len&#39;)</span>

<span class="gd">-    def __init__(self, env_file: Optional[DotenvType], env_file_encoding:</span>
<span class="gd">-        Optional[str], env_nested_delimiter: Optional[str]=None,</span>
<span class="gd">-        env_prefix_len: int=0):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        env_file: Optional[DotenvType],</span>
<span class="gi">+        env_file_encoding: Optional[str],</span>
<span class="gi">+        env_nested_delimiter: Optional[str] = None,</span>
<span class="gi">+        env_prefix_len: int = 0,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.env_file: Optional[DotenvType] = env_file
<span class="w"> </span>        self.env_file_encoding: Optional[str] = env_file_encoding
<span class="w"> </span>        self.env_nested_delimiter: Optional[str] = env_nested_delimiter
<span class="w"> </span>        self.env_prefix_len: int = env_prefix_len

<span class="gd">-    def __call__(self, settings: BaseSettings) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def __call__(self, settings: BaseSettings) -&gt; Dict[str, Any]:  # noqa C901</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Build environment variables suitable for passing to the Model.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        d: Dict[str, Any] = {}
<span class="gi">+</span>
<span class="w"> </span>        if settings.__config__.case_sensitive:
<span class="w"> </span>            env_vars: Mapping[str, Optional[str]] = os.environ
<span class="w"> </span>        else:
<span class="w"> </span>            env_vars = {k.lower(): v for k, v in os.environ.items()}
<span class="gi">+</span>
<span class="w"> </span>        dotenv_vars = self._read_env_files(settings.__config__.case_sensitive)
<span class="w"> </span>        if dotenv_vars:
<span class="w"> </span>            env_vars = {**dotenv_vars, **env_vars}
<span class="gi">+</span>
<span class="w"> </span>        for field in settings.__fields__.values():
<span class="w"> </span>            env_val: Optional[str] = None
<span class="w"> </span>            for env_name in field.field_info.extra[&#39;env_names&#39;]:
<span class="w"> </span>                env_val = env_vars.get(env_name)
<span class="w"> </span>                if env_val is not None:
<span class="w"> </span>                    break
<span class="gi">+</span>
<span class="w"> </span>            is_complex, allow_parse_failure = self.field_is_complex(field)
<span class="w"> </span>            if is_complex:
<span class="w"> </span>                if env_val is None:
<span class="gi">+                    # field is complex but no value found so far, try explode_env_vars</span>
<span class="w"> </span>                    env_val_built = self.explode_env_vars(field, env_vars)
<span class="w"> </span>                    if env_val_built:
<span class="w"> </span>                        d[field.alias] = env_val_built
<span class="w"> </span>                else:
<span class="gi">+                    # field is complex and there&#39;s a value, decode that as JSON, then add explode_env_vars</span>
<span class="w"> </span>                    try:
<span class="gd">-                        env_val = settings.__config__.parse_env_var(field.</span>
<span class="gd">-                            name, env_val)</span>
<span class="gi">+                        env_val = settings.__config__.parse_env_var(field.name, env_val)</span>
<span class="w"> </span>                    except ValueError as e:
<span class="w"> </span>                        if not allow_parse_failure:
<span class="gd">-                            raise SettingsError(</span>
<span class="gd">-                                f&#39;error parsing env var &quot;{env_name}&quot;&#39;) from e</span>
<span class="gi">+                            raise SettingsError(f&#39;error parsing env var &quot;{env_name}&quot;&#39;) from e</span>
<span class="gi">+</span>
<span class="w"> </span>                    if isinstance(env_val, dict):
<span class="gd">-                        d[field.alias] = deep_update(env_val, self.</span>
<span class="gd">-                            explode_env_vars(field, env_vars))</span>
<span class="gi">+                        d[field.alias] = deep_update(env_val, self.explode_env_vars(field, env_vars))</span>
<span class="w"> </span>                    else:
<span class="w"> </span>                        d[field.alias] = env_val
<span class="w"> </span>            elif env_val is not None:
<span class="gi">+                # simplest case, field is not complex, we only need to add the value if it was found</span>
<span class="w"> </span>                d[field.alias] = env_val
<span class="gi">+</span>
<span class="w"> </span>        return d

<span class="gd">-    def field_is_complex(self, field: ModelField) -&gt;Tuple[bool, bool]:</span>
<span class="gi">+    def _read_env_files(self, case_sensitive: bool) -&gt; Dict[str, Optional[str]]:</span>
<span class="gi">+        env_files = self.env_file</span>
<span class="gi">+        if env_files is None:</span>
<span class="gi">+            return {}</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(env_files, (str, os.PathLike)):</span>
<span class="gi">+            env_files = [env_files]</span>
<span class="gi">+</span>
<span class="gi">+        dotenv_vars = {}</span>
<span class="gi">+        for env_file in env_files:</span>
<span class="gi">+            env_path = Path(env_file).expanduser()</span>
<span class="gi">+            if env_path.is_file():</span>
<span class="gi">+                dotenv_vars.update(</span>
<span class="gi">+                    read_env_file(env_path, encoding=self.env_file_encoding, case_sensitive=case_sensitive)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        return dotenv_vars</span>
<span class="gi">+</span>
<span class="gi">+    def field_is_complex(self, field: ModelField) -&gt; Tuple[bool, bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find out if a field is complex, and if so whether JSON errors should be ignored
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if lenient_issubclass(field.annotation, JsonWrapper):</span>
<span class="gi">+            return False, False</span>
<span class="gi">+</span>
<span class="gi">+        if field.is_complex():</span>
<span class="gi">+            allow_parse_failure = False</span>
<span class="gi">+        elif is_union(get_origin(field.type_)) and field.sub_fields and any(f.is_complex() for f in field.sub_fields):</span>
<span class="gi">+            allow_parse_failure = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False, False</span>

<span class="gd">-    def explode_env_vars(self, field: ModelField, env_vars: Mapping[str,</span>
<span class="gd">-        Optional[str]]) -&gt;Dict[str, Any]:</span>
<span class="gi">+        return True, allow_parse_failure</span>
<span class="gi">+</span>
<span class="gi">+    def explode_env_vars(self, field: ModelField, env_vars: Mapping[str, Optional[str]]) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Process env_vars and extract the values of keys containing env_nested_delimiter into nested dictionaries.

<span class="w"> </span>        This is applied to a single field, hence filtering by env_var prefix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prefixes = [f&#39;{env_name}{self.env_nested_delimiter}&#39; for env_name in field.field_info.extra[&#39;env_names&#39;]]</span>
<span class="gi">+        result: Dict[str, Any] = {}</span>
<span class="gi">+        for env_name, env_val in env_vars.items():</span>
<span class="gi">+            if not any(env_name.startswith(prefix) for prefix in prefixes):</span>
<span class="gi">+                continue</span>
<span class="gi">+            # we remove the prefix before splitting in case the prefix has characters in common with the delimiter</span>
<span class="gi">+            env_name_without_prefix = env_name[self.env_prefix_len :]</span>
<span class="gi">+            _, *keys, last_key = env_name_without_prefix.split(self.env_nested_delimiter)</span>
<span class="gi">+            env_var = result</span>
<span class="gi">+            for key in keys:</span>
<span class="gi">+                env_var = env_var.setdefault(key, {})</span>
<span class="gi">+            env_var[last_key] = env_val</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;EnvSettingsSource(env_file={self.env_file!r}, env_file_encoding={self.env_file_encoding!r}, env_nested_delimiter={self.env_nested_delimiter!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&#39;EnvSettingsSource(env_file={self.env_file!r}, env_file_encoding={self.env_file_encoding!r}, &#39;</span>
<span class="gi">+            f&#39;env_nested_delimiter={self.env_nested_delimiter!r})&#39;</span>
<span class="gi">+        )</span>


<span class="w"> </span>class SecretsSettingsSource:
<span class="gd">-    __slots__ = &#39;secrets_dir&#39;,</span>
<span class="gi">+    __slots__ = (&#39;secrets_dir&#39;,)</span>

<span class="w"> </span>    def __init__(self, secrets_dir: Optional[StrPath]):
<span class="w"> </span>        self.secrets_dir: Optional[StrPath] = secrets_dir

<span class="gd">-    def __call__(self, settings: BaseSettings) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def __call__(self, settings: BaseSettings) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Build fields from &quot;secrets&quot; files.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        secrets: Dict[str, Optional[str]] = {}
<span class="gi">+</span>
<span class="w"> </span>        if self.secrets_dir is None:
<span class="w"> </span>            return secrets
<span class="gi">+</span>
<span class="w"> </span>        secrets_path = Path(self.secrets_dir).expanduser()
<span class="gi">+</span>
<span class="w"> </span>        if not secrets_path.exists():
<span class="w"> </span>            warnings.warn(f&#39;directory &quot;{secrets_path}&quot; does not exist&#39;)
<span class="w"> </span>            return secrets
<span class="gi">+</span>
<span class="w"> </span>        if not secrets_path.is_dir():
<span class="gd">-            raise SettingsError(</span>
<span class="gd">-                f&#39;secrets_dir must reference a directory, not a {path_type(secrets_path)}&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise SettingsError(f&#39;secrets_dir must reference a directory, not a {path_type(secrets_path)}&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>        for field in settings.__fields__.values():
<span class="w"> </span>            for env_name in field.field_info.extra[&#39;env_names&#39;]:
<span class="gd">-                path = find_case_path(secrets_path, env_name, settings.</span>
<span class="gd">-                    __config__.case_sensitive)</span>
<span class="gi">+                path = find_case_path(secrets_path, env_name, settings.__config__.case_sensitive)</span>
<span class="w"> </span>                if not path:
<span class="gi">+                    # path does not exist, we currently don&#39;t return a warning for this</span>
<span class="w"> </span>                    continue
<span class="gi">+</span>
<span class="w"> </span>                if path.is_file():
<span class="w"> </span>                    secret_value = path.read_text().strip()
<span class="w"> </span>                    if field.is_complex():
<span class="w"> </span>                        try:
<span class="gd">-                            secret_value = settings.__config__.parse_env_var(</span>
<span class="gd">-                                field.name, secret_value)</span>
<span class="gi">+                            secret_value = settings.__config__.parse_env_var(field.name, secret_value)</span>
<span class="w"> </span>                        except ValueError as e:
<span class="gd">-                            raise SettingsError(</span>
<span class="gd">-                                f&#39;error parsing env var &quot;{env_name}&quot;&#39;) from e</span>
<span class="gi">+                            raise SettingsError(f&#39;error parsing env var &quot;{env_name}&quot;&#39;) from e</span>
<span class="gi">+</span>
<span class="w"> </span>                    secrets[field.alias] = secret_value
<span class="w"> </span>                else:
<span class="w"> </span>                    warnings.warn(
<span class="gd">-                        f&#39;attempted to load secret file &quot;{path}&quot; but found a {path_type(path)} instead.&#39;</span>
<span class="gd">-                        , stacklevel=4)</span>
<span class="gi">+                        f&#39;attempted to load secret file &quot;{path}&quot; but found a {path_type(path)} instead.&#39;,</span>
<span class="gi">+                        stacklevel=4,</span>
<span class="gi">+                    )</span>
<span class="w"> </span>        return secrets

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;SecretsSettingsSource(secrets_dir={self.secrets_dir!r})&#39;


<span class="gd">-def find_case_path(dir_path: Path, file_name: str, case_sensitive: bool</span>
<span class="gd">-    ) -&gt;Optional[Path]:</span>
<span class="gi">+def read_env_file(</span>
<span class="gi">+    file_path: StrPath, *, encoding: str = None, case_sensitive: bool = False</span>
<span class="gi">+) -&gt; Dict[str, Optional[str]]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        from dotenv import dotenv_values</span>
<span class="gi">+    except ImportError as e:</span>
<span class="gi">+        raise ImportError(&#39;python-dotenv is not installed, run `pip install pydantic[dotenv]`&#39;) from e</span>
<span class="gi">+</span>
<span class="gi">+    file_vars: Dict[str, Optional[str]] = dotenv_values(file_path, encoding=encoding or &#39;utf8&#39;)</span>
<span class="gi">+    if not case_sensitive:</span>
<span class="gi">+        return {k.lower(): v for k, v in file_vars.items()}</span>
<span class="gi">+    else:</span>
<span class="gi">+        return file_vars</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_case_path(dir_path: Path, file_name: str, case_sensitive: bool) -&gt; Optional[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Find a file within path&#39;s directory matching filename, optionally ignoring case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for f in dir_path.iterdir():</span>
<span class="gi">+        if f.name == file_name:</span>
<span class="gi">+            return f</span>
<span class="gi">+        elif not case_sensitive and f.name.lower() == file_name.lower():</span>
<span class="gi">+            return f</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/pydantic/v1/error_wrappers.py b/pydantic/v1/error_wrappers.py</span>
<span class="gh">index 5f65f32c2..bc7f26314 100644</span>
<span class="gd">--- a/pydantic/v1/error_wrappers.py</span>
<span class="gi">+++ b/pydantic/v1/error_wrappers.py</span>
<span class="gu">@@ -1,56 +1,161 @@</span>
<span class="w"> </span>import json
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Dict, Generator, List, Optional, Sequence, Tuple, Type, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.json import pydantic_encoder
<span class="w"> </span>from pydantic.v1.utils import Representation
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import TypedDict
<span class="gi">+</span>
<span class="w"> </span>    from pydantic.v1.config import BaseConfig
<span class="w"> </span>    from pydantic.v1.types import ModelOrDc
<span class="w"> </span>    from pydantic.v1.typing import ReprArgs
<span class="gd">-    Loc = Tuple[Union[int, str], ...]</span>

<span class="gi">+    Loc = Tuple[Union[int, str], ...]</span>

<span class="w"> </span>    class _ErrorDictRequired(TypedDict):
<span class="w"> </span>        loc: Loc
<span class="w"> </span>        msg: str
<span class="w"> </span>        type: str

<span class="gd">-</span>
<span class="gd">-    class ErrorDict(_ErrorDictRequired, total=(False)):</span>
<span class="gi">+    class ErrorDict(_ErrorDictRequired, total=False):</span>
<span class="w"> </span>        ctx: Dict[str, Any]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;ErrorWrapper&#39;, &#39;ValidationError&#39;


<span class="w"> </span>class ErrorWrapper(Representation):
<span class="w"> </span>    __slots__ = &#39;exc&#39;, &#39;_loc&#39;

<span class="gd">-    def __init__(self, exc: Exception, loc: Union[str, &#39;Loc&#39;]) -&gt;None:</span>
<span class="gi">+    def __init__(self, exc: Exception, loc: Union[str, &#39;Loc&#39;]) -&gt; None:</span>
<span class="w"> </span>        self.exc = exc
<span class="w"> </span>        self._loc = loc

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gi">+    def loc_tuple(self) -&gt; &#39;Loc&#39;:</span>
<span class="gi">+        if isinstance(self._loc, tuple):</span>
<span class="gi">+            return self._loc</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (self._loc,)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="w"> </span>        return [(&#39;exc&#39;, self.exc), (&#39;loc&#39;, self.loc_tuple())]


<span class="gi">+# ErrorList is something like Union[List[Union[List[ErrorWrapper], ErrorWrapper]], ErrorWrapper]</span>
<span class="gi">+# but recursive, therefore just use:</span>
<span class="w"> </span>ErrorList = Union[Sequence[Any], ErrorWrapper]


<span class="w"> </span>class ValidationError(Representation, ValueError):
<span class="w"> </span>    __slots__ = &#39;raw_errors&#39;, &#39;model&#39;, &#39;_error_cache&#39;

<span class="gd">-    def __init__(self, errors: Sequence[ErrorList], model: &#39;ModelOrDc&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, errors: Sequence[ErrorList], model: &#39;ModelOrDc&#39;) -&gt; None:</span>
<span class="w"> </span>        self.raw_errors = errors
<span class="w"> </span>        self.model = model
<span class="w"> </span>        self._error_cache: Optional[List[&#39;ErrorDict&#39;]] = None

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def errors(self) -&gt; List[&#39;ErrorDict&#39;]:</span>
<span class="gi">+        if self._error_cache is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                config = self.model.__config__  # type: ignore</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                config = self.model.__pydantic_model__.__config__  # type: ignore</span>
<span class="gi">+            self._error_cache = list(flatten_errors(self.raw_errors, config))</span>
<span class="gi">+        return self._error_cache</span>
<span class="gi">+</span>
<span class="gi">+    def json(self, *, indent: Union[None, int, str] = 2) -&gt; str:</span>
<span class="gi">+        return json.dumps(self.errors(), indent=indent, default=pydantic_encoder)</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        errors = self.errors()
<span class="w"> </span>        no_errors = len(errors)
<span class="gd">-        return f&quot;&quot;&quot;{no_errors} validation error{&#39;&#39; if no_errors == 1 else &#39;s&#39;} for {self.model.__name__}</span>
<span class="gd">-{display_errors(errors)}&quot;&quot;&quot;</span>
<span class="gi">+        return (</span>
<span class="gi">+            f&#39;{no_errors} validation error{&quot;&quot; if no_errors == 1 else &quot;s&quot;} for {self.model.__name__}\n&#39;</span>
<span class="gi">+            f&#39;{display_errors(errors)}&#39;</span>
<span class="gi">+        )</span>

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="w"> </span>        return [(&#39;model&#39;, self.model.__name__), (&#39;errors&#39;, self.errors())]


<span class="gi">+def display_errors(errors: List[&#39;ErrorDict&#39;]) -&gt; str:</span>
<span class="gi">+    return &#39;\n&#39;.join(f&#39;{_display_error_loc(e)}\n  {e[&quot;msg&quot;]} ({_display_error_type_and_ctx(e)})&#39; for e in errors)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _display_error_loc(error: &#39;ErrorDict&#39;) -&gt; str:</span>
<span class="gi">+    return &#39; -&gt; &#39;.join(str(e) for e in error[&#39;loc&#39;])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _display_error_type_and_ctx(error: &#39;ErrorDict&#39;) -&gt; str:</span>
<span class="gi">+    t = &#39;type=&#39; + error[&#39;type&#39;]</span>
<span class="gi">+    ctx = error.get(&#39;ctx&#39;)</span>
<span class="gi">+    if ctx:</span>
<span class="gi">+        return t + &#39;&#39;.join(f&#39;; {k}={v}&#39; for k, v in ctx.items())</span>
<span class="gi">+    else:</span>
<span class="gi">+        return t</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def flatten_errors(</span>
<span class="gi">+    errors: Sequence[Any], config: Type[&#39;BaseConfig&#39;], loc: Optional[&#39;Loc&#39;] = None</span>
<span class="gi">+) -&gt; Generator[&#39;ErrorDict&#39;, None, None]:</span>
<span class="gi">+    for error in errors:</span>
<span class="gi">+        if isinstance(error, ErrorWrapper):</span>
<span class="gi">+            if loc:</span>
<span class="gi">+                error_loc = loc + error.loc_tuple()</span>
<span class="gi">+            else:</span>
<span class="gi">+                error_loc = error.loc_tuple()</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(error.exc, ValidationError):</span>
<span class="gi">+                yield from flatten_errors(error.exc.raw_errors, config, error_loc)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield error_dict(error.exc, config, error_loc)</span>
<span class="gi">+        elif isinstance(error, list):</span>
<span class="gi">+            yield from flatten_errors(error, config, loc=loc)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuntimeError(f&#39;Unknown error object: {error}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_dict(exc: Exception, config: Type[&#39;BaseConfig&#39;], loc: &#39;Loc&#39;) -&gt; &#39;ErrorDict&#39;:</span>
<span class="gi">+    type_ = get_exc_type(exc.__class__)</span>
<span class="gi">+    msg_template = config.error_msg_templates.get(type_) or getattr(exc, &#39;msg_template&#39;, None)</span>
<span class="gi">+    ctx = exc.__dict__</span>
<span class="gi">+    if msg_template:</span>
<span class="gi">+        msg = msg_template.format(**ctx)</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = str(exc)</span>
<span class="gi">+</span>
<span class="gi">+    d: &#39;ErrorDict&#39; = {&#39;loc&#39;: loc, &#39;msg&#39;: msg, &#39;type&#39;: type_}</span>
<span class="gi">+</span>
<span class="gi">+    if ctx:</span>
<span class="gi">+        d[&#39;ctx&#39;] = ctx</span>
<span class="gi">+</span>
<span class="gi">+    return d</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_EXC_TYPE_CACHE: Dict[Type[Exception], str] = {}
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_exc_type(cls: Type[Exception]) -&gt; str:</span>
<span class="gi">+    # slightly more efficient than using lru_cache since we don&#39;t need to worry about the cache filling up</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _EXC_TYPE_CACHE[cls]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        r = _get_exc_type(cls)</span>
<span class="gi">+        _EXC_TYPE_CACHE[cls] = r</span>
<span class="gi">+        return r</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_exc_type(cls: Type[Exception]) -&gt; str:</span>
<span class="gi">+    if issubclass(cls, AssertionError):</span>
<span class="gi">+        return &#39;assertion_error&#39;</span>
<span class="gi">+</span>
<span class="gi">+    base_name = &#39;type_error&#39; if issubclass(cls, TypeError) else &#39;value_error&#39;</span>
<span class="gi">+    if cls in (TypeError, ValueError):</span>
<span class="gi">+        # just TypeError or ValueError, no extra code</span>
<span class="gi">+        return base_name</span>
<span class="gi">+</span>
<span class="gi">+    # if it&#39;s not a TypeError or ValueError, we just take the lowercase of the exception name</span>
<span class="gi">+    # no chaining or snake case logic, use &quot;code&quot; for more complex error types.</span>
<span class="gi">+    code = getattr(cls, &#39;code&#39;, None) or cls.__name__.replace(&#39;Error&#39;, &#39;&#39;).lower()</span>
<span class="gi">+    return base_name + &#39;.&#39; + code</span>
<span class="gh">diff --git a/pydantic/v1/errors.py b/pydantic/v1/errors.py</span>
<span class="gh">index 20d3509bc..6e8644258 100644</span>
<span class="gd">--- a/pydantic/v1/errors.py</span>
<span class="gi">+++ b/pydantic/v1/errors.py</span>
<span class="gu">@@ -1,41 +1,111 @@</span>
<span class="w"> </span>from decimal import Decimal
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Sequence, Set, Tuple, Type, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.typing import display_as_type
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.typing import DictStrAny
<span class="gd">-__all__ = (&#39;PydanticTypeError&#39;, &#39;PydanticValueError&#39;, &#39;ConfigError&#39;,</span>
<span class="gd">-    &#39;MissingError&#39;, &#39;ExtraError&#39;, &#39;NoneIsNotAllowedError&#39;,</span>
<span class="gd">-    &#39;NoneIsAllowedError&#39;, &#39;WrongConstantError&#39;, &#39;NotNoneError&#39;, &#39;BoolError&#39;,</span>
<span class="gd">-    &#39;BytesError&#39;, &#39;DictError&#39;, &#39;EmailError&#39;, &#39;UrlError&#39;, &#39;UrlSchemeError&#39;,</span>
<span class="gd">-    &#39;UrlSchemePermittedError&#39;, &#39;UrlUserInfoError&#39;, &#39;UrlHostError&#39;,</span>
<span class="gd">-    &#39;UrlHostTldError&#39;, &#39;UrlPortError&#39;, &#39;UrlExtraError&#39;, &#39;EnumError&#39;,</span>
<span class="gd">-    &#39;IntEnumError&#39;, &#39;EnumMemberError&#39;, &#39;IntegerError&#39;, &#39;FloatError&#39;,</span>
<span class="gd">-    &#39;PathError&#39;, &#39;PathNotExistsError&#39;, &#39;PathNotAFileError&#39;,</span>
<span class="gd">-    &#39;PathNotADirectoryError&#39;, &#39;PyObjectError&#39;, &#39;SequenceError&#39;, &#39;ListError&#39;,</span>
<span class="gd">-    &#39;SetError&#39;, &#39;FrozenSetError&#39;, &#39;TupleError&#39;, &#39;TupleLengthError&#39;,</span>
<span class="gd">-    &#39;ListMinLengthError&#39;, &#39;ListMaxLengthError&#39;, &#39;ListUniqueItemsError&#39;,</span>
<span class="gd">-    &#39;SetMinLengthError&#39;, &#39;SetMaxLengthError&#39;, &#39;FrozenSetMinLengthError&#39;,</span>
<span class="gd">-    &#39;FrozenSetMaxLengthError&#39;, &#39;AnyStrMinLengthError&#39;,</span>
<span class="gd">-    &#39;AnyStrMaxLengthError&#39;, &#39;StrError&#39;, &#39;StrRegexError&#39;, &#39;NumberNotGtError&#39;,</span>
<span class="gd">-    &#39;NumberNotGeError&#39;, &#39;NumberNotLtError&#39;, &#39;NumberNotLeError&#39;,</span>
<span class="gd">-    &#39;NumberNotMultipleError&#39;, &#39;DecimalError&#39;, &#39;DecimalIsNotFiniteError&#39;,</span>
<span class="gd">-    &#39;DecimalMaxDigitsError&#39;, &#39;DecimalMaxPlacesError&#39;,</span>
<span class="gd">-    &#39;DecimalWholeDigitsError&#39;, &#39;DateTimeError&#39;, &#39;DateError&#39;,</span>
<span class="gd">-    &#39;DateNotInThePastError&#39;, &#39;DateNotInTheFutureError&#39;, &#39;TimeError&#39;,</span>
<span class="gd">-    &#39;DurationError&#39;, &#39;HashableError&#39;, &#39;UUIDError&#39;, &#39;UUIDVersionError&#39;,</span>
<span class="gd">-    &#39;ArbitraryTypeError&#39;, &#39;ClassError&#39;, &#39;SubclassError&#39;, &#39;JsonError&#39;,</span>
<span class="gd">-    &#39;JsonTypeError&#39;, &#39;PatternError&#39;, &#39;DataclassTypeError&#39;, &#39;CallableError&#39;,</span>
<span class="gd">-    &#39;IPvAnyAddressError&#39;, &#39;IPvAnyInterfaceError&#39;, &#39;IPvAnyNetworkError&#39;,</span>
<span class="gd">-    &#39;IPv4AddressError&#39;, &#39;IPv6AddressError&#39;, &#39;IPv4NetworkError&#39;,</span>
<span class="gd">-    &#39;IPv6NetworkError&#39;, &#39;IPv4InterfaceError&#39;, &#39;IPv6InterfaceError&#39;,</span>
<span class="gd">-    &#39;ColorError&#39;, &#39;StrictBoolError&#39;, &#39;NotDigitError&#39;, &#39;LuhnValidationError&#39;,</span>
<span class="gd">-    &#39;InvalidLengthForBrand&#39;, &#39;InvalidByteSize&#39;, &#39;InvalidByteSizeUnit&#39;,</span>
<span class="gd">-    &#39;MissingDiscriminator&#39;, &#39;InvalidDiscriminator&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def cls_kwargs(cls: Type[&#39;PydanticErrorMixin&#39;], ctx: &#39;DictStrAny&#39;</span>
<span class="gd">-    ) -&gt;&#39;PydanticErrorMixin&#39;:</span>
<span class="gi">+</span>
<span class="gi">+# explicitly state exports to avoid &quot;from pydantic.v1.errors import *&quot; also importing Decimal, Path etc.</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &#39;PydanticTypeError&#39;,</span>
<span class="gi">+    &#39;PydanticValueError&#39;,</span>
<span class="gi">+    &#39;ConfigError&#39;,</span>
<span class="gi">+    &#39;MissingError&#39;,</span>
<span class="gi">+    &#39;ExtraError&#39;,</span>
<span class="gi">+    &#39;NoneIsNotAllowedError&#39;,</span>
<span class="gi">+    &#39;NoneIsAllowedError&#39;,</span>
<span class="gi">+    &#39;WrongConstantError&#39;,</span>
<span class="gi">+    &#39;NotNoneError&#39;,</span>
<span class="gi">+    &#39;BoolError&#39;,</span>
<span class="gi">+    &#39;BytesError&#39;,</span>
<span class="gi">+    &#39;DictError&#39;,</span>
<span class="gi">+    &#39;EmailError&#39;,</span>
<span class="gi">+    &#39;UrlError&#39;,</span>
<span class="gi">+    &#39;UrlSchemeError&#39;,</span>
<span class="gi">+    &#39;UrlSchemePermittedError&#39;,</span>
<span class="gi">+    &#39;UrlUserInfoError&#39;,</span>
<span class="gi">+    &#39;UrlHostError&#39;,</span>
<span class="gi">+    &#39;UrlHostTldError&#39;,</span>
<span class="gi">+    &#39;UrlPortError&#39;,</span>
<span class="gi">+    &#39;UrlExtraError&#39;,</span>
<span class="gi">+    &#39;EnumError&#39;,</span>
<span class="gi">+    &#39;IntEnumError&#39;,</span>
<span class="gi">+    &#39;EnumMemberError&#39;,</span>
<span class="gi">+    &#39;IntegerError&#39;,</span>
<span class="gi">+    &#39;FloatError&#39;,</span>
<span class="gi">+    &#39;PathError&#39;,</span>
<span class="gi">+    &#39;PathNotExistsError&#39;,</span>
<span class="gi">+    &#39;PathNotAFileError&#39;,</span>
<span class="gi">+    &#39;PathNotADirectoryError&#39;,</span>
<span class="gi">+    &#39;PyObjectError&#39;,</span>
<span class="gi">+    &#39;SequenceError&#39;,</span>
<span class="gi">+    &#39;ListError&#39;,</span>
<span class="gi">+    &#39;SetError&#39;,</span>
<span class="gi">+    &#39;FrozenSetError&#39;,</span>
<span class="gi">+    &#39;TupleError&#39;,</span>
<span class="gi">+    &#39;TupleLengthError&#39;,</span>
<span class="gi">+    &#39;ListMinLengthError&#39;,</span>
<span class="gi">+    &#39;ListMaxLengthError&#39;,</span>
<span class="gi">+    &#39;ListUniqueItemsError&#39;,</span>
<span class="gi">+    &#39;SetMinLengthError&#39;,</span>
<span class="gi">+    &#39;SetMaxLengthError&#39;,</span>
<span class="gi">+    &#39;FrozenSetMinLengthError&#39;,</span>
<span class="gi">+    &#39;FrozenSetMaxLengthError&#39;,</span>
<span class="gi">+    &#39;AnyStrMinLengthError&#39;,</span>
<span class="gi">+    &#39;AnyStrMaxLengthError&#39;,</span>
<span class="gi">+    &#39;StrError&#39;,</span>
<span class="gi">+    &#39;StrRegexError&#39;,</span>
<span class="gi">+    &#39;NumberNotGtError&#39;,</span>
<span class="gi">+    &#39;NumberNotGeError&#39;,</span>
<span class="gi">+    &#39;NumberNotLtError&#39;,</span>
<span class="gi">+    &#39;NumberNotLeError&#39;,</span>
<span class="gi">+    &#39;NumberNotMultipleError&#39;,</span>
<span class="gi">+    &#39;DecimalError&#39;,</span>
<span class="gi">+    &#39;DecimalIsNotFiniteError&#39;,</span>
<span class="gi">+    &#39;DecimalMaxDigitsError&#39;,</span>
<span class="gi">+    &#39;DecimalMaxPlacesError&#39;,</span>
<span class="gi">+    &#39;DecimalWholeDigitsError&#39;,</span>
<span class="gi">+    &#39;DateTimeError&#39;,</span>
<span class="gi">+    &#39;DateError&#39;,</span>
<span class="gi">+    &#39;DateNotInThePastError&#39;,</span>
<span class="gi">+    &#39;DateNotInTheFutureError&#39;,</span>
<span class="gi">+    &#39;TimeError&#39;,</span>
<span class="gi">+    &#39;DurationError&#39;,</span>
<span class="gi">+    &#39;HashableError&#39;,</span>
<span class="gi">+    &#39;UUIDError&#39;,</span>
<span class="gi">+    &#39;UUIDVersionError&#39;,</span>
<span class="gi">+    &#39;ArbitraryTypeError&#39;,</span>
<span class="gi">+    &#39;ClassError&#39;,</span>
<span class="gi">+    &#39;SubclassError&#39;,</span>
<span class="gi">+    &#39;JsonError&#39;,</span>
<span class="gi">+    &#39;JsonTypeError&#39;,</span>
<span class="gi">+    &#39;PatternError&#39;,</span>
<span class="gi">+    &#39;DataclassTypeError&#39;,</span>
<span class="gi">+    &#39;CallableError&#39;,</span>
<span class="gi">+    &#39;IPvAnyAddressError&#39;,</span>
<span class="gi">+    &#39;IPvAnyInterfaceError&#39;,</span>
<span class="gi">+    &#39;IPvAnyNetworkError&#39;,</span>
<span class="gi">+    &#39;IPv4AddressError&#39;,</span>
<span class="gi">+    &#39;IPv6AddressError&#39;,</span>
<span class="gi">+    &#39;IPv4NetworkError&#39;,</span>
<span class="gi">+    &#39;IPv6NetworkError&#39;,</span>
<span class="gi">+    &#39;IPv4InterfaceError&#39;,</span>
<span class="gi">+    &#39;IPv6InterfaceError&#39;,</span>
<span class="gi">+    &#39;ColorError&#39;,</span>
<span class="gi">+    &#39;StrictBoolError&#39;,</span>
<span class="gi">+    &#39;NotDigitError&#39;,</span>
<span class="gi">+    &#39;LuhnValidationError&#39;,</span>
<span class="gi">+    &#39;InvalidLengthForBrand&#39;,</span>
<span class="gi">+    &#39;InvalidByteSize&#39;,</span>
<span class="gi">+    &#39;InvalidByteSizeUnit&#39;,</span>
<span class="gi">+    &#39;MissingDiscriminator&#39;,</span>
<span class="gi">+    &#39;InvalidDiscriminator&#39;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def cls_kwargs(cls: Type[&#39;PydanticErrorMixin&#39;], ctx: &#39;DictStrAny&#39;) -&gt; &#39;PydanticErrorMixin&#39;:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    For built-in exceptions like ValueError or TypeError, we need to implement
<span class="w"> </span>    __reduce__ to override the default behaviour (instead of __getstate__/__setstate__)
<span class="gu">@@ -43,21 +113,20 @@ def cls_kwargs(cls: Type[&#39;PydanticErrorMixin&#39;], ctx: &#39;DictStrAny&#39;</span>
<span class="w"> </span>    Since we only use kwargs, we need a little constructor to change that.
<span class="w"> </span>    Note: the callable can&#39;t be a lambda as pickle looks in the namespace to find it
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls(**ctx)</span>


<span class="w"> </span>class PydanticErrorMixin:
<span class="w"> </span>    code: str
<span class="w"> </span>    msg_template: str

<span class="gd">-    def __init__(self, **ctx: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, **ctx: Any) -&gt; None:</span>
<span class="w"> </span>        self.__dict__ = ctx

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.msg_template.format(**self.__dict__)

<span class="gd">-    def __reduce__(self) -&gt;Tuple[Callable[..., &#39;PydanticErrorMixin&#39;], Tuple</span>
<span class="gd">-        [Type[&#39;PydanticErrorMixin&#39;], &#39;DictStrAny&#39;]]:</span>
<span class="gi">+    def __reduce__(self) -&gt; Tuple[Callable[..., &#39;PydanticErrorMixin&#39;], Tuple[Type[&#39;PydanticErrorMixin&#39;], &#39;DictStrAny&#39;]]:</span>
<span class="w"> </span>        return cls_kwargs, (self.__class__, self.__dict__)


<span class="gu">@@ -94,8 +163,8 @@ class NoneIsAllowedError(PydanticTypeError):</span>
<span class="w"> </span>class WrongConstantError(PydanticValueError):
<span class="w"> </span>    code = &#39;const&#39;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        permitted = &#39;, &#39;.join(repr(v) for v in self.permitted)</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        permitted = &#39;, &#39;.join(repr(v) for v in self.permitted)  # type: ignore</span>
<span class="w"> </span>        return f&#39;unexpected value; permitted: {permitted}&#39;


<span class="gu">@@ -159,17 +228,15 @@ class UrlPortError(UrlError):</span>

<span class="w"> </span>class UrlExtraError(UrlError):
<span class="w"> </span>    code = &#39;url.extra&#39;
<span class="gd">-    msg_template = (</span>
<span class="gd">-        &#39;URL invalid, extra characters found after valid URL: {extra!r}&#39;)</span>
<span class="gi">+    msg_template = &#39;URL invalid, extra characters found after valid URL: {extra!r}&#39;</span>


<span class="w"> </span>class EnumMemberError(PydanticTypeError):
<span class="w"> </span>    code = &#39;enum&#39;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        permitted = &#39;, &#39;.join(repr(v.value) for v in self.enum_values)</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;value is not a valid enumeration member; permitted: {permitted}&#39;)</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        permitted = &#39;, &#39;.join(repr(v.value) for v in self.enum_values)  # type: ignore</span>
<span class="gi">+        return f&#39;value is not a valid enumeration member; permitted: {permitted}&#39;</span>


<span class="w"> </span>class IntegerError(PydanticTypeError):
<span class="gu">@@ -185,8 +252,7 @@ class PathError(PydanticTypeError):</span>


<span class="w"> </span>class _PathValueError(PydanticValueError):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, path: Path) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, path: Path) -&gt; None:</span>
<span class="w"> </span>        super().__init__(path=str(path))


<span class="gu">@@ -206,9 +272,7 @@ class PathNotADirectoryError(_PathValueError):</span>


<span class="w"> </span>class PyObjectError(PydanticTypeError):
<span class="gd">-    msg_template = (</span>
<span class="gd">-        &#39;ensure this value contains valid import path or valid callable: {error_message}&#39;</span>
<span class="gd">-        )</span>
<span class="gi">+    msg_template = &#39;ensure this value contains valid import path or valid callable: {error_message}&#39;</span>


<span class="w"> </span>class SequenceError(PydanticTypeError):
<span class="gu">@@ -241,19 +305,17 @@ class TupleError(PydanticTypeError):</span>

<span class="w"> </span>class TupleLengthError(PydanticValueError):
<span class="w"> </span>    code = &#39;tuple.length&#39;
<span class="gd">-    msg_template = (</span>
<span class="gd">-        &#39;wrong tuple length {actual_length}, expected {expected_length}&#39;)</span>
<span class="gi">+    msg_template = &#39;wrong tuple length {actual_length}, expected {expected_length}&#39;</span>

<span class="gd">-    def __init__(self, *, actual_length: int, expected_length: int) -&gt;None:</span>
<span class="gd">-        super().__init__(actual_length=actual_length, expected_length=</span>
<span class="gd">-            expected_length)</span>
<span class="gi">+    def __init__(self, *, actual_length: int, expected_length: int) -&gt; None:</span>
<span class="gi">+        super().__init__(actual_length=actual_length, expected_length=expected_length)</span>


<span class="w"> </span>class ListMinLengthError(PydanticValueError):
<span class="w"> </span>    code = &#39;list.min_items&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value has at least {limit_value} items&#39;

<span class="gd">-    def __init__(self, *, limit_value: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -261,7 +323,7 @@ class ListMaxLengthError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;list.max_items&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value has at most {limit_value} items&#39;

<span class="gd">-    def __init__(self, *, limit_value: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -274,7 +336,7 @@ class SetMinLengthError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;set.min_items&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value has at least {limit_value} items&#39;

<span class="gd">-    def __init__(self, *, limit_value: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -282,7 +344,7 @@ class SetMaxLengthError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;set.max_items&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value has at most {limit_value} items&#39;

<span class="gd">-    def __init__(self, *, limit_value: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -290,7 +352,7 @@ class FrozenSetMinLengthError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;frozenset.min_items&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value has at least {limit_value} items&#39;

<span class="gd">-    def __init__(self, *, limit_value: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -298,7 +360,7 @@ class FrozenSetMaxLengthError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;frozenset.max_items&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value has at most {limit_value} items&#39;

<span class="gd">-    def __init__(self, *, limit_value: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -306,7 +368,7 @@ class AnyStrMinLengthError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;any_str.min_length&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value has at least {limit_value} characters&#39;

<span class="gd">-    def __init__(self, *, limit_value: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -314,7 +376,7 @@ class AnyStrMaxLengthError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;any_str.max_length&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value has at most {limit_value} characters&#39;

<span class="gd">-    def __init__(self, *, limit_value: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -326,13 +388,12 @@ class StrRegexError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;str.regex&#39;
<span class="w"> </span>    msg_template = &#39;string does not match regex &quot;{pattern}&quot;&#39;

<span class="gd">-    def __init__(self, *, pattern: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, pattern: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(pattern=pattern)


<span class="w"> </span>class _NumberBoundError(PydanticValueError):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, limit_value: Union[int, float, Decimal]) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, limit_value: Union[int, float, Decimal]) -&gt; None:</span>
<span class="w"> </span>        super().__init__(limit_value=limit_value)


<span class="gu">@@ -343,8 +404,7 @@ class NumberNotGtError(_NumberBoundError):</span>

<span class="w"> </span>class NumberNotGeError(_NumberBoundError):
<span class="w"> </span>    code = &#39;number.not_ge&#39;
<span class="gd">-    msg_template = (</span>
<span class="gd">-        &#39;ensure this value is greater than or equal to {limit_value}&#39;)</span>
<span class="gi">+    msg_template = &#39;ensure this value is greater than or equal to {limit_value}&#39;</span>


<span class="w"> </span>class NumberNotLtError(_NumberBoundError):
<span class="gu">@@ -366,7 +426,7 @@ class NumberNotMultipleError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;number.not_multiple&#39;
<span class="w"> </span>    msg_template = &#39;ensure this value is a multiple of {multiple_of}&#39;

<span class="gd">-    def __init__(self, *, multiple_of: Union[int, float, Decimal]) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, multiple_of: Union[int, float, Decimal]) -&gt; None:</span>
<span class="w"> </span>        super().__init__(multiple_of=multiple_of)


<span class="gu">@@ -381,29 +441,25 @@ class DecimalIsNotFiniteError(PydanticValueError):</span>

<span class="w"> </span>class DecimalMaxDigitsError(PydanticValueError):
<span class="w"> </span>    code = &#39;decimal.max_digits&#39;
<span class="gd">-    msg_template = (</span>
<span class="gd">-        &#39;ensure that there are no more than {max_digits} digits in total&#39;)</span>
<span class="gi">+    msg_template = &#39;ensure that there are no more than {max_digits} digits in total&#39;</span>

<span class="gd">-    def __init__(self, *, max_digits: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, max_digits: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(max_digits=max_digits)


<span class="w"> </span>class DecimalMaxPlacesError(PydanticValueError):
<span class="w"> </span>    code = &#39;decimal.max_places&#39;
<span class="gd">-    msg_template = (</span>
<span class="gd">-        &#39;ensure that there are no more than {decimal_places} decimal places&#39;)</span>
<span class="gi">+    msg_template = &#39;ensure that there are no more than {decimal_places} decimal places&#39;</span>

<span class="gd">-    def __init__(self, *, decimal_places: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, decimal_places: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(decimal_places=decimal_places)


<span class="w"> </span>class DecimalWholeDigitsError(PydanticValueError):
<span class="w"> </span>    code = &#39;decimal.whole_digits&#39;
<span class="gd">-    msg_template = (</span>
<span class="gd">-        &#39;ensure that there are no more than {whole_digits} digits before the decimal point&#39;</span>
<span class="gd">-        )</span>
<span class="gi">+    msg_template = &#39;ensure that there are no more than {whole_digits} digits before the decimal point&#39;</span>

<span class="gd">-    def __init__(self, *, whole_digits: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, whole_digits: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(whole_digits=whole_digits)


<span class="gu">@@ -445,7 +501,7 @@ class UUIDVersionError(PydanticValueError):</span>
<span class="w"> </span>    code = &#39;uuid.version&#39;
<span class="w"> </span>    msg_template = &#39;uuid version {required_version} expected&#39;

<span class="gd">-    def __init__(self, *, required_version: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, required_version: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(required_version=required_version)


<span class="gu">@@ -453,9 +509,8 @@ class ArbitraryTypeError(PydanticTypeError):</span>
<span class="w"> </span>    code = &#39;arbitrary_type&#39;
<span class="w"> </span>    msg_template = &#39;instance of {expected_arbitrary_type} expected&#39;

<span class="gd">-    def __init__(self, *, expected_arbitrary_type: Type[Any]) -&gt;None:</span>
<span class="gd">-        super().__init__(expected_arbitrary_type=display_as_type(</span>
<span class="gd">-            expected_arbitrary_type))</span>
<span class="gi">+    def __init__(self, *, expected_arbitrary_type: Type[Any]) -&gt; None:</span>
<span class="gi">+        super().__init__(expected_arbitrary_type=display_as_type(expected_arbitrary_type))</span>


<span class="w"> </span>class ClassError(PydanticTypeError):
<span class="gu">@@ -467,7 +522,7 @@ class SubclassError(PydanticTypeError):</span>
<span class="w"> </span>    code = &#39;subclass&#39;
<span class="w"> </span>    msg_template = &#39;subclass of {expected_class} expected&#39;

<span class="gd">-    def __init__(self, *, expected_class: Type[Any]) -&gt;None:</span>
<span class="gi">+    def __init__(self, *, expected_class: Type[Any]) -&gt; None:</span>
<span class="w"> </span>        super().__init__(expected_class=display_as_type(expected_class))


<span class="gu">@@ -579,11 +634,13 @@ class MissingDiscriminator(PydanticValueError):</span>
<span class="w"> </span>class InvalidDiscriminator(PydanticValueError):
<span class="w"> </span>    code = &#39;discriminated_union.invalid_discriminator&#39;
<span class="w"> </span>    msg_template = (
<span class="gd">-        &#39;No match for discriminator {discriminator_key!r} and value {discriminator_value!r} (allowed values: {allowed_values})&#39;</span>
<span class="gi">+        &#39;No match for discriminator {discriminator_key!r} and value {discriminator_value!r} &#39;</span>
<span class="gi">+        &#39;(allowed values: {allowed_values})&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *, discriminator_key: str, discriminator_value: Any, allowed_values: Sequence[Any]) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            discriminator_key=discriminator_key,</span>
<span class="gi">+            discriminator_value=discriminator_value,</span>
<span class="gi">+            allowed_values=&#39;, &#39;.join(map(repr, allowed_values)),</span>
<span class="w"> </span>        )
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, discriminator_key: str, discriminator_value: Any,</span>
<span class="gd">-        allowed_values: Sequence[Any]) -&gt;None:</span>
<span class="gd">-        super().__init__(discriminator_key=discriminator_key,</span>
<span class="gd">-            discriminator_value=discriminator_value, allowed_values=&#39;, &#39;.</span>
<span class="gd">-            join(map(repr, allowed_values)))</span>
<span class="gh">diff --git a/pydantic/v1/fields.py b/pydantic/v1/fields.py</span>
<span class="gh">index 5364c3533..002b60cde 100644</span>
<span class="gd">--- a/pydantic/v1/fields.py</span>
<span class="gi">+++ b/pydantic/v1/fields.py</span>
<span class="gu">@@ -2,42 +2,93 @@ import copy</span>
<span class="w"> </span>import re
<span class="w"> </span>from collections import Counter as CollectionCounter, defaultdict, deque
<span class="w"> </span>from collections.abc import Callable, Hashable as CollectionsHashable, Iterable as CollectionsIterable
<span class="gd">-from typing import TYPE_CHECKING, Any, Counter, DefaultDict, Deque, Dict, ForwardRef, FrozenSet, Generator, Iterable, Iterator, List, Mapping, Optional, Pattern, Sequence, Set, Tuple, Type, TypeVar, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Counter,</span>
<span class="gi">+    DefaultDict,</span>
<span class="gi">+    Deque,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    ForwardRef,</span>
<span class="gi">+    FrozenSet,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Annotated, Final
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1 import errors as errors_
<span class="w"> </span>from pydantic.v1.class_validators import Validator, make_generic_validator, prep_validators
<span class="w"> </span>from pydantic.v1.error_wrappers import ErrorWrapper
<span class="w"> </span>from pydantic.v1.errors import ConfigError, InvalidDiscriminator, MissingDiscriminator, NoneIsNotAllowedError
<span class="w"> </span>from pydantic.v1.types import Json, JsonWrapper
<span class="gd">-from pydantic.v1.typing import NoArgAnyCallable, convert_generics, display_as_type, get_args, get_origin, is_finalvar, is_literal_type, is_new_type, is_none_type, is_typeddict, is_typeddict_special, is_union, new_type_supertype</span>
<span class="gd">-from pydantic.v1.utils import PyObjectStr, Representation, ValueItems, get_discriminator_alias_and_values, get_unique_discriminator_alias, lenient_isinstance, lenient_issubclass, sequence_like, smart_deepcopy</span>
<span class="gi">+from pydantic.v1.typing import (</span>
<span class="gi">+    NoArgAnyCallable,</span>
<span class="gi">+    convert_generics,</span>
<span class="gi">+    display_as_type,</span>
<span class="gi">+    get_args,</span>
<span class="gi">+    get_origin,</span>
<span class="gi">+    is_finalvar,</span>
<span class="gi">+    is_literal_type,</span>
<span class="gi">+    is_new_type,</span>
<span class="gi">+    is_none_type,</span>
<span class="gi">+    is_typeddict,</span>
<span class="gi">+    is_typeddict_special,</span>
<span class="gi">+    is_union,</span>
<span class="gi">+    new_type_supertype,</span>
<span class="gi">+)</span>
<span class="gi">+from pydantic.v1.utils import (</span>
<span class="gi">+    PyObjectStr,</span>
<span class="gi">+    Representation,</span>
<span class="gi">+    ValueItems,</span>
<span class="gi">+    get_discriminator_alias_and_values,</span>
<span class="gi">+    get_unique_discriminator_alias,</span>
<span class="gi">+    lenient_isinstance,</span>
<span class="gi">+    lenient_issubclass,</span>
<span class="gi">+    sequence_like,</span>
<span class="gi">+    smart_deepcopy,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pydantic.v1.validators import constant_validator, dict_validator, find_validators, validate_json
<span class="gi">+</span>
<span class="w"> </span>Required: Any = Ellipsis
<span class="gi">+</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)


<span class="w"> </span>class UndefinedType:
<span class="gd">-</span>
<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return &#39;PydanticUndefined&#39;

<span class="gd">-    def __copy__(self: T) -&gt;T:</span>
<span class="gi">+    def __copy__(self: T) -&gt; T:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __reduce__(self) -&gt;str:</span>
<span class="gi">+    def __reduce__(self) -&gt; str:</span>
<span class="w"> </span>        return &#39;Undefined&#39;

<span class="gd">-    def __deepcopy__(self: T, _: Any) -&gt;T:</span>
<span class="gi">+    def __deepcopy__(self: T, _: Any) -&gt; T:</span>
<span class="w"> </span>        return self


<span class="w"> </span>Undefined = UndefinedType()
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.class_validators import ValidatorsList
<span class="w"> </span>    from pydantic.v1.config import BaseConfig
<span class="w"> </span>    from pydantic.v1.error_wrappers import ErrorList
<span class="w"> </span>    from pydantic.v1.types import ModelOrDc
<span class="w"> </span>    from pydantic.v1.typing import AbstractSetIntStr, MappingIntStrAny, ReprArgs
<span class="gi">+</span>
<span class="w"> </span>    ValidateReturn = Tuple[Optional[Any], Optional[ErrorList]]
<span class="w"> </span>    LocStr = Union[Tuple[Union[int, str], ...], str]
<span class="w"> </span>    BoolUndefined = Union[bool, UndefinedType]
<span class="gu">@@ -47,24 +98,61 @@ class FieldInfo(Representation):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Captures extra information about a field.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;default&#39;, &#39;default_factory&#39;, &#39;alias&#39;, &#39;alias_priority&#39;,</span>
<span class="gd">-        &#39;title&#39;, &#39;description&#39;, &#39;exclude&#39;, &#39;include&#39;, &#39;const&#39;, &#39;gt&#39;, &#39;ge&#39;,</span>
<span class="gd">-        &#39;lt&#39;, &#39;le&#39;, &#39;multiple_of&#39;, &#39;allow_inf_nan&#39;, &#39;max_digits&#39;,</span>
<span class="gd">-        &#39;decimal_places&#39;, &#39;min_items&#39;, &#39;max_items&#39;, &#39;unique_items&#39;,</span>
<span class="gd">-        &#39;min_length&#39;, &#39;max_length&#39;, &#39;allow_mutation&#39;, &#39;repr&#39;, &#39;regex&#39;,</span>
<span class="gd">-        &#39;discriminator&#39;, &#39;extra&#39;)</span>
<span class="gd">-    __field_constraints__ = {&#39;min_length&#39;: None, &#39;max_length&#39;: None,</span>
<span class="gd">-        &#39;regex&#39;: None, &#39;gt&#39;: None, &#39;lt&#39;: None, &#39;ge&#39;: None, &#39;le&#39;: None,</span>
<span class="gd">-        &#39;multiple_of&#39;: None, &#39;allow_inf_nan&#39;: None, &#39;max_digits&#39;: None,</span>
<span class="gd">-        &#39;decimal_places&#39;: None, &#39;min_items&#39;: None, &#39;max_items&#39;: None,</span>
<span class="gd">-        &#39;unique_items&#39;: None, &#39;allow_mutation&#39;: True}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, default: Any=Undefined, **kwargs: Any) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;default&#39;,</span>
<span class="gi">+        &#39;default_factory&#39;,</span>
<span class="gi">+        &#39;alias&#39;,</span>
<span class="gi">+        &#39;alias_priority&#39;,</span>
<span class="gi">+        &#39;title&#39;,</span>
<span class="gi">+        &#39;description&#39;,</span>
<span class="gi">+        &#39;exclude&#39;,</span>
<span class="gi">+        &#39;include&#39;,</span>
<span class="gi">+        &#39;const&#39;,</span>
<span class="gi">+        &#39;gt&#39;,</span>
<span class="gi">+        &#39;ge&#39;,</span>
<span class="gi">+        &#39;lt&#39;,</span>
<span class="gi">+        &#39;le&#39;,</span>
<span class="gi">+        &#39;multiple_of&#39;,</span>
<span class="gi">+        &#39;allow_inf_nan&#39;,</span>
<span class="gi">+        &#39;max_digits&#39;,</span>
<span class="gi">+        &#39;decimal_places&#39;,</span>
<span class="gi">+        &#39;min_items&#39;,</span>
<span class="gi">+        &#39;max_items&#39;,</span>
<span class="gi">+        &#39;unique_items&#39;,</span>
<span class="gi">+        &#39;min_length&#39;,</span>
<span class="gi">+        &#39;max_length&#39;,</span>
<span class="gi">+        &#39;allow_mutation&#39;,</span>
<span class="gi">+        &#39;repr&#39;,</span>
<span class="gi">+        &#39;regex&#39;,</span>
<span class="gi">+        &#39;discriminator&#39;,</span>
<span class="gi">+        &#39;extra&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # field constraints with the default value, it&#39;s also used in update_from_config below</span>
<span class="gi">+    __field_constraints__ = {</span>
<span class="gi">+        &#39;min_length&#39;: None,</span>
<span class="gi">+        &#39;max_length&#39;: None,</span>
<span class="gi">+        &#39;regex&#39;: None,</span>
<span class="gi">+        &#39;gt&#39;: None,</span>
<span class="gi">+        &#39;lt&#39;: None,</span>
<span class="gi">+        &#39;ge&#39;: None,</span>
<span class="gi">+        &#39;le&#39;: None,</span>
<span class="gi">+        &#39;multiple_of&#39;: None,</span>
<span class="gi">+        &#39;allow_inf_nan&#39;: None,</span>
<span class="gi">+        &#39;max_digits&#39;: None,</span>
<span class="gi">+        &#39;decimal_places&#39;: None,</span>
<span class="gi">+        &#39;min_items&#39;: None,</span>
<span class="gi">+        &#39;max_items&#39;: None,</span>
<span class="gi">+        &#39;unique_items&#39;: None,</span>
<span class="gi">+        &#39;allow_mutation&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, default: Any = Undefined, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        self.default = default
<span class="w"> </span>        self.default_factory = kwargs.pop(&#39;default_factory&#39;, None)
<span class="w"> </span>        self.alias = kwargs.pop(&#39;alias&#39;, None)
<span class="gd">-        self.alias_priority = kwargs.pop(&#39;alias_priority&#39;, 2 if self.alias</span>
<span class="gd">-             is not None else None)</span>
<span class="gi">+        self.alias_priority = kwargs.pop(&#39;alias_priority&#39;, 2 if self.alias is not None else None)</span>
<span class="w"> </span>        self.title = kwargs.pop(&#39;title&#39;, None)
<span class="w"> </span>        self.description = kwargs.pop(&#39;description&#39;, None)
<span class="w"> </span>        self.exclude = kwargs.pop(&#39;exclude&#39;, None)
<span class="gu">@@ -89,42 +177,76 @@ class FieldInfo(Representation):</span>
<span class="w"> </span>        self.repr = kwargs.pop(&#39;repr&#39;, True)
<span class="w"> </span>        self.extra = kwargs

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gd">-        field_defaults_to_hide: Dict[str, Any] = {&#39;repr&#39;: True, **self.</span>
<span class="gd">-            __field_constraints__}</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="gi">+        field_defaults_to_hide: Dict[str, Any] = {</span>
<span class="gi">+            &#39;repr&#39;: True,</span>
<span class="gi">+            **self.__field_constraints__,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>        attrs = ((s, getattr(self, s)) for s in self.__slots__)
<span class="gd">-        return [(a, v) for a, v in attrs if v != field_defaults_to_hide.get</span>
<span class="gd">-            (a, None)]</span>
<span class="gi">+        return [(a, v) for a, v in attrs if v != field_defaults_to_hide.get(a, None)]</span>

<span class="gd">-    def get_constraints(self) -&gt;Set[str]:</span>
<span class="gi">+    def get_constraints(self) -&gt; Set[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Gets the constraints set on the field by comparing the constraint value with its default value

<span class="w"> </span>        :return: the constraints set on field_info
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {attr for attr, default in self.__field_constraints__.items() if getattr(self, attr) != default}</span>

<span class="gd">-    def update_from_config(self, from_config: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+    def update_from_config(self, from_config: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Update this FieldInfo based on a dict from get_field_info, only fields which have not been set are dated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def Field(default: Any=Undefined, *, default_factory: Optional[</span>
<span class="gd">-    NoArgAnyCallable]=None, alias: Optional[str]=None, title: Optional[str]</span>
<span class="gd">-    =None, description: Optional[str]=None, exclude: Optional[Union[</span>
<span class="gd">-    &#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;, Any]]=None, include: Optional[</span>
<span class="gd">-    Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;, Any]]=None, const:</span>
<span class="gd">-    Optional[bool]=None, gt: Optional[float]=None, ge: Optional[float]=None,</span>
<span class="gd">-    lt: Optional[float]=None, le: Optional[float]=None, multiple_of:</span>
<span class="gd">-    Optional[float]=None, allow_inf_nan: Optional[bool]=None, max_digits:</span>
<span class="gd">-    Optional[int]=None, decimal_places: Optional[int]=None, min_items:</span>
<span class="gd">-    Optional[int]=None, max_items: Optional[int]=None, unique_items:</span>
<span class="gd">-    Optional[bool]=None, min_length: Optional[int]=None, max_length:</span>
<span class="gd">-    Optional[int]=None, allow_mutation: bool=True, regex: Optional[str]=</span>
<span class="gd">-    None, discriminator: Optional[str]=None, repr: bool=True, **extra: Any</span>
<span class="gd">-    ) -&gt;Any:</span>
<span class="gi">+        for attr_name, value in from_config.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                current_value = getattr(self, attr_name)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                # attr_name is not an attribute of FieldInfo, it should therefore be added to extra</span>
<span class="gi">+                # (except if extra already has this value!)</span>
<span class="gi">+                self.extra.setdefault(attr_name, value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if current_value is self.__field_constraints__.get(attr_name, None):</span>
<span class="gi">+                    setattr(self, attr_name, value)</span>
<span class="gi">+                elif attr_name == &#39;exclude&#39;:</span>
<span class="gi">+                    self.exclude = ValueItems.merge(value, current_value)</span>
<span class="gi">+                elif attr_name == &#39;include&#39;:</span>
<span class="gi">+                    self.include = ValueItems.merge(value, current_value, intersect=True)</span>
<span class="gi">+</span>
<span class="gi">+    def _validate(self) -&gt; None:</span>
<span class="gi">+        if self.default is not Undefined and self.default_factory is not None:</span>
<span class="gi">+            raise ValueError(&#39;cannot specify both default and default_factory&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def Field(</span>
<span class="gi">+    default: Any = Undefined,</span>
<span class="gi">+    *,</span>
<span class="gi">+    default_factory: Optional[NoArgAnyCallable] = None,</span>
<span class="gi">+    alias: Optional[str] = None,</span>
<span class="gi">+    title: Optional[str] = None,</span>
<span class="gi">+    description: Optional[str] = None,</span>
<span class="gi">+    exclude: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;, Any]] = None,</span>
<span class="gi">+    include: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;, Any]] = None,</span>
<span class="gi">+    const: Optional[bool] = None,</span>
<span class="gi">+    gt: Optional[float] = None,</span>
<span class="gi">+    ge: Optional[float] = None,</span>
<span class="gi">+    lt: Optional[float] = None,</span>
<span class="gi">+    le: Optional[float] = None,</span>
<span class="gi">+    multiple_of: Optional[float] = None,</span>
<span class="gi">+    allow_inf_nan: Optional[bool] = None,</span>
<span class="gi">+    max_digits: Optional[int] = None,</span>
<span class="gi">+    decimal_places: Optional[int] = None,</span>
<span class="gi">+    min_items: Optional[int] = None,</span>
<span class="gi">+    max_items: Optional[int] = None,</span>
<span class="gi">+    unique_items: Optional[bool] = None,</span>
<span class="gi">+    min_length: Optional[int] = None,</span>
<span class="gi">+    max_length: Optional[int] = None,</span>
<span class="gi">+    allow_mutation: bool = True,</span>
<span class="gi">+    regex: Optional[str] = None,</span>
<span class="gi">+    discriminator: Optional[str] = None,</span>
<span class="gi">+    repr: bool = True,</span>
<span class="gi">+    **extra: Any,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments
<span class="w"> </span>    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``.
<span class="gu">@@ -176,9 +298,39 @@ def Field(default: Any=Undefined, *, default_factory: Optional[</span>
<span class="w"> </span>    :param repr: show this field in the representation
<span class="w"> </span>    :param **extra: any additional keyword arguments will be added as is to the schema
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    field_info = FieldInfo(</span>
<span class="gi">+        default,</span>
<span class="gi">+        default_factory=default_factory,</span>
<span class="gi">+        alias=alias,</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        description=description,</span>
<span class="gi">+        exclude=exclude,</span>
<span class="gi">+        include=include,</span>
<span class="gi">+        const=const,</span>
<span class="gi">+        gt=gt,</span>
<span class="gi">+        ge=ge,</span>
<span class="gi">+        lt=lt,</span>
<span class="gi">+        le=le,</span>
<span class="gi">+        multiple_of=multiple_of,</span>
<span class="gi">+        allow_inf_nan=allow_inf_nan,</span>
<span class="gi">+        max_digits=max_digits,</span>
<span class="gi">+        decimal_places=decimal_places,</span>
<span class="gi">+        min_items=min_items,</span>
<span class="gi">+        max_items=max_items,</span>
<span class="gi">+        unique_items=unique_items,</span>
<span class="gi">+        min_length=min_length,</span>
<span class="gi">+        max_length=max_length,</span>
<span class="gi">+        allow_mutation=allow_mutation,</span>
<span class="gi">+        regex=regex,</span>
<span class="gi">+        discriminator=discriminator,</span>
<span class="gi">+        repr=repr,</span>
<span class="gi">+        **extra,</span>
<span class="gi">+    )</span>
<span class="gi">+    field_info._validate()</span>
<span class="gi">+    return field_info</span>


<span class="gi">+# used to be an enum but changed to int&#39;s for small performance improvement as less access overhead</span>
<span class="w"> </span>SHAPE_SINGLETON = 1
<span class="w"> </span>SHAPE_LIST = 2
<span class="w"> </span>SHAPE_SET = 3
<span class="gu">@@ -193,28 +345,65 @@ SHAPE_DEQUE = 11</span>
<span class="w"> </span>SHAPE_DICT = 12
<span class="w"> </span>SHAPE_DEFAULTDICT = 13
<span class="w"> </span>SHAPE_COUNTER = 14
<span class="gd">-SHAPE_NAME_LOOKUP = {SHAPE_LIST: &#39;List[{}]&#39;, SHAPE_SET: &#39;Set[{}]&#39;,</span>
<span class="gd">-    SHAPE_TUPLE_ELLIPSIS: &#39;Tuple[{}, ...]&#39;, SHAPE_SEQUENCE: &#39;Sequence[{}]&#39;,</span>
<span class="gd">-    SHAPE_FROZENSET: &#39;FrozenSet[{}]&#39;, SHAPE_ITERABLE: &#39;Iterable[{}]&#39;,</span>
<span class="gd">-    SHAPE_DEQUE: &#39;Deque[{}]&#39;, SHAPE_DICT: &#39;Dict[{}]&#39;, SHAPE_DEFAULTDICT:</span>
<span class="gd">-    &#39;DefaultDict[{}]&#39;, SHAPE_COUNTER: &#39;Counter[{}]&#39;}</span>
<span class="gd">-MAPPING_LIKE_SHAPES: Set[int] = {SHAPE_DEFAULTDICT, SHAPE_DICT,</span>
<span class="gd">-    SHAPE_MAPPING, SHAPE_COUNTER}</span>
<span class="gi">+SHAPE_NAME_LOOKUP = {</span>
<span class="gi">+    SHAPE_LIST: &#39;List[{}]&#39;,</span>
<span class="gi">+    SHAPE_SET: &#39;Set[{}]&#39;,</span>
<span class="gi">+    SHAPE_TUPLE_ELLIPSIS: &#39;Tuple[{}, ...]&#39;,</span>
<span class="gi">+    SHAPE_SEQUENCE: &#39;Sequence[{}]&#39;,</span>
<span class="gi">+    SHAPE_FROZENSET: &#39;FrozenSet[{}]&#39;,</span>
<span class="gi">+    SHAPE_ITERABLE: &#39;Iterable[{}]&#39;,</span>
<span class="gi">+    SHAPE_DEQUE: &#39;Deque[{}]&#39;,</span>
<span class="gi">+    SHAPE_DICT: &#39;Dict[{}]&#39;,</span>
<span class="gi">+    SHAPE_DEFAULTDICT: &#39;DefaultDict[{}]&#39;,</span>
<span class="gi">+    SHAPE_COUNTER: &#39;Counter[{}]&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+MAPPING_LIKE_SHAPES: Set[int] = {SHAPE_DEFAULTDICT, SHAPE_DICT, SHAPE_MAPPING, SHAPE_COUNTER}</span>


<span class="w"> </span>class ModelField(Representation):
<span class="gd">-    __slots__ = (&#39;type_&#39;, &#39;outer_type_&#39;, &#39;annotation&#39;, &#39;sub_fields&#39;,</span>
<span class="gd">-        &#39;sub_fields_mapping&#39;, &#39;key_field&#39;, &#39;validators&#39;, &#39;pre_validators&#39;,</span>
<span class="gd">-        &#39;post_validators&#39;, &#39;default&#39;, &#39;default_factory&#39;, &#39;required&#39;,</span>
<span class="gd">-        &#39;final&#39;, &#39;model_config&#39;, &#39;name&#39;, &#39;alias&#39;, &#39;has_alias&#39;, &#39;field_info&#39;,</span>
<span class="gd">-        &#39;discriminator_key&#39;, &#39;discriminator_alias&#39;, &#39;validate_always&#39;,</span>
<span class="gd">-        &#39;allow_none&#39;, &#39;shape&#39;, &#39;class_validators&#39;, &#39;parse_json&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, name: str, type_: Type[Any], class_validators:</span>
<span class="gd">-        Optional[Dict[str, Validator]], model_config: Type[&#39;BaseConfig&#39;],</span>
<span class="gd">-        default: Any=None, default_factory: Optional[NoArgAnyCallable]=None,</span>
<span class="gd">-        required: &#39;BoolUndefined&#39;=Undefined, final: bool=False, alias:</span>
<span class="gd">-        Optional[str]=None, field_info: Optional[FieldInfo]=None) -&gt;None:</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;type_&#39;,</span>
<span class="gi">+        &#39;outer_type_&#39;,</span>
<span class="gi">+        &#39;annotation&#39;,</span>
<span class="gi">+        &#39;sub_fields&#39;,</span>
<span class="gi">+        &#39;sub_fields_mapping&#39;,</span>
<span class="gi">+        &#39;key_field&#39;,</span>
<span class="gi">+        &#39;validators&#39;,</span>
<span class="gi">+        &#39;pre_validators&#39;,</span>
<span class="gi">+        &#39;post_validators&#39;,</span>
<span class="gi">+        &#39;default&#39;,</span>
<span class="gi">+        &#39;default_factory&#39;,</span>
<span class="gi">+        &#39;required&#39;,</span>
<span class="gi">+        &#39;final&#39;,</span>
<span class="gi">+        &#39;model_config&#39;,</span>
<span class="gi">+        &#39;name&#39;,</span>
<span class="gi">+        &#39;alias&#39;,</span>
<span class="gi">+        &#39;has_alias&#39;,</span>
<span class="gi">+        &#39;field_info&#39;,</span>
<span class="gi">+        &#39;discriminator_key&#39;,</span>
<span class="gi">+        &#39;discriminator_alias&#39;,</span>
<span class="gi">+        &#39;validate_always&#39;,</span>
<span class="gi">+        &#39;allow_none&#39;,</span>
<span class="gi">+        &#39;shape&#39;,</span>
<span class="gi">+        &#39;class_validators&#39;,</span>
<span class="gi">+        &#39;parse_json&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        type_: Type[Any],</span>
<span class="gi">+        class_validators: Optional[Dict[str, Validator]],</span>
<span class="gi">+        model_config: Type[&#39;BaseConfig&#39;],</span>
<span class="gi">+        default: Any = None,</span>
<span class="gi">+        default_factory: Optional[NoArgAnyCallable] = None,</span>
<span class="gi">+        required: &#39;BoolUndefined&#39; = Undefined,</span>
<span class="gi">+        final: bool = False,</span>
<span class="gi">+        alias: Optional[str] = None,</span>
<span class="gi">+        field_info: Optional[FieldInfo] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.name: str = name
<span class="w"> </span>        self.has_alias: bool = alias is not None
<span class="w"> </span>        self.alias: str = alias if alias is not None else name
<span class="gu">@@ -230,10 +419,11 @@ class ModelField(Representation):</span>
<span class="w"> </span>        self.field_info: FieldInfo = field_info or FieldInfo(default)
<span class="w"> </span>        self.discriminator_key: Optional[str] = self.field_info.discriminator
<span class="w"> </span>        self.discriminator_alias: Optional[str] = self.discriminator_key
<span class="gi">+</span>
<span class="w"> </span>        self.allow_none: bool = False
<span class="w"> </span>        self.validate_always: bool = False
<span class="w"> </span>        self.sub_fields: Optional[List[ModelField]] = None
<span class="gd">-        self.sub_fields_mapping: Optional[Dict[str, &#39;ModelField&#39;]] = None</span>
<span class="gi">+        self.sub_fields_mapping: Optional[Dict[str, &#39;ModelField&#39;]] = None  # used for discriminated union</span>
<span class="w"> </span>        self.key_field: Optional[ModelField] = None
<span class="w"> </span>        self.validators: &#39;ValidatorsList&#39; = []
<span class="w"> </span>        self.pre_validators: Optional[&#39;ValidatorsList&#39;] = None
<span class="gu">@@ -243,9 +433,13 @@ class ModelField(Representation):</span>
<span class="w"> </span>        self.model_config.prepare_field(self)
<span class="w"> </span>        self.prepare()

<span class="gi">+    def get_default(self) -&gt; Any:</span>
<span class="gi">+        return smart_deepcopy(self.default) if self.default_factory is None else self.default_factory()</span>
<span class="gi">+</span>
<span class="w"> </span>    @staticmethod
<span class="gd">-    def _get_field_info(field_name: str, annotation: Any, value: Any,</span>
<span class="gd">-        config: Type[&#39;BaseConfig&#39;]) -&gt;Tuple[FieldInfo, Any]:</span>
<span class="gi">+    def _get_field_info(</span>
<span class="gi">+        field_name: str, annotation: Any, value: Any, config: Type[&#39;BaseConfig&#39;]</span>
<span class="gi">+    ) -&gt; Tuple[FieldInfo, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get a FieldInfo from a root typing.Annotated annotation, value, or config default.

<span class="gu">@@ -258,99 +452,777 @@ class ModelField(Representation):</span>
<span class="w"> </span>        :param config: the model&#39;s config object
<span class="w"> </span>        :return: the FieldInfo contained in the `annotation`, the value, or a new one from the config.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        field_info_from_config = config.get_field_info(field_name)</span>
<span class="gi">+</span>
<span class="gi">+        field_info = None</span>
<span class="gi">+        if get_origin(annotation) is Annotated:</span>
<span class="gi">+            field_infos = [arg for arg in get_args(annotation)[1:] if isinstance(arg, FieldInfo)]</span>
<span class="gi">+            if len(field_infos) &gt; 1:</span>
<span class="gi">+                raise ValueError(f&#39;cannot specify multiple `Annotated` `Field`s for {field_name!r}&#39;)</span>
<span class="gi">+            field_info = next(iter(field_infos), None)</span>
<span class="gi">+            if field_info is not None:</span>
<span class="gi">+                field_info = copy.copy(field_info)</span>
<span class="gi">+                field_info.update_from_config(field_info_from_config)</span>
<span class="gi">+                if field_info.default not in (Undefined, Required):</span>
<span class="gi">+                    raise ValueError(f&#39;`Field` default cannot be set in `Annotated` for {field_name!r}&#39;)</span>
<span class="gi">+                if value is not Undefined and value is not Required:</span>
<span class="gi">+                    # check also `Required` because of `validate_arguments` that sets `...` as default value</span>
<span class="gi">+                    field_info.default = value</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, FieldInfo):</span>
<span class="gi">+            if field_info is not None:</span>
<span class="gi">+                raise ValueError(f&#39;cannot specify `Annotated` and value `Field`s together for {field_name!r}&#39;)</span>
<span class="gi">+            field_info = value</span>
<span class="gi">+            field_info.update_from_config(field_info_from_config)</span>
<span class="gi">+        elif field_info is None:</span>
<span class="gi">+            field_info = FieldInfo(value, **field_info_from_config)</span>
<span class="gi">+        value = None if field_info.default_factory is not None else field_info.default</span>
<span class="gi">+        field_info._validate()</span>
<span class="gi">+        return field_info, value</span>

<span class="gd">-    def prepare(self) -&gt;None:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def infer(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        *,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        value: Any,</span>
<span class="gi">+        annotation: Any,</span>
<span class="gi">+        class_validators: Optional[Dict[str, Validator]],</span>
<span class="gi">+        config: Type[&#39;BaseConfig&#39;],</span>
<span class="gi">+    ) -&gt; &#39;ModelField&#39;:</span>
<span class="gi">+        from pydantic.v1.schema import get_annotation_from_field_info</span>
<span class="gi">+</span>
<span class="gi">+        field_info, value = cls._get_field_info(name, annotation, value, config)</span>
<span class="gi">+        required: &#39;BoolUndefined&#39; = Undefined</span>
<span class="gi">+        if value is Required:</span>
<span class="gi">+            required = True</span>
<span class="gi">+            value = None</span>
<span class="gi">+        elif value is not Undefined:</span>
<span class="gi">+            required = False</span>
<span class="gi">+        annotation = get_annotation_from_field_info(annotation, field_info, name, config.validate_assignment)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            name=name,</span>
<span class="gi">+            type_=annotation,</span>
<span class="gi">+            alias=field_info.alias,</span>
<span class="gi">+            class_validators=class_validators,</span>
<span class="gi">+            default=value,</span>
<span class="gi">+            default_factory=field_info.default_factory,</span>
<span class="gi">+            required=required,</span>
<span class="gi">+            model_config=config,</span>
<span class="gi">+            field_info=field_info,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def set_config(self, config: Type[&#39;BaseConfig&#39;]) -&gt; None:</span>
<span class="gi">+        self.model_config = config</span>
<span class="gi">+        info_from_config = config.get_field_info(self.name)</span>
<span class="gi">+        config.prepare_field(self)</span>
<span class="gi">+        new_alias = info_from_config.get(&#39;alias&#39;)</span>
<span class="gi">+        new_alias_priority = info_from_config.get(&#39;alias_priority&#39;) or 0</span>
<span class="gi">+        if new_alias and new_alias_priority &gt;= (self.field_info.alias_priority or 0):</span>
<span class="gi">+            self.field_info.alias = new_alias</span>
<span class="gi">+            self.field_info.alias_priority = new_alias_priority</span>
<span class="gi">+            self.alias = new_alias</span>
<span class="gi">+        new_exclude = info_from_config.get(&#39;exclude&#39;)</span>
<span class="gi">+        if new_exclude is not None:</span>
<span class="gi">+            self.field_info.exclude = ValueItems.merge(self.field_info.exclude, new_exclude)</span>
<span class="gi">+        new_include = info_from_config.get(&#39;include&#39;)</span>
<span class="gi">+        if new_include is not None:</span>
<span class="gi">+            self.field_info.include = ValueItems.merge(self.field_info.include, new_include, intersect=True)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def alt_alias(self) -&gt; bool:</span>
<span class="gi">+        return self.name != self.alias</span>
<span class="gi">+</span>
<span class="gi">+    def prepare(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Prepare the field but inspecting self.default, self.type_ etc.

<span class="w"> </span>        Note: this method is **not** idempotent (because _type_analysis is not idempotent),
<span class="w"> </span>        e.g. calling it it multiple times may modify the field and configure it incorrectly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_default_and_type()</span>
<span class="gi">+        if self.type_.__class__ is ForwardRef or self.type_.__class__ is DeferredType:</span>
<span class="gi">+            # self.type_ is currently a ForwardRef and there&#39;s nothing we can do now,</span>
<span class="gi">+            # user will need to call model.update_forward_refs()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._type_analysis()</span>
<span class="gi">+        if self.required is Undefined:</span>
<span class="gi">+            self.required = True</span>
<span class="gi">+        if self.default is Undefined and self.default_factory is None:</span>
<span class="gi">+            self.default = None</span>
<span class="gi">+        self.populate_validators()</span>

<span class="gd">-    def _set_default_and_type(self) -&gt;None:</span>
<span class="gi">+    def _set_default_and_type(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the default value, infer the type if needed and check if `None` value is valid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_factory is not None:</span>
<span class="gi">+            if self.type_ is Undefined:</span>
<span class="gi">+                raise errors_.ConfigError(</span>
<span class="gi">+                    f&#39;you need to set the type of field {self.name!r} when using `default_factory`&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            return</span>

<span class="gd">-    def prepare_discriminated_union_sub_fields(self) -&gt;None:</span>
<span class="gi">+        default_value = self.get_default()</span>
<span class="gi">+</span>
<span class="gi">+        if default_value is not None and self.type_ is Undefined:</span>
<span class="gi">+            self.type_ = default_value.__class__</span>
<span class="gi">+            self.outer_type_ = self.type_</span>
<span class="gi">+            self.annotation = self.type_</span>
<span class="gi">+</span>
<span class="gi">+        if self.type_ is Undefined:</span>
<span class="gi">+            raise errors_.ConfigError(f&#39;unable to infer type for attribute &quot;{self.name}&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.required is False and default_value is None:</span>
<span class="gi">+            self.allow_none = True</span>
<span class="gi">+</span>
<span class="gi">+    def _type_analysis(self) -&gt; None:  # noqa: C901 (ignore complexity)</span>
<span class="gi">+        # typing interface is horrible, we have to do some ugly checks</span>
<span class="gi">+        if lenient_issubclass(self.type_, JsonWrapper):</span>
<span class="gi">+            self.type_ = self.type_.inner_type</span>
<span class="gi">+            self.parse_json = True</span>
<span class="gi">+        elif lenient_issubclass(self.type_, Json):</span>
<span class="gi">+            self.type_ = Any</span>
<span class="gi">+            self.parse_json = True</span>
<span class="gi">+        elif isinstance(self.type_, TypeVar):</span>
<span class="gi">+            if self.type_.__bound__:</span>
<span class="gi">+                self.type_ = self.type_.__bound__</span>
<span class="gi">+            elif self.type_.__constraints__:</span>
<span class="gi">+                self.type_ = Union[self.type_.__constraints__]</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.type_ = Any</span>
<span class="gi">+        elif is_new_type(self.type_):</span>
<span class="gi">+            self.type_ = new_type_supertype(self.type_)</span>
<span class="gi">+</span>
<span class="gi">+        if self.type_ is Any or self.type_ is object:</span>
<span class="gi">+            if self.required is Undefined:</span>
<span class="gi">+                self.required = False</span>
<span class="gi">+            self.allow_none = True</span>
<span class="gi">+            return</span>
<span class="gi">+        elif self.type_ is Pattern or self.type_ is re.Pattern:</span>
<span class="gi">+            # python 3.7 only, Pattern is a typing object but without sub fields</span>
<span class="gi">+            return</span>
<span class="gi">+        elif is_literal_type(self.type_):</span>
<span class="gi">+            return</span>
<span class="gi">+        elif is_typeddict(self.type_):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if is_finalvar(self.type_):</span>
<span class="gi">+            self.final = True</span>
<span class="gi">+</span>
<span class="gi">+            if self.type_ is Final:</span>
<span class="gi">+                self.type_ = Any</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.type_ = get_args(self.type_)[0]</span>
<span class="gi">+</span>
<span class="gi">+            self._type_analysis()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        origin = get_origin(self.type_)</span>
<span class="gi">+</span>
<span class="gi">+        if origin is Annotated or is_typeddict_special(origin):</span>
<span class="gi">+            self.type_ = get_args(self.type_)[0]</span>
<span class="gi">+            self._type_analysis()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self.discriminator_key is not None and not is_union(origin):</span>
<span class="gi">+            raise TypeError(&#39;`discriminator` can only be used with `Union` type with more than one variant&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # add extra check for `collections.abc.Hashable` for python 3.10+ where origin is not `None`</span>
<span class="gi">+        if origin is None or origin is CollectionsHashable:</span>
<span class="gi">+            # field is not &quot;typing&quot; object eg. Union, Dict, List etc.</span>
<span class="gi">+            # allow None for virtual superclasses of NoneType, e.g. Hashable</span>
<span class="gi">+            if isinstance(self.type_, type) and isinstance(None, self.type_):</span>
<span class="gi">+                self.allow_none = True</span>
<span class="gi">+            return</span>
<span class="gi">+        elif origin is Callable:</span>
<span class="gi">+            return</span>
<span class="gi">+        elif is_union(origin):</span>
<span class="gi">+            types_ = []</span>
<span class="gi">+            for type_ in get_args(self.type_):</span>
<span class="gi">+                if is_none_type(type_) or type_ is Any or type_ is object:</span>
<span class="gi">+                    if self.required is Undefined:</span>
<span class="gi">+                        self.required = False</span>
<span class="gi">+                    self.allow_none = True</span>
<span class="gi">+                if is_none_type(type_):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                types_.append(type_)</span>
<span class="gi">+</span>
<span class="gi">+            if len(types_) == 1:</span>
<span class="gi">+                # Optional[]</span>
<span class="gi">+                self.type_ = types_[0]</span>
<span class="gi">+                # this is the one case where the &quot;outer type&quot; isn&#39;t just the original type</span>
<span class="gi">+                self.outer_type_ = self.type_</span>
<span class="gi">+                # re-run to correctly interpret the new self.type_</span>
<span class="gi">+                self._type_analysis()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.sub_fields = [self._create_sub_type(t, f&#39;{self.name}_{display_as_type(t)}&#39;) for t in types_]</span>
<span class="gi">+</span>
<span class="gi">+                if self.discriminator_key is not None:</span>
<span class="gi">+                    self.prepare_discriminated_union_sub_fields()</span>
<span class="gi">+            return</span>
<span class="gi">+        elif issubclass(origin, Tuple):  # type: ignore</span>
<span class="gi">+            # origin == Tuple without item type</span>
<span class="gi">+            args = get_args(self.type_)</span>
<span class="gi">+            if not args:  # plain tuple</span>
<span class="gi">+                self.type_ = Any</span>
<span class="gi">+                self.shape = SHAPE_TUPLE_ELLIPSIS</span>
<span class="gi">+            elif len(args) == 2 and args[1] is Ellipsis:  # e.g. Tuple[int, ...]</span>
<span class="gi">+                self.type_ = args[0]</span>
<span class="gi">+                self.shape = SHAPE_TUPLE_ELLIPSIS</span>
<span class="gi">+                self.sub_fields = [self._create_sub_type(args[0], f&#39;{self.name}_0&#39;)]</span>
<span class="gi">+            elif args == ((),):  # Tuple[()] means empty tuple</span>
<span class="gi">+                self.shape = SHAPE_TUPLE</span>
<span class="gi">+                self.type_ = Any</span>
<span class="gi">+                self.sub_fields = []</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.shape = SHAPE_TUPLE</span>
<span class="gi">+                self.sub_fields = [self._create_sub_type(t, f&#39;{self.name}_{i}&#39;) for i, t in enumerate(args)]</span>
<span class="gi">+            return</span>
<span class="gi">+        elif issubclass(origin, List):</span>
<span class="gi">+            # Create self validators</span>
<span class="gi">+            get_validators = getattr(self.type_, &#39;__get_validators__&#39;, None)</span>
<span class="gi">+            if get_validators:</span>
<span class="gi">+                self.class_validators.update(</span>
<span class="gi">+                    {f&#39;list_{i}&#39;: Validator(validator, pre=True) for i, validator in enumerate(get_validators())}</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            self.type_ = get_args(self.type_)[0]</span>
<span class="gi">+            self.shape = SHAPE_LIST</span>
<span class="gi">+        elif issubclass(origin, Set):</span>
<span class="gi">+            # Create self validators</span>
<span class="gi">+            get_validators = getattr(self.type_, &#39;__get_validators__&#39;, None)</span>
<span class="gi">+            if get_validators:</span>
<span class="gi">+                self.class_validators.update(</span>
<span class="gi">+                    {f&#39;set_{i}&#39;: Validator(validator, pre=True) for i, validator in enumerate(get_validators())}</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            self.type_ = get_args(self.type_)[0]</span>
<span class="gi">+            self.shape = SHAPE_SET</span>
<span class="gi">+        elif issubclass(origin, FrozenSet):</span>
<span class="gi">+            # Create self validators</span>
<span class="gi">+            get_validators = getattr(self.type_, &#39;__get_validators__&#39;, None)</span>
<span class="gi">+            if get_validators:</span>
<span class="gi">+                self.class_validators.update(</span>
<span class="gi">+                    {f&#39;frozenset_{i}&#39;: Validator(validator, pre=True) for i, validator in enumerate(get_validators())}</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            self.type_ = get_args(self.type_)[0]</span>
<span class="gi">+            self.shape = SHAPE_FROZENSET</span>
<span class="gi">+        elif issubclass(origin, Deque):</span>
<span class="gi">+            self.type_ = get_args(self.type_)[0]</span>
<span class="gi">+            self.shape = SHAPE_DEQUE</span>
<span class="gi">+        elif issubclass(origin, Sequence):</span>
<span class="gi">+            self.type_ = get_args(self.type_)[0]</span>
<span class="gi">+            self.shape = SHAPE_SEQUENCE</span>
<span class="gi">+        # priority to most common mapping: dict</span>
<span class="gi">+        elif origin is dict or origin is Dict:</span>
<span class="gi">+            self.key_field = self._create_sub_type(get_args(self.type_)[0], &#39;key_&#39; + self.name, for_keys=True)</span>
<span class="gi">+            self.type_ = get_args(self.type_)[1]</span>
<span class="gi">+            self.shape = SHAPE_DICT</span>
<span class="gi">+        elif issubclass(origin, DefaultDict):</span>
<span class="gi">+            self.key_field = self._create_sub_type(get_args(self.type_)[0], &#39;key_&#39; + self.name, for_keys=True)</span>
<span class="gi">+            self.type_ = get_args(self.type_)[1]</span>
<span class="gi">+            self.shape = SHAPE_DEFAULTDICT</span>
<span class="gi">+        elif issubclass(origin, Counter):</span>
<span class="gi">+            self.key_field = self._create_sub_type(get_args(self.type_)[0], &#39;key_&#39; + self.name, for_keys=True)</span>
<span class="gi">+            self.type_ = int</span>
<span class="gi">+            self.shape = SHAPE_COUNTER</span>
<span class="gi">+        elif issubclass(origin, Mapping):</span>
<span class="gi">+            self.key_field = self._create_sub_type(get_args(self.type_)[0], &#39;key_&#39; + self.name, for_keys=True)</span>
<span class="gi">+            self.type_ = get_args(self.type_)[1]</span>
<span class="gi">+            self.shape = SHAPE_MAPPING</span>
<span class="gi">+        # Equality check as almost everything inherits form Iterable, including str</span>
<span class="gi">+        # check for Iterable and CollectionsIterable, as it could receive one even when declared with the other</span>
<span class="gi">+        elif origin in {Iterable, CollectionsIterable}:</span>
<span class="gi">+            self.type_ = get_args(self.type_)[0]</span>
<span class="gi">+            self.shape = SHAPE_ITERABLE</span>
<span class="gi">+            self.sub_fields = [self._create_sub_type(self.type_, f&#39;{self.name}_type&#39;)]</span>
<span class="gi">+        elif issubclass(origin, Type):  # type: ignore</span>
<span class="gi">+            return</span>
<span class="gi">+        elif hasattr(origin, &#39;__get_validators__&#39;) or self.model_config.arbitrary_types_allowed:</span>
<span class="gi">+            # Is a Pydantic-compatible generic that handles itself</span>
<span class="gi">+            # or we have arbitrary_types_allowed = True</span>
<span class="gi">+            self.shape = SHAPE_GENERIC</span>
<span class="gi">+            self.sub_fields = [self._create_sub_type(t, f&#39;{self.name}_{i}&#39;) for i, t in enumerate(get_args(self.type_))]</span>
<span class="gi">+            self.type_ = origin</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&#39;Fields of type &quot;{origin}&quot; are not supported.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # type_ has been refined eg. as the type of a List and sub_fields needs to be populated</span>
<span class="gi">+        self.sub_fields = [self._create_sub_type(self.type_, &#39;_&#39; + self.name)]</span>
<span class="gi">+</span>
<span class="gi">+    def prepare_discriminated_union_sub_fields(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Prepare the mapping &lt;discriminator key&gt; -&gt; &lt;ModelField&gt; and update `sub_fields`
<span class="w"> </span>        Note that this process can be aborted if a `ForwardRef` is encountered
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.discriminator_key is not None</span>
<span class="gi">+</span>
<span class="gi">+        if self.type_.__class__ is DeferredType:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        assert self.sub_fields is not None</span>
<span class="gi">+        sub_fields_mapping: Dict[str, &#39;ModelField&#39;] = {}</span>
<span class="gi">+        all_aliases: Set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        for sub_field in self.sub_fields:</span>
<span class="gi">+            t = sub_field.type_</span>
<span class="gi">+            if t.__class__ is ForwardRef:</span>
<span class="gi">+                # Stopping everything...will need to call `update_forward_refs`</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            alias, discriminator_values = get_discriminator_alias_and_values(t, self.discriminator_key)</span>
<span class="gi">+            all_aliases.add(alias)</span>
<span class="gi">+            for discriminator_value in discriminator_values:</span>
<span class="gi">+                sub_fields_mapping[discriminator_value] = sub_field</span>

<span class="gd">-    def populate_validators(self) -&gt;None:</span>
<span class="gi">+        self.sub_fields_mapping = sub_fields_mapping</span>
<span class="gi">+        self.discriminator_alias = get_unique_discriminator_alias(all_aliases, self.discriminator_key)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_sub_type(self, type_: Type[Any], name: str, *, for_keys: bool = False) -&gt; &#39;ModelField&#39;:</span>
<span class="gi">+        if for_keys:</span>
<span class="gi">+            class_validators = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            # validators for sub items should not have `each_item` as we want to check only the first sublevel</span>
<span class="gi">+            class_validators = {</span>
<span class="gi">+                k: Validator(</span>
<span class="gi">+                    func=v.func,</span>
<span class="gi">+                    pre=v.pre,</span>
<span class="gi">+                    each_item=False,</span>
<span class="gi">+                    always=v.always,</span>
<span class="gi">+                    check_fields=v.check_fields,</span>
<span class="gi">+                    skip_on_failure=v.skip_on_failure,</span>
<span class="gi">+                )</span>
<span class="gi">+                for k, v in self.class_validators.items()</span>
<span class="gi">+                if v.each_item</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        field_info, _ = self._get_field_info(name, type_, None, self.model_config)</span>
<span class="gi">+</span>
<span class="gi">+        return self.__class__(</span>
<span class="gi">+            type_=type_,</span>
<span class="gi">+            name=name,</span>
<span class="gi">+            class_validators=class_validators,</span>
<span class="gi">+            model_config=self.model_config,</span>
<span class="gi">+            field_info=field_info,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def populate_validators(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Prepare self.pre_validators, self.validators, and self.post_validators based on self.type_&#39;s  __get_validators__
<span class="w"> </span>        and class validators. This method should be idempotent, e.g. it should be safe to call multiple times
<span class="w"> </span>        without mis-configuring the field.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.validate_always = getattr(self.type_, &#39;validate_always&#39;, False) or any(</span>
<span class="gi">+            v.always for v in self.class_validators.values()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        class_validators_ = self.class_validators.values()</span>
<span class="gi">+        if not self.sub_fields or self.shape == SHAPE_GENERIC:</span>
<span class="gi">+            get_validators = getattr(self.type_, &#39;__get_validators__&#39;, None)</span>
<span class="gi">+            v_funcs = (</span>
<span class="gi">+                *[v.func for v in class_validators_ if v.each_item and v.pre],</span>
<span class="gi">+                *(get_validators() if get_validators else list(find_validators(self.type_, self.model_config))),</span>
<span class="gi">+                *[v.func for v in class_validators_ if v.each_item and not v.pre],</span>
<span class="gi">+            )</span>
<span class="gi">+            self.validators = prep_validators(v_funcs)</span>
<span class="gi">+</span>
<span class="gi">+        self.pre_validators = []</span>
<span class="gi">+        self.post_validators = []</span>
<span class="gi">+</span>
<span class="gi">+        if self.field_info and self.field_info.const:</span>
<span class="gi">+            self.post_validators.append(make_generic_validator(constant_validator))</span>

<span class="gd">-    def _validate_sequence_like(self, v: Any, values: Dict[str, Any], loc:</span>
<span class="gd">-        &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;]) -&gt;&#39;ValidateReturn&#39;:</span>
<span class="gi">+        if class_validators_:</span>
<span class="gi">+            self.pre_validators += prep_validators(v.func for v in class_validators_ if not v.each_item and v.pre)</span>
<span class="gi">+            self.post_validators += prep_validators(v.func for v in class_validators_ if not v.each_item and not v.pre)</span>
<span class="gi">+</span>
<span class="gi">+        if self.parse_json:</span>
<span class="gi">+            self.pre_validators.append(make_generic_validator(validate_json))</span>
<span class="gi">+</span>
<span class="gi">+        self.pre_validators = self.pre_validators or None</span>
<span class="gi">+        self.post_validators = self.post_validators or None</span>
<span class="gi">+</span>
<span class="gi">+    def validate(</span>
<span class="gi">+        self, v: Any, values: Dict[str, Any], *, loc: &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;] = None</span>
<span class="gi">+    ) -&gt; &#39;ValidateReturn&#39;:</span>
<span class="gi">+        assert self.type_.__class__ is not DeferredType</span>
<span class="gi">+</span>
<span class="gi">+        if self.type_.__class__ is ForwardRef:</span>
<span class="gi">+            assert cls is not None</span>
<span class="gi">+            raise ConfigError(</span>
<span class="gi">+                f&#39;field &quot;{self.name}&quot; not yet prepared so type is still a ForwardRef, &#39;</span>
<span class="gi">+                f&#39;you might need to call {cls.__name__}.update_forward_refs().&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        errors: Optional[&#39;ErrorList&#39;]</span>
<span class="gi">+        if self.pre_validators:</span>
<span class="gi">+            v, errors = self._apply_validators(v, values, loc, cls, self.pre_validators)</span>
<span class="gi">+            if errors:</span>
<span class="gi">+                return v, errors</span>
<span class="gi">+</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            if is_none_type(self.type_):</span>
<span class="gi">+                # keep validating</span>
<span class="gi">+                pass</span>
<span class="gi">+            elif self.allow_none:</span>
<span class="gi">+                if self.post_validators:</span>
<span class="gi">+                    return self._apply_validators(v, values, loc, cls, self.post_validators)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return None, None</span>
<span class="gi">+            else:</span>
<span class="gi">+                return v, ErrorWrapper(NoneIsNotAllowedError(), loc)</span>
<span class="gi">+</span>
<span class="gi">+        if self.shape == SHAPE_SINGLETON:</span>
<span class="gi">+            v, errors = self._validate_singleton(v, values, loc, cls)</span>
<span class="gi">+        elif self.shape in MAPPING_LIKE_SHAPES:</span>
<span class="gi">+            v, errors = self._validate_mapping_like(v, values, loc, cls)</span>
<span class="gi">+        elif self.shape == SHAPE_TUPLE:</span>
<span class="gi">+            v, errors = self._validate_tuple(v, values, loc, cls)</span>
<span class="gi">+        elif self.shape == SHAPE_ITERABLE:</span>
<span class="gi">+            v, errors = self._validate_iterable(v, values, loc, cls)</span>
<span class="gi">+        elif self.shape == SHAPE_GENERIC:</span>
<span class="gi">+            v, errors = self._apply_validators(v, values, loc, cls, self.validators)</span>
<span class="gi">+        else:</span>
<span class="gi">+            #  sequence, list, set, generator, tuple with ellipsis, frozen set</span>
<span class="gi">+            v, errors = self._validate_sequence_like(v, values, loc, cls)</span>
<span class="gi">+</span>
<span class="gi">+        if not errors and self.post_validators:</span>
<span class="gi">+            v, errors = self._apply_validators(v, values, loc, cls, self.post_validators)</span>
<span class="gi">+        return v, errors</span>
<span class="gi">+</span>
<span class="gi">+    def _validate_sequence_like(  # noqa: C901 (ignore complexity)</span>
<span class="gi">+        self, v: Any, values: Dict[str, Any], loc: &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;]</span>
<span class="gi">+    ) -&gt; &#39;ValidateReturn&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Validate sequence-like containers: lists, tuples, sets and generators
<span class="w"> </span>        Note that large if-else blocks are necessary to enable Cython
<span class="w"> </span>        optimization, which is why we disable the complexity check above.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not sequence_like(v):</span>
<span class="gi">+            e: errors_.PydanticTypeError</span>
<span class="gi">+            if self.shape == SHAPE_LIST:</span>
<span class="gi">+                e = errors_.ListError()</span>
<span class="gi">+            elif self.shape in (SHAPE_TUPLE, SHAPE_TUPLE_ELLIPSIS):</span>
<span class="gi">+                e = errors_.TupleError()</span>
<span class="gi">+            elif self.shape == SHAPE_SET:</span>
<span class="gi">+                e = errors_.SetError()</span>
<span class="gi">+            elif self.shape == SHAPE_FROZENSET:</span>
<span class="gi">+                e = errors_.FrozenSetError()</span>
<span class="gi">+            else:</span>
<span class="gi">+                e = errors_.SequenceError()</span>
<span class="gi">+            return v, ErrorWrapper(e, loc)</span>
<span class="gi">+</span>
<span class="gi">+        loc = loc if isinstance(loc, tuple) else (loc,)</span>
<span class="gi">+        result = []</span>
<span class="gi">+        errors: List[ErrorList] = []</span>
<span class="gi">+        for i, v_ in enumerate(v):</span>
<span class="gi">+            v_loc = *loc, i</span>
<span class="gi">+            r, ee = self._validate_singleton(v_, values, v_loc, cls)</span>
<span class="gi">+            if ee:</span>
<span class="gi">+                errors.append(ee)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(r)</span>
<span class="gi">+</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            return v, errors</span>

<span class="gd">-    def _validate_iterable(self, v: Any, values: Dict[str, Any], loc:</span>
<span class="gd">-        &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;]) -&gt;&#39;ValidateReturn&#39;:</span>
<span class="gi">+        converted: Union[List[Any], Set[Any], FrozenSet[Any], Tuple[Any, ...], Iterator[Any], Deque[Any]] = result</span>
<span class="gi">+</span>
<span class="gi">+        if self.shape == SHAPE_SET:</span>
<span class="gi">+            converted = set(result)</span>
<span class="gi">+        elif self.shape == SHAPE_FROZENSET:</span>
<span class="gi">+            converted = frozenset(result)</span>
<span class="gi">+        elif self.shape == SHAPE_TUPLE_ELLIPSIS:</span>
<span class="gi">+            converted = tuple(result)</span>
<span class="gi">+        elif self.shape == SHAPE_DEQUE:</span>
<span class="gi">+            converted = deque(result, maxlen=getattr(v, &#39;maxlen&#39;, None))</span>
<span class="gi">+        elif self.shape == SHAPE_SEQUENCE:</span>
<span class="gi">+            if isinstance(v, tuple):</span>
<span class="gi">+                converted = tuple(result)</span>
<span class="gi">+            elif isinstance(v, set):</span>
<span class="gi">+                converted = set(result)</span>
<span class="gi">+            elif isinstance(v, Generator):</span>
<span class="gi">+                converted = iter(result)</span>
<span class="gi">+            elif isinstance(v, deque):</span>
<span class="gi">+                converted = deque(result, maxlen=getattr(v, &#39;maxlen&#39;, None))</span>
<span class="gi">+        return converted, None</span>
<span class="gi">+</span>
<span class="gi">+    def _validate_iterable(</span>
<span class="gi">+        self, v: Any, values: Dict[str, Any], loc: &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;]</span>
<span class="gi">+    ) -&gt; &#39;ValidateReturn&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Validate Iterables.

<span class="w"> </span>        This intentionally doesn&#39;t validate values to allow infinite generators.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _get_mapping_value(self, original: T, converted: Dict[Any, Any]</span>
<span class="gd">-        ) -&gt;Union[T, Dict[Any, Any]]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            iterable = iter(v)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            return v, ErrorWrapper(errors_.IterableError(), loc)</span>
<span class="gi">+        return iterable, None</span>
<span class="gi">+</span>
<span class="gi">+    def _validate_tuple(</span>
<span class="gi">+        self, v: Any, values: Dict[str, Any], loc: &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;]</span>
<span class="gi">+    ) -&gt; &#39;ValidateReturn&#39;:</span>
<span class="gi">+        e: Optional[Exception] = None</span>
<span class="gi">+        if not sequence_like(v):</span>
<span class="gi">+            e = errors_.TupleError()</span>
<span class="gi">+        else:</span>
<span class="gi">+            actual_length, expected_length = len(v), len(self.sub_fields)  # type: ignore</span>
<span class="gi">+            if actual_length != expected_length:</span>
<span class="gi">+                e = errors_.TupleLengthError(actual_length=actual_length, expected_length=expected_length)</span>
<span class="gi">+</span>
<span class="gi">+        if e:</span>
<span class="gi">+            return v, ErrorWrapper(e, loc)</span>
<span class="gi">+</span>
<span class="gi">+        loc = loc if isinstance(loc, tuple) else (loc,)</span>
<span class="gi">+        result = []</span>
<span class="gi">+        errors: List[ErrorList] = []</span>
<span class="gi">+        for i, (v_, field) in enumerate(zip(v, self.sub_fields)):  # type: ignore</span>
<span class="gi">+            v_loc = *loc, i</span>
<span class="gi">+            r, ee = field.validate(v_, values, loc=v_loc, cls=cls)</span>
<span class="gi">+            if ee:</span>
<span class="gi">+                errors.append(ee)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(r)</span>
<span class="gi">+</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            return v, errors</span>
<span class="gi">+        else:</span>
<span class="gi">+            return tuple(result), None</span>
<span class="gi">+</span>
<span class="gi">+    def _validate_mapping_like(</span>
<span class="gi">+        self, v: Any, values: Dict[str, Any], loc: &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;]</span>
<span class="gi">+    ) -&gt; &#39;ValidateReturn&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            v_iter = dict_validator(v)</span>
<span class="gi">+        except TypeError as exc:</span>
<span class="gi">+            return v, ErrorWrapper(exc, loc)</span>
<span class="gi">+</span>
<span class="gi">+        loc = loc if isinstance(loc, tuple) else (loc,)</span>
<span class="gi">+        result, errors = {}, []</span>
<span class="gi">+        for k, v_ in v_iter.items():</span>
<span class="gi">+            v_loc = *loc, &#39;__key__&#39;</span>
<span class="gi">+            key_result, key_errors = self.key_field.validate(k, values, loc=v_loc, cls=cls)  # type: ignore</span>
<span class="gi">+            if key_errors:</span>
<span class="gi">+                errors.append(key_errors)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            v_loc = *loc, k</span>
<span class="gi">+            value_result, value_errors = self._validate_singleton(v_, values, v_loc, cls)</span>
<span class="gi">+            if value_errors:</span>
<span class="gi">+                errors.append(value_errors)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            result[key_result] = value_result</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            return v, errors</span>
<span class="gi">+        elif self.shape == SHAPE_DICT:</span>
<span class="gi">+            return result, None</span>
<span class="gi">+        elif self.shape == SHAPE_DEFAULTDICT:</span>
<span class="gi">+            return defaultdict(self.type_, result), None</span>
<span class="gi">+        elif self.shape == SHAPE_COUNTER:</span>
<span class="gi">+            return CollectionCounter(result), None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._get_mapping_value(v, result), None</span>
<span class="gi">+</span>
<span class="gi">+    def _get_mapping_value(self, original: T, converted: Dict[Any, Any]) -&gt; Union[T, Dict[Any, Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        When type is `Mapping[KT, KV]` (or another unsupported mapping), we try to avoid
<span class="w"> </span>        coercing to `dict` unwillingly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        original_cls = original.__class__</span>
<span class="gi">+</span>
<span class="gi">+        if original_cls == dict or original_cls == Dict:</span>
<span class="gi">+            return converted</span>
<span class="gi">+        elif original_cls in {defaultdict, DefaultDict}:</span>
<span class="gi">+            return defaultdict(self.type_, converted)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Counter, OrderedDict, UserDict, ...</span>
<span class="gi">+                return original_cls(converted)  # type: ignore</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                raise RuntimeError(f&#39;Could not convert dictionary to {original_cls.__name__!r}&#39;) from None</span>
<span class="gi">+</span>
<span class="gi">+    def _validate_singleton(</span>
<span class="gi">+        self, v: Any, values: Dict[str, Any], loc: &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;]</span>
<span class="gi">+    ) -&gt; &#39;ValidateReturn&#39;:</span>
<span class="gi">+        if self.sub_fields:</span>
<span class="gi">+            if self.discriminator_key is not None:</span>
<span class="gi">+                return self._validate_discriminated_union(v, values, loc, cls)</span>
<span class="gi">+</span>
<span class="gi">+            errors = []</span>
<span class="gi">+</span>
<span class="gi">+            if self.model_config.smart_union and is_union(get_origin(self.type_)):</span>
<span class="gi">+                # 1st pass: check if the value is an exact instance of one of the Union types</span>
<span class="gi">+                # (e.g. to avoid coercing a bool into an int)</span>
<span class="gi">+                for field in self.sub_fields:</span>
<span class="gi">+                    if v.__class__ is field.outer_type_:</span>
<span class="gi">+                        return v, None</span>
<span class="gi">+</span>
<span class="gi">+                # 2nd pass: check if the value is an instance of any subclass of the Union types</span>
<span class="gi">+                for field in self.sub_fields:</span>
<span class="gi">+                    # This whole logic will be improved later on to support more complex `isinstance` checks</span>
<span class="gi">+                    # It will probably be done once a strict mode is added and be something like:</span>
<span class="gi">+                    # ```</span>
<span class="gi">+                    #     value, error = field.validate(v, values, strict=True)</span>
<span class="gi">+                    #     if error is None:</span>
<span class="gi">+                    #         return value, None</span>
<span class="gi">+                    # ```</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        if isinstance(v, field.outer_type_):</span>
<span class="gi">+                            return v, None</span>
<span class="gi">+                    except TypeError:</span>
<span class="gi">+                        # compound type</span>
<span class="gi">+                        if lenient_isinstance(v, get_origin(field.outer_type_)):</span>
<span class="gi">+                            value, error = field.validate(v, values, loc=loc, cls=cls)</span>
<span class="gi">+                            if not error:</span>
<span class="gi">+                                return value, None</span>
<span class="gi">+</span>
<span class="gi">+            # 1st pass by default or 3rd pass with `smart_union` enabled:</span>
<span class="gi">+            # check if the value can be coerced into one of the Union types</span>
<span class="gi">+            for field in self.sub_fields:</span>
<span class="gi">+                value, error = field.validate(v, values, loc=loc, cls=cls)</span>
<span class="gi">+                if error:</span>
<span class="gi">+                    errors.append(error)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return value, None</span>
<span class="gi">+            return v, errors</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._apply_validators(v, values, loc, cls, self.validators)</span>
<span class="gi">+</span>
<span class="gi">+    def _validate_discriminated_union(</span>
<span class="gi">+        self, v: Any, values: Dict[str, Any], loc: &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;]</span>
<span class="gi">+    ) -&gt; &#39;ValidateReturn&#39;:</span>
<span class="gi">+        assert self.discriminator_key is not None</span>
<span class="gi">+        assert self.discriminator_alias is not None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            try:</span>
<span class="gi">+                discriminator_value = v[self.discriminator_alias]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                if self.model_config.allow_population_by_field_name:</span>
<span class="gi">+                    discriminator_value = v[self.discriminator_key]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return v, ErrorWrapper(MissingDiscriminator(discriminator_key=self.discriminator_key), loc)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # BaseModel or dataclass</span>
<span class="gi">+                discriminator_value = getattr(v, self.discriminator_key)</span>
<span class="gi">+            except (AttributeError, TypeError):</span>
<span class="gi">+                return v, ErrorWrapper(MissingDiscriminator(discriminator_key=self.discriminator_key), loc)</span>

<span class="gd">-    def is_complex(self) -&gt;bool:</span>
<span class="gi">+        if self.sub_fields_mapping is None:</span>
<span class="gi">+            assert cls is not None</span>
<span class="gi">+            raise ConfigError(</span>
<span class="gi">+                f&#39;field &quot;{self.name}&quot; not yet prepared so type is still a ForwardRef, &#39;</span>
<span class="gi">+                f&#39;you might need to call {cls.__name__}.update_forward_refs().&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            sub_field = self.sub_fields_mapping[discriminator_value]</span>
<span class="gi">+        except (KeyError, TypeError):</span>
<span class="gi">+            # KeyError: `discriminator_value` is not in the dictionary.</span>
<span class="gi">+            # TypeError: `discriminator_value` is unhashable.</span>
<span class="gi">+            assert self.sub_fields_mapping is not None</span>
<span class="gi">+            return v, ErrorWrapper(</span>
<span class="gi">+                InvalidDiscriminator(</span>
<span class="gi">+                    discriminator_key=self.discriminator_key,</span>
<span class="gi">+                    discriminator_value=discriminator_value,</span>
<span class="gi">+                    allowed_values=list(self.sub_fields_mapping),</span>
<span class="gi">+                ),</span>
<span class="gi">+                loc,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not isinstance(loc, tuple):</span>
<span class="gi">+                loc = (loc,)</span>
<span class="gi">+            return sub_field.validate(v, values, loc=(*loc, display_as_type(sub_field.type_)), cls=cls)</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_validators(</span>
<span class="gi">+        self, v: Any, values: Dict[str, Any], loc: &#39;LocStr&#39;, cls: Optional[&#39;ModelOrDc&#39;], validators: &#39;ValidatorsList&#39;</span>
<span class="gi">+    ) -&gt; &#39;ValidateReturn&#39;:</span>
<span class="gi">+        for validator in validators:</span>
<span class="gi">+            try:</span>
<span class="gi">+                v = validator(cls, v, values, self, self.model_config)</span>
<span class="gi">+            except (ValueError, TypeError, AssertionError) as exc:</span>
<span class="gi">+                return v, ErrorWrapper(exc, loc)</span>
<span class="gi">+        return v, None</span>
<span class="gi">+</span>
<span class="gi">+    def is_complex(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Whether the field is &quot;complex&quot; eg. env variables should be parsed as JSON.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pydantic.v1.main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.shape != SHAPE_SINGLETON</span>
<span class="gi">+            or hasattr(self.type_, &#39;__pydantic_model__&#39;)</span>
<span class="gi">+            or lenient_issubclass(self.type_, (BaseModel, list, set, frozenset, dict))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _type_display(self) -&gt; PyObjectStr:</span>
<span class="gi">+        t = display_as_type(self.type_)</span>
<span class="gi">+</span>
<span class="gi">+        if self.shape in MAPPING_LIKE_SHAPES:</span>
<span class="gi">+            t = f&#39;Mapping[{display_as_type(self.key_field.type_)}, {t}]&#39;  # type: ignore</span>
<span class="gi">+        elif self.shape == SHAPE_TUPLE:</span>
<span class="gi">+            t = &#39;Tuple[{}]&#39;.format(&#39;, &#39;.join(display_as_type(f.type_) for f in self.sub_fields))  # type: ignore</span>
<span class="gi">+        elif self.shape == SHAPE_GENERIC:</span>
<span class="gi">+            assert self.sub_fields</span>
<span class="gi">+            t = &#39;{}[{}]&#39;.format(</span>
<span class="gi">+                display_as_type(self.type_), &#39;, &#39;.join(display_as_type(f.type_) for f in self.sub_fields)</span>
<span class="gi">+            )</span>
<span class="gi">+        elif self.shape != SHAPE_SINGLETON:</span>
<span class="gi">+            t = SHAPE_NAME_LOOKUP[self.shape].format(t)</span>
<span class="gi">+</span>
<span class="gi">+        if self.allow_none and (self.shape != SHAPE_SINGLETON or not self.sub_fields):</span>
<span class="gi">+            t = f&#39;Optional[{t}]&#39;</span>
<span class="gi">+        return PyObjectStr(t)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="gi">+        args = [(&#39;name&#39;, self.name), (&#39;type&#39;, self._type_display()), (&#39;required&#39;, self.required)]</span>

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gd">-        args = [(&#39;name&#39;, self.name), (&#39;type&#39;, self._type_display()), (</span>
<span class="gd">-            &#39;required&#39;, self.required)]</span>
<span class="w"> </span>        if not self.required:
<span class="w"> </span>            if self.default_factory is not None:
<span class="gd">-                args.append((&#39;default_factory&#39;,</span>
<span class="gd">-                    f&#39;&lt;function {self.default_factory.__name__}&gt;&#39;))</span>
<span class="gi">+                args.append((&#39;default_factory&#39;, f&#39;&lt;function {self.default_factory.__name__}&gt;&#39;))</span>
<span class="w"> </span>            else:
<span class="w"> </span>                args.append((&#39;default&#39;, self.default))
<span class="gi">+</span>
<span class="w"> </span>        if self.alt_alias:
<span class="w"> </span>            args.append((&#39;alias&#39;, self.alias))
<span class="w"> </span>        return args


<span class="w"> </span>class ModelPrivateAttr(Representation):
<span class="gd">-    __slots__ = &#39;default&#39;, &#39;default_factory&#39;</span>
<span class="gi">+    __slots__ = (&#39;default&#39;, &#39;default_factory&#39;)</span>

<span class="gd">-    def __init__(self, default: Any=Undefined, *, default_factory: Optional</span>
<span class="gd">-        [NoArgAnyCallable]=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, default: Any = Undefined, *, default_factory: Optional[NoArgAnyCallable] = None) -&gt; None:</span>
<span class="w"> </span>        self.default = default
<span class="w"> </span>        self.default_factory = default_factory

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, self.__class__) and (self.default, self.</span>
<span class="gd">-            default_factory) == (other.default, other.default_factory)</span>
<span class="gi">+    def get_default(self) -&gt; Any:</span>
<span class="gi">+        return smart_deepcopy(self.default) if self.default_factory is None else self.default_factory()</span>
<span class="gi">+</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, self.__class__) and (self.default, self.default_factory) == (</span>
<span class="gi">+            other.default,</span>
<span class="gi">+            other.default_factory,</span>
<span class="gi">+        )</span>


<span class="gd">-def PrivateAttr(default: Any=Undefined, *, default_factory: Optional[</span>
<span class="gd">-    NoArgAnyCallable]=None) -&gt;Any:</span>
<span class="gi">+def PrivateAttr(</span>
<span class="gi">+    default: Any = Undefined,</span>
<span class="gi">+    *,</span>
<span class="gi">+    default_factory: Optional[NoArgAnyCallable] = None,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Indicates that attribute is only used internally and never mixed with regular fields.

<span class="gu">@@ -362,10 +1234,20 @@ def PrivateAttr(default: Any=Undefined, *, default_factory: Optional[</span>
<span class="w"> </span>    :param default_factory: callable that will be called when a default value is needed for this attribute
<span class="w"> </span>      If both `default` and `default_factory` are set, an error is raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default is not Undefined and default_factory is not None:</span>
<span class="gi">+        raise ValueError(&#39;cannot specify both default and default_factory&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return ModelPrivateAttr(</span>
<span class="gi">+        default,</span>
<span class="gi">+        default_factory=default_factory,</span>
<span class="gi">+    )</span>


<span class="w"> </span>class DeferredType:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Used to postpone field preparation, while creating recursive generic models.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_finalvar_with_default_val(type_: Type[Any], val: Any) -&gt; bool:</span>
<span class="gi">+    return is_finalvar(type_) and val is not Undefined and not isinstance(val, FieldInfo)</span>
<span class="gh">diff --git a/pydantic/v1/generics.py b/pydantic/v1/generics.py</span>
<span class="gh">index 2211c7798..9a69f2b39 100644</span>
<span class="gd">--- a/pydantic/v1/generics.py</span>
<span class="gi">+++ b/pydantic/v1/generics.py</span>
<span class="gu">@@ -1,41 +1,78 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="w"> </span>import typing
<span class="gd">-from typing import TYPE_CHECKING, Any, ClassVar, Dict, ForwardRef, Generic, Iterator, List, Mapping, Optional, Tuple, Type, TypeVar, Union, cast</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    ClassVar,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    ForwardRef,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+)</span>
<span class="w"> </span>from weakref import WeakKeyDictionary, WeakValueDictionary
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Annotated, Literal as ExtLiteral
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.class_validators import gather_all_validators
<span class="w"> </span>from pydantic.v1.fields import DeferredType
<span class="w"> </span>from pydantic.v1.main import BaseModel, create_model
<span class="w"> </span>from pydantic.v1.types import JsonWrapper
<span class="w"> </span>from pydantic.v1.typing import display_as_type, get_all_type_hints, get_args, get_origin, typing_base
<span class="w"> </span>from pydantic.v1.utils import all_identical, lenient_issubclass
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):
<span class="w"> </span>    from typing import _UnionGenericAlias
<span class="w"> </span>if sys.version_info &gt;= (3, 8):
<span class="w"> </span>    from typing import Literal
<span class="gi">+</span>
<span class="w"> </span>GenericModelT = TypeVar(&#39;GenericModelT&#39;, bound=&#39;GenericModel&#39;)
<span class="gd">-TypeVarType = Any</span>
<span class="gi">+TypeVarType = Any  # since mypy doesn&#39;t allow the use of TypeVar as a type</span>
<span class="gi">+</span>
<span class="w"> </span>CacheKey = Tuple[Type[Any], Any, Tuple[Any, ...]]
<span class="w"> </span>Parametrization = Mapping[TypeVarType, Type[Any]]
<span class="gd">-if sys.version_info &gt;= (3, 9):</span>
<span class="gi">+</span>
<span class="gi">+# weak dictionaries allow the dynamically created parametrized versions of generic models to get collected</span>
<span class="gi">+# once they are no longer referenced by the caller.</span>
<span class="gi">+if sys.version_info &gt;= (3, 9):  # Typing for weak dictionaries available at 3.9</span>
<span class="w"> </span>    GenericTypesCache = WeakValueDictionary[CacheKey, Type[BaseModel]]
<span class="w"> </span>    AssignedParameters = WeakKeyDictionary[Type[BaseModel], Parametrization]
<span class="w"> </span>else:
<span class="w"> </span>    GenericTypesCache = WeakValueDictionary
<span class="w"> </span>    AssignedParameters = WeakKeyDictionary
<span class="gi">+</span>
<span class="gi">+# _generic_types_cache is a Mapping from __class_getitem__ arguments to the parametrized version of generic models.</span>
<span class="gi">+# This ensures multiple calls of e.g. A[B] return always the same class.</span>
<span class="w"> </span>_generic_types_cache = GenericTypesCache()
<span class="gi">+</span>
<span class="gi">+# _assigned_parameters is a Mapping from parametrized version of generic models to assigned types of parametrizations</span>
<span class="gi">+# as captured during construction of the class (not instances).</span>
<span class="gi">+# E.g., for generic model `Model[A, B]`, when parametrized model `Model[int, str]` is created,</span>
<span class="gi">+# `Model[int, str]`: {A: int, B: str}` will be stored in `_assigned_parameters`.</span>
<span class="gi">+# (This information is only otherwise available after creation from the class name string).</span>
<span class="w"> </span>_assigned_parameters = AssignedParameters()


<span class="w"> </span>class GenericModel(BaseModel):
<span class="w"> </span>    __slots__ = ()
<span class="w"> </span>    __concrete__: ClassVar[bool] = False
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="gi">+        # Putting this in a TYPE_CHECKING block allows us to replace `if Generic not in cls.__bases__` with</span>
<span class="gi">+        # `not hasattr(cls, &quot;__parameters__&quot;)`. This means we don&#39;t need to force non-concrete subclasses of</span>
<span class="gi">+        # `GenericModel` to also inherit from `Generic`, which would require changes to the use of `create_model` below.</span>
<span class="w"> </span>        __parameters__: ClassVar[Tuple[TypeVarType, ...]]

<span class="gd">-    def __class_getitem__(cls: Type[GenericModelT], params: Union[Type[Any],</span>
<span class="gd">-        Tuple[Type[Any], ...]]) -&gt;Type[Any]:</span>
<span class="gi">+    # Setting the return type as Type[Any] instead of Type[BaseModel] prevents PyCharm warnings</span>
<span class="gi">+    def __class_getitem__(cls: Type[GenericModelT], params: Union[Type[Any], Tuple[Type[Any], ...]]) -&gt; Type[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Instantiates a new class from a generic class `cls` and type variables `params`.

<span class="w"> </span>        :param params: Tuple of types the class . Given a generic class
<span class="gu">@@ -47,72 +84,91 @@ class GenericModel(BaseModel):</span>

<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-        def _cache_key(_params: Any) -&gt;CacheKey:</span>
<span class="gi">+        def _cache_key(_params: Any) -&gt; CacheKey:</span>
<span class="w"> </span>            args = get_args(_params)
<span class="gi">+            # python returns a list for Callables, which is not hashable</span>
<span class="w"> </span>            if len(args) == 2 and isinstance(args[0], list):
<span class="gd">-                args = tuple(args[0]), args[1]</span>
<span class="gi">+                args = (tuple(args[0]), args[1])</span>
<span class="w"> </span>            return cls, _params, args
<span class="gi">+</span>
<span class="w"> </span>        cached = _generic_types_cache.get(_cache_key(params))
<span class="w"> </span>        if cached is not None:
<span class="w"> </span>            return cached
<span class="w"> </span>        if cls.__concrete__ and Generic not in cls.__bases__:
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                &#39;Cannot parameterize a concrete instantiation of a generic model&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise TypeError(&#39;Cannot parameterize a concrete instantiation of a generic model&#39;)</span>
<span class="w"> </span>        if not isinstance(params, tuple):
<span class="gd">-            params = params,</span>
<span class="gd">-        if cls is GenericModel and any(isinstance(param, TypeVar) for param in</span>
<span class="gd">-            params):</span>
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                &#39;Type parameters should be placed on typing.Generic, not GenericModel&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            params = (params,)</span>
<span class="gi">+        if cls is GenericModel and any(isinstance(param, TypeVar) for param in params):</span>
<span class="gi">+            raise TypeError(&#39;Type parameters should be placed on typing.Generic, not GenericModel&#39;)</span>
<span class="w"> </span>        if not hasattr(cls, &#39;__parameters__&#39;):
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                f&#39;Type {cls.__name__} must inherit from typing.Generic before being parameterized&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise TypeError(f&#39;Type {cls.__name__} must inherit from typing.Generic before being parameterized&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>        check_parameters_count(cls, params)
<span class="gd">-        typevars_map: Dict[TypeVarType, Type[Any]] = dict(zip(cls.</span>
<span class="gd">-            __parameters__, params))</span>
<span class="gd">-        if all_identical(typevars_map.keys(), typevars_map.values()</span>
<span class="gd">-            ) and typevars_map:</span>
<span class="gd">-            return cls</span>
<span class="gi">+        # Build map from generic typevars to passed params</span>
<span class="gi">+        typevars_map: Dict[TypeVarType, Type[Any]] = dict(zip(cls.__parameters__, params))</span>
<span class="gi">+        if all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:</span>
<span class="gi">+            return cls  # if arguments are equal to parameters it&#39;s the same object</span>
<span class="gi">+</span>
<span class="gi">+        # Create new model with original model as parent inserting fields with DeferredType.</span>
<span class="w"> </span>        model_name = cls.__concrete_name__(params)
<span class="w"> </span>        validators = gather_all_validators(cls)
<span class="gi">+</span>
<span class="w"> </span>        type_hints = get_all_type_hints(cls).items()
<span class="gd">-        instance_type_hints = {k: v for k, v in type_hints if get_origin(v)</span>
<span class="gd">-             is not ClassVar}</span>
<span class="gd">-        fields = {k: (DeferredType(), cls.__fields__[k].field_info) for k in</span>
<span class="gd">-            instance_type_hints if k in cls.__fields__}</span>
<span class="gi">+        instance_type_hints = {k: v for k, v in type_hints if get_origin(v) is not ClassVar}</span>
<span class="gi">+</span>
<span class="gi">+        fields = {k: (DeferredType(), cls.__fields__[k].field_info) for k in instance_type_hints if k in cls.__fields__}</span>
<span class="gi">+</span>
<span class="w"> </span>        model_module, called_globally = get_caller_frame_info()
<span class="gd">-        created_model = cast(Type[GenericModel], create_model(model_name,</span>
<span class="gd">-            __module__=model_module or cls.__module__, __base__=(cls,) +</span>
<span class="gd">-            tuple(cls.__parameterized_bases__(typevars_map)), __config__=</span>
<span class="gd">-            None, __validators__=validators, __cls_kwargs__=None, **fields))</span>
<span class="gi">+        created_model = cast(</span>
<span class="gi">+            Type[GenericModel],  # casting ensures mypy is aware of the __concrete__ and __parameters__ attributes</span>
<span class="gi">+            create_model(</span>
<span class="gi">+                model_name,</span>
<span class="gi">+                __module__=model_module or cls.__module__,</span>
<span class="gi">+                __base__=(cls,) + tuple(cls.__parameterized_bases__(typevars_map)),</span>
<span class="gi">+                __config__=None,</span>
<span class="gi">+                __validators__=validators,</span>
<span class="gi">+                __cls_kwargs__=None,</span>
<span class="gi">+                **fields,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        _assigned_parameters[created_model] = typevars_map
<span class="gd">-        if called_globally:</span>
<span class="gi">+</span>
<span class="gi">+        if called_globally:  # create global reference and therefore allow pickling</span>
<span class="w"> </span>            object_by_reference = None
<span class="w"> </span>            reference_name = model_name
<span class="gd">-            reference_module_globals = sys.modules[created_model.__module__</span>
<span class="gd">-                ].__dict__</span>
<span class="gi">+            reference_module_globals = sys.modules[created_model.__module__].__dict__</span>
<span class="w"> </span>            while object_by_reference is not created_model:
<span class="gd">-                object_by_reference = reference_module_globals.setdefault(</span>
<span class="gd">-                    reference_name, created_model)</span>
<span class="gi">+                object_by_reference = reference_module_globals.setdefault(reference_name, created_model)</span>
<span class="w"> </span>                reference_name += &#39;_&#39;
<span class="gi">+</span>
<span class="w"> </span>        created_model.Config = cls.Config
<span class="gd">-        new_params = tuple({param: None for param in</span>
<span class="gd">-            iter_contained_typevars(typevars_map.values())})</span>
<span class="gi">+</span>
<span class="gi">+        # Find any typevars that are still present in the model.</span>
<span class="gi">+        # If none are left, the model is fully &quot;concrete&quot;, otherwise the new</span>
<span class="gi">+        # class is a generic class as well taking the found typevars as</span>
<span class="gi">+        # parameters.</span>
<span class="gi">+        new_params = tuple(</span>
<span class="gi">+            {param: None for param in iter_contained_typevars(typevars_map.values())}</span>
<span class="gi">+        )  # use dict as ordered set</span>
<span class="w"> </span>        created_model.__concrete__ = not new_params
<span class="w"> </span>        if new_params:
<span class="w"> </span>            created_model.__parameters__ = new_params
<span class="gi">+</span>
<span class="gi">+        # Save created model in cache so we don&#39;t end up creating duplicate</span>
<span class="gi">+        # models that should be identical.</span>
<span class="w"> </span>        _generic_types_cache[_cache_key(params)] = created_model
<span class="w"> </span>        if len(params) == 1:
<span class="w"> </span>            _generic_types_cache[_cache_key(params[0])] = created_model
<span class="gd">-        _prepare_model_fields(created_model, fields, instance_type_hints,</span>
<span class="gd">-            typevars_map)</span>
<span class="gi">+</span>
<span class="gi">+        # Recursively walk class type hints and replace generic typevars</span>
<span class="gi">+        # with concrete types that were passed.</span>
<span class="gi">+        _prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)</span>
<span class="gi">+</span>
<span class="w"> </span>        return created_model

<span class="w"> </span>    @classmethod
<span class="gd">-    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...]) -&gt;str:</span>
<span class="gi">+    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compute class name for child classes.

<span class="w"> </span>        :param params: Tuple of types the class . Given a generic class
<span class="gu">@@ -128,8 +184,7 @@ class GenericModel(BaseModel):</span>
<span class="w"> </span>        return f&#39;{cls.__name__}[{params_component}]&#39;

<span class="w"> </span>    @classmethod
<span class="gd">-    def __parameterized_bases__(cls, typevars_map: Parametrization) -&gt;Iterator[</span>
<span class="gd">-        Type[Any]]:</span>
<span class="gi">+    def __parameterized_bases__(cls, typevars_map: Parametrization) -&gt; Iterator[Type[Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns unbound bases of cls parameterised to given type variables

<span class="gu">@@ -152,32 +207,48 @@ class GenericModel(BaseModel):</span>
<span class="w"> </span>        ```
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-        def build_base_model(base_model: Type[GenericModel], mapped_types:</span>
<span class="gd">-            Parametrization) -&gt;Iterator[Type[GenericModel]]:</span>
<span class="gd">-            base_parameters = tuple(mapped_types[param] for param in</span>
<span class="gd">-                base_model.__parameters__)</span>
<span class="gi">+        def build_base_model(</span>
<span class="gi">+            base_model: Type[GenericModel], mapped_types: Parametrization</span>
<span class="gi">+        ) -&gt; Iterator[Type[GenericModel]]:</span>
<span class="gi">+            base_parameters = tuple(mapped_types[param] for param in base_model.__parameters__)</span>
<span class="w"> </span>            parameterized_base = base_model.__class_getitem__(base_parameters)
<span class="w"> </span>            if parameterized_base is base_model or parameterized_base is cls:
<span class="gi">+                # Avoid duplication in MRO</span>
<span class="w"> </span>                return
<span class="w"> </span>            yield parameterized_base
<span class="gi">+</span>
<span class="w"> </span>        for base_model in cls.__bases__:
<span class="w"> </span>            if not issubclass(base_model, GenericModel):
<span class="gi">+                # not a class that can be meaningfully parameterized</span>
<span class="w"> </span>                continue
<span class="w"> </span>            elif not getattr(base_model, &#39;__parameters__&#39;, None):
<span class="gi">+                # base_model is &quot;GenericModel&quot;  (and has no __parameters__)</span>
<span class="gi">+                # or</span>
<span class="gi">+                # base_model is already concrete, and will be included transitively via cls.</span>
<span class="w"> </span>                continue
<span class="w"> </span>            elif cls in _assigned_parameters:
<span class="w"> </span>                if base_model in _assigned_parameters:
<span class="gi">+                    # cls is partially parameterised but not from base_model</span>
<span class="gi">+                    # e.g. cls = B[S], base_model = A[S]</span>
<span class="gi">+                    # B[S][int] should subclass A[int],  (and will be transitively via B[int])</span>
<span class="gi">+                    # but it&#39;s not viable to consistently subclass types with arbitrary construction</span>
<span class="gi">+                    # So don&#39;t attempt to include A[S][int]</span>
<span class="w"> </span>                    continue
<span class="gd">-                else:</span>
<span class="gd">-                    mapped_types: Parametrization = {key: typevars_map.get(</span>
<span class="gd">-                        value, value) for key, value in</span>
<span class="gd">-                        _assigned_parameters[cls].items()}</span>
<span class="gi">+                else:  # base_model not in _assigned_parameters:</span>
<span class="gi">+                    # cls is partially parameterized, base_model is original generic</span>
<span class="gi">+                    # e.g.  cls = B[str, T], base_model = B[S, T]</span>
<span class="gi">+                    # Need to determine the mapping for the base_model parameters</span>
<span class="gi">+                    mapped_types: Parametrization = {</span>
<span class="gi">+                        key: typevars_map.get(value, value) for key, value in _assigned_parameters[cls].items()</span>
<span class="gi">+                    }</span>
<span class="w"> </span>                    yield from build_base_model(base_model, mapped_types)
<span class="w"> </span>            else:
<span class="gi">+                # cls is base generic, so base_class has a distinct base</span>
<span class="gi">+                # can construct the Parameterised base model using typevars_map directly</span>
<span class="w"> </span>                yield from build_base_model(base_model, typevars_map)


<span class="gd">-def replace_types(type_: Any, type_map: Mapping[Any, Any]) -&gt;Any:</span>
<span class="gi">+def replace_types(type_: Any, type_map: Mapping[Any, Any]) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return type with all occurrences of `type_map` keys recursively replaced with their values.

<span class="w"> </span>    :param type_: Any type, class or generic alias
<span class="gu">@@ -189,18 +260,103 @@ def replace_types(type_: Any, type_map: Mapping[Any, Any]) -&gt;Any:</span>
<span class="w"> </span>    Tuple[int, Union[List[int], float]]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not type_map:</span>
<span class="gi">+        return type_</span>
<span class="gi">+</span>
<span class="gi">+    type_args = get_args(type_)</span>
<span class="gi">+    origin_type = get_origin(type_)</span>
<span class="gi">+</span>
<span class="gi">+    if origin_type is Annotated:</span>
<span class="gi">+        annotated_type, *annotations = type_args</span>
<span class="gi">+        return Annotated[replace_types(annotated_type, type_map), tuple(annotations)]</span>
<span class="gi">+</span>
<span class="gi">+    if (origin_type is ExtLiteral) or (sys.version_info &gt;= (3, 8) and origin_type is Literal):</span>
<span class="gi">+        return type_map.get(type_, type_)</span>
<span class="gi">+    # Having type args is a good indicator that this is a typing module</span>
<span class="gi">+    # class instantiation or a generic alias of some sort.</span>
<span class="gi">+    if type_args:</span>
<span class="gi">+        resolved_type_args = tuple(replace_types(arg, type_map) for arg in type_args)</span>
<span class="gi">+        if all_identical(type_args, resolved_type_args):</span>
<span class="gi">+            # If all arguments are the same, there is no need to modify the</span>
<span class="gi">+            # type or create a new object at all</span>
<span class="gi">+            return type_</span>
<span class="gi">+        if (</span>
<span class="gi">+            origin_type is not None</span>
<span class="gi">+            and isinstance(type_, typing_base)</span>
<span class="gi">+            and not isinstance(origin_type, typing_base)</span>
<span class="gi">+            and getattr(type_, &#39;_name&#39;, None) is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            # In python &lt; 3.9 generic aliases don&#39;t exist so any of these like `list`,</span>
<span class="gi">+            # `type` or `collections.abc.Callable` need to be translated.</span>
<span class="gi">+            # See: https://www.python.org/dev/peps/pep-0585</span>
<span class="gi">+            origin_type = getattr(typing, type_._name)</span>
<span class="gi">+        assert origin_type is not None</span>
<span class="gi">+        # PEP-604 syntax (Ex.: list | str) is represented with a types.UnionType object that does not have __getitem__.</span>
<span class="gi">+        # We also cannot use isinstance() since we have to compare types.</span>
<span class="gi">+        if sys.version_info &gt;= (3, 10) and origin_type is types.UnionType:  # noqa: E721</span>
<span class="gi">+            return _UnionGenericAlias(origin_type, resolved_type_args)</span>
<span class="gi">+        return origin_type[resolved_type_args]</span>
<span class="gi">+</span>
<span class="gi">+    # We handle pydantic generic models separately as they don&#39;t have the same</span>
<span class="gi">+    # semantics as &quot;typing&quot; classes or generic aliases</span>
<span class="gi">+    if not origin_type and lenient_issubclass(type_, GenericModel) and not type_.__concrete__:</span>
<span class="gi">+        type_args = type_.__parameters__</span>
<span class="gi">+        resolved_type_args = tuple(replace_types(t, type_map) for t in type_args)</span>
<span class="gi">+        if all_identical(type_args, resolved_type_args):</span>
<span class="gi">+            return type_</span>
<span class="gi">+        return type_[resolved_type_args]</span>
<span class="gi">+</span>
<span class="gi">+    # Handle special case for typehints that can have lists as arguments.</span>
<span class="gi">+    # `typing.Callable[[int, str], int]` is an example for this.</span>
<span class="gi">+    if isinstance(type_, (List, list)):</span>
<span class="gi">+        resolved_list = list(replace_types(element, type_map) for element in type_)</span>
<span class="gi">+        if all_identical(type_, resolved_list):</span>
<span class="gi">+            return type_</span>
<span class="gi">+        return resolved_list</span>
<span class="gi">+</span>
<span class="gi">+    # For JsonWrapperValue, need to handle its inner type to allow correct parsing</span>
<span class="gi">+    # of generic Json arguments like Json[T]</span>
<span class="gi">+    if not origin_type and lenient_issubclass(type_, JsonWrapper):</span>
<span class="gi">+        type_.inner_type = replace_types(type_.inner_type, type_map)</span>
<span class="gi">+        return type_</span>
<span class="gi">+</span>
<span class="gi">+    # If all else fails, we try to resolve the type directly and otherwise just</span>
<span class="gi">+    # return the input with no modifications.</span>
<span class="gi">+    new_type = type_map.get(type_, type_)</span>
<span class="gi">+    # Convert string to ForwardRef</span>
<span class="gi">+    if isinstance(new_type, str):</span>
<span class="gi">+        return ForwardRef(new_type)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return new_type</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def check_parameters_count(cls: Type[GenericModel], parameters: Tuple[Any, ...]) -&gt; None:</span>
<span class="gi">+    actual = len(parameters)</span>
<span class="gi">+    expected = len(cls.__parameters__)</span>
<span class="gi">+    if actual != expected:</span>
<span class="gi">+        description = &#39;many&#39; if actual &gt; expected else &#39;few&#39;</span>
<span class="gi">+        raise TypeError(f&#39;Too {description} parameters for {cls.__name__}; actual {actual}, expected {expected}&#39;)</span>


<span class="w"> </span>DictValues: Type[Any] = {}.values().__class__


<span class="gd">-def iter_contained_typevars(v: Any) -&gt;Iterator[TypeVarType]:</span>
<span class="gi">+def iter_contained_typevars(v: Any) -&gt; Iterator[TypeVarType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(v, TypeVar):</span>
<span class="gi">+        yield v</span>
<span class="gi">+    elif hasattr(v, &#39;__parameters__&#39;) and not get_origin(v) and lenient_issubclass(v, GenericModel):</span>
<span class="gi">+        yield from v.__parameters__</span>
<span class="gi">+    elif isinstance(v, (DictValues, list)):</span>
<span class="gi">+        for var in v:</span>
<span class="gi">+            yield from iter_contained_typevars(var)</span>
<span class="gi">+    else:</span>
<span class="gi">+        args = get_args(v)</span>
<span class="gi">+        for arg in args:</span>
<span class="gi">+            yield from iter_contained_typevars(arg)</span>


<span class="gd">-def get_caller_frame_info() -&gt;Tuple[Optional[str], bool]:</span>
<span class="gi">+def get_caller_frame_info() -&gt; Tuple[Optional[str], bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Used inside a function to check whether it was called globally

<span class="gu">@@ -208,13 +364,37 @@ def get_caller_frame_info() -&gt;Tuple[Optional[str], bool]:</span>

<span class="w"> </span>    :returns Tuple[module_name, called_globally]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        previous_caller_frame = sys._getframe(2)</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise RuntimeError(&#39;This function must be used inside another function&#39;) from e</span>
<span class="gi">+    except AttributeError:  # sys module does not have _getframe function, so there&#39;s nothing we can do about it</span>
<span class="gi">+        return None, False</span>
<span class="gi">+    frame_globals = previous_caller_frame.f_globals</span>
<span class="gi">+    return frame_globals.get(&#39;__name__&#39;), previous_caller_frame.f_locals is frame_globals</span>


<span class="gd">-def _prepare_model_fields(created_model: Type[GenericModel], fields:</span>
<span class="gd">-    Mapping[str, Any], instance_type_hints: Mapping[str, type],</span>
<span class="gd">-    typevars_map: Mapping[Any, type]) -&gt;None:</span>
<span class="gi">+def _prepare_model_fields(</span>
<span class="gi">+    created_model: Type[GenericModel],</span>
<span class="gi">+    fields: Mapping[str, Any],</span>
<span class="gi">+    instance_type_hints: Mapping[str, type],</span>
<span class="gi">+    typevars_map: Mapping[Any, type],</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace DeferredType fields with concrete type hints and prepare them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    for key, field in created_model.__fields__.items():</span>
<span class="gi">+        if key not in fields:</span>
<span class="gi">+            assert field.type_.__class__ is not DeferredType</span>
<span class="gi">+            # https://github.com/nedbat/coveragepy/issues/198</span>
<span class="gi">+            continue  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+        assert field.type_.__class__ is DeferredType, field.type_.__class__</span>
<span class="gi">+</span>
<span class="gi">+        field_type_hint = instance_type_hints[key]</span>
<span class="gi">+        concrete_type = replace_types(field_type_hint, typevars_map)</span>
<span class="gi">+        field.type_ = concrete_type</span>
<span class="gi">+        field.outer_type_ = concrete_type</span>
<span class="gi">+        field.prepare()</span>
<span class="gi">+        created_model.__annotations__[key] = concrete_type</span>
<span class="gh">diff --git a/pydantic/v1/json.py b/pydantic/v1/json.py</span>
<span class="gh">index 9de1baa27..41d0d5fca 100644</span>
<span class="gd">--- a/pydantic/v1/json.py</span>
<span class="gi">+++ b/pydantic/v1/json.py</span>
<span class="gu">@@ -8,13 +8,19 @@ from re import Pattern</span>
<span class="w"> </span>from types import GeneratorType
<span class="w"> </span>from typing import Any, Callable, Dict, Type, Union
<span class="w"> </span>from uuid import UUID
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.color import Color
<span class="w"> </span>from pydantic.v1.networks import NameEmail
<span class="w"> </span>from pydantic.v1.types import SecretBytes, SecretStr
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;pydantic_encoder&#39;, &#39;custom_pydantic_encoder&#39;, &#39;timedelta_isoformat&#39;


<span class="gd">-def decimal_encoder(dec_value: Decimal) -&gt;Union[int, float]:</span>
<span class="gi">+def isoformat(o: Union[datetime.date, datetime.time]) -&gt; str:</span>
<span class="gi">+    return o.isoformat()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def decimal_encoder(dec_value: Decimal) -&gt; Union[int, float]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Encodes a Decimal as int of there&#39;s no exponent, otherwise float

<span class="gu">@@ -29,21 +35,78 @@ def decimal_encoder(dec_value: Decimal) -&gt;Union[int, float]:</span>
<span class="w"> </span>    &gt;&gt;&gt; decimal_encoder(Decimal(&quot;1&quot;))
<span class="w"> </span>    1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if dec_value.as_tuple().exponent &gt;= 0:</span>
<span class="gi">+        return int(dec_value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return float(dec_value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {</span>
<span class="gi">+    bytes: lambda o: o.decode(),</span>
<span class="gi">+    Color: str,</span>
<span class="gi">+    datetime.date: isoformat,</span>
<span class="gi">+    datetime.datetime: isoformat,</span>
<span class="gi">+    datetime.time: isoformat,</span>
<span class="gi">+    datetime.timedelta: lambda td: td.total_seconds(),</span>
<span class="gi">+    Decimal: decimal_encoder,</span>
<span class="gi">+    Enum: lambda o: o.value,</span>
<span class="gi">+    frozenset: list,</span>
<span class="gi">+    deque: list,</span>
<span class="gi">+    GeneratorType: list,</span>
<span class="gi">+    IPv4Address: str,</span>
<span class="gi">+    IPv4Interface: str,</span>
<span class="gi">+    IPv4Network: str,</span>
<span class="gi">+    IPv6Address: str,</span>
<span class="gi">+    IPv6Interface: str,</span>
<span class="gi">+    IPv6Network: str,</span>
<span class="gi">+    NameEmail: str,</span>
<span class="gi">+    Path: str,</span>
<span class="gi">+    Pattern: lambda o: o.pattern,</span>
<span class="gi">+    SecretBytes: str,</span>
<span class="gi">+    SecretStr: str,</span>
<span class="gi">+    set: list,</span>
<span class="gi">+    UUID: str,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pydantic_encoder(obj: Any) -&gt; Any:</span>
<span class="gi">+    from dataclasses import asdict, is_dataclass</span>
<span class="gi">+</span>
<span class="gi">+    from pydantic.v1.main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(obj, BaseModel):</span>
<span class="gi">+        return obj.dict()</span>
<span class="gi">+    elif is_dataclass(obj):</span>
<span class="gi">+        return asdict(obj)</span>
<span class="gi">+</span>
<span class="gi">+    # Check the class type and its superclasses for a matching encoder</span>
<span class="gi">+    for base in obj.__class__.__mro__[:-1]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            encoder = ENCODERS_BY_TYPE[base]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        return encoder(obj)</span>
<span class="gi">+    else:  # We have exited the for loop without finding a suitable encoder</span>
<span class="gi">+        raise TypeError(f&quot;Object of type &#39;{obj.__class__.__name__}&#39; is not JSON serializable&quot;)</span>
<span class="gi">+</span>

<span class="gi">+def custom_pydantic_encoder(type_encoders: Dict[Any, Callable[[Type[Any]], Any]], obj: Any) -&gt; Any:</span>
<span class="gi">+    # Check the class type and its superclasses for a matching encoder</span>
<span class="gi">+    for base in obj.__class__.__mro__[:-1]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            encoder = type_encoders[base]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>

<span class="gd">-ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {bytes: lambda o:</span>
<span class="gd">-    o.decode(), Color: str, datetime.date: isoformat, datetime.datetime:</span>
<span class="gd">-    isoformat, datetime.time: isoformat, datetime.timedelta: lambda td: td.</span>
<span class="gd">-    total_seconds(), Decimal: decimal_encoder, Enum: lambda o: o.value,</span>
<span class="gd">-    frozenset: list, deque: list, GeneratorType: list, IPv4Address: str,</span>
<span class="gd">-    IPv4Interface: str, IPv4Network: str, IPv6Address: str, IPv6Interface:</span>
<span class="gd">-    str, IPv6Network: str, NameEmail: str, Path: str, Pattern: lambda o: o.</span>
<span class="gd">-    pattern, SecretBytes: str, SecretStr: str, set: list, UUID: str}</span>
<span class="gi">+        return encoder(obj)</span>
<span class="gi">+    else:  # We have exited the for loop without finding a suitable encoder</span>
<span class="gi">+        return pydantic_encoder(obj)</span>


<span class="gd">-def timedelta_isoformat(td: datetime.timedelta) -&gt;str:</span>
<span class="gi">+def timedelta_isoformat(td: datetime.timedelta) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    ISO 8601 encoding for Python timedelta object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    minutes, seconds = divmod(td.seconds, 60)</span>
<span class="gi">+    hours, minutes = divmod(minutes, 60)</span>
<span class="gi">+    return f&#39;{&quot;-&quot; if td.days &lt; 0 else &quot;&quot;}P{abs(td.days)}DT{hours:d}H{minutes:d}M{seconds:d}.{td.microseconds:06d}S&#39;</span>
<span class="gh">diff --git a/pydantic/v1/main.py b/pydantic/v1/main.py</span>
<span class="gh">index 48a9e5a2a..cd376037c 100644</span>
<span class="gd">--- a/pydantic/v1/main.py</span>
<span class="gi">+++ b/pydantic/v1/main.py</span>
<span class="gu">@@ -5,42 +5,126 @@ from enum import Enum</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from types import FunctionType, prepare_class, resolve_bases
<span class="gd">-from typing import TYPE_CHECKING, AbstractSet, Any, Callable, ClassVar, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, cast, no_type_check, overload</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    AbstractSet,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    ClassVar,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    no_type_check,</span>
<span class="gi">+    overload,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import dataclass_transform
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.class_validators import ValidatorGroup, extract_root_validators, extract_validators, inherit_validators
<span class="w"> </span>from pydantic.v1.config import BaseConfig, Extra, inherit_config, prepare_config
<span class="w"> </span>from pydantic.v1.error_wrappers import ErrorWrapper, ValidationError
<span class="w"> </span>from pydantic.v1.errors import ConfigError, DictError, ExtraError, MissingError
<span class="gd">-from pydantic.v1.fields import MAPPING_LIKE_SHAPES, Field, ModelField, ModelPrivateAttr, PrivateAttr, Undefined, is_finalvar_with_default_val</span>
<span class="gi">+from pydantic.v1.fields import (</span>
<span class="gi">+    MAPPING_LIKE_SHAPES,</span>
<span class="gi">+    Field,</span>
<span class="gi">+    ModelField,</span>
<span class="gi">+    ModelPrivateAttr,</span>
<span class="gi">+    PrivateAttr,</span>
<span class="gi">+    Undefined,</span>
<span class="gi">+    is_finalvar_with_default_val,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pydantic.v1.json import custom_pydantic_encoder, pydantic_encoder
<span class="w"> </span>from pydantic.v1.parse import Protocol, load_file, load_str_bytes
<span class="w"> </span>from pydantic.v1.schema import default_ref_template, model_schema
<span class="w"> </span>from pydantic.v1.types import PyObject, StrBytes
<span class="gd">-from pydantic.v1.typing import AnyCallable, get_args, get_origin, is_classvar, is_namedtuple, is_union, resolve_annotations, update_model_forward_refs</span>
<span class="gd">-from pydantic.v1.utils import DUNDER_ATTRIBUTES, ROOT_KEY, ClassAttribute, GetterDict, Representation, ValueItems, generate_model_signature, is_valid_field, is_valid_private_name, lenient_issubclass, sequence_like, smart_deepcopy, unique_list, validate_field_name</span>
<span class="gi">+from pydantic.v1.typing import (</span>
<span class="gi">+    AnyCallable,</span>
<span class="gi">+    get_args,</span>
<span class="gi">+    get_origin,</span>
<span class="gi">+    is_classvar,</span>
<span class="gi">+    is_namedtuple,</span>
<span class="gi">+    is_union,</span>
<span class="gi">+    resolve_annotations,</span>
<span class="gi">+    update_model_forward_refs,</span>
<span class="gi">+)</span>
<span class="gi">+from pydantic.v1.utils import (</span>
<span class="gi">+    DUNDER_ATTRIBUTES,</span>
<span class="gi">+    ROOT_KEY,</span>
<span class="gi">+    ClassAttribute,</span>
<span class="gi">+    GetterDict,</span>
<span class="gi">+    Representation,</span>
<span class="gi">+    ValueItems,</span>
<span class="gi">+    generate_model_signature,</span>
<span class="gi">+    is_valid_field,</span>
<span class="gi">+    is_valid_private_name,</span>
<span class="gi">+    lenient_issubclass,</span>
<span class="gi">+    sequence_like,</span>
<span class="gi">+    smart_deepcopy,</span>
<span class="gi">+    unique_list,</span>
<span class="gi">+    validate_field_name,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from inspect import Signature
<span class="gi">+</span>
<span class="w"> </span>    from pydantic.v1.class_validators import ValidatorListDict
<span class="w"> </span>    from pydantic.v1.types import ModelOrDc
<span class="gd">-    from pydantic.v1.typing import AbstractSetIntStr, AnyClassMethod, CallableGenerator, DictAny, DictStrAny, MappingIntStrAny, ReprArgs, SetStr, TupleGenerator</span>
<span class="gi">+    from pydantic.v1.typing import (</span>
<span class="gi">+        AbstractSetIntStr,</span>
<span class="gi">+        AnyClassMethod,</span>
<span class="gi">+        CallableGenerator,</span>
<span class="gi">+        DictAny,</span>
<span class="gi">+        DictStrAny,</span>
<span class="gi">+        MappingIntStrAny,</span>
<span class="gi">+        ReprArgs,</span>
<span class="gi">+        SetStr,</span>
<span class="gi">+        TupleGenerator,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    Model = TypeVar(&#39;Model&#39;, bound=&#39;BaseModel&#39;)
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;BaseModel&#39;, &#39;create_model&#39;, &#39;validate_model&#39;
<span class="gi">+</span>
<span class="w"> </span>_T = TypeVar(&#39;_T&#39;)
<span class="gd">-ANNOTATED_FIELD_UNTOUCHED_TYPES: Tuple[Any, ...] = (property, type,</span>
<span class="gd">-    classmethod, staticmethod)</span>
<span class="gd">-UNTOUCHED_TYPES: Tuple[Any, ...] = (FunctionType,</span>
<span class="gd">-    ) + ANNOTATED_FIELD_UNTOUCHED_TYPES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_custom_root_type(fields: Dict[str, ModelField]) -&gt; None:</span>
<span class="gi">+    if len(fields) &gt; 1:</span>
<span class="gi">+        raise ValueError(f&#39;{ROOT_KEY} cannot be mixed with other fields&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate_hash_function(frozen: bool) -&gt; Optional[Callable[[Any], int]]:</span>
<span class="gi">+    def hash_function(self_: Any) -&gt; int:</span>
<span class="gi">+        return hash(self_.__class__) + hash(tuple(self_.__dict__.values()))</span>
<span class="gi">+</span>
<span class="gi">+    return hash_function if frozen else None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# If a field is of type `Callable`, its default value should be a function and cannot to ignored.</span>
<span class="gi">+ANNOTATED_FIELD_UNTOUCHED_TYPES: Tuple[Any, ...] = (property, type, classmethod, staticmethod)</span>
<span class="gi">+# When creating a `BaseModel` instance, we bypass all the methods, properties... added to the model</span>
<span class="gi">+UNTOUCHED_TYPES: Tuple[Any, ...] = (FunctionType,) + ANNOTATED_FIELD_UNTOUCHED_TYPES</span>
<span class="gi">+# Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we need to add this extra</span>
<span class="gi">+# (somewhat hacky) boolean to keep track of whether we&#39;ve created the `BaseModel` class yet, and therefore whether it&#39;s</span>
<span class="gi">+# safe to refer to it. If it *hasn&#39;t* been created, we assume that the `__new__` call we&#39;re in the middle of is for</span>
<span class="gi">+# the `BaseModel` class, since that&#39;s defined immediately after the metaclass.</span>
<span class="w"> </span>_is_base_model_class_defined = False


<span class="w"> </span>@dataclass_transform(kw_only_default=True, field_specifiers=(Field,))
<span class="w"> </span>class ModelMetaclass(ABCMeta):
<span class="gd">-</span>
<span class="gd">-    @no_type_check</span>
<span class="gd">-    def __new__(mcs, name, bases, namespace, **kwargs):</span>
<span class="gi">+    @no_type_check  # noqa C901</span>
<span class="gi">+    def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901</span>
<span class="w"> </span>        fields: Dict[str, ModelField] = {}
<span class="w"> </span>        config = BaseConfig
<span class="w"> </span>        validators: &#39;ValidatorListDict&#39; = {}
<span class="gi">+</span>
<span class="w"> </span>        pre_root_validators, post_root_validators = [], []
<span class="w"> </span>        private_attributes: Dict[str, ModelPrivateAttr] = {}
<span class="w"> </span>        base_private_attributes: Dict[str, ModelPrivateAttr] = {}
<span class="gu">@@ -48,150 +132,176 @@ class ModelMetaclass(ABCMeta):</span>
<span class="w"> </span>        slots = {slots} if isinstance(slots, str) else set(slots)
<span class="w"> </span>        class_vars: SetStr = set()
<span class="w"> </span>        hash_func: Optional[Callable[[Any], int]] = None
<span class="gi">+</span>
<span class="w"> </span>        for base in reversed(bases):
<span class="gd">-            if _is_base_model_class_defined and issubclass(base, BaseModel</span>
<span class="gd">-                ) and base != BaseModel:</span>
<span class="gi">+            if _is_base_model_class_defined and issubclass(base, BaseModel) and base != BaseModel:</span>
<span class="w"> </span>                fields.update(smart_deepcopy(base.__fields__))
<span class="w"> </span>                config = inherit_config(base.__config__, config)
<span class="gd">-                validators = inherit_validators(base.__validators__, validators</span>
<span class="gd">-                    )</span>
<span class="gi">+                validators = inherit_validators(base.__validators__, validators)</span>
<span class="w"> </span>                pre_root_validators += base.__pre_root_validators__
<span class="w"> </span>                post_root_validators += base.__post_root_validators__
<span class="w"> </span>                base_private_attributes.update(base.__private_attributes__)
<span class="w"> </span>                class_vars.update(base.__class_vars__)
<span class="w"> </span>                hash_func = base.__hash__
<span class="gi">+</span>
<span class="w"> </span>        resolve_forward_refs = kwargs.pop(&#39;__resolve_forward_refs__&#39;, True)
<span class="gd">-        allowed_config_kwargs: SetStr = {key for key in dir(config) if not</span>
<span class="gd">-            (key.startswith(&#39;__&#39;) and key.endswith(&#39;__&#39;))}</span>
<span class="gd">-        config_kwargs = {key: kwargs.pop(key) for key in kwargs.keys() &amp;</span>
<span class="gd">-            allowed_config_kwargs}</span>
<span class="gi">+        allowed_config_kwargs: SetStr = {</span>
<span class="gi">+            key</span>
<span class="gi">+            for key in dir(config)</span>
<span class="gi">+            if not (key.startswith(&#39;__&#39;) and key.endswith(&#39;__&#39;))  # skip dunder methods and attributes</span>
<span class="gi">+        }</span>
<span class="gi">+        config_kwargs = {key: kwargs.pop(key) for key in kwargs.keys() &amp; allowed_config_kwargs}</span>
<span class="w"> </span>        config_from_namespace = namespace.get(&#39;Config&#39;)
<span class="w"> </span>        if config_kwargs and config_from_namespace:
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                &#39;Specifying config in two places is ambiguous, use either Config attribute or class kwargs&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise TypeError(&#39;Specifying config in two places is ambiguous, use either Config attribute or class kwargs&#39;)</span>
<span class="w"> </span>        config = inherit_config(config_from_namespace, config, **config_kwargs)
<span class="gd">-        validators = inherit_validators(extract_validators(namespace),</span>
<span class="gd">-            validators)</span>
<span class="gi">+</span>
<span class="gi">+        validators = inherit_validators(extract_validators(namespace), validators)</span>
<span class="w"> </span>        vg = ValidatorGroup(validators)
<span class="gi">+</span>
<span class="w"> </span>        for f in fields.values():
<span class="w"> </span>            f.set_config(config)
<span class="w"> </span>            extra_validators = vg.get_validators(f.name)
<span class="w"> </span>            if extra_validators:
<span class="w"> </span>                f.class_validators.update(extra_validators)
<span class="gi">+                # re-run prepare to add extra validators</span>
<span class="w"> </span>                f.populate_validators()
<span class="gi">+</span>
<span class="w"> </span>        prepare_config(config, name)
<span class="gi">+</span>
<span class="w"> </span>        untouched_types = ANNOTATED_FIELD_UNTOUCHED_TYPES

<span class="gd">-        def is_untouched(v: Any) -&gt;bool:</span>
<span class="gd">-            return isinstance(v, untouched_types</span>
<span class="gd">-                ) or v.__class__.__name__ == &#39;cython_function_or_method&#39;</span>
<span class="gd">-        if (namespace.get(&#39;__module__&#39;), namespace.get(&#39;__qualname__&#39;)) != (</span>
<span class="gd">-            &#39;pydantic.main&#39;, &#39;BaseModel&#39;):</span>
<span class="gd">-            annotations = resolve_annotations(namespace.get(</span>
<span class="gd">-                &#39;__annotations__&#39;, {}), namespace.get(&#39;__module__&#39;, None))</span>
<span class="gi">+        def is_untouched(v: Any) -&gt; bool:</span>
<span class="gi">+            return isinstance(v, untouched_types) or v.__class__.__name__ == &#39;cython_function_or_method&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if (namespace.get(&#39;__module__&#39;), namespace.get(&#39;__qualname__&#39;)) != (&#39;pydantic.main&#39;, &#39;BaseModel&#39;):</span>
<span class="gi">+            annotations = resolve_annotations(namespace.get(&#39;__annotations__&#39;, {}), namespace.get(&#39;__module__&#39;, None))</span>
<span class="gi">+            # annotation only fields need to come first in fields</span>
<span class="w"> </span>            for ann_name, ann_type in annotations.items():
<span class="w"> </span>                if is_classvar(ann_type):
<span class="w"> </span>                    class_vars.add(ann_name)
<span class="gd">-                elif is_finalvar_with_default_val(ann_type, namespace.get(</span>
<span class="gd">-                    ann_name, Undefined)):</span>
<span class="gi">+                elif is_finalvar_with_default_val(ann_type, namespace.get(ann_name, Undefined)):</span>
<span class="w"> </span>                    class_vars.add(ann_name)
<span class="w"> </span>                elif is_valid_field(ann_name):
<span class="w"> </span>                    validate_field_name(bases, ann_name)
<span class="w"> </span>                    value = namespace.get(ann_name, Undefined)
<span class="gd">-                    allowed_types = get_args(ann_type) if is_union(get_origin</span>
<span class="gd">-                        (ann_type)) else (ann_type,)</span>
<span class="gd">-                    if is_untouched(value</span>
<span class="gd">-                        ) and ann_type != PyObject and not any(</span>
<span class="gd">-                        lenient_issubclass(get_origin(allowed_type), Type) for</span>
<span class="gd">-                        allowed_type in allowed_types):</span>
<span class="gi">+                    allowed_types = get_args(ann_type) if is_union(get_origin(ann_type)) else (ann_type,)</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        is_untouched(value)</span>
<span class="gi">+                        and ann_type != PyObject</span>
<span class="gi">+                        and not any(</span>
<span class="gi">+                            lenient_issubclass(get_origin(allowed_type), Type) for allowed_type in allowed_types</span>
<span class="gi">+                        )</span>
<span class="gi">+                    ):</span>
<span class="w"> </span>                        continue
<span class="gd">-                    fields[ann_name] = ModelField.infer(name=ann_name,</span>
<span class="gd">-                        value=value, annotation=ann_type, class_validators=</span>
<span class="gd">-                        vg.get_validators(ann_name), config=config)</span>
<span class="gi">+                    fields[ann_name] = ModelField.infer(</span>
<span class="gi">+                        name=ann_name,</span>
<span class="gi">+                        value=value,</span>
<span class="gi">+                        annotation=ann_type,</span>
<span class="gi">+                        class_validators=vg.get_validators(ann_name),</span>
<span class="gi">+                        config=config,</span>
<span class="gi">+                    )</span>
<span class="w"> </span>                elif ann_name not in namespace and config.underscore_attrs_are_private:
<span class="w"> </span>                    private_attributes[ann_name] = PrivateAttr()
<span class="gi">+</span>
<span class="w"> </span>            untouched_types = UNTOUCHED_TYPES + config.keep_untouched
<span class="w"> </span>            for var_name, value in namespace.items():
<span class="gd">-                can_be_changed = (var_name not in class_vars and not</span>
<span class="gd">-                    is_untouched(value))</span>
<span class="gi">+                can_be_changed = var_name not in class_vars and not is_untouched(value)</span>
<span class="w"> </span>                if isinstance(value, ModelPrivateAttr):
<span class="w"> </span>                    if not is_valid_private_name(var_name):
<span class="w"> </span>                        raise NameError(
<span class="gd">-                            f&#39;Private attributes &quot;{var_name}&quot; must not be a valid field name; Use sunder or dunder names, e. g. &quot;_{var_name}&quot; or &quot;__{var_name}__&quot;&#39;</span>
<span class="gd">-                            )</span>
<span class="gi">+                            f&#39;Private attributes &quot;{var_name}&quot; must not be a valid field name; &#39;</span>
<span class="gi">+                            f&#39;Use sunder or dunder names, e. g. &quot;_{var_name}&quot; or &quot;__{var_name}__&quot;&#39;</span>
<span class="gi">+                        )</span>
<span class="w"> </span>                    private_attributes[var_name] = value
<span class="gd">-                elif config.underscore_attrs_are_private and is_valid_private_name(</span>
<span class="gd">-                    var_name) and can_be_changed:</span>
<span class="gi">+                elif config.underscore_attrs_are_private and is_valid_private_name(var_name) and can_be_changed:</span>
<span class="w"> </span>                    private_attributes[var_name] = PrivateAttr(default=value)
<span class="gd">-                elif is_valid_field(var_name</span>
<span class="gd">-                    ) and var_name not in annotations and can_be_changed:</span>
<span class="gi">+                elif is_valid_field(var_name) and var_name not in annotations and can_be_changed:</span>
<span class="w"> </span>                    validate_field_name(bases, var_name)
<span class="gd">-                    inferred = ModelField.infer(name=var_name, value=value,</span>
<span class="gi">+                    inferred = ModelField.infer(</span>
<span class="gi">+                        name=var_name,</span>
<span class="gi">+                        value=value,</span>
<span class="w"> </span>                        annotation=annotations.get(var_name, Undefined),
<span class="w"> </span>                        class_validators=vg.get_validators(var_name),
<span class="gd">-                        config=config)</span>
<span class="gi">+                        config=config,</span>
<span class="gi">+                    )</span>
<span class="w"> </span>                    if var_name in fields:
<span class="gd">-                        if lenient_issubclass(inferred.type_, fields[</span>
<span class="gd">-                            var_name].type_):</span>
<span class="gi">+                        if lenient_issubclass(inferred.type_, fields[var_name].type_):</span>
<span class="w"> </span>                            inferred.type_ = fields[var_name].type_
<span class="w"> </span>                        else:
<span class="w"> </span>                            raise TypeError(
<span class="gd">-                                f&#39;The type of {name}.{var_name} differs from the new default value; if you wish to change the type of this field, please use a type annotation&#39;</span>
<span class="gd">-                                )</span>
<span class="gi">+                                f&#39;The type of {name}.{var_name} differs from the new default value; &#39;</span>
<span class="gi">+                                f&#39;if you wish to change the type of this field, please use a type annotation&#39;</span>
<span class="gi">+                            )</span>
<span class="w"> </span>                    fields[var_name] = inferred
<span class="gi">+</span>
<span class="w"> </span>        _custom_root_type = ROOT_KEY in fields
<span class="w"> </span>        if _custom_root_type:
<span class="w"> </span>            validate_custom_root_type(fields)
<span class="w"> </span>        vg.check_for_unused()
<span class="w"> </span>        if config.json_encoders:
<span class="gd">-            json_encoder = partial(custom_pydantic_encoder, config.</span>
<span class="gd">-                json_encoders)</span>
<span class="gi">+            json_encoder = partial(custom_pydantic_encoder, config.json_encoders)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            json_encoder = pydantic_encoder
<span class="w"> </span>        pre_rv_new, post_rv_new = extract_root_validators(namespace)
<span class="gi">+</span>
<span class="w"> </span>        if hash_func is None:
<span class="w"> </span>            hash_func = generate_hash_function(config.frozen)
<span class="gd">-        exclude_from_namespace = fields | private_attributes.keys() | {</span>
<span class="gd">-            &#39;__slots__&#39;}</span>
<span class="gd">-        new_namespace = {&#39;__config__&#39;: config, &#39;__fields__&#39;: fields,</span>
<span class="gd">-            &#39;__exclude_fields__&#39;: {name: field.field_info.exclude for name,</span>
<span class="gd">-            field in fields.items() if field.field_info.exclude is not None</span>
<span class="gd">-            } or None, &#39;__include_fields__&#39;: {name: field.field_info.</span>
<span class="gd">-            include for name, field in fields.items() if field.field_info.</span>
<span class="gd">-            include is not None} or None, &#39;__validators__&#39;: vg.validators,</span>
<span class="gd">-            &#39;__pre_root_validators__&#39;: unique_list(pre_root_validators +</span>
<span class="gd">-            pre_rv_new, name_factory=lambda v: v.__name__),</span>
<span class="gd">-            &#39;__post_root_validators__&#39;: unique_list(post_root_validators +</span>
<span class="gd">-            post_rv_new, name_factory=lambda skip_on_failure_and_v:</span>
<span class="gd">-            skip_on_failure_and_v[1].__name__), &#39;__schema_cache__&#39;: {},</span>
<span class="gi">+</span>
<span class="gi">+        exclude_from_namespace = fields | private_attributes.keys() | {&#39;__slots__&#39;}</span>
<span class="gi">+        new_namespace = {</span>
<span class="gi">+            &#39;__config__&#39;: config,</span>
<span class="gi">+            &#39;__fields__&#39;: fields,</span>
<span class="gi">+            &#39;__exclude_fields__&#39;: {</span>
<span class="gi">+                name: field.field_info.exclude for name, field in fields.items() if field.field_info.exclude is not None</span>
<span class="gi">+            }</span>
<span class="gi">+            or None,</span>
<span class="gi">+            &#39;__include_fields__&#39;: {</span>
<span class="gi">+                name: field.field_info.include for name, field in fields.items() if field.field_info.include is not None</span>
<span class="gi">+            }</span>
<span class="gi">+            or None,</span>
<span class="gi">+            &#39;__validators__&#39;: vg.validators,</span>
<span class="gi">+            &#39;__pre_root_validators__&#39;: unique_list(</span>
<span class="gi">+                pre_root_validators + pre_rv_new,</span>
<span class="gi">+                name_factory=lambda v: v.__name__,</span>
<span class="gi">+            ),</span>
<span class="gi">+            &#39;__post_root_validators__&#39;: unique_list(</span>
<span class="gi">+                post_root_validators + post_rv_new,</span>
<span class="gi">+                name_factory=lambda skip_on_failure_and_v: skip_on_failure_and_v[1].__name__,</span>
<span class="gi">+            ),</span>
<span class="gi">+            &#39;__schema_cache__&#39;: {},</span>
<span class="w"> </span>            &#39;__json_encoder__&#39;: staticmethod(json_encoder),
<span class="w"> </span>            &#39;__custom_root_type__&#39;: _custom_root_type,
<span class="gd">-            &#39;__private_attributes__&#39;: {**base_private_attributes, **</span>
<span class="gd">-            private_attributes}, &#39;__slots__&#39;: slots | private_attributes.</span>
<span class="gd">-            keys(), &#39;__hash__&#39;: hash_func, &#39;__class_vars__&#39;: class_vars, **</span>
<span class="gd">-            {n: v for n, v in namespace.items() if n not in</span>
<span class="gd">-            exclude_from_namespace}}</span>
<span class="gi">+            &#39;__private_attributes__&#39;: {**base_private_attributes, **private_attributes},</span>
<span class="gi">+            &#39;__slots__&#39;: slots | private_attributes.keys(),</span>
<span class="gi">+            &#39;__hash__&#39;: hash_func,</span>
<span class="gi">+            &#39;__class_vars__&#39;: class_vars,</span>
<span class="gi">+            **{n: v for n, v in namespace.items() if n not in exclude_from_namespace},</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>        cls = super().__new__(mcs, name, bases, new_namespace, **kwargs)
<span class="gd">-        cls.__signature__ = ClassAttribute(&#39;__signature__&#39;,</span>
<span class="gd">-            generate_model_signature(cls.__init__, fields, config))</span>
<span class="gi">+        # set __signature__ attr only for model class, but not for its instances</span>
<span class="gi">+        cls.__signature__ = ClassAttribute(&#39;__signature__&#39;, generate_model_signature(cls.__init__, fields, config))</span>
<span class="w"> </span>        if resolve_forward_refs:
<span class="w"> </span>            cls.__try_update_forward_refs__()
<span class="gi">+</span>
<span class="gi">+        # preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487</span>
<span class="gi">+        # for attributes not in `new_namespace` (e.g. private attributes)</span>
<span class="w"> </span>        for name, obj in namespace.items():
<span class="w"> </span>            if name not in new_namespace:
<span class="w"> </span>                set_name = getattr(obj, &#39;__set_name__&#39;, None)
<span class="w"> </span>                if callable(set_name):
<span class="w"> </span>                    set_name(cls, name)
<span class="gi">+</span>
<span class="w"> </span>        return cls

<span class="gd">-    def __instancecheck__(self, instance: Any) -&gt;bool:</span>
<span class="gi">+    def __instancecheck__(self, instance: Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Avoid calling ABC _abc_subclasscheck unless we&#39;re pretty sure.

<span class="w"> </span>        See #3829 and python/cpython#92810
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return hasattr(instance, &#39;__fields__&#39;) and super().__instancecheck__(</span>
<span class="gd">-            instance)</span>
<span class="gi">+        return hasattr(instance, &#39;__fields__&#39;) and super().__instancecheck__(instance)</span>


<span class="w"> </span>object_setattr = object.__setattr__
<span class="gu">@@ -199,6 +309,7 @@ object_setattr = object.__setattr__</span>

<span class="w"> </span>class BaseModel(Representation, metaclass=ModelMetaclass):
<span class="w"> </span>    if TYPE_CHECKING:
<span class="gi">+        # populated by the metaclass, defined here to help IDEs only</span>
<span class="w"> </span>        __fields__: ClassVar[Dict[str, ModelField]] = {}
<span class="w"> </span>        __include_fields__: ClassVar[Optional[Mapping[str, Any]]] = None
<span class="w"> </span>        __exclude_fields__: ClassVar[Optional[Mapping[str, Any]]] = None
<span class="gu">@@ -213,18 +324,19 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>
<span class="w"> </span>        __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]
<span class="w"> </span>        __class_vars__: ClassVar[SetStr]
<span class="w"> </span>        __fields_set__: ClassVar[SetStr] = set()
<span class="gi">+</span>
<span class="w"> </span>    Config = BaseConfig
<span class="gd">-    __slots__ = &#39;__dict__&#39;, &#39;__fields_set__&#39;</span>
<span class="gd">-    __doc__ = &#39;&#39;</span>
<span class="gi">+    __slots__ = (&#39;__dict__&#39;, &#39;__fields_set__&#39;)</span>
<span class="gi">+    __doc__ = &#39;&#39;  # Null out the Representation docstring</span>

<span class="gd">-    def __init__(__pydantic_self__, **data: Any) -&gt;None:</span>
<span class="gi">+    def __init__(__pydantic_self__, **data: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new model by parsing and validating input data from keyword arguments.

<span class="w"> </span>        Raises ValidationError if the input data cannot be parsed to form a valid model.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        values, fields_set, validation_error = validate_model(__pydantic_self__</span>
<span class="gd">-            .__class__, data)</span>
<span class="gi">+        # Uses something other than `self` the first arg to allow &quot;self&quot; as a settable attribute</span>
<span class="gi">+        values, fields_set, validation_error = validate_model(__pydantic_self__.__class__, data)</span>
<span class="w"> </span>        if validation_error:
<span class="w"> </span>            raise validation_error
<span class="w"> </span>        try:
<span class="gu">@@ -232,48 +344,47 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>
<span class="w"> </span>        except TypeError as e:
<span class="w"> </span>            raise TypeError(
<span class="w"> </span>                &#39;Model values must be a dict; you may not have returned a dictionary from a root validator&#39;
<span class="gd">-                ) from e</span>
<span class="gi">+            ) from e</span>
<span class="w"> </span>        object_setattr(__pydantic_self__, &#39;__fields_set__&#39;, fields_set)
<span class="w"> </span>        __pydantic_self__._init_private_attributes()

<span class="w"> </span>    @no_type_check
<span class="gd">-    def __setattr__(self, name, value):</span>
<span class="gi">+    def __setattr__(self, name, value):  # noqa: C901 (ignore complexity)</span>
<span class="w"> </span>        if name in self.__private_attributes__ or name in DUNDER_ATTRIBUTES:
<span class="w"> </span>            return object_setattr(self, name, value)
<span class="gd">-        if (self.__config__.extra is not Extra.allow and name not in self.</span>
<span class="gd">-            __fields__):</span>
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                f&#39;&quot;{self.__class__.__name__}&quot; object has no field &quot;{name}&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.__config__.extra is not Extra.allow and name not in self.__fields__:</span>
<span class="gi">+            raise ValueError(f&#39;&quot;{self.__class__.__name__}&quot; object has no field &quot;{name}&quot;&#39;)</span>
<span class="w"> </span>        elif not self.__config__.allow_mutation or self.__config__.frozen:
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                f&#39;&quot;{self.__class__.__name__}&quot; is immutable and does not support item assignment&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise TypeError(f&#39;&quot;{self.__class__.__name__}&quot; is immutable and does not support item assignment&#39;)</span>
<span class="w"> </span>        elif name in self.__fields__ and self.__fields__[name].final:
<span class="w"> </span>            raise TypeError(
<span class="w"> </span>                f&#39;&quot;{self.__class__.__name__}&quot; object &quot;{name}&quot; field is final and does not support reassignment&#39;
<span class="gd">-                )</span>
<span class="gi">+            )</span>
<span class="w"> </span>        elif self.__config__.validate_assignment:
<span class="w"> </span>            new_values = {**self.__dict__, name: value}
<span class="gi">+</span>
<span class="w"> </span>            for validator in self.__pre_root_validators__:
<span class="w"> </span>                try:
<span class="w"> </span>                    new_values = validator(self.__class__, new_values)
<span class="w"> </span>                except (ValueError, TypeError, AssertionError) as exc:
<span class="gd">-                    raise ValidationError([ErrorWrapper(exc, loc=ROOT_KEY)],</span>
<span class="gd">-                        self.__class__)</span>
<span class="gi">+                    raise ValidationError([ErrorWrapper(exc, loc=ROOT_KEY)], self.__class__)</span>
<span class="gi">+</span>
<span class="w"> </span>            known_field = self.__fields__.get(name, None)
<span class="w"> </span>            if known_field:
<span class="gi">+                # We want to</span>
<span class="gi">+                # - make sure validators are called without the current value for this field inside `values`</span>
<span class="gi">+                # - keep other values (e.g. submodels) untouched (using `BaseModel.dict()` will change them into dicts)</span>
<span class="gi">+                # - keep the order of the fields</span>
<span class="w"> </span>                if not known_field.field_info.allow_mutation:
<span class="gd">-                    raise TypeError(</span>
<span class="gd">-                        f&#39;&quot;{known_field.name}&quot; has allow_mutation set to False and cannot be assigned&#39;</span>
<span class="gd">-                        )</span>
<span class="gd">-                dict_without_original_value = {k: v for k, v in self.</span>
<span class="gd">-                    __dict__.items() if k != name}</span>
<span class="gd">-                value, error_ = known_field.validate(value,</span>
<span class="gd">-                    dict_without_original_value, loc=name, cls=self.__class__)</span>
<span class="gi">+                    raise TypeError(f&#39;&quot;{known_field.name}&quot; has allow_mutation set to False and cannot be assigned&#39;)</span>
<span class="gi">+                dict_without_original_value = {k: v for k, v in self.__dict__.items() if k != name}</span>
<span class="gi">+                value, error_ = known_field.validate(value, dict_without_original_value, loc=name, cls=self.__class__)</span>
<span class="w"> </span>                if error_:
<span class="w"> </span>                    raise ValidationError([error_], self.__class__)
<span class="w"> </span>                else:
<span class="w"> </span>                    new_values[name] = value
<span class="gi">+</span>
<span class="w"> </span>            errors = []
<span class="w"> </span>            for skip_on_failure, validator in self.__post_root_validators__:
<span class="w"> </span>                if skip_on_failure and errors:
<span class="gu">@@ -284,65 +395,243 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>
<span class="w"> </span>                    errors.append(ErrorWrapper(exc, loc=ROOT_KEY))
<span class="w"> </span>            if errors:
<span class="w"> </span>                raise ValidationError(errors, self.__class__)
<span class="gi">+</span>
<span class="gi">+            # update the whole __dict__ as other values than just `value`</span>
<span class="gi">+            # may be changed (e.g. with `root_validator`)</span>
<span class="w"> </span>            object_setattr(self, &#39;__dict__&#39;, new_values)
<span class="w"> </span>        else:
<span class="w"> </span>            self.__dict__[name] = value
<span class="gi">+</span>
<span class="w"> </span>        self.__fields_set__.add(name)

<span class="gd">-    def __getstate__(self) -&gt;&#39;DictAny&#39;:</span>
<span class="gd">-        private_attrs = ((k, getattr(self, k, Undefined)) for k in self.</span>
<span class="gd">-            __private_attributes__)</span>
<span class="gd">-        return {&#39;__dict__&#39;: self.__dict__, &#39;__fields_set__&#39;: self.</span>
<span class="gd">-            __fields_set__, &#39;__private_attribute_values__&#39;: {k: v for k, v in</span>
<span class="gd">-            private_attrs if v is not Undefined}}</span>
<span class="gi">+    def __getstate__(self) -&gt; &#39;DictAny&#39;:</span>
<span class="gi">+        private_attrs = ((k, getattr(self, k, Undefined)) for k in self.__private_attributes__)</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;__dict__&#39;: self.__dict__,</span>
<span class="gi">+            &#39;__fields_set__&#39;: self.__fields_set__,</span>
<span class="gi">+            &#39;__private_attribute_values__&#39;: {k: v for k, v in private_attrs if v is not Undefined},</span>
<span class="gi">+        }</span>

<span class="gd">-    def __setstate__(self, state: &#39;DictAny&#39;) -&gt;None:</span>
<span class="gi">+    def __setstate__(self, state: &#39;DictAny&#39;) -&gt; None:</span>
<span class="w"> </span>        object_setattr(self, &#39;__dict__&#39;, state[&#39;__dict__&#39;])
<span class="w"> </span>        object_setattr(self, &#39;__fields_set__&#39;, state[&#39;__fields_set__&#39;])
<span class="gd">-        for name, value in state.get(&#39;__private_attribute_values__&#39;, {}).items(</span>
<span class="gd">-            ):</span>
<span class="gi">+        for name, value in state.get(&#39;__private_attribute_values__&#39;, {}).items():</span>
<span class="w"> </span>            object_setattr(self, name, value)

<span class="gd">-    def dict(self, *, include: Optional[Union[&#39;AbstractSetIntStr&#39;,</span>
<span class="gd">-        &#39;MappingIntStrAny&#39;]]=None, exclude: Optional[Union[</span>
<span class="gd">-        &#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]]=None, by_alias: bool=</span>
<span class="gd">-        False, skip_defaults: Optional[bool]=None, exclude_unset: bool=</span>
<span class="gd">-        False, exclude_defaults: bool=False, exclude_none: bool=False</span>
<span class="gd">-        ) -&gt;&#39;DictStrAny&#39;:</span>
<span class="gi">+    def _init_private_attributes(self) -&gt; None:</span>
<span class="gi">+        for name, private_attr in self.__private_attributes__.items():</span>
<span class="gi">+            default = private_attr.get_default()</span>
<span class="gi">+            if default is not Undefined:</span>
<span class="gi">+                object_setattr(self, name, default)</span>
<span class="gi">+</span>
<span class="gi">+    def dict(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        include: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]] = None,</span>
<span class="gi">+        exclude: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]] = None,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        skip_defaults: Optional[bool] = None,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+    ) -&gt; &#39;DictStrAny&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def json(self, *, include: Optional[Union[&#39;AbstractSetIntStr&#39;,</span>
<span class="gd">-        &#39;MappingIntStrAny&#39;]]=None, exclude: Optional[Union[</span>
<span class="gd">-        &#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]]=None, by_alias: bool=</span>
<span class="gd">-        False, skip_defaults: Optional[bool]=None, exclude_unset: bool=</span>
<span class="gd">-        False, exclude_defaults: bool=False, exclude_none: bool=False,</span>
<span class="gd">-        encoder: Optional[Callable[[Any], Any]]=None, models_as_dict: bool=</span>
<span class="gd">-        True, **dumps_kwargs: Any) -&gt;str:</span>
<span class="gi">+        if skip_defaults is not None:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&#39;{self.__class__.__name__}.dict(): &quot;skip_defaults&quot; is deprecated and replaced by &quot;exclude_unset&quot;&#39;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+            )</span>
<span class="gi">+            exclude_unset = skip_defaults</span>
<span class="gi">+</span>
<span class="gi">+        return dict(</span>
<span class="gi">+            self._iter(</span>
<span class="gi">+                to_dict=True,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                include=include,</span>
<span class="gi">+                exclude=exclude,</span>
<span class="gi">+                exclude_unset=exclude_unset,</span>
<span class="gi">+                exclude_defaults=exclude_defaults,</span>
<span class="gi">+                exclude_none=exclude_none,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def json(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        include: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]] = None,</span>
<span class="gi">+        exclude: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]] = None,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        skip_defaults: Optional[bool] = None,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+        encoder: Optional[Callable[[Any], Any]] = None,</span>
<span class="gi">+        models_as_dict: bool = True,</span>
<span class="gi">+        **dumps_kwargs: Any,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generate a JSON representation of the model, `include` and `exclude` arguments as per `dict()`.

<span class="w"> </span>        `encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if skip_defaults is not None:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&#39;{self.__class__.__name__}.json(): &quot;skip_defaults&quot; is deprecated and replaced by &quot;exclude_unset&quot;&#39;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+            )</span>
<span class="gi">+            exclude_unset = skip_defaults</span>
<span class="gi">+        encoder = cast(Callable[[Any], Any], encoder or self.__json_encoder__)</span>
<span class="gi">+</span>
<span class="gi">+        # We don&#39;t directly call `self.dict()`, which does exactly this with `to_dict=True`</span>
<span class="gi">+        # because we want to be able to keep raw `BaseModel` instances and not as `dict`.</span>
<span class="gi">+        # This allows users to write custom JSON encoders for given `BaseModel` classes.</span>
<span class="gi">+        data = dict(</span>
<span class="gi">+            self._iter(</span>
<span class="gi">+                to_dict=models_as_dict,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                include=include,</span>
<span class="gi">+                exclude=exclude,</span>
<span class="gi">+                exclude_unset=exclude_unset,</span>
<span class="gi">+                exclude_defaults=exclude_defaults,</span>
<span class="gi">+                exclude_none=exclude_none,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        if self.__custom_root_type__:</span>
<span class="gi">+            data = data[ROOT_KEY]</span>
<span class="gi">+        return self.__config__.json_dumps(data, default=encoder, **dumps_kwargs)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def construct(cls: Type[&#39;Model&#39;], _fields_set: Optional[&#39;SetStr&#39;]=None,</span>
<span class="gd">-        **values: Any) -&gt;&#39;Model&#39;:</span>
<span class="gi">+    def _enforce_dict_if_root(cls, obj: Any) -&gt; Any:</span>
<span class="gi">+        if cls.__custom_root_type__ and (</span>
<span class="gi">+            not (isinstance(obj, dict) and obj.keys() == {ROOT_KEY})</span>
<span class="gi">+            and not (isinstance(obj, BaseModel) and obj.__fields__.keys() == {ROOT_KEY})</span>
<span class="gi">+            or cls.__fields__[ROOT_KEY].shape in MAPPING_LIKE_SHAPES</span>
<span class="gi">+        ):</span>
<span class="gi">+            return {ROOT_KEY: obj}</span>
<span class="gi">+        else:</span>
<span class="gi">+            return obj</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_obj(cls: Type[&#39;Model&#39;], obj: Any) -&gt; &#39;Model&#39;:</span>
<span class="gi">+        obj = cls._enforce_dict_if_root(obj)</span>
<span class="gi">+        if not isinstance(obj, dict):</span>
<span class="gi">+            try:</span>
<span class="gi">+                obj = dict(obj)</span>
<span class="gi">+            except (TypeError, ValueError) as e:</span>
<span class="gi">+                exc = TypeError(f&#39;{cls.__name__} expected dict not {obj.__class__.__name__}&#39;)</span>
<span class="gi">+                raise ValidationError([ErrorWrapper(exc, loc=ROOT_KEY)], cls) from e</span>
<span class="gi">+        return cls(**obj)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_raw(</span>
<span class="gi">+        cls: Type[&#39;Model&#39;],</span>
<span class="gi">+        b: StrBytes,</span>
<span class="gi">+        *,</span>
<span class="gi">+        content_type: str = None,</span>
<span class="gi">+        encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+        proto: Protocol = None,</span>
<span class="gi">+        allow_pickle: bool = False,</span>
<span class="gi">+    ) -&gt; &#39;Model&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj = load_str_bytes(</span>
<span class="gi">+                b,</span>
<span class="gi">+                proto=proto,</span>
<span class="gi">+                content_type=content_type,</span>
<span class="gi">+                encoding=encoding,</span>
<span class="gi">+                allow_pickle=allow_pickle,</span>
<span class="gi">+                json_loads=cls.__config__.json_loads,</span>
<span class="gi">+            )</span>
<span class="gi">+        except (ValueError, TypeError, UnicodeDecodeError) as e:</span>
<span class="gi">+            raise ValidationError([ErrorWrapper(e, loc=ROOT_KEY)], cls)</span>
<span class="gi">+        return cls.parse_obj(obj)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def parse_file(</span>
<span class="gi">+        cls: Type[&#39;Model&#39;],</span>
<span class="gi">+        path: Union[str, Path],</span>
<span class="gi">+        *,</span>
<span class="gi">+        content_type: str = None,</span>
<span class="gi">+        encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+        proto: Protocol = None,</span>
<span class="gi">+        allow_pickle: bool = False,</span>
<span class="gi">+    ) -&gt; &#39;Model&#39;:</span>
<span class="gi">+        obj = load_file(</span>
<span class="gi">+            path,</span>
<span class="gi">+            proto=proto,</span>
<span class="gi">+            content_type=content_type,</span>
<span class="gi">+            encoding=encoding,</span>
<span class="gi">+            allow_pickle=allow_pickle,</span>
<span class="gi">+            json_loads=cls.__config__.json_loads,</span>
<span class="gi">+        )</span>
<span class="gi">+        return cls.parse_obj(obj)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_orm(cls: Type[&#39;Model&#39;], obj: Any) -&gt; &#39;Model&#39;:</span>
<span class="gi">+        if not cls.__config__.orm_mode:</span>
<span class="gi">+            raise ConfigError(&#39;You must have the config attribute orm_mode=True to use from_orm&#39;)</span>
<span class="gi">+        obj = {ROOT_KEY: obj} if cls.__custom_root_type__ else cls._decompose_class(obj)</span>
<span class="gi">+        m = cls.__new__(cls)</span>
<span class="gi">+        values, fields_set, validation_error = validate_model(cls, obj)</span>
<span class="gi">+        if validation_error:</span>
<span class="gi">+            raise validation_error</span>
<span class="gi">+        object_setattr(m, &#39;__dict__&#39;, values)</span>
<span class="gi">+        object_setattr(m, &#39;__fields_set__&#39;, fields_set)</span>
<span class="gi">+        m._init_private_attributes()</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def construct(cls: Type[&#39;Model&#39;], _fields_set: Optional[&#39;SetStr&#39;] = None, **values: Any) -&gt; &#39;Model&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.
<span class="w"> </span>        Default values are respected, but no other validation is performed.
<span class="w"> </span>        Behaves as if `Config.extra = &#39;allow&#39;` was set since it adds all passed values
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = cls.__new__(cls)</span>
<span class="gi">+        fields_values: Dict[str, Any] = {}</span>
<span class="gi">+        for name, field in cls.__fields__.items():</span>
<span class="gi">+            if field.alt_alias and field.alias in values:</span>
<span class="gi">+                fields_values[name] = values[field.alias]</span>
<span class="gi">+            elif name in values:</span>
<span class="gi">+                fields_values[name] = values[name]</span>
<span class="gi">+            elif not field.required:</span>
<span class="gi">+                fields_values[name] = field.get_default()</span>
<span class="gi">+        fields_values.update(values)</span>
<span class="gi">+        object_setattr(m, &#39;__dict__&#39;, fields_values)</span>
<span class="gi">+        if _fields_set is None:</span>
<span class="gi">+            _fields_set = set(values.keys())</span>
<span class="gi">+        object_setattr(m, &#39;__fields_set__&#39;, _fields_set)</span>
<span class="gi">+        m._init_private_attributes()</span>
<span class="gi">+        return m</span>

<span class="gd">-    def copy(self: &#39;Model&#39;, *, include: Optional[Union[&#39;AbstractSetIntStr&#39;,</span>
<span class="gd">-        &#39;MappingIntStrAny&#39;]]=None, exclude: Optional[Union[</span>
<span class="gd">-        &#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]]=None, update: Optional[</span>
<span class="gd">-        &#39;DictStrAny&#39;]=None, deep: bool=False) -&gt;&#39;Model&#39;:</span>
<span class="gi">+    def _copy_and_set_values(self: &#39;Model&#39;, values: &#39;DictStrAny&#39;, fields_set: &#39;SetStr&#39;, *, deep: bool) -&gt; &#39;Model&#39;:</span>
<span class="gi">+        if deep:</span>
<span class="gi">+            # chances of having empty dict here are quite low for using smart_deepcopy</span>
<span class="gi">+            values = deepcopy(values)</span>
<span class="gi">+</span>
<span class="gi">+        cls = self.__class__</span>
<span class="gi">+        m = cls.__new__(cls)</span>
<span class="gi">+        object_setattr(m, &#39;__dict__&#39;, values)</span>
<span class="gi">+        object_setattr(m, &#39;__fields_set__&#39;, fields_set)</span>
<span class="gi">+        for name in self.__private_attributes__:</span>
<span class="gi">+            value = getattr(self, name, Undefined)</span>
<span class="gi">+            if value is not Undefined:</span>
<span class="gi">+                if deep:</span>
<span class="gi">+                    value = deepcopy(value)</span>
<span class="gi">+                object_setattr(m, name, value)</span>
<span class="gi">+</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    def copy(</span>
<span class="gi">+        self: &#39;Model&#39;,</span>
<span class="gi">+        *,</span>
<span class="gi">+        include: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]] = None,</span>
<span class="gi">+        exclude: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]] = None,</span>
<span class="gi">+        update: Optional[&#39;DictStrAny&#39;] = None,</span>
<span class="gi">+        deep: bool = False,</span>
<span class="gi">+    ) -&gt; &#39;Model&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Duplicate a model, optionally choose which fields to include, exclude and change.

<span class="gu">@@ -353,54 +642,322 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>
<span class="w"> </span>        :param deep: set to `True` to make a deep copy of the model
<span class="w"> </span>        :return: new model instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        values = dict(</span>
<span class="gi">+            self._iter(to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False),</span>
<span class="gi">+            **(update or {}),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # new `__fields_set__` can have unset optional fields with a set value in `update` kwarg</span>
<span class="gi">+        if update:</span>
<span class="gi">+            fields_set = self.__fields_set__ | update.keys()</span>
<span class="gi">+        else:</span>
<span class="gi">+            fields_set = set(self.__fields_set__)</span>
<span class="gi">+</span>
<span class="gi">+        return self._copy_and_set_values(values, fields_set, deep=deep)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def schema(cls, by_alias: bool = True, ref_template: str = default_ref_template) -&gt; &#39;DictStrAny&#39;:</span>
<span class="gi">+        cached = cls.__schema_cache__.get((by_alias, ref_template))</span>
<span class="gi">+        if cached is not None:</span>
<span class="gi">+            return cached</span>
<span class="gi">+        s = model_schema(cls, by_alias=by_alias, ref_template=ref_template)</span>
<span class="gi">+        cls.__schema_cache__[(by_alias, ref_template)] = s</span>
<span class="gi">+        return s</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def schema_json(</span>
<span class="gi">+        cls, *, by_alias: bool = True, ref_template: str = default_ref_template, **dumps_kwargs: Any</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        from pydantic.v1.json import pydantic_encoder</span>
<span class="gi">+</span>
<span class="gi">+        return cls.__config__.json_dumps(</span>
<span class="gi">+            cls.schema(by_alias=by_alias, ref_template=ref_template), default=pydantic_encoder, **dumps_kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.validate

<span class="w"> </span>    @classmethod
<span class="gd">-    def __try_update_forward_refs__(cls, **localns: Any) -&gt;None:</span>
<span class="gi">+    def validate(cls: Type[&#39;Model&#39;], value: Any) -&gt; &#39;Model&#39;:</span>
<span class="gi">+        if isinstance(value, cls):</span>
<span class="gi">+            copy_on_model_validation = cls.__config__.copy_on_model_validation</span>
<span class="gi">+            # whether to deep or shallow copy the model on validation, None means do not copy</span>
<span class="gi">+            deep_copy: Optional[bool] = None</span>
<span class="gi">+            if copy_on_model_validation not in {&#39;deep&#39;, &#39;shallow&#39;, &#39;none&#39;}:</span>
<span class="gi">+                # Warn about deprecated behavior</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    &quot;`copy_on_model_validation` should be a string: &#39;deep&#39;, &#39;shallow&#39; or &#39;none&#39;&quot;, DeprecationWarning</span>
<span class="gi">+                )</span>
<span class="gi">+                if copy_on_model_validation:</span>
<span class="gi">+                    deep_copy = False</span>
<span class="gi">+</span>
<span class="gi">+            if copy_on_model_validation == &#39;shallow&#39;:</span>
<span class="gi">+                # shallow copy</span>
<span class="gi">+                deep_copy = False</span>
<span class="gi">+            elif copy_on_model_validation == &#39;deep&#39;:</span>
<span class="gi">+                # deep copy</span>
<span class="gi">+                deep_copy = True</span>
<span class="gi">+</span>
<span class="gi">+            if deep_copy is None:</span>
<span class="gi">+                return value</span>
<span class="gi">+            else:</span>
<span class="gi">+                return value._copy_and_set_values(value.__dict__, value.__fields_set__, deep=deep_copy)</span>
<span class="gi">+</span>
<span class="gi">+        value = cls._enforce_dict_if_root(value)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, dict):</span>
<span class="gi">+            return cls(**value)</span>
<span class="gi">+        elif cls.__config__.orm_mode:</span>
<span class="gi">+            return cls.from_orm(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                value_as_dict = dict(value)</span>
<span class="gi">+            except (TypeError, ValueError) as e:</span>
<span class="gi">+                raise DictError() from e</span>
<span class="gi">+            return cls(**value_as_dict)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _decompose_class(cls: Type[&#39;Model&#39;], obj: Any) -&gt; GetterDict:</span>
<span class="gi">+        if isinstance(obj, GetterDict):</span>
<span class="gi">+            return obj</span>
<span class="gi">+        return cls.__config__.getter_dict(obj)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @no_type_check</span>
<span class="gi">+    def _get_value(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        v: Any,</span>
<span class="gi">+        to_dict: bool,</span>
<span class="gi">+        by_alias: bool,</span>
<span class="gi">+        include: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]],</span>
<span class="gi">+        exclude: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]],</span>
<span class="gi">+        exclude_unset: bool,</span>
<span class="gi">+        exclude_defaults: bool,</span>
<span class="gi">+        exclude_none: bool,</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="gi">+        if isinstance(v, BaseModel):</span>
<span class="gi">+            if to_dict:</span>
<span class="gi">+                v_dict = v.dict(</span>
<span class="gi">+                    by_alias=by_alias,</span>
<span class="gi">+                    exclude_unset=exclude_unset,</span>
<span class="gi">+                    exclude_defaults=exclude_defaults,</span>
<span class="gi">+                    include=include,</span>
<span class="gi">+                    exclude=exclude,</span>
<span class="gi">+                    exclude_none=exclude_none,</span>
<span class="gi">+                )</span>
<span class="gi">+                if ROOT_KEY in v_dict:</span>
<span class="gi">+                    return v_dict[ROOT_KEY]</span>
<span class="gi">+                return v_dict</span>
<span class="gi">+            else:</span>
<span class="gi">+                return v.copy(include=include, exclude=exclude)</span>
<span class="gi">+</span>
<span class="gi">+        value_exclude = ValueItems(v, exclude) if exclude else None</span>
<span class="gi">+        value_include = ValueItems(v, include) if include else None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(v, dict):</span>
<span class="gi">+            return {</span>
<span class="gi">+                k_: cls._get_value(</span>
<span class="gi">+                    v_,</span>
<span class="gi">+                    to_dict=to_dict,</span>
<span class="gi">+                    by_alias=by_alias,</span>
<span class="gi">+                    exclude_unset=exclude_unset,</span>
<span class="gi">+                    exclude_defaults=exclude_defaults,</span>
<span class="gi">+                    include=value_include and value_include.for_element(k_),</span>
<span class="gi">+                    exclude=value_exclude and value_exclude.for_element(k_),</span>
<span class="gi">+                    exclude_none=exclude_none,</span>
<span class="gi">+                )</span>
<span class="gi">+                for k_, v_ in v.items()</span>
<span class="gi">+                if (not value_exclude or not value_exclude.is_excluded(k_))</span>
<span class="gi">+                and (not value_include or value_include.is_included(k_))</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        elif sequence_like(v):</span>
<span class="gi">+            seq_args = (</span>
<span class="gi">+                cls._get_value(</span>
<span class="gi">+                    v_,</span>
<span class="gi">+                    to_dict=to_dict,</span>
<span class="gi">+                    by_alias=by_alias,</span>
<span class="gi">+                    exclude_unset=exclude_unset,</span>
<span class="gi">+                    exclude_defaults=exclude_defaults,</span>
<span class="gi">+                    include=value_include and value_include.for_element(i),</span>
<span class="gi">+                    exclude=value_exclude and value_exclude.for_element(i),</span>
<span class="gi">+                    exclude_none=exclude_none,</span>
<span class="gi">+                )</span>
<span class="gi">+                for i, v_ in enumerate(v)</span>
<span class="gi">+                if (not value_exclude or not value_exclude.is_excluded(i))</span>
<span class="gi">+                and (not value_include or value_include.is_included(i))</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            return v.__class__(*seq_args) if is_namedtuple(v.__class__) else v.__class__(seq_args)</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(v, Enum) and getattr(cls.Config, &#39;use_enum_values&#39;, False):</span>
<span class="gi">+            return v.value</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            return v</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def __try_update_forward_refs__(cls, **localns: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Same as update_forward_refs but will not raise exception
<span class="w"> </span>        when forward references are not defined.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        update_model_forward_refs(cls, cls.__fields__.values(), cls.</span>
<span class="gd">-            __config__.json_encoders, localns, (NameError,))</span>
<span class="gi">+        update_model_forward_refs(cls, cls.__fields__.values(), cls.__config__.json_encoders, localns, (NameError,))</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def update_forward_refs(cls, **localns: Any) -&gt;None:</span>
<span class="gi">+    def update_forward_refs(cls, **localns: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Try to update ForwardRefs on fields based on this Model, globalns and localns.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        update_model_forward_refs(cls, cls.__fields__.values(), cls.__config__.json_encoders, localns)</span>

<span class="gd">-    def __iter__(self) -&gt;&#39;TupleGenerator&#39;:</span>
<span class="gi">+    def __iter__(self) -&gt; &#39;TupleGenerator&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        so `dict(model)` works
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        yield from self.__dict__.items()

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def _iter(</span>
<span class="gi">+        self,</span>
<span class="gi">+        to_dict: bool = False,</span>
<span class="gi">+        by_alias: bool = False,</span>
<span class="gi">+        include: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]] = None,</span>
<span class="gi">+        exclude: Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]] = None,</span>
<span class="gi">+        exclude_unset: bool = False,</span>
<span class="gi">+        exclude_defaults: bool = False,</span>
<span class="gi">+        exclude_none: bool = False,</span>
<span class="gi">+    ) -&gt; &#39;TupleGenerator&#39;:</span>
<span class="gi">+        # Merge field set excludes with explicit exclude parameter with explicit overriding field set options.</span>
<span class="gi">+        # The extra &quot;is not None&quot; guards are not logically necessary but optimizes performance for the simple case.</span>
<span class="gi">+        if exclude is not None or self.__exclude_fields__ is not None:</span>
<span class="gi">+            exclude = ValueItems.merge(self.__exclude_fields__, exclude)</span>
<span class="gi">+</span>
<span class="gi">+        if include is not None or self.__include_fields__ is not None:</span>
<span class="gi">+            include = ValueItems.merge(self.__include_fields__, include, intersect=True)</span>
<span class="gi">+</span>
<span class="gi">+        allowed_keys = self._calculate_keys(</span>
<span class="gi">+            include=include, exclude=exclude, exclude_unset=exclude_unset  # type: ignore</span>
<span class="gi">+        )</span>
<span class="gi">+        if allowed_keys is None and not (to_dict or by_alias or exclude_unset or exclude_defaults or exclude_none):</span>
<span class="gi">+            # huge boost for plain _iter()</span>
<span class="gi">+            yield from self.__dict__.items()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        value_exclude = ValueItems(self, exclude) if exclude is not None else None</span>
<span class="gi">+        value_include = ValueItems(self, include) if include is not None else None</span>
<span class="gi">+</span>
<span class="gi">+        for field_key, v in self.__dict__.items():</span>
<span class="gi">+            if (allowed_keys is not None and field_key not in allowed_keys) or (exclude_none and v is None):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if exclude_defaults:</span>
<span class="gi">+                model_field = self.__fields__.get(field_key)</span>
<span class="gi">+                if not getattr(model_field, &#39;required&#39;, True) and getattr(model_field, &#39;default&#39;, _missing) == v:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            if by_alias and field_key in self.__fields__:</span>
<span class="gi">+                dict_key = self.__fields__[field_key].alias</span>
<span class="gi">+            else:</span>
<span class="gi">+                dict_key = field_key</span>
<span class="gi">+</span>
<span class="gi">+            if to_dict or value_include or value_exclude:</span>
<span class="gi">+                v = self._get_value(</span>
<span class="gi">+                    v,</span>
<span class="gi">+                    to_dict=to_dict,</span>
<span class="gi">+                    by_alias=by_alias,</span>
<span class="gi">+                    include=value_include and value_include.for_element(field_key),</span>
<span class="gi">+                    exclude=value_exclude and value_exclude.for_element(field_key),</span>
<span class="gi">+                    exclude_unset=exclude_unset,</span>
<span class="gi">+                    exclude_defaults=exclude_defaults,</span>
<span class="gi">+                    exclude_none=exclude_none,</span>
<span class="gi">+                )</span>
<span class="gi">+            yield dict_key, v</span>
<span class="gi">+</span>
<span class="gi">+    def _calculate_keys(</span>
<span class="gi">+        self,</span>
<span class="gi">+        include: Optional[&#39;MappingIntStrAny&#39;],</span>
<span class="gi">+        exclude: Optional[&#39;MappingIntStrAny&#39;],</span>
<span class="gi">+        exclude_unset: bool,</span>
<span class="gi">+        update: Optional[&#39;DictStrAny&#39;] = None,</span>
<span class="gi">+    ) -&gt; Optional[AbstractSet[str]]:</span>
<span class="gi">+        if include is None and exclude is None and exclude_unset is False:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        keys: AbstractSet[str]</span>
<span class="gi">+        if exclude_unset:</span>
<span class="gi">+            keys = self.__fields_set__.copy()</span>
<span class="gi">+        else:</span>
<span class="gi">+            keys = self.__dict__.keys()</span>
<span class="gi">+</span>
<span class="gi">+        if include is not None:</span>
<span class="gi">+            keys &amp;= include.keys()</span>
<span class="gi">+</span>
<span class="gi">+        if update:</span>
<span class="gi">+            keys -= update.keys()</span>
<span class="gi">+</span>
<span class="gi">+        if exclude:</span>
<span class="gi">+            keys -= {k for k, v in exclude.items() if ValueItems.is_true(v)}</span>
<span class="gi">+</span>
<span class="gi">+        return keys</span>
<span class="gi">+</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        if isinstance(other, BaseModel):
<span class="w"> </span>            return self.dict() == other.dict()
<span class="w"> </span>        else:
<span class="w"> </span>            return self.dict() == other

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gd">-        return [(k, v) for k, v in self.__dict__.items() if k not in</span>
<span class="gd">-            DUNDER_ATTRIBUTES and (k not in self.__fields__ or self.</span>
<span class="gd">-            __fields__[k].field_info.repr)]</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="gi">+        return [</span>
<span class="gi">+            (k, v)</span>
<span class="gi">+            for k, v in self.__dict__.items()</span>
<span class="gi">+            if k not in DUNDER_ATTRIBUTES and (k not in self.__fields__ or self.__fields__[k].field_info.repr)</span>
<span class="gi">+        ]</span>


<span class="w"> </span>_is_base_model_class_defined = True


<span class="gd">-def create_model(__model_name: str, *, __config__: Optional[Type[BaseConfig</span>
<span class="gd">-    ]]=None, __base__: Union[None, Type[&#39;Model&#39;], Tuple[Type[&#39;Model&#39;], ...]</span>
<span class="gd">-    ]=None, __module__: str=__name__, __validators__: Dict[str,</span>
<span class="gd">-    &#39;AnyClassMethod&#39;]=None, __cls_kwargs__: Dict[str, Any]=None, __slots__:</span>
<span class="gd">-    Optional[Tuple[str, ...]]=None, **field_definitions: Any) -&gt;Type[&#39;Model&#39;]:</span>
<span class="gi">+@overload</span>
<span class="gi">+def create_model(</span>
<span class="gi">+    __model_name: str,</span>
<span class="gi">+    *,</span>
<span class="gi">+    __config__: Optional[Type[BaseConfig]] = None,</span>
<span class="gi">+    __base__: None = None,</span>
<span class="gi">+    __module__: str = __name__,</span>
<span class="gi">+    __validators__: Dict[str, &#39;AnyClassMethod&#39;] = None,</span>
<span class="gi">+    __cls_kwargs__: Dict[str, Any] = None,</span>
<span class="gi">+    **field_definitions: Any,</span>
<span class="gi">+) -&gt; Type[&#39;BaseModel&#39;]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def create_model(</span>
<span class="gi">+    __model_name: str,</span>
<span class="gi">+    *,</span>
<span class="gi">+    __config__: Optional[Type[BaseConfig]] = None,</span>
<span class="gi">+    __base__: Union[Type[&#39;Model&#39;], Tuple[Type[&#39;Model&#39;], ...]],</span>
<span class="gi">+    __module__: str = __name__,</span>
<span class="gi">+    __validators__: Dict[str, &#39;AnyClassMethod&#39;] = None,</span>
<span class="gi">+    __cls_kwargs__: Dict[str, Any] = None,</span>
<span class="gi">+    **field_definitions: Any,</span>
<span class="gi">+) -&gt; Type[&#39;Model&#39;]:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_model(</span>
<span class="gi">+    __model_name: str,</span>
<span class="gi">+    *,</span>
<span class="gi">+    __config__: Optional[Type[BaseConfig]] = None,</span>
<span class="gi">+    __base__: Union[None, Type[&#39;Model&#39;], Tuple[Type[&#39;Model&#39;], ...]] = None,</span>
<span class="gi">+    __module__: str = __name__,</span>
<span class="gi">+    __validators__: Dict[str, &#39;AnyClassMethod&#39;] = None,</span>
<span class="gi">+    __cls_kwargs__: Dict[str, Any] = None,</span>
<span class="gi">+    __slots__: Optional[Tuple[str, ...]] = None,</span>
<span class="gi">+    **field_definitions: Any,</span>
<span class="gi">+) -&gt; Type[&#39;Model&#39;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Dynamically create a model.
<span class="w"> </span>    :param __model_name: name of the created model
<span class="gu">@@ -417,16 +974,134 @@ def create_model(__model_name: str, *, __config__: Optional[Type[BaseConfig</span>
<span class="w"> </span>        `foo=Field(datetime, default_factory=datetime.utcnow, alias=&#39;bar&#39;)` or
<span class="w"> </span>        `foo=(str, FieldInfo(title=&#39;Foo&#39;))`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if __slots__ is not None:</span>
<span class="gi">+        # __slots__ will be ignored from here on</span>
<span class="gi">+        warnings.warn(&#39;__slots__ should not be passed to create_model&#39;, RuntimeWarning)</span>
<span class="gi">+</span>
<span class="gi">+    if __base__ is not None:</span>
<span class="gi">+        if __config__ is not None:</span>
<span class="gi">+            raise ConfigError(&#39;to avoid confusion __config__ and __base__ cannot be used together&#39;)</span>
<span class="gi">+        if not isinstance(__base__, tuple):</span>
<span class="gi">+            __base__ = (__base__,)</span>
<span class="gi">+    else:</span>
<span class="gi">+        __base__ = (cast(Type[&#39;Model&#39;], BaseModel),)</span>
<span class="gi">+</span>
<span class="gi">+    __cls_kwargs__ = __cls_kwargs__ or {}</span>
<span class="gi">+</span>
<span class="gi">+    fields = {}</span>
<span class="gi">+    annotations = {}</span>
<span class="gi">+</span>
<span class="gi">+    for f_name, f_def in field_definitions.items():</span>
<span class="gi">+        if not is_valid_field(f_name):</span>
<span class="gi">+            warnings.warn(f&#39;fields may not start with an underscore, ignoring &quot;{f_name}&quot;&#39;, RuntimeWarning)</span>
<span class="gi">+        if isinstance(f_def, tuple):</span>
<span class="gi">+            try:</span>
<span class="gi">+                f_annotation, f_value = f_def</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                raise ConfigError(</span>
<span class="gi">+                    &#39;field definitions should either be a tuple of (&lt;type&gt;, &lt;default&gt;) or just a &#39;</span>
<span class="gi">+                    &#39;default value, unfortunately this means tuples as &#39;</span>
<span class="gi">+                    &#39;default values are not allowed&#39;</span>
<span class="gi">+                ) from e</span>
<span class="gi">+        else:</span>
<span class="gi">+            f_annotation, f_value = None, f_def</span>
<span class="gi">+</span>
<span class="gi">+        if f_annotation:</span>
<span class="gi">+            annotations[f_name] = f_annotation</span>
<span class="gi">+        fields[f_name] = f_value</span>
<span class="gi">+</span>
<span class="gi">+    namespace: &#39;DictStrAny&#39; = {&#39;__annotations__&#39;: annotations, &#39;__module__&#39;: __module__}</span>
<span class="gi">+    if __validators__:</span>
<span class="gi">+        namespace.update(__validators__)</span>
<span class="gi">+    namespace.update(fields)</span>
<span class="gi">+    if __config__:</span>
<span class="gi">+        namespace[&#39;Config&#39;] = inherit_config(__config__, BaseConfig)</span>
<span class="gi">+    resolved_bases = resolve_bases(__base__)</span>
<span class="gi">+    meta, ns, kwds = prepare_class(__model_name, resolved_bases, kwds=__cls_kwargs__)</span>
<span class="gi">+    if resolved_bases is not __base__:</span>
<span class="gi">+        ns[&#39;__orig_bases__&#39;] = __base__</span>
<span class="gi">+    namespace.update(ns)</span>
<span class="gi">+    return meta(__model_name, resolved_bases, namespace, **kwds)</span>


<span class="w"> </span>_missing = object()


<span class="gd">-def validate_model(model: Type[BaseModel], input_data: &#39;DictStrAny&#39;, cls:</span>
<span class="gd">-    &#39;ModelOrDc&#39;=None) -&gt;Tuple[&#39;DictStrAny&#39;, &#39;SetStr&#39;, Optional[ValidationError]</span>
<span class="gd">-    ]:</span>
<span class="gi">+def validate_model(  # noqa: C901 (ignore complexity)</span>
<span class="gi">+    model: Type[BaseModel], input_data: &#39;DictStrAny&#39;, cls: &#39;ModelOrDc&#39; = None</span>
<span class="gi">+) -&gt; Tuple[&#39;DictStrAny&#39;, &#39;SetStr&#39;, Optional[ValidationError]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    validate data against a model.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    values = {}</span>
<span class="gi">+    errors = []</span>
<span class="gi">+    # input_data names, possibly alias</span>
<span class="gi">+    names_used = set()</span>
<span class="gi">+    # field names, never aliases</span>
<span class="gi">+    fields_set = set()</span>
<span class="gi">+    config = model.__config__</span>
<span class="gi">+    check_extra = config.extra is not Extra.ignore</span>
<span class="gi">+    cls_ = cls or model</span>
<span class="gi">+</span>
<span class="gi">+    for validator in model.__pre_root_validators__:</span>
<span class="gi">+        try:</span>
<span class="gi">+            input_data = validator(cls_, input_data)</span>
<span class="gi">+        except (ValueError, TypeError, AssertionError) as exc:</span>
<span class="gi">+            return {}, set(), ValidationError([ErrorWrapper(exc, loc=ROOT_KEY)], cls_)</span>
<span class="gi">+</span>
<span class="gi">+    for name, field in model.__fields__.items():</span>
<span class="gi">+        value = input_data.get(field.alias, _missing)</span>
<span class="gi">+        using_name = False</span>
<span class="gi">+        if value is _missing and config.allow_population_by_field_name and field.alt_alias:</span>
<span class="gi">+            value = input_data.get(field.name, _missing)</span>
<span class="gi">+            using_name = True</span>
<span class="gi">+</span>
<span class="gi">+        if value is _missing:</span>
<span class="gi">+            if field.required:</span>
<span class="gi">+                errors.append(ErrorWrapper(MissingError(), loc=field.alias))</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            value = field.get_default()</span>
<span class="gi">+</span>
<span class="gi">+            if not config.validate_all and not field.validate_always:</span>
<span class="gi">+                values[name] = value</span>
<span class="gi">+                continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            fields_set.add(name)</span>
<span class="gi">+            if check_extra:</span>
<span class="gi">+                names_used.add(field.name if using_name else field.alias)</span>
<span class="gi">+</span>
<span class="gi">+        v_, errors_ = field.validate(value, values, loc=field.alias, cls=cls_)</span>
<span class="gi">+        if isinstance(errors_, ErrorWrapper):</span>
<span class="gi">+            errors.append(errors_)</span>
<span class="gi">+        elif isinstance(errors_, list):</span>
<span class="gi">+            errors.extend(errors_)</span>
<span class="gi">+        else:</span>
<span class="gi">+            values[name] = v_</span>
<span class="gi">+</span>
<span class="gi">+    if check_extra:</span>
<span class="gi">+        if isinstance(input_data, GetterDict):</span>
<span class="gi">+            extra = input_data.extra_keys() - names_used</span>
<span class="gi">+        else:</span>
<span class="gi">+            extra = input_data.keys() - names_used</span>
<span class="gi">+        if extra:</span>
<span class="gi">+            fields_set |= extra</span>
<span class="gi">+            if config.extra is Extra.allow:</span>
<span class="gi">+                for f in extra:</span>
<span class="gi">+                    values[f] = input_data[f]</span>
<span class="gi">+            else:</span>
<span class="gi">+                for f in sorted(extra):</span>
<span class="gi">+                    errors.append(ErrorWrapper(ExtraError(), loc=f))</span>
<span class="gi">+</span>
<span class="gi">+    for skip_on_failure, validator in model.__post_root_validators__:</span>
<span class="gi">+        if skip_on_failure and errors:</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            values = validator(cls_, values)</span>
<span class="gi">+        except (ValueError, TypeError, AssertionError) as exc:</span>
<span class="gi">+            errors.append(ErrorWrapper(exc, loc=ROOT_KEY))</span>
<span class="gi">+</span>
<span class="gi">+    if errors:</span>
<span class="gi">+        return values, fields_set, ValidationError(errors, cls_)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return values, fields_set, None</span>
<span class="gh">diff --git a/pydantic/v1/mypy.py b/pydantic/v1/mypy.py</span>
<span class="gh">index 69913f634..20fc039d5 100644</span>
<span class="gd">--- a/pydantic/v1/mypy.py</span>
<span class="gi">+++ b/pydantic/v1/mypy.py</span>
<span class="gu">@@ -1,78 +1,174 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>from configparser import ConfigParser
<span class="w"> </span>from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as TypingType, Union
<span class="gi">+</span>
<span class="w"> </span>from mypy.errorcodes import ErrorCode
<span class="gd">-from mypy.nodes import ARG_NAMED, ARG_NAMED_OPT, ARG_OPT, ARG_POS, ARG_STAR2, MDEF, Argument, AssignmentStmt, Block, CallExpr, ClassDef, Context, Decorator, EllipsisExpr, FuncBase, FuncDef, JsonDict, MemberExpr, NameExpr, PassStmt, PlaceholderNode, RefExpr, StrExpr, SymbolNode, SymbolTableNode, TempNode, TypeInfo, TypeVarExpr, Var</span>
<span class="gi">+from mypy.nodes import (</span>
<span class="gi">+    ARG_NAMED,</span>
<span class="gi">+    ARG_NAMED_OPT,</span>
<span class="gi">+    ARG_OPT,</span>
<span class="gi">+    ARG_POS,</span>
<span class="gi">+    ARG_STAR2,</span>
<span class="gi">+    MDEF,</span>
<span class="gi">+    Argument,</span>
<span class="gi">+    AssignmentStmt,</span>
<span class="gi">+    Block,</span>
<span class="gi">+    CallExpr,</span>
<span class="gi">+    ClassDef,</span>
<span class="gi">+    Context,</span>
<span class="gi">+    Decorator,</span>
<span class="gi">+    EllipsisExpr,</span>
<span class="gi">+    FuncBase,</span>
<span class="gi">+    FuncDef,</span>
<span class="gi">+    JsonDict,</span>
<span class="gi">+    MemberExpr,</span>
<span class="gi">+    NameExpr,</span>
<span class="gi">+    PassStmt,</span>
<span class="gi">+    PlaceholderNode,</span>
<span class="gi">+    RefExpr,</span>
<span class="gi">+    StrExpr,</span>
<span class="gi">+    SymbolNode,</span>
<span class="gi">+    SymbolTableNode,</span>
<span class="gi">+    TempNode,</span>
<span class="gi">+    TypeInfo,</span>
<span class="gi">+    TypeVarExpr,</span>
<span class="gi">+    Var,</span>
<span class="gi">+)</span>
<span class="w"> </span>from mypy.options import Options
<span class="gd">-from mypy.plugin import CheckerPluginInterface, ClassDefContext, FunctionContext, MethodContext, Plugin, ReportConfigContext, SemanticAnalyzerPluginInterface</span>
<span class="gi">+from mypy.plugin import (</span>
<span class="gi">+    CheckerPluginInterface,</span>
<span class="gi">+    ClassDefContext,</span>
<span class="gi">+    FunctionContext,</span>
<span class="gi">+    MethodContext,</span>
<span class="gi">+    Plugin,</span>
<span class="gi">+    ReportConfigContext,</span>
<span class="gi">+    SemanticAnalyzerPluginInterface,</span>
<span class="gi">+)</span>
<span class="w"> </span>from mypy.plugins import dataclasses
<span class="gd">-from mypy.semanal import set_callable_name</span>
<span class="gi">+from mypy.semanal import set_callable_name  # type: ignore</span>
<span class="w"> </span>from mypy.server.trigger import make_wildcard_trigger
<span class="gd">-from mypy.types import AnyType, CallableType, Instance, NoneType, Overloaded, ProperType, Type, TypeOfAny, TypeType, TypeVarId, TypeVarType, UnionType, get_proper_type</span>
<span class="gi">+from mypy.types import (</span>
<span class="gi">+    AnyType,</span>
<span class="gi">+    CallableType,</span>
<span class="gi">+    Instance,</span>
<span class="gi">+    NoneType,</span>
<span class="gi">+    Overloaded,</span>
<span class="gi">+    ProperType,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeOfAny,</span>
<span class="gi">+    TypeType,</span>
<span class="gi">+    TypeVarId,</span>
<span class="gi">+    TypeVarType,</span>
<span class="gi">+    UnionType,</span>
<span class="gi">+    get_proper_type,</span>
<span class="gi">+)</span>
<span class="w"> </span>from mypy.typevars import fill_typevars
<span class="w"> </span>from mypy.util import get_unique_redefinition_name
<span class="w"> </span>from mypy.version import __version__ as mypy_version
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.utils import is_valid_field
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    from mypy.types import TypeVarDef</span>
<span class="gd">-except ImportError:</span>
<span class="gi">+    from mypy.types import TypeVarDef  # type: ignore[attr-defined]</span>
<span class="gi">+except ImportError:  # pragma: no cover</span>
<span class="gi">+    # Backward-compatible with TypeVarDef from Mypy 0.910.</span>
<span class="w"> </span>    from mypy.types import TypeVarType as TypeVarDef
<span class="gi">+</span>
<span class="w"> </span>CONFIGFILE_KEY = &#39;pydantic-mypy&#39;
<span class="w"> </span>METADATA_KEY = &#39;pydantic-mypy-metadata&#39;
<span class="gd">-_NAMESPACE = __name__[:-5]</span>
<span class="gi">+_NAMESPACE = __name__[:-5]  # &#39;pydantic&#39; in 1.10.X, &#39;pydantic.v1&#39; in v2.X</span>
<span class="w"> </span>BASEMODEL_FULLNAME = f&#39;{_NAMESPACE}.main.BaseModel&#39;
<span class="w"> </span>BASESETTINGS_FULLNAME = f&#39;{_NAMESPACE}.env_settings.BaseSettings&#39;
<span class="w"> </span>MODEL_METACLASS_FULLNAME = f&#39;{_NAMESPACE}.main.ModelMetaclass&#39;
<span class="w"> </span>FIELD_FULLNAME = f&#39;{_NAMESPACE}.fields.Field&#39;
<span class="w"> </span>DATACLASS_FULLNAME = f&#39;{_NAMESPACE}.dataclasses.dataclass&#39;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_mypy_version(version: str) -&gt; Tuple[int, ...]:</span>
<span class="gi">+    return tuple(map(int, version.partition(&#39;+&#39;)[0].split(&#39;.&#39;)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>MYPY_VERSION_TUPLE = parse_mypy_version(mypy_version)
<span class="gd">-BUILTINS_NAME = &#39;builtins&#39; if MYPY_VERSION_TUPLE &gt;= (0, 930</span>
<span class="gd">-    ) else &#39;__builtins__&#39;</span>
<span class="gi">+BUILTINS_NAME = &#39;builtins&#39; if MYPY_VERSION_TUPLE &gt;= (0, 930) else &#39;__builtins__&#39;</span>
<span class="gi">+</span>
<span class="gi">+# Increment version if plugin changes and mypy caches should be invalidated</span>
<span class="w"> </span>__version__ = 2


<span class="gd">-def plugin(version: str) -&gt;&#39;TypingType[Plugin]&#39;:</span>
<span class="gi">+def plugin(version: str) -&gt; &#39;TypingType[Plugin]&#39;:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    `version` is the mypy version string

<span class="w"> </span>    We might want to use this to print a warning if the mypy version being used is
<span class="w"> </span>    newer, or especially older, than we expect (or need).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return PydanticPlugin</span>


<span class="w"> </span>class PydanticPlugin(Plugin):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options: Options) -&gt;None:</span>
<span class="gi">+    def __init__(self, options: Options) -&gt; None:</span>
<span class="w"> </span>        self.plugin_config = PydanticPluginConfig(options)
<span class="w"> </span>        self._plugin_data = self.plugin_config.to_data()
<span class="w"> </span>        super().__init__(options)

<span class="gd">-    def get_class_decorator_hook(self, fullname: str) -&gt;Optional[Callable[[</span>
<span class="gd">-        ClassDefContext], None]]:</span>
<span class="gi">+    def get_base_class_hook(self, fullname: str) -&gt; &#39;Optional[Callable[[ClassDefContext], None]]&#39;:</span>
<span class="gi">+        sym = self.lookup_fully_qualified(fullname)</span>
<span class="gi">+        if sym and isinstance(sym.node, TypeInfo):  # pragma: no branch</span>
<span class="gi">+            # No branching may occur if the mypy cache has not been cleared</span>
<span class="gi">+            if any(get_fullname(base) == BASEMODEL_FULLNAME for base in sym.node.mro):</span>
<span class="gi">+                return self._pydantic_model_class_maker_callback</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_metaclass_hook(self, fullname: str) -&gt; Optional[Callable[[ClassDefContext], None]]:</span>
<span class="gi">+        if fullname == MODEL_METACLASS_FULLNAME:</span>
<span class="gi">+            return self._pydantic_model_metaclass_marker_callback</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_function_hook(self, fullname: str) -&gt; &#39;Optional[Callable[[FunctionContext], Type]]&#39;:</span>
<span class="gi">+        sym = self.lookup_fully_qualified(fullname)</span>
<span class="gi">+        if sym and sym.fullname == FIELD_FULLNAME:</span>
<span class="gi">+            return self._pydantic_field_callback</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_method_hook(self, fullname: str) -&gt; Optional[Callable[[MethodContext], Type]]:</span>
<span class="gi">+        if fullname.endswith(&#39;.from_orm&#39;):</span>
<span class="gi">+            return from_orm_callback</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_class_decorator_hook(self, fullname: str) -&gt; Optional[Callable[[ClassDefContext], None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mark pydantic.dataclasses as dataclass.

<span class="w"> </span>        Mypy version 1.1.1 added support for `@dataclass_transform` decorator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname == DATACLASS_FULLNAME and MYPY_VERSION_TUPLE &lt; (1, 1):</span>
<span class="gi">+            return dataclasses.dataclass_class_maker_callback  # type: ignore[return-value]</span>
<span class="gi">+        return None</span>

<span class="gd">-    def report_config_data(self, ctx: ReportConfigContext) -&gt;Dict[str, Any]:</span>
<span class="gi">+    def report_config_data(self, ctx: ReportConfigContext) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return all plugin config data.

<span class="w"> </span>        Used by mypy to determine if cache needs to be discarded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._plugin_data</span>

<span class="gd">-    def _pydantic_model_metaclass_marker_callback(self, ctx: ClassDefContext</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _pydantic_model_class_maker_callback(self, ctx: ClassDefContext) -&gt; None:</span>
<span class="gi">+        transformer = PydanticModelTransformer(ctx, self.plugin_config)</span>
<span class="gi">+        transformer.transform()</span>
<span class="gi">+</span>
<span class="gi">+    def _pydantic_model_metaclass_marker_callback(self, ctx: ClassDefContext) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset dataclass_transform_spec attribute of ModelMetaclass.

<span class="w"> </span>        Let the plugin handle it. This behavior can be disabled
<span class="w"> </span>        if &#39;debug_dataclass_transform&#39; is set to True&#39;, for testing purposes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.plugin_config.debug_dataclass_transform:</span>
<span class="gi">+            return</span>
<span class="gi">+        info_metaclass = ctx.cls.info.declared_metaclass</span>
<span class="gi">+        assert info_metaclass, &quot;callback not passed from &#39;get_metaclass_hook&#39;&quot;</span>
<span class="gi">+        if getattr(info_metaclass.type, &#39;dataclass_transform_spec&#39;, None):</span>
<span class="gi">+            info_metaclass.type.dataclass_transform_spec = None  # type: ignore[attr-defined]</span>

<span class="gd">-    def _pydantic_field_callback(self, ctx: FunctionContext) -&gt;&#39;Type&#39;:</span>
<span class="gi">+    def _pydantic_field_callback(self, ctx: FunctionContext) -&gt; &#39;Type&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Extract the type of the `default` argument from the Field function, and use it as the return type.

<span class="gu">@@ -81,58 +177,128 @@ class PydanticPlugin(Plugin):</span>
<span class="w"> </span>        * Output an error if both are specified.
<span class="w"> </span>        * Retrieve the type of the argument which is specified, and use it as return type for the function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        default_any_type = ctx.default_return_type</span>
<span class="gi">+</span>
<span class="gi">+        assert ctx.callee_arg_names[0] == &#39;default&#39;, &#39;&quot;default&quot; is no longer first argument in Field()&#39;</span>
<span class="gi">+        assert ctx.callee_arg_names[1] == &#39;default_factory&#39;, &#39;&quot;default_factory&quot; is no longer second argument in Field()&#39;</span>
<span class="gi">+        default_args = ctx.args[0]</span>
<span class="gi">+        default_factory_args = ctx.args[1]</span>
<span class="gi">+</span>
<span class="gi">+        if default_args and default_factory_args:</span>
<span class="gi">+            error_default_and_default_factory_specified(ctx.api, ctx.context)</span>
<span class="gi">+            return default_any_type</span>
<span class="gi">+</span>
<span class="gi">+        if default_args:</span>
<span class="gi">+            default_type = ctx.arg_types[0][0]</span>
<span class="gi">+            default_arg = default_args[0]</span>
<span class="gi">+</span>
<span class="gi">+            # Fallback to default Any type if the field is required</span>
<span class="gi">+            if not isinstance(default_arg, EllipsisExpr):</span>
<span class="gi">+                return default_type</span>
<span class="gi">+</span>
<span class="gi">+        elif default_factory_args:</span>
<span class="gi">+            default_factory_type = ctx.arg_types[1][0]</span>
<span class="gi">+</span>
<span class="gi">+            # Functions which use `ParamSpec` can be overloaded, exposing the callable&#39;s types as a parameter</span>
<span class="gi">+            # Pydantic calls the default factory without any argument, so we retrieve the first item</span>
<span class="gi">+            if isinstance(default_factory_type, Overloaded):</span>
<span class="gi">+                if MYPY_VERSION_TUPLE &gt; (0, 910):</span>
<span class="gi">+                    default_factory_type = default_factory_type.items[0]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Mypy0.910 exposes the items of overloaded types in a function</span>
<span class="gi">+                    default_factory_type = default_factory_type.items()[0]  # type: ignore[operator]</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(default_factory_type, CallableType):</span>
<span class="gi">+                ret_type = default_factory_type.ret_type</span>
<span class="gi">+                # mypy doesn&#39;t think `ret_type` has `args`, you&#39;d think mypy should know,</span>
<span class="gi">+                # add this check in case it varies by version</span>
<span class="gi">+                args = getattr(ret_type, &#39;args&#39;, None)</span>
<span class="gi">+                if args:</span>
<span class="gi">+                    if all(isinstance(arg, TypeVarType) for arg in args):</span>
<span class="gi">+                        # Looks like the default factory is a type like `list` or `dict`, replace all args with `Any`</span>
<span class="gi">+                        ret_type.args = tuple(default_any_type for _ in args)  # type: ignore[attr-defined]</span>
<span class="gi">+                return ret_type</span>
<span class="gi">+</span>
<span class="gi">+        return default_any_type</span>


<span class="w"> </span>class PydanticPluginConfig:
<span class="gd">-    __slots__ = (&#39;init_forbid_extra&#39;, &#39;init_typed&#39;,</span>
<span class="gd">-        &#39;warn_required_dynamic_aliases&#39;, &#39;warn_untyped_fields&#39;,</span>
<span class="gd">-        &#39;debug_dataclass_transform&#39;)</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;init_forbid_extra&#39;,</span>
<span class="gi">+        &#39;init_typed&#39;,</span>
<span class="gi">+        &#39;warn_required_dynamic_aliases&#39;,</span>
<span class="gi">+        &#39;warn_untyped_fields&#39;,</span>
<span class="gi">+        &#39;debug_dataclass_transform&#39;,</span>
<span class="gi">+    )</span>
<span class="w"> </span>    init_forbid_extra: bool
<span class="w"> </span>    init_typed: bool
<span class="w"> </span>    warn_required_dynamic_aliases: bool
<span class="w"> </span>    warn_untyped_fields: bool
<span class="gd">-    debug_dataclass_transform: bool</span>
<span class="gi">+    debug_dataclass_transform: bool  # undocumented</span>

<span class="gd">-    def __init__(self, options: Options) -&gt;None:</span>
<span class="gd">-        if options.config_file is None:</span>
<span class="gi">+    def __init__(self, options: Options) -&gt; None:</span>
<span class="gi">+        if options.config_file is None:  # pragma: no cover</span>
<span class="w"> </span>            return
<span class="gi">+</span>
<span class="w"> </span>        toml_config = parse_toml(options.config_file)
<span class="w"> </span>        if toml_config is not None:
<span class="w"> </span>            config = toml_config.get(&#39;tool&#39;, {}).get(&#39;pydantic-mypy&#39;, {})
<span class="w"> </span>            for key in self.__slots__:
<span class="w"> </span>                setting = config.get(key, False)
<span class="w"> </span>                if not isinstance(setting, bool):
<span class="gd">-                    raise ValueError(</span>
<span class="gd">-                        f&#39;Configuration value must be a boolean for key: {key}&#39;</span>
<span class="gd">-                        )</span>
<span class="gi">+                    raise ValueError(f&#39;Configuration value must be a boolean for key: {key}&#39;)</span>
<span class="w"> </span>                setattr(self, key, setting)
<span class="w"> </span>        else:
<span class="w"> </span>            plugin_config = ConfigParser()
<span class="w"> </span>            plugin_config.read(options.config_file)
<span class="w"> </span>            for key in self.__slots__:
<span class="gd">-                setting = plugin_config.getboolean(CONFIGFILE_KEY, key,</span>
<span class="gd">-                    fallback=False)</span>
<span class="gi">+                setting = plugin_config.getboolean(CONFIGFILE_KEY, key, fallback=False)</span>
<span class="w"> </span>                setattr(self, key, setting)

<span class="gi">+    def to_data(self) -&gt; Dict[str, Any]:</span>
<span class="gi">+        return {key: getattr(self, key) for key in self.__slots__}</span>

<span class="gd">-def from_orm_callback(ctx: MethodContext) -&gt;Type:</span>
<span class="gi">+</span>
<span class="gi">+def from_orm_callback(ctx: MethodContext) -&gt; Type:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Raise an error if orm_mode is not enabled
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    model_type: Instance</span>
<span class="gi">+    ctx_type = ctx.type</span>
<span class="gi">+    if isinstance(ctx_type, TypeType):</span>
<span class="gi">+        ctx_type = ctx_type.item</span>
<span class="gi">+    if isinstance(ctx_type, CallableType) and isinstance(ctx_type.ret_type, Instance):</span>
<span class="gi">+        model_type = ctx_type.ret_type  # called on the class</span>
<span class="gi">+    elif isinstance(ctx_type, Instance):</span>
<span class="gi">+        model_type = ctx_type  # called on an instance (unusual, but still valid)</span>
<span class="gi">+    else:  # pragma: no cover</span>
<span class="gi">+        detail = f&#39;ctx.type: {ctx_type} (of type {ctx_type.__class__.__name__})&#39;</span>
<span class="gi">+        error_unexpected_behavior(detail, ctx.api, ctx.context)</span>
<span class="gi">+        return ctx.default_return_type</span>
<span class="gi">+    pydantic_metadata = model_type.type.metadata.get(METADATA_KEY)</span>
<span class="gi">+    if pydantic_metadata is None:</span>
<span class="gi">+        return ctx.default_return_type</span>
<span class="gi">+    orm_mode = pydantic_metadata.get(&#39;config&#39;, {}).get(&#39;orm_mode&#39;)</span>
<span class="gi">+    if orm_mode is not True:</span>
<span class="gi">+        error_from_orm(get_name(model_type.type), ctx.api, ctx.context)</span>
<span class="gi">+    return ctx.default_return_type</span>


<span class="w"> </span>class PydanticModelTransformer:
<span class="gd">-    tracked_config_fields: Set[str] = {&#39;extra&#39;, &#39;allow_mutation&#39;, &#39;frozen&#39;,</span>
<span class="gd">-        &#39;orm_mode&#39;, &#39;allow_population_by_field_name&#39;, &#39;alias_generator&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, ctx: ClassDefContext, plugin_config:</span>
<span class="gd">-        PydanticPluginConfig) -&gt;None:</span>
<span class="gi">+    tracked_config_fields: Set[str] = {</span>
<span class="gi">+        &#39;extra&#39;,</span>
<span class="gi">+        &#39;allow_mutation&#39;,</span>
<span class="gi">+        &#39;frozen&#39;,</span>
<span class="gi">+        &#39;orm_mode&#39;,</span>
<span class="gi">+        &#39;allow_population_by_field_name&#39;,</span>
<span class="gi">+        &#39;alias_generator&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, ctx: ClassDefContext, plugin_config: PydanticPluginConfig) -&gt; None:</span>
<span class="w"> </span>        self._ctx = ctx
<span class="w"> </span>        self.plugin_config = plugin_config

<span class="gd">-    def transform(self) -&gt;None:</span>
<span class="gi">+    def transform(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Configures the BaseModel subclass according to the plugin settings.

<span class="gu">@@ -142,9 +308,22 @@ class PydanticModelTransformer:</span>
<span class="w"> </span>        * freezes the class if allow_mutation = False or frozen = True
<span class="w"> </span>        * stores the fields, config, and if the class is settings in the mypy metadata for access by subclasses
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def adjust_validator_signatures(self) -&gt;None:</span>
<span class="gi">+        ctx = self._ctx</span>
<span class="gi">+        info = ctx.cls.info</span>
<span class="gi">+</span>
<span class="gi">+        self.adjust_validator_signatures()</span>
<span class="gi">+        config = self.collect_config()</span>
<span class="gi">+        fields = self.collect_fields(config)</span>
<span class="gi">+        is_settings = any(get_fullname(base) == BASESETTINGS_FULLNAME for base in info.mro[:-1])</span>
<span class="gi">+        self.add_initializer(fields, config, is_settings)</span>
<span class="gi">+        self.add_construct_method(fields)</span>
<span class="gi">+        self.set_frozen(fields, frozen=config.allow_mutation is False or config.frozen is True)</span>
<span class="gi">+        info.metadata[METADATA_KEY] = {</span>
<span class="gi">+            &#39;fields&#39;: {field.name: field.serialize() for field in fields},</span>
<span class="gi">+            &#39;config&#39;: config.set_values_dict(),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def adjust_validator_signatures(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;When we decorate a function `f` with `pydantic.validator(...), mypy sees
<span class="w"> </span>        `f` as a regular method taking a `self` instance, even though pydantic
<span class="w"> </span>        internally wraps `f` with `classmethod` if necessary.
<span class="gu">@@ -152,117 +331,390 @@ class PydanticModelTransformer:</span>
<span class="w"> </span>        Teach mypy this by marking any function whose outermost decorator is a
<span class="w"> </span>        `validator()` call as a classmethod.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, sym in self._ctx.cls.info.names.items():</span>
<span class="gi">+            if isinstance(sym.node, Decorator):</span>
<span class="gi">+                first_dec = sym.node.original_decorators[0]</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(first_dec, CallExpr)</span>
<span class="gi">+                    and isinstance(first_dec.callee, NameExpr)</span>
<span class="gi">+                    and first_dec.callee.fullname == f&#39;{_NAMESPACE}.class_validators.validator&#39;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    sym.node.func.is_class = True</span>

<span class="gd">-    def collect_config(self) -&gt;&#39;ModelConfigData&#39;:</span>
<span class="gi">+    def collect_config(self) -&gt; &#39;ModelConfigData&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Collects the values of the config attributes that are used by the plugin, accounting for parent classes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def collect_fields(self, model_config: &#39;ModelConfigData&#39;) -&gt;List[</span>
<span class="gd">-        &#39;PydanticModelField&#39;]:</span>
<span class="gi">+        ctx = self._ctx</span>
<span class="gi">+        cls = ctx.cls</span>
<span class="gi">+        config = ModelConfigData()</span>
<span class="gi">+        for stmt in cls.defs.body:</span>
<span class="gi">+            if not isinstance(stmt, ClassDef):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if stmt.name == &#39;Config&#39;:</span>
<span class="gi">+                for substmt in stmt.defs.body:</span>
<span class="gi">+                    if not isinstance(substmt, AssignmentStmt):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    config.update(self.get_config_update(substmt))</span>
<span class="gi">+                if (</span>
<span class="gi">+                    config.has_alias_generator</span>
<span class="gi">+                    and not config.allow_population_by_field_name</span>
<span class="gi">+                    and self.plugin_config.warn_required_dynamic_aliases</span>
<span class="gi">+                ):</span>
<span class="gi">+                    error_required_dynamic_aliases(ctx.api, stmt)</span>
<span class="gi">+        for info in cls.info.mro[1:]:  # 0 is the current class</span>
<span class="gi">+            if METADATA_KEY not in info.metadata:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Each class depends on the set of fields in its ancestors</span>
<span class="gi">+            ctx.api.add_plugin_dependency(make_wildcard_trigger(get_fullname(info)))</span>
<span class="gi">+            for name, value in info.metadata[METADATA_KEY][&#39;config&#39;].items():</span>
<span class="gi">+                config.setdefault(name, value)</span>
<span class="gi">+        return config</span>
<span class="gi">+</span>
<span class="gi">+    def collect_fields(self, model_config: &#39;ModelConfigData&#39;) -&gt; List[&#39;PydanticModelField&#39;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Collects the fields for the model, accounting for parent classes
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_initializer(self, fields: List[&#39;PydanticModelField&#39;], config:</span>
<span class="gd">-        &#39;ModelConfigData&#39;, is_settings: bool) -&gt;None:</span>
<span class="gi">+        # First, collect fields belonging to the current class.</span>
<span class="gi">+        ctx = self._ctx</span>
<span class="gi">+        cls = self._ctx.cls</span>
<span class="gi">+        fields = []  # type: List[PydanticModelField]</span>
<span class="gi">+        known_fields = set()  # type: Set[str]</span>
<span class="gi">+        for stmt in cls.defs.body:</span>
<span class="gi">+            if not isinstance(stmt, AssignmentStmt):  # `and stmt.new_syntax` to require annotation</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            lhs = stmt.lvalues[0]</span>
<span class="gi">+            if not isinstance(lhs, NameExpr) or not is_valid_field(lhs.name):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not stmt.new_syntax and self.plugin_config.warn_untyped_fields:</span>
<span class="gi">+                error_untyped_fields(ctx.api, stmt)</span>
<span class="gi">+</span>
<span class="gi">+            # if lhs.name == &#39;__config__&#39;:  # BaseConfig not well handled; I&#39;m not sure why yet</span>
<span class="gi">+            #     continue</span>
<span class="gi">+</span>
<span class="gi">+            sym = cls.info.names.get(lhs.name)</span>
<span class="gi">+            if sym is None:  # pragma: no cover</span>
<span class="gi">+                # This is likely due to a star import (see the dataclasses plugin for a more detailed explanation)</span>
<span class="gi">+                # This is the same logic used in the dataclasses plugin</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            node = sym.node</span>
<span class="gi">+            if isinstance(node, PlaceholderNode):  # pragma: no cover</span>
<span class="gi">+                # See the PlaceholderNode docstring for more detail about how this can occur</span>
<span class="gi">+                # Basically, it is an edge case when dealing with complex import logic</span>
<span class="gi">+                # This is the same logic used in the dataclasses plugin</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(node, Var):  # pragma: no cover</span>
<span class="gi">+                # Don&#39;t know if this edge case still happens with the `is_valid_field` check above</span>
<span class="gi">+                # but better safe than sorry</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # x: ClassVar[int] is ignored by dataclasses.</span>
<span class="gi">+            if node.is_classvar:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            is_required = self.get_is_required(cls, stmt, lhs)</span>
<span class="gi">+            alias, has_dynamic_alias = self.get_alias_info(stmt)</span>
<span class="gi">+            if (</span>
<span class="gi">+                has_dynamic_alias</span>
<span class="gi">+                and not model_config.allow_population_by_field_name</span>
<span class="gi">+                and self.plugin_config.warn_required_dynamic_aliases</span>
<span class="gi">+            ):</span>
<span class="gi">+                error_required_dynamic_aliases(ctx.api, stmt)</span>
<span class="gi">+            fields.append(</span>
<span class="gi">+                PydanticModelField(</span>
<span class="gi">+                    name=lhs.name,</span>
<span class="gi">+                    is_required=is_required,</span>
<span class="gi">+                    alias=alias,</span>
<span class="gi">+                    has_dynamic_alias=has_dynamic_alias,</span>
<span class="gi">+                    line=stmt.line,</span>
<span class="gi">+                    column=stmt.column,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            known_fields.add(lhs.name)</span>
<span class="gi">+        all_fields = fields.copy()</span>
<span class="gi">+        for info in cls.info.mro[1:]:  # 0 is the current class, -2 is BaseModel, -1 is object</span>
<span class="gi">+            if METADATA_KEY not in info.metadata:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            superclass_fields = []</span>
<span class="gi">+            # Each class depends on the set of fields in its ancestors</span>
<span class="gi">+            ctx.api.add_plugin_dependency(make_wildcard_trigger(get_fullname(info)))</span>
<span class="gi">+</span>
<span class="gi">+            for name, data in info.metadata[METADATA_KEY][&#39;fields&#39;].items():</span>
<span class="gi">+                if name not in known_fields:</span>
<span class="gi">+                    field = PydanticModelField.deserialize(info, data)</span>
<span class="gi">+                    known_fields.add(name)</span>
<span class="gi">+                    superclass_fields.append(field)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    (field,) = (a for a in all_fields if a.name == name)</span>
<span class="gi">+                    all_fields.remove(field)</span>
<span class="gi">+                    superclass_fields.append(field)</span>
<span class="gi">+            all_fields = superclass_fields + all_fields</span>
<span class="gi">+        return all_fields</span>
<span class="gi">+</span>
<span class="gi">+    def add_initializer(self, fields: List[&#39;PydanticModelField&#39;], config: &#39;ModelConfigData&#39;, is_settings: bool) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Adds a fields-aware `__init__` method to the class.

<span class="w"> </span>        The added `__init__` will be annotated with types vs. all `Any` depending on the plugin settings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctx = self._ctx</span>
<span class="gi">+        typed = self.plugin_config.init_typed</span>
<span class="gi">+        use_alias = config.allow_population_by_field_name is not True</span>
<span class="gi">+        force_all_optional = is_settings or bool(</span>
<span class="gi">+            config.has_alias_generator and not config.allow_population_by_field_name</span>
<span class="gi">+        )</span>
<span class="gi">+        init_arguments = self.get_field_arguments(</span>
<span class="gi">+            fields, typed=typed, force_all_optional=force_all_optional, use_alias=use_alias</span>
<span class="gi">+        )</span>
<span class="gi">+        if not self.should_init_forbid_extra(fields, config):</span>
<span class="gi">+            var = Var(&#39;kwargs&#39;)</span>
<span class="gi">+            init_arguments.append(Argument(var, AnyType(TypeOfAny.explicit), None, ARG_STAR2))</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;__init__&#39; not in ctx.cls.info.names:</span>
<span class="gi">+            add_method(ctx, &#39;__init__&#39;, init_arguments, NoneType())</span>

<span class="gd">-    def add_construct_method(self, fields: List[&#39;PydanticModelField&#39;]) -&gt;None:</span>
<span class="gi">+    def add_construct_method(self, fields: List[&#39;PydanticModelField&#39;]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Adds a fully typed `construct` classmethod to the class.

<span class="w"> </span>        Similar to the fields-aware __init__ method, but always uses the field names (not aliases),
<span class="w"> </span>        and does not treat settings fields as optional.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctx = self._ctx</span>
<span class="gi">+        set_str = ctx.api.named_type(f&#39;{BUILTINS_NAME}.set&#39;, [ctx.api.named_type(f&#39;{BUILTINS_NAME}.str&#39;)])</span>
<span class="gi">+        optional_set_str = UnionType([set_str, NoneType()])</span>
<span class="gi">+        fields_set_argument = Argument(Var(&#39;_fields_set&#39;, optional_set_str), optional_set_str, None, ARG_OPT)</span>
<span class="gi">+        construct_arguments = self.get_field_arguments(fields, typed=True, force_all_optional=False, use_alias=False)</span>
<span class="gi">+        construct_arguments = [fields_set_argument] + construct_arguments</span>
<span class="gi">+</span>
<span class="gi">+        obj_type = ctx.api.named_type(f&#39;{BUILTINS_NAME}.object&#39;)</span>
<span class="gi">+        self_tvar_name = &#39;_PydanticBaseModel&#39;  # Make sure it does not conflict with other names in the class</span>
<span class="gi">+        tvar_fullname = ctx.cls.fullname + &#39;.&#39; + self_tvar_name</span>
<span class="gi">+        if MYPY_VERSION_TUPLE &gt;= (1, 4):</span>
<span class="gi">+            tvd = TypeVarType(</span>
<span class="gi">+                self_tvar_name,</span>
<span class="gi">+                tvar_fullname,</span>
<span class="gi">+                TypeVarId(-1),</span>
<span class="gi">+                [],</span>
<span class="gi">+                obj_type,</span>
<span class="gi">+                AnyType(TypeOfAny.from_omitted_generics),  # type: ignore[arg-type]</span>
<span class="gi">+            )</span>
<span class="gi">+            self_tvar_expr = TypeVarExpr(</span>
<span class="gi">+                self_tvar_name,</span>
<span class="gi">+                tvar_fullname,</span>
<span class="gi">+                [],</span>
<span class="gi">+                obj_type,</span>
<span class="gi">+                AnyType(TypeOfAny.from_omitted_generics),  # type: ignore[arg-type]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            tvd = TypeVarDef(self_tvar_name, tvar_fullname, -1, [], obj_type)</span>
<span class="gi">+            self_tvar_expr = TypeVarExpr(self_tvar_name, tvar_fullname, [], obj_type)</span>
<span class="gi">+        ctx.cls.info.names[self_tvar_name] = SymbolTableNode(MDEF, self_tvar_expr)</span>
<span class="gi">+</span>
<span class="gi">+        # Backward-compatible with TypeVarDef from Mypy 0.910.</span>
<span class="gi">+        if isinstance(tvd, TypeVarType):</span>
<span class="gi">+            self_type = tvd</span>
<span class="gi">+        else:</span>
<span class="gi">+            self_type = TypeVarType(tvd)</span>

<span class="gd">-    def set_frozen(self, fields: List[&#39;PydanticModelField&#39;], frozen: bool</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        add_method(</span>
<span class="gi">+            ctx,</span>
<span class="gi">+            &#39;construct&#39;,</span>
<span class="gi">+            construct_arguments,</span>
<span class="gi">+            return_type=self_type,</span>
<span class="gi">+            self_type=self_type,</span>
<span class="gi">+            tvar_def=tvd,</span>
<span class="gi">+            is_classmethod=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def set_frozen(self, fields: List[&#39;PydanticModelField&#39;], frozen: bool) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Marks all fields as properties so that attempts to set them trigger mypy errors.

<span class="w"> </span>        This is the same approach used by the attrs and dataclasses plugins.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_config_update(self, substmt: AssignmentStmt) -&gt;Optional[</span>
<span class="gd">-        &#39;ModelConfigData&#39;]:</span>
<span class="gi">+        ctx = self._ctx</span>
<span class="gi">+        info = ctx.cls.info</span>
<span class="gi">+        for field in fields:</span>
<span class="gi">+            sym_node = info.names.get(field.name)</span>
<span class="gi">+            if sym_node is not None:</span>
<span class="gi">+                var = sym_node.node</span>
<span class="gi">+                if isinstance(var, Var):</span>
<span class="gi">+                    var.is_property = frozen</span>
<span class="gi">+                elif isinstance(var, PlaceholderNode) and not ctx.api.final_iteration:</span>
<span class="gi">+                    # See https://github.com/pydantic/pydantic/issues/5191 to hit this branch for test coverage</span>
<span class="gi">+                    ctx.api.defer()</span>
<span class="gi">+                else:  # pragma: no cover</span>
<span class="gi">+                    # I don&#39;t know whether it&#39;s possible to hit this branch, but I&#39;ve added it for safety</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        var_str = str(var)</span>
<span class="gi">+                    except TypeError:</span>
<span class="gi">+                        # This happens for PlaceholderNode; perhaps it will happen for other types in the future..</span>
<span class="gi">+                        var_str = repr(var)</span>
<span class="gi">+                    detail = f&#39;sym_node.node: {var_str} (of type {var.__class__})&#39;</span>
<span class="gi">+                    error_unexpected_behavior(detail, ctx.api, ctx.cls)</span>
<span class="gi">+            else:</span>
<span class="gi">+                var = field.to_var(info, use_alias=False)</span>
<span class="gi">+                var.info = info</span>
<span class="gi">+                var.is_property = frozen</span>
<span class="gi">+                var._fullname = get_fullname(info) + &#39;.&#39; + get_name(var)</span>
<span class="gi">+                info.names[get_name(var)] = SymbolTableNode(MDEF, var)</span>
<span class="gi">+</span>
<span class="gi">+    def get_config_update(self, substmt: AssignmentStmt) -&gt; Optional[&#39;ModelConfigData&#39;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Determines the config update due to a single statement in the Config class definition.

<span class="w"> </span>        Warns if a tracked config attribute is set to a value the plugin doesn&#39;t know how to interpret (e.g., an int)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lhs = substmt.lvalues[0]</span>
<span class="gi">+        if not (isinstance(lhs, NameExpr) and lhs.name in self.tracked_config_fields):</span>
<span class="gi">+            return None</span>
<span class="gi">+        if lhs.name == &#39;extra&#39;:</span>
<span class="gi">+            if isinstance(substmt.rvalue, StrExpr):</span>
<span class="gi">+                forbid_extra = substmt.rvalue.value == &#39;forbid&#39;</span>
<span class="gi">+            elif isinstance(substmt.rvalue, MemberExpr):</span>
<span class="gi">+                forbid_extra = substmt.rvalue.name == &#39;forbid&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                error_invalid_config_value(lhs.name, self._ctx.api, substmt)</span>
<span class="gi">+                return None</span>
<span class="gi">+            return ModelConfigData(forbid_extra=forbid_extra)</span>
<span class="gi">+        if lhs.name == &#39;alias_generator&#39;:</span>
<span class="gi">+            has_alias_generator = True</span>
<span class="gi">+            if isinstance(substmt.rvalue, NameExpr) and substmt.rvalue.fullname == &#39;builtins.None&#39;:</span>
<span class="gi">+                has_alias_generator = False</span>
<span class="gi">+            return ModelConfigData(has_alias_generator=has_alias_generator)</span>
<span class="gi">+        if isinstance(substmt.rvalue, NameExpr) and substmt.rvalue.fullname in (&#39;builtins.True&#39;, &#39;builtins.False&#39;):</span>
<span class="gi">+            return ModelConfigData(**{lhs.name: substmt.rvalue.fullname == &#39;builtins.True&#39;})</span>
<span class="gi">+        error_invalid_config_value(lhs.name, self._ctx.api, substmt)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def get_is_required(cls: ClassDef, stmt: AssignmentStmt, lhs: NameExpr</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def get_is_required(cls: ClassDef, stmt: AssignmentStmt, lhs: NameExpr) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a boolean indicating whether the field defined in `stmt` is a required field.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expr = stmt.rvalue</span>
<span class="gi">+        if isinstance(expr, TempNode):</span>
<span class="gi">+            # TempNode means annotation-only, so only non-required if Optional</span>
<span class="gi">+            value_type = get_proper_type(cls.info[lhs.name].type)</span>
<span class="gi">+            return not PydanticModelTransformer.type_has_implicit_default(value_type)</span>
<span class="gi">+        if isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr) and expr.callee.fullname == FIELD_FULLNAME:</span>
<span class="gi">+            # The &quot;default value&quot; is a call to `Field`; at this point, the field is</span>
<span class="gi">+            # only required if default is Ellipsis (i.e., `field_name: Annotation = Field(...)`) or if default_factory</span>
<span class="gi">+            # is specified.</span>
<span class="gi">+            for arg, name in zip(expr.args, expr.arg_names):</span>
<span class="gi">+                # If name is None, then this arg is the default because it is the only positional argument.</span>
<span class="gi">+                if name is None or name == &#39;default&#39;:</span>
<span class="gi">+                    return arg.__class__ is EllipsisExpr</span>
<span class="gi">+                if name == &#39;default_factory&#39;:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            # In this case, default and default_factory are not specified, so we need to look at the annotation</span>
<span class="gi">+            value_type = get_proper_type(cls.info[lhs.name].type)</span>
<span class="gi">+            return not PydanticModelTransformer.type_has_implicit_default(value_type)</span>
<span class="gi">+        # Only required if the &quot;default value&quot; is Ellipsis (i.e., `field_name: Annotation = ...`)</span>
<span class="gi">+        return isinstance(expr, EllipsisExpr)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def type_has_implicit_default(type_: Optional[ProperType]) -&gt;bool:</span>
<span class="gi">+    def type_has_implicit_default(type_: Optional[ProperType]) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns True if the passed type will be given an implicit default value.

<span class="w"> </span>        In pydantic v1, this is the case for Optional types and Any (with default value None).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(type_, AnyType):</span>
<span class="gi">+            # Annotated as Any</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(type_, UnionType) and any(</span>
<span class="gi">+            isinstance(item, NoneType) or isinstance(item, AnyType) for item in type_.items</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Annotated as Optional, or otherwise having NoneType or AnyType in the union</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def get_alias_info(stmt: AssignmentStmt) -&gt;Tuple[Optional[str], bool]:</span>
<span class="gi">+    def get_alias_info(stmt: AssignmentStmt) -&gt; Tuple[Optional[str], bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a pair (alias, has_dynamic_alias), extracted from the declaration of the field defined in `stmt`.

<span class="w"> </span>        `has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal.
<span class="w"> </span>        If `has_dynamic_alias` is True, `alias` will be None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_field_arguments(self, fields: List[&#39;PydanticModelField&#39;], typed:</span>
<span class="gd">-        bool, force_all_optional: bool, use_alias: bool) -&gt;List[Argument]:</span>
<span class="gi">+        expr = stmt.rvalue</span>
<span class="gi">+        if isinstance(expr, TempNode):</span>
<span class="gi">+            # TempNode means annotation-only</span>
<span class="gi">+            return None, False</span>
<span class="gi">+</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr) and expr.callee.fullname == FIELD_FULLNAME</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Assigned value is not a call to pydantic.fields.Field</span>
<span class="gi">+            return None, False</span>
<span class="gi">+</span>
<span class="gi">+        for i, arg_name in enumerate(expr.arg_names):</span>
<span class="gi">+            if arg_name != &#39;alias&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            arg = expr.args[i]</span>
<span class="gi">+            if isinstance(arg, StrExpr):</span>
<span class="gi">+                return arg.value, False</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None, True</span>
<span class="gi">+        return None, False</span>
<span class="gi">+</span>
<span class="gi">+    def get_field_arguments(</span>
<span class="gi">+        self, fields: List[&#39;PydanticModelField&#39;], typed: bool, force_all_optional: bool, use_alias: bool</span>
<span class="gi">+    ) -&gt; List[Argument]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Helper function used during the construction of the `__init__` and `construct` method signatures.

<span class="w"> </span>        Returns a list of mypy Argument instances for use in the generated signatures.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        info = self._ctx.cls.info</span>
<span class="gi">+        arguments = [</span>
<span class="gi">+            field.to_argument(info, typed=typed, force_optional=force_all_optional, use_alias=use_alias)</span>
<span class="gi">+            for field in fields</span>
<span class="gi">+            if not (use_alias and field.has_dynamic_alias)</span>
<span class="gi">+        ]</span>
<span class="gi">+        return arguments</span>

<span class="gd">-    def should_init_forbid_extra(self, fields: List[&#39;PydanticModelField&#39;],</span>
<span class="gd">-        config: &#39;ModelConfigData&#39;) -&gt;bool:</span>
<span class="gi">+    def should_init_forbid_extra(self, fields: List[&#39;PydanticModelField&#39;], config: &#39;ModelConfigData&#39;) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Indicates whether the generated `__init__` should get a `**kwargs` at the end of its signature

<span class="w"> </span>        We disallow arbitrary kwargs if the extra config setting is &quot;forbid&quot;, or if the plugin config says to,
<span class="w"> </span>        *unless* a required dynamic alias is present (since then we can&#39;t determine a valid signature).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not config.allow_population_by_field_name:</span>
<span class="gi">+            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):</span>
<span class="gi">+                return False</span>
<span class="gi">+        if config.forbid_extra:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return self.plugin_config.init_forbid_extra</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def is_dynamic_alias_present(fields: List[&#39;PydanticModelField&#39;],</span>
<span class="gd">-        has_alias_generator: bool) -&gt;bool:</span>
<span class="gi">+    def is_dynamic_alias_present(fields: List[&#39;PydanticModelField&#39;], has_alias_generator: bool) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns whether any fields on the model have a &quot;dynamic alias&quot;, i.e., an alias that cannot be
<span class="w"> </span>        determined during static analysis.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for field in fields:</span>
<span class="gi">+            if field.has_dynamic_alias:</span>
<span class="gi">+                return True</span>
<span class="gi">+        if has_alias_generator:</span>
<span class="gi">+            for field in fields:</span>
<span class="gi">+                if field.alias is None:</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return False</span>


<span class="w"> </span>class PydanticModelField:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, name: str, is_required: bool, alias: Optional[str],</span>
<span class="gd">-        has_dynamic_alias: bool, line: int, column: int):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, name: str, is_required: bool, alias: Optional[str], has_dynamic_alias: bool, line: int, column: int</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.is_required = is_required
<span class="w"> </span>        self.alias = alias
<span class="gu">@@ -270,13 +722,42 @@ class PydanticModelField:</span>
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.column = column

<span class="gi">+    def to_var(self, info: TypeInfo, use_alias: bool) -&gt; Var:</span>
<span class="gi">+        name = self.name</span>
<span class="gi">+        if use_alias and self.alias is not None:</span>
<span class="gi">+            name = self.alias</span>
<span class="gi">+        return Var(name, info[self.name].type)</span>

<span class="gd">-class ModelConfigData:</span>
<span class="gi">+    def to_argument(self, info: TypeInfo, typed: bool, force_optional: bool, use_alias: bool) -&gt; Argument:</span>
<span class="gi">+        if typed and info[self.name].type is not None:</span>
<span class="gi">+            type_annotation = info[self.name].type</span>
<span class="gi">+        else:</span>
<span class="gi">+            type_annotation = AnyType(TypeOfAny.explicit)</span>
<span class="gi">+        return Argument(</span>
<span class="gi">+            variable=self.to_var(info, use_alias),</span>
<span class="gi">+            type_annotation=type_annotation,</span>
<span class="gi">+            initializer=None,</span>
<span class="gi">+            kind=ARG_NAMED_OPT if force_optional or not self.is_required else ARG_NAMED,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def serialize(self) -&gt; JsonDict:</span>
<span class="gi">+        return self.__dict__</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def deserialize(cls, info: TypeInfo, data: JsonDict) -&gt; &#39;PydanticModelField&#39;:</span>
<span class="gi">+        return cls(**data)</span>

<span class="gd">-    def __init__(self, forbid_extra: Optional[bool]=None, allow_mutation:</span>
<span class="gd">-        Optional[bool]=None, frozen: Optional[bool]=None, orm_mode:</span>
<span class="gd">-        Optional[bool]=None, allow_population_by_field_name: Optional[bool]</span>
<span class="gd">-        =None, has_alias_generator: Optional[bool]=None):</span>
<span class="gi">+</span>
<span class="gi">+class ModelConfigData:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        forbid_extra: Optional[bool] = None,</span>
<span class="gi">+        allow_mutation: Optional[bool] = None,</span>
<span class="gi">+        frozen: Optional[bool] = None,</span>
<span class="gi">+        orm_mode: Optional[bool] = None,</span>
<span class="gi">+        allow_population_by_field_name: Optional[bool] = None,</span>
<span class="gi">+        has_alias_generator: Optional[bool] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.forbid_extra = forbid_extra
<span class="w"> </span>        self.allow_mutation = allow_mutation
<span class="w"> </span>        self.frozen = frozen
<span class="gu">@@ -284,39 +765,181 @@ class ModelConfigData:</span>
<span class="w"> </span>        self.allow_population_by_field_name = allow_population_by_field_name
<span class="w"> </span>        self.has_alias_generator = has_alias_generator

<span class="gi">+    def set_values_dict(self) -&gt; Dict[str, Any]:</span>
<span class="gi">+        return {k: v for k, v in self.__dict__.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, config: Optional[&#39;ModelConfigData&#39;]) -&gt; None:</span>
<span class="gi">+        if config is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        for k, v in config.set_values_dict().items():</span>
<span class="gi">+            setattr(self, k, v)</span>
<span class="gi">+</span>
<span class="gi">+    def setdefault(self, key: str, value: Any) -&gt; None:</span>
<span class="gi">+        if getattr(self, key) is None:</span>
<span class="gi">+            setattr(self, key, value)</span>
<span class="gi">+</span>

<span class="w"> </span>ERROR_ORM = ErrorCode(&#39;pydantic-orm&#39;, &#39;Invalid from_orm call&#39;, &#39;Pydantic&#39;)
<span class="w"> </span>ERROR_CONFIG = ErrorCode(&#39;pydantic-config&#39;, &#39;Invalid config value&#39;, &#39;Pydantic&#39;)
<span class="gd">-ERROR_ALIAS = ErrorCode(&#39;pydantic-alias&#39;, &#39;Dynamic alias disallowed&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gd">-ERROR_UNEXPECTED = ErrorCode(&#39;pydantic-unexpected&#39;, &#39;Unexpected behavior&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gd">-ERROR_UNTYPED = ErrorCode(&#39;pydantic-field&#39;, &#39;Untyped field disallowed&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gd">-ERROR_FIELD_DEFAULTS = ErrorCode(&#39;pydantic-field&#39;, &#39;Invalid Field defaults&#39;,</span>
<span class="gd">-    &#39;Pydantic&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def add_method(ctx: ClassDefContext, name: str, args: List[Argument],</span>
<span class="gd">-    return_type: Type, self_type: Optional[Type]=None, tvar_def: Optional[</span>
<span class="gd">-    TypeVarDef]=None, is_classmethod: bool=False, is_new: bool=False) -&gt;None:</span>
<span class="gi">+ERROR_ALIAS = ErrorCode(&#39;pydantic-alias&#39;, &#39;Dynamic alias disallowed&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+ERROR_UNEXPECTED = ErrorCode(&#39;pydantic-unexpected&#39;, &#39;Unexpected behavior&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+ERROR_UNTYPED = ErrorCode(&#39;pydantic-field&#39;, &#39;Untyped field disallowed&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+ERROR_FIELD_DEFAULTS = ErrorCode(&#39;pydantic-field&#39;, &#39;Invalid Field defaults&#39;, &#39;Pydantic&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_from_orm(model_name: str, api: CheckerPluginInterface, context: Context) -&gt; None:</span>
<span class="gi">+    api.fail(f&#39;&quot;{model_name}&quot; does not have orm_mode=True&#39;, context, code=ERROR_ORM)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_invalid_config_value(name: str, api: SemanticAnalyzerPluginInterface, context: Context) -&gt; None:</span>
<span class="gi">+    api.fail(f&#39;Invalid value for &quot;Config.{name}&quot;&#39;, context, code=ERROR_CONFIG)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_required_dynamic_aliases(api: SemanticAnalyzerPluginInterface, context: Context) -&gt; None:</span>
<span class="gi">+    api.fail(&#39;Required dynamic aliases disallowed&#39;, context, code=ERROR_ALIAS)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_unexpected_behavior(</span>
<span class="gi">+    detail: str, api: Union[CheckerPluginInterface, SemanticAnalyzerPluginInterface], context: Context</span>
<span class="gi">+) -&gt; None:  # pragma: no cover</span>
<span class="gi">+    # Can&#39;t think of a good way to test this, but I confirmed it renders as desired by adding to a non-error path</span>
<span class="gi">+    link = &#39;https://github.com/pydantic/pydantic/issues/new/choose&#39;</span>
<span class="gi">+    full_message = f&#39;The pydantic mypy plugin ran into unexpected behavior: {detail}\n&#39;</span>
<span class="gi">+    full_message += f&#39;Please consider reporting this bug at {link} so we can try to fix it!&#39;</span>
<span class="gi">+    api.fail(full_message, context, code=ERROR_UNEXPECTED)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_untyped_fields(api: SemanticAnalyzerPluginInterface, context: Context) -&gt; None:</span>
<span class="gi">+    api.fail(&#39;Untyped fields disallowed&#39;, context, code=ERROR_UNTYPED)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_default_and_default_factory_specified(api: CheckerPluginInterface, context: Context) -&gt; None:</span>
<span class="gi">+    api.fail(&#39;Field default and default_factory cannot be specified together&#39;, context, code=ERROR_FIELD_DEFAULTS)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add_method(</span>
<span class="gi">+    ctx: ClassDefContext,</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    args: List[Argument],</span>
<span class="gi">+    return_type: Type,</span>
<span class="gi">+    self_type: Optional[Type] = None,</span>
<span class="gi">+    tvar_def: Optional[TypeVarDef] = None,</span>
<span class="gi">+    is_classmethod: bool = False,</span>
<span class="gi">+    is_new: bool = False,</span>
<span class="gi">+    # is_staticmethod: bool = False,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Adds a new method to a class.

<span class="w"> </span>    This can be dropped if/when https://github.com/python/mypy/issues/7301 is merged
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_fullname(x: Union[FuncBase, SymbolNode]) -&gt;str:</span>
<span class="gi">+    info = ctx.cls.info</span>
<span class="gi">+</span>
<span class="gi">+    # First remove any previously generated methods with the same name</span>
<span class="gi">+    # to avoid clashes and problems in the semantic analyzer.</span>
<span class="gi">+    if name in info.names:</span>
<span class="gi">+        sym = info.names[name]</span>
<span class="gi">+        if sym.plugin_generated and isinstance(sym.node, FuncDef):</span>
<span class="gi">+            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+    self_type = self_type or fill_typevars(info)</span>
<span class="gi">+    if is_classmethod or is_new:</span>
<span class="gi">+        first = [Argument(Var(&#39;_cls&#39;), TypeType.make_normalized(self_type), None, ARG_POS)]</span>
<span class="gi">+    # elif is_staticmethod:</span>
<span class="gi">+    #     first = []</span>
<span class="gi">+    else:</span>
<span class="gi">+        self_type = self_type or fill_typevars(info)</span>
<span class="gi">+        first = [Argument(Var(&#39;__pydantic_self__&#39;), self_type, None, ARG_POS)]</span>
<span class="gi">+    args = first + args</span>
<span class="gi">+    arg_types, arg_names, arg_kinds = [], [], []</span>
<span class="gi">+    for arg in args:</span>
<span class="gi">+        assert arg.type_annotation, &#39;All arguments must be fully typed.&#39;</span>
<span class="gi">+        arg_types.append(arg.type_annotation)</span>
<span class="gi">+        arg_names.append(get_name(arg.variable))</span>
<span class="gi">+        arg_kinds.append(arg.kind)</span>
<span class="gi">+</span>
<span class="gi">+    function_type = ctx.api.named_type(f&#39;{BUILTINS_NAME}.function&#39;)</span>
<span class="gi">+    signature = CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)</span>
<span class="gi">+    if tvar_def:</span>
<span class="gi">+        signature.variables = [tvar_def]</span>
<span class="gi">+</span>
<span class="gi">+    func = FuncDef(name, args, Block([PassStmt()]))</span>
<span class="gi">+    func.info = info</span>
<span class="gi">+    func.type = set_callable_name(signature, func)</span>
<span class="gi">+    func.is_class = is_classmethod</span>
<span class="gi">+    # func.is_static = is_staticmethod</span>
<span class="gi">+    func._fullname = get_fullname(info) + &#39;.&#39; + name</span>
<span class="gi">+    func.line = info.line</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: we would like the plugin generated node to dominate, but we still</span>
<span class="gi">+    # need to keep any existing definitions so they get semantically analyzed.</span>
<span class="gi">+    if name in info.names:</span>
<span class="gi">+        # Get a nice unique name instead.</span>
<span class="gi">+        r_name = get_unique_redefinition_name(name, info.names)</span>
<span class="gi">+        info.names[r_name] = info.names[name]</span>
<span class="gi">+</span>
<span class="gi">+    if is_classmethod:  # or is_staticmethod:</span>
<span class="gi">+        func.is_decorated = True</span>
<span class="gi">+        v = Var(name, func.type)</span>
<span class="gi">+        v.info = info</span>
<span class="gi">+        v._fullname = func._fullname</span>
<span class="gi">+        # if is_classmethod:</span>
<span class="gi">+        v.is_classmethod = True</span>
<span class="gi">+        dec = Decorator(func, [NameExpr(&#39;classmethod&#39;)], v)</span>
<span class="gi">+        # else:</span>
<span class="gi">+        #     v.is_staticmethod = True</span>
<span class="gi">+        #     dec = Decorator(func, [NameExpr(&#39;staticmethod&#39;)], v)</span>
<span class="gi">+</span>
<span class="gi">+        dec.line = info.line</span>
<span class="gi">+        sym = SymbolTableNode(MDEF, dec)</span>
<span class="gi">+    else:</span>
<span class="gi">+        sym = SymbolTableNode(MDEF, func)</span>
<span class="gi">+    sym.plugin_generated = True</span>
<span class="gi">+</span>
<span class="gi">+    info.names[name] = sym</span>
<span class="gi">+    info.defn.defs.body.append(func)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_fullname(x: Union[FuncBase, SymbolNode]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Used for compatibility with mypy 0.740; can be dropped once support for 0.740 is dropped.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fn = x.fullname</span>
<span class="gi">+    if callable(fn):  # pragma: no cover</span>
<span class="gi">+        return fn()</span>
<span class="gi">+    return fn</span>


<span class="gd">-def get_name(x: Union[FuncBase, SymbolNode]) -&gt;str:</span>
<span class="gi">+def get_name(x: Union[FuncBase, SymbolNode]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Used for compatibility with mypy 0.740; can be dropped once support for 0.740 is dropped.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fn = x.name</span>
<span class="gi">+    if callable(fn):  # pragma: no cover</span>
<span class="gi">+        return fn()</span>
<span class="gi">+    return fn</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_toml(config_file: str) -&gt; Optional[Dict[str, Any]]:</span>
<span class="gi">+    if not config_file.endswith(&#39;.toml&#39;):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    read_mode = &#39;rb&#39;</span>
<span class="gi">+    if sys.version_info &gt;= (3, 11):</span>
<span class="gi">+        import tomllib as toml_</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            import tomli as toml_</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            # older versions of mypy have toml as a dependency, not tomli</span>
<span class="gi">+            read_mode = &#39;r&#39;</span>
<span class="gi">+            try:</span>
<span class="gi">+                import toml as toml_  # type: ignore[no-redef]</span>
<span class="gi">+            except ImportError:  # pragma: no cover</span>
<span class="gi">+                import warnings</span>
<span class="gi">+</span>
<span class="gi">+                warnings.warn(&#39;No TOML parser installed, cannot read configuration from `pyproject.toml`.&#39;)</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+    with open(config_file, read_mode) as rf:</span>
<span class="gi">+        return toml_.load(rf)  # type: ignore[arg-type]</span>
<span class="gh">diff --git a/pydantic/v1/networks.py b/pydantic/v1/networks.py</span>
<span class="gh">index 8106fecb6..ba07b7486 100644</span>
<span class="gd">--- a/pydantic/v1/networks.py</span>
<span class="gi">+++ b/pydantic/v1/networks.py</span>
<span class="gu">@@ -1,19 +1,47 @@</span>
<span class="w"> </span>import re
<span class="gd">-from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network, _BaseAddress, _BaseNetwork</span>
<span class="gd">-from typing import TYPE_CHECKING, Any, Collection, Dict, Generator, List, Match, Optional, Pattern, Set, Tuple, Type, Union, cast, no_type_check</span>
<span class="gi">+from ipaddress import (</span>
<span class="gi">+    IPv4Address,</span>
<span class="gi">+    IPv4Interface,</span>
<span class="gi">+    IPv4Network,</span>
<span class="gi">+    IPv6Address,</span>
<span class="gi">+    IPv6Interface,</span>
<span class="gi">+    IPv6Network,</span>
<span class="gi">+    _BaseAddress,</span>
<span class="gi">+    _BaseNetwork,</span>
<span class="gi">+)</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Collection,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Match,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    no_type_check,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1 import errors
<span class="w"> </span>from pydantic.v1.utils import Representation, update_not_none
<span class="w"> </span>from pydantic.v1.validators import constr_length_validator, str_validator
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    import email_validator
<span class="w"> </span>    from typing_extensions import TypedDict
<span class="gi">+</span>
<span class="w"> </span>    from pydantic.v1.config import BaseConfig
<span class="w"> </span>    from pydantic.v1.fields import ModelField
<span class="w"> </span>    from pydantic.v1.typing import AnyCallable
<span class="gd">-    CallableGenerator = Generator[AnyCallable, None, None]</span>

<span class="gi">+    CallableGenerator = Generator[AnyCallable, None, None]</span>

<span class="gd">-    class Parts(TypedDict, total=(False)):</span>
<span class="gi">+    class Parts(TypedDict, total=False):</span>
<span class="w"> </span>        scheme: str
<span class="w"> </span>        user: Optional[str]
<span class="w"> </span>        password: Optional[str]
<span class="gu">@@ -25,71 +53,152 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>        query: Optional[str]
<span class="w"> </span>        fragment: Optional[str]

<span class="gd">-</span>
<span class="gd">-    class HostParts(TypedDict, total=(False)):</span>
<span class="gi">+    class HostParts(TypedDict, total=False):</span>
<span class="w"> </span>        host: str
<span class="w"> </span>        tld: Optional[str]
<span class="w"> </span>        host_type: Optional[str]
<span class="w"> </span>        port: Optional[str]
<span class="w"> </span>        rebuild: bool
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    email_validator = None

<span class="gd">-</span>
<span class="w"> </span>    class Parts(dict):
<span class="w"> </span>        pass
<span class="gd">-NetworkType = Union[str, bytes, int, Tuple[Union[str, bytes, int], Union[</span>
<span class="gd">-    str, int]]]</span>
<span class="gd">-__all__ = [&#39;AnyUrl&#39;, &#39;AnyHttpUrl&#39;, &#39;FileUrl&#39;, &#39;HttpUrl&#39;, &#39;stricturl&#39;,</span>
<span class="gd">-    &#39;EmailStr&#39;, &#39;NameEmail&#39;, &#39;IPvAnyAddress&#39;, &#39;IPvAnyInterface&#39;,</span>
<span class="gd">-    &#39;IPvAnyNetwork&#39;, &#39;PostgresDsn&#39;, &#39;CockroachDsn&#39;, &#39;AmqpDsn&#39;, &#39;RedisDsn&#39;,</span>
<span class="gd">-    &#39;MongoDsn&#39;, &#39;KafkaDsn&#39;, &#39;validate_email&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+NetworkType = Union[str, bytes, int, Tuple[Union[str, bytes, int], Union[str, int]]]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &#39;AnyUrl&#39;,</span>
<span class="gi">+    &#39;AnyHttpUrl&#39;,</span>
<span class="gi">+    &#39;FileUrl&#39;,</span>
<span class="gi">+    &#39;HttpUrl&#39;,</span>
<span class="gi">+    &#39;stricturl&#39;,</span>
<span class="gi">+    &#39;EmailStr&#39;,</span>
<span class="gi">+    &#39;NameEmail&#39;,</span>
<span class="gi">+    &#39;IPvAnyAddress&#39;,</span>
<span class="gi">+    &#39;IPvAnyInterface&#39;,</span>
<span class="gi">+    &#39;IPvAnyNetwork&#39;,</span>
<span class="gi">+    &#39;PostgresDsn&#39;,</span>
<span class="gi">+    &#39;CockroachDsn&#39;,</span>
<span class="gi">+    &#39;AmqpDsn&#39;,</span>
<span class="gi">+    &#39;RedisDsn&#39;,</span>
<span class="gi">+    &#39;MongoDsn&#39;,</span>
<span class="gi">+    &#39;KafkaDsn&#39;,</span>
<span class="gi">+    &#39;validate_email&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>_url_regex_cache = None
<span class="w"> </span>_multi_host_url_regex_cache = None
<span class="w"> </span>_ascii_domain_regex_cache = None
<span class="w"> </span>_int_domain_regex_cache = None
<span class="w"> </span>_host_regex_cache = None
<span class="gd">-_host_regex = (</span>
<span class="gd">-    &#39;(?:(?P&lt;ipv4&gt;(?:\\d{1,3}\\.){3}\\d{1,3})(?=$|[/:#?])|(?P&lt;ipv6&gt;\\[[A-F0-9]*:[A-F0-9:]+\\])(?=$|[/:#?])|(?P&lt;domain&gt;[^\\s/:?#]+))?(?::(?P&lt;port&gt;\\d+))?&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-_scheme_regex = &#39;(?:(?P&lt;scheme&gt;[a-z][a-z0-9+\\-.]+)://)?&#39;</span>
<span class="gd">-_user_info_regex = &#39;(?:(?P&lt;user&gt;[^\\s:/]*)(?::(?P&lt;password&gt;[^\\s/]*))?@)?&#39;</span>
<span class="gd">-_path_regex = &#39;(?P&lt;path&gt;/[^\\s?#]*)?&#39;</span>
<span class="gd">-_query_regex = &#39;(?:\\?(?P&lt;query&gt;[^\\s#]*))?&#39;</span>
<span class="gd">-_fragment_regex = &#39;(?:#(?P&lt;fragment&gt;[^\\s#]*))?&#39;</span>

<span class="gd">-</span>
<span class="gd">-def multi_host_url_regex() -&gt;Pattern[str]:</span>
<span class="gi">+_host_regex = (</span>
<span class="gi">+    r&#39;(?:&#39;</span>
<span class="gi">+    r&#39;(?P&lt;ipv4&gt;(?:\d{1,3}\.){3}\d{1,3})(?=$|[/:#?])|&#39;  # ipv4</span>
<span class="gi">+    r&#39;(?P&lt;ipv6&gt;\[[A-F0-9]*:[A-F0-9:]+\])(?=$|[/:#?])|&#39;  # ipv6</span>
<span class="gi">+    r&#39;(?P&lt;domain&gt;[^\s/:?#]+)&#39;  # domain, validation occurs later</span>
<span class="gi">+    r&#39;)?&#39;</span>
<span class="gi">+    r&#39;(?::(?P&lt;port&gt;\d+))?&#39;  # port</span>
<span class="gi">+)</span>
<span class="gi">+_scheme_regex = r&#39;(?:(?P&lt;scheme&gt;[a-z][a-z0-9+\-.]+)://)?&#39;  # scheme https://tools.ietf.org/html/rfc3986#appendix-A</span>
<span class="gi">+_user_info_regex = r&#39;(?:(?P&lt;user&gt;[^\s:/]*)(?::(?P&lt;password&gt;[^\s/]*))?@)?&#39;</span>
<span class="gi">+_path_regex = r&#39;(?P&lt;path&gt;/[^\s?#]*)?&#39;</span>
<span class="gi">+_query_regex = r&#39;(?:\?(?P&lt;query&gt;[^\s#]*))?&#39;</span>
<span class="gi">+_fragment_regex = r&#39;(?:#(?P&lt;fragment&gt;[^\s#]*))?&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def url_regex() -&gt; Pattern[str]:</span>
<span class="gi">+    global _url_regex_cache</span>
<span class="gi">+    if _url_regex_cache is None:</span>
<span class="gi">+        _url_regex_cache = re.compile(</span>
<span class="gi">+            rf&#39;{_scheme_regex}{_user_info_regex}{_host_regex}{_path_regex}{_query_regex}{_fragment_regex}&#39;,</span>
<span class="gi">+            re.IGNORECASE,</span>
<span class="gi">+        )</span>
<span class="gi">+    return _url_regex_cache</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def multi_host_url_regex() -&gt; Pattern[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Compiled multi host url regex.

<span class="w"> </span>    Additionally to `url_regex` it allows to match multiple hosts.
<span class="w"> </span>    E.g. host1.db.net,host2.db.net
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _multi_host_url_regex_cache</span>
<span class="gi">+    if _multi_host_url_regex_cache is None:</span>
<span class="gi">+        _multi_host_url_regex_cache = re.compile(</span>
<span class="gi">+            rf&#39;{_scheme_regex}{_user_info_regex}&#39;</span>
<span class="gi">+            r&#39;(?P&lt;hosts&gt;([^/]*))&#39;  # validation occurs later</span>
<span class="gi">+            rf&#39;{_path_regex}{_query_regex}{_fragment_regex}&#39;,</span>
<span class="gi">+            re.IGNORECASE,</span>
<span class="gi">+        )</span>
<span class="gi">+    return _multi_host_url_regex_cache</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ascii_domain_regex() -&gt; Pattern[str]:</span>
<span class="gi">+    global _ascii_domain_regex_cache</span>
<span class="gi">+    if _ascii_domain_regex_cache is None:</span>
<span class="gi">+        ascii_chunk = r&#39;[_0-9a-z](?:[-_0-9a-z]{0,61}[_0-9a-z])?&#39;</span>
<span class="gi">+        ascii_domain_ending = r&#39;(?P&lt;tld&gt;\.[a-z]{2,63})?\.?&#39;</span>
<span class="gi">+        _ascii_domain_regex_cache = re.compile(</span>
<span class="gi">+            fr&#39;(?:{ascii_chunk}\.)*?{ascii_chunk}{ascii_domain_ending}&#39;, re.IGNORECASE</span>
<span class="gi">+        )</span>
<span class="gi">+    return _ascii_domain_regex_cache</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def int_domain_regex() -&gt; Pattern[str]:</span>
<span class="gi">+    global _int_domain_regex_cache</span>
<span class="gi">+    if _int_domain_regex_cache is None:</span>
<span class="gi">+        int_chunk = r&#39;[_0-9a-\U00040000](?:[-_0-9a-\U00040000]{0,61}[_0-9a-\U00040000])?&#39;</span>
<span class="gi">+        int_domain_ending = r&#39;(?P&lt;tld&gt;(\.[^\W\d_]{2,63})|(\.(?:xn--)[_0-9a-z-]{2,63}))?\.?&#39;</span>
<span class="gi">+        _int_domain_regex_cache = re.compile(fr&#39;(?:{int_chunk}\.)*?{int_chunk}{int_domain_ending}&#39;, re.IGNORECASE)</span>
<span class="gi">+    return _int_domain_regex_cache</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def host_regex() -&gt; Pattern[str]:</span>
<span class="gi">+    global _host_regex_cache</span>
<span class="gi">+    if _host_regex_cache is None:</span>
<span class="gi">+        _host_regex_cache = re.compile(</span>
<span class="gi">+            _host_regex,</span>
<span class="gi">+            re.IGNORECASE,</span>
<span class="gi">+        )</span>
<span class="gi">+    return _host_regex_cache</span>


<span class="w"> </span>class AnyUrl(str):
<span class="w"> </span>    strip_whitespace = True
<span class="w"> </span>    min_length = 1
<span class="gd">-    max_length = 2 ** 16</span>
<span class="gi">+    max_length = 2**16</span>
<span class="w"> </span>    allowed_schemes: Optional[Collection[str]] = None
<span class="w"> </span>    tld_required: bool = False
<span class="w"> </span>    user_required: bool = False
<span class="w"> </span>    host_required: bool = True
<span class="w"> </span>    hidden_parts: Set[str] = set()
<span class="gd">-    __slots__ = (&#39;scheme&#39;, &#39;user&#39;, &#39;password&#39;, &#39;host&#39;, &#39;tld&#39;, &#39;host_type&#39;,</span>
<span class="gd">-        &#39;port&#39;, &#39;path&#39;, &#39;query&#39;, &#39;fragment&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&#39;scheme&#39;, &#39;user&#39;, &#39;password&#39;, &#39;host&#39;, &#39;tld&#39;, &#39;host_type&#39;, &#39;port&#39;, &#39;path&#39;, &#39;query&#39;, &#39;fragment&#39;)</span>

<span class="w"> </span>    @no_type_check
<span class="gd">-    def __new__(cls, url: Optional[str], **kwargs) -&gt;object:</span>
<span class="gi">+    def __new__(cls, url: Optional[str], **kwargs) -&gt; object:</span>
<span class="w"> </span>        return str.__new__(cls, cls.build(**kwargs) if url is None else url)

<span class="gd">-    def __init__(self, url: str, *, scheme: str, user: Optional[str]=None,</span>
<span class="gd">-        password: Optional[str]=None, host: Optional[str]=None, tld:</span>
<span class="gd">-        Optional[str]=None, host_type: str=&#39;domain&#39;, port: Optional[str]=</span>
<span class="gd">-        None, path: Optional[str]=None, query: Optional[str]=None, fragment:</span>
<span class="gd">-        Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        url: str,</span>
<span class="gi">+        *,</span>
<span class="gi">+        scheme: str,</span>
<span class="gi">+        user: Optional[str] = None,</span>
<span class="gi">+        password: Optional[str] = None,</span>
<span class="gi">+        host: Optional[str] = None,</span>
<span class="gi">+        tld: Optional[str] = None,</span>
<span class="gi">+        host_type: str = &#39;domain&#39;,</span>
<span class="gi">+        port: Optional[str] = None,</span>
<span class="gi">+        path: Optional[str] = None,</span>
<span class="gi">+        query: Optional[str] = None,</span>
<span class="gi">+        fragment: Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        str.__init__(url)
<span class="w"> </span>        self.scheme = scheme
<span class="w"> </span>        self.user = user
<span class="gu">@@ -103,75 +212,301 @@ class AnyUrl(str):</span>
<span class="w"> </span>        self.fragment = fragment

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, minLength=cls.min_length, maxLength=</span>
<span class="gd">-            cls.max_length, format=&#39;uri&#39;)</span>
<span class="gi">+    def build(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        *,</span>
<span class="gi">+        scheme: str,</span>
<span class="gi">+        user: Optional[str] = None,</span>
<span class="gi">+        password: Optional[str] = None,</span>
<span class="gi">+        host: str,</span>
<span class="gi">+        port: Optional[str] = None,</span>
<span class="gi">+        path: Optional[str] = None,</span>
<span class="gi">+        query: Optional[str] = None,</span>
<span class="gi">+        fragment: Optional[str] = None,</span>
<span class="gi">+        **_kwargs: str,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        parts = Parts(</span>
<span class="gi">+            scheme=scheme,</span>
<span class="gi">+            user=user,</span>
<span class="gi">+            password=password,</span>
<span class="gi">+            host=host,</span>
<span class="gi">+            port=port,</span>
<span class="gi">+            path=path,</span>
<span class="gi">+            query=query,</span>
<span class="gi">+            fragment=fragment,</span>
<span class="gi">+            **_kwargs,  # type: ignore[misc]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        url = scheme + &#39;://&#39;</span>
<span class="gi">+        if user:</span>
<span class="gi">+            url += user</span>
<span class="gi">+        if password:</span>
<span class="gi">+            url += &#39;:&#39; + password</span>
<span class="gi">+        if user or password:</span>
<span class="gi">+            url += &#39;@&#39;</span>
<span class="gi">+        url += host</span>
<span class="gi">+        if port and (&#39;port&#39; not in cls.hidden_parts or cls.get_default_parts(parts).get(&#39;port&#39;) != port):</span>
<span class="gi">+            url += &#39;:&#39; + port</span>
<span class="gi">+        if path:</span>
<span class="gi">+            url += path</span>
<span class="gi">+        if query:</span>
<span class="gi">+            url += &#39;?&#39; + query</span>
<span class="gi">+        if fragment:</span>
<span class="gi">+            url += &#39;#&#39; + fragment</span>
<span class="gi">+        return url</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(field_schema, minLength=cls.min_length, maxLength=cls.max_length, format=&#39;uri&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.validate

<span class="w"> </span>    @classmethod
<span class="gd">-    def _build_url(cls, m: Match[str], url: str, parts: &#39;Parts&#39;) -&gt;&#39;AnyUrl&#39;:</span>
<span class="gi">+    def validate(cls, value: Any, field: &#39;ModelField&#39;, config: &#39;BaseConfig&#39;) -&gt; &#39;AnyUrl&#39;:</span>
<span class="gi">+        if value.__class__ == cls:</span>
<span class="gi">+            return value</span>
<span class="gi">+        value = str_validator(value)</span>
<span class="gi">+        if cls.strip_whitespace:</span>
<span class="gi">+            value = value.strip()</span>
<span class="gi">+        url: str = cast(str, constr_length_validator(value, field, config))</span>
<span class="gi">+</span>
<span class="gi">+        m = cls._match_url(url)</span>
<span class="gi">+        # the regex should always match, if it doesn&#39;t please report with details of the URL tried</span>
<span class="gi">+        assert m, &#39;URL regex failed unexpectedly&#39;</span>
<span class="gi">+</span>
<span class="gi">+        original_parts = cast(&#39;Parts&#39;, m.groupdict())</span>
<span class="gi">+        parts = cls.apply_default_parts(original_parts)</span>
<span class="gi">+        parts = cls.validate_parts(parts)</span>
<span class="gi">+</span>
<span class="gi">+        if m.end() != len(url):</span>
<span class="gi">+            raise errors.UrlExtraError(extra=url[m.end() :])</span>
<span class="gi">+</span>
<span class="gi">+        return cls._build_url(m, url, parts)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _build_url(cls, m: Match[str], url: str, parts: &#39;Parts&#39;) -&gt; &#39;AnyUrl&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Validate hosts and build the AnyUrl object. Split from `validate` so this method
<span class="w"> </span>        can be altered in `MultiHostDsn`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        host, tld, host_type, rebuild = cls.validate_host(parts)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            None if rebuild else url,</span>
<span class="gi">+            scheme=parts[&#39;scheme&#39;],</span>
<span class="gi">+            user=parts[&#39;user&#39;],</span>
<span class="gi">+            password=parts[&#39;password&#39;],</span>
<span class="gi">+            host=host,</span>
<span class="gi">+            tld=tld,</span>
<span class="gi">+            host_type=host_type,</span>
<span class="gi">+            port=parts[&#39;port&#39;],</span>
<span class="gi">+            path=parts[&#39;path&#39;],</span>
<span class="gi">+            query=parts[&#39;query&#39;],</span>
<span class="gi">+            fragment=parts[&#39;fragment&#39;],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _match_url(url: str) -&gt; Optional[Match[str]]:</span>
<span class="gi">+        return url_regex().match(url)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _validate_port(port: Optional[str]) -&gt; None:</span>
<span class="gi">+        if port is not None and int(port) &gt; 65_535:</span>
<span class="gi">+            raise errors.UrlPortError()</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def validate_parts(cls, parts: &#39;Parts&#39;, validate_port: bool=True</span>
<span class="gd">-        ) -&gt;&#39;Parts&#39;:</span>
<span class="gi">+    def validate_parts(cls, parts: &#39;Parts&#39;, validate_port: bool = True) -&gt; &#39;Parts&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        A method used to validate parts of a URL.
<span class="w"> </span>        Could be overridden to set default values for parts if missing
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        scheme = parts[&#39;scheme&#39;]</span>
<span class="gi">+        if scheme is None:</span>
<span class="gi">+            raise errors.UrlSchemeError()</span>
<span class="gi">+</span>
<span class="gi">+        if cls.allowed_schemes and scheme.lower() not in cls.allowed_schemes:</span>
<span class="gi">+            raise errors.UrlSchemePermittedError(set(cls.allowed_schemes))</span>
<span class="gi">+</span>
<span class="gi">+        if validate_port:</span>
<span class="gi">+            cls._validate_port(parts[&#39;port&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        user = parts[&#39;user&#39;]</span>
<span class="gi">+        if cls.user_required and user is None:</span>
<span class="gi">+            raise errors.UrlUserInfoError()</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        extra = &#39;, &#39;.join(f&#39;{n}={getattr(self, n)!r}&#39; for n in self.</span>
<span class="gd">-            __slots__ if getattr(self, n) is not None)</span>
<span class="gi">+        return parts</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate_host(cls, parts: &#39;Parts&#39;) -&gt; Tuple[str, Optional[str], str, bool]:</span>
<span class="gi">+        tld, host_type, rebuild = None, None, False</span>
<span class="gi">+        for f in (&#39;domain&#39;, &#39;ipv4&#39;, &#39;ipv6&#39;):</span>
<span class="gi">+            host = parts[f]  # type: ignore[literal-required]</span>
<span class="gi">+            if host:</span>
<span class="gi">+                host_type = f</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if host is None:</span>
<span class="gi">+            if cls.host_required:</span>
<span class="gi">+                raise errors.UrlHostError()</span>
<span class="gi">+        elif host_type == &#39;domain&#39;:</span>
<span class="gi">+            is_international = False</span>
<span class="gi">+            d = ascii_domain_regex().fullmatch(host)</span>
<span class="gi">+            if d is None:</span>
<span class="gi">+                d = int_domain_regex().fullmatch(host)</span>
<span class="gi">+                if d is None:</span>
<span class="gi">+                    raise errors.UrlHostError()</span>
<span class="gi">+                is_international = True</span>
<span class="gi">+</span>
<span class="gi">+            tld = d.group(&#39;tld&#39;)</span>
<span class="gi">+            if tld is None and not is_international:</span>
<span class="gi">+                d = int_domain_regex().fullmatch(host)</span>
<span class="gi">+                assert d is not None</span>
<span class="gi">+                tld = d.group(&#39;tld&#39;)</span>
<span class="gi">+                is_international = True</span>
<span class="gi">+</span>
<span class="gi">+            if tld is not None:</span>
<span class="gi">+                tld = tld[1:]</span>
<span class="gi">+            elif cls.tld_required:</span>
<span class="gi">+                raise errors.UrlHostTldError()</span>
<span class="gi">+</span>
<span class="gi">+            if is_international:</span>
<span class="gi">+                host_type = &#39;int_domain&#39;</span>
<span class="gi">+                rebuild = True</span>
<span class="gi">+                host = host.encode(&#39;idna&#39;).decode(&#39;ascii&#39;)</span>
<span class="gi">+                if tld is not None:</span>
<span class="gi">+                    tld = tld.encode(&#39;idna&#39;).decode(&#39;ascii&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return host, tld, host_type, rebuild  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def get_default_parts(parts: &#39;Parts&#39;) -&gt; &#39;Parts&#39;:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def apply_default_parts(cls, parts: &#39;Parts&#39;) -&gt; &#39;Parts&#39;:</span>
<span class="gi">+        for key, value in cls.get_default_parts(parts).items():</span>
<span class="gi">+            if not parts[key]:  # type: ignore[literal-required]</span>
<span class="gi">+                parts[key] = value  # type: ignore[literal-required]</span>
<span class="gi">+        return parts</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        extra = &#39;, &#39;.join(f&#39;{n}={getattr(self, n)!r}&#39; for n in self.__slots__ if getattr(self, n) is not None)</span>
<span class="w"> </span>        return f&#39;{self.__class__.__name__}({super().__repr__()}, {extra})&#39;


<span class="w"> </span>class AnyHttpUrl(AnyUrl):
<span class="w"> </span>    allowed_schemes = {&#39;http&#39;, &#39;https&#39;}
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()


<span class="w"> </span>class HttpUrl(AnyHttpUrl):
<span class="w"> </span>    tld_required = True
<span class="gi">+    # https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers</span>
<span class="w"> </span>    max_length = 2083
<span class="w"> </span>    hidden_parts = {&#39;port&#39;}

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def get_default_parts(parts: &#39;Parts&#39;) -&gt; &#39;Parts&#39;:</span>
<span class="gi">+        return {&#39;port&#39;: &#39;80&#39; if parts[&#39;scheme&#39;] == &#39;http&#39; else &#39;443&#39;}</span>
<span class="gi">+</span>

<span class="w"> </span>class FileUrl(AnyUrl):
<span class="w"> </span>    allowed_schemes = {&#39;file&#39;}
<span class="w"> </span>    host_required = False
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()


<span class="w"> </span>class MultiHostDsn(AnyUrl):
<span class="w"> </span>    __slots__ = AnyUrl.__slots__ + (&#39;hosts&#39;,)

<span class="gd">-    def __init__(self, *args: Any, hosts: Optional[List[&#39;HostParts&#39;]]=None,</span>
<span class="gd">-        **kwargs: Any):</span>
<span class="gi">+    def __init__(self, *args: Any, hosts: Optional[List[&#39;HostParts&#39;]] = None, **kwargs: Any):</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.hosts = hosts

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _match_url(url: str) -&gt; Optional[Match[str]]:</span>
<span class="gi">+        return multi_host_url_regex().match(url)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate_parts(cls, parts: &#39;Parts&#39;, validate_port: bool = True) -&gt; &#39;Parts&#39;:</span>
<span class="gi">+        return super().validate_parts(parts, validate_port=False)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _build_url(cls, m: Match[str], url: str, parts: &#39;Parts&#39;) -&gt; &#39;MultiHostDsn&#39;:</span>
<span class="gi">+        hosts_parts: List[&#39;HostParts&#39;] = []</span>
<span class="gi">+        host_re = host_regex()</span>
<span class="gi">+        for host in m.groupdict()[&#39;hosts&#39;].split(&#39;,&#39;):</span>
<span class="gi">+            d: Parts = host_re.match(host).groupdict()  # type: ignore</span>
<span class="gi">+            host, tld, host_type, rebuild = cls.validate_host(d)</span>
<span class="gi">+            port = d.get(&#39;port&#39;)</span>
<span class="gi">+            cls._validate_port(port)</span>
<span class="gi">+            hosts_parts.append(</span>
<span class="gi">+                {</span>
<span class="gi">+                    &#39;host&#39;: host,</span>
<span class="gi">+                    &#39;host_type&#39;: host_type,</span>
<span class="gi">+                    &#39;tld&#39;: tld,</span>
<span class="gi">+                    &#39;rebuild&#39;: rebuild,</span>
<span class="gi">+                    &#39;port&#39;: port,</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if len(hosts_parts) &gt; 1:</span>
<span class="gi">+            return cls(</span>
<span class="gi">+                None if any([hp[&#39;rebuild&#39;] for hp in hosts_parts]) else url,</span>
<span class="gi">+                scheme=parts[&#39;scheme&#39;],</span>
<span class="gi">+                user=parts[&#39;user&#39;],</span>
<span class="gi">+                password=parts[&#39;password&#39;],</span>
<span class="gi">+                path=parts[&#39;path&#39;],</span>
<span class="gi">+                query=parts[&#39;query&#39;],</span>
<span class="gi">+                fragment=parts[&#39;fragment&#39;],</span>
<span class="gi">+                host_type=None,</span>
<span class="gi">+                hosts=hosts_parts,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # backwards compatibility with single host</span>
<span class="gi">+            host_part = hosts_parts[0]</span>
<span class="gi">+            return cls(</span>
<span class="gi">+                None if host_part[&#39;rebuild&#39;] else url,</span>
<span class="gi">+                scheme=parts[&#39;scheme&#39;],</span>
<span class="gi">+                user=parts[&#39;user&#39;],</span>
<span class="gi">+                password=parts[&#39;password&#39;],</span>
<span class="gi">+                host=host_part[&#39;host&#39;],</span>
<span class="gi">+                tld=host_part[&#39;tld&#39;],</span>
<span class="gi">+                host_type=host_part[&#39;host_type&#39;],</span>
<span class="gi">+                port=host_part.get(&#39;port&#39;),</span>
<span class="gi">+                path=parts[&#39;path&#39;],</span>
<span class="gi">+                query=parts[&#39;query&#39;],</span>
<span class="gi">+                fragment=parts[&#39;fragment&#39;],</span>
<span class="gi">+            )</span>
<span class="gi">+</span>

<span class="w"> </span>class PostgresDsn(MultiHostDsn):
<span class="gd">-    allowed_schemes = {&#39;postgres&#39;, &#39;postgresql&#39;, &#39;postgresql+asyncpg&#39;,</span>
<span class="gd">-        &#39;postgresql+pg8000&#39;, &#39;postgresql+psycopg&#39;, &#39;postgresql+psycopg2&#39;,</span>
<span class="gd">-        &#39;postgresql+psycopg2cffi&#39;, &#39;postgresql+py-postgresql&#39;,</span>
<span class="gd">-        &#39;postgresql+pygresql&#39;}</span>
<span class="gi">+    allowed_schemes = {</span>
<span class="gi">+        &#39;postgres&#39;,</span>
<span class="gi">+        &#39;postgresql&#39;,</span>
<span class="gi">+        &#39;postgresql+asyncpg&#39;,</span>
<span class="gi">+        &#39;postgresql+pg8000&#39;,</span>
<span class="gi">+        &#39;postgresql+psycopg&#39;,</span>
<span class="gi">+        &#39;postgresql+psycopg2&#39;,</span>
<span class="gi">+        &#39;postgresql+psycopg2cffi&#39;,</span>
<span class="gi">+        &#39;postgresql+py-postgresql&#39;,</span>
<span class="gi">+        &#39;postgresql+pygresql&#39;,</span>
<span class="gi">+    }</span>
<span class="w"> </span>    user_required = True
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()


<span class="w"> </span>class CockroachDsn(AnyUrl):
<span class="gd">-    allowed_schemes = {&#39;cockroachdb&#39;, &#39;cockroachdb+psycopg2&#39;,</span>
<span class="gd">-        &#39;cockroachdb+asyncpg&#39;}</span>
<span class="gi">+    allowed_schemes = {</span>
<span class="gi">+        &#39;cockroachdb&#39;,</span>
<span class="gi">+        &#39;cockroachdb+psycopg2&#39;,</span>
<span class="gi">+        &#39;cockroachdb+asyncpg&#39;,</span>
<span class="gi">+    }</span>
<span class="w"> </span>    user_required = True


<span class="gu">@@ -185,27 +520,83 @@ class RedisDsn(AnyUrl):</span>
<span class="w"> </span>    allowed_schemes = {&#39;redis&#39;, &#39;rediss&#39;}
<span class="w"> </span>    host_required = False

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def get_default_parts(parts: &#39;Parts&#39;) -&gt; &#39;Parts&#39;:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;domain&#39;: &#39;localhost&#39; if not (parts[&#39;ipv4&#39;] or parts[&#39;ipv6&#39;]) else &#39;&#39;,</span>
<span class="gi">+            &#39;port&#39;: &#39;6379&#39;,</span>
<span class="gi">+            &#39;path&#39;: &#39;/0&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>

<span class="w"> </span>class MongoDsn(AnyUrl):
<span class="w"> </span>    allowed_schemes = {&#39;mongodb&#39;}

<span class="gi">+    # TODO: Needed to generic &quot;Parts&quot; for &quot;Replica Set&quot;, &quot;Sharded Cluster&quot;, and other mongodb deployment modes</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def get_default_parts(parts: &#39;Parts&#39;) -&gt; &#39;Parts&#39;:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;port&#39;: &#39;27017&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>

<span class="w"> </span>class KafkaDsn(AnyUrl):
<span class="w"> </span>    allowed_schemes = {&#39;kafka&#39;}

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def get_default_parts(parts: &#39;Parts&#39;) -&gt; &#39;Parts&#39;:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;domain&#39;: &#39;localhost&#39;,</span>
<span class="gi">+            &#39;port&#39;: &#39;9092&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def stricturl(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strip_whitespace: bool = True,</span>
<span class="gi">+    min_length: int = 1,</span>
<span class="gi">+    max_length: int = 2**16,</span>
<span class="gi">+    tld_required: bool = True,</span>
<span class="gi">+    host_required: bool = True,</span>
<span class="gi">+    allowed_schemes: Optional[Collection[str]] = None,</span>
<span class="gi">+) -&gt; Type[AnyUrl]:</span>
<span class="gi">+    # use kwargs then define conf in a dict to aid with IDE type hinting</span>
<span class="gi">+    namespace = dict(</span>
<span class="gi">+        strip_whitespace=strip_whitespace,</span>
<span class="gi">+        min_length=min_length,</span>
<span class="gi">+        max_length=max_length,</span>
<span class="gi">+        tld_required=tld_required,</span>
<span class="gi">+        host_required=host_required,</span>
<span class="gi">+        allowed_schemes=allowed_schemes,</span>
<span class="gi">+    )</span>
<span class="gi">+    return type(&#39;UrlValue&#39;, (AnyUrl,), namespace)</span>
<span class="gi">+</span>

<span class="gd">-class EmailStr(str):</span>
<span class="gi">+def import_email_validator() -&gt; None:</span>
<span class="gi">+    global email_validator</span>
<span class="gi">+    try:</span>
<span class="gi">+        import email_validator</span>
<span class="gi">+    except ImportError as e:</span>
<span class="gi">+        raise ImportError(&#39;email-validator is not installed, run `pip install pydantic[email]`&#39;) from e</span>

<span class="gi">+</span>
<span class="gi">+class EmailStr(str):</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;email&#39;)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="gi">+        # included here and below so the error happens straight away</span>
<span class="w"> </span>        import_email_validator()
<span class="gi">+</span>
<span class="w"> </span>        yield str_validator
<span class="w"> </span>        yield cls.validate

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: Union[str]) -&gt; str:</span>
<span class="gi">+        return validate_email(value)[1]</span>
<span class="gi">+</span>

<span class="w"> </span>class NameEmail(Representation):
<span class="w"> </span>    __slots__ = &#39;name&#39;, &#39;email&#39;
<span class="gu">@@ -214,20 +605,27 @@ class NameEmail(Representation):</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.email = email

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, NameEmail) and (self.name, self.email) == (</span>
<span class="gd">-            other.name, other.email)</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, NameEmail) and (self.name, self.email) == (other.name, other.email)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;name-email&#39;)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        import_email_validator()
<span class="gi">+</span>
<span class="w"> </span>        yield cls.validate

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: Any) -&gt; &#39;NameEmail&#39;:</span>
<span class="gi">+        if value.__class__ == cls:</span>
<span class="gi">+            return value</span>
<span class="gi">+        value = str_validator(value)</span>
<span class="gi">+        return cls(*validate_email(value))</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;{self.name} &lt;{self.email}&gt;&#39;


<span class="gu">@@ -235,45 +633,82 @@ class IPvAnyAddress(_BaseAddress):</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;ipvanyaddress&#39;)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.validate

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: Union[str, bytes, int]) -&gt; Union[IPv4Address, IPv6Address]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return IPv4Address(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return IPv6Address(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise errors.IPvAnyAddressError()</span>
<span class="gi">+</span>

<span class="w"> </span>class IPvAnyInterface(_BaseAddress):
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;ipvanyinterface&#39;)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.validate

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: NetworkType) -&gt; Union[IPv4Interface, IPv6Interface]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return IPv4Interface(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return IPv6Interface(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise errors.IPvAnyInterfaceError()</span>

<span class="gd">-class IPvAnyNetwork(_BaseNetwork):</span>

<span class="gi">+class IPvAnyNetwork(_BaseNetwork):  # type: ignore</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>        field_schema.update(type=&#39;string&#39;, format=&#39;ipvanynetwork&#39;)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.validate

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: NetworkType) -&gt; Union[IPv4Network, IPv6Network]:</span>
<span class="gi">+        # Assume IP Network is defined with a default value for ``strict`` argument.</span>
<span class="gi">+        # Define your own class if you want to specify network address check strictness.</span>
<span class="gi">+        try:</span>
<span class="gi">+            return IPv4Network(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return IPv6Network(value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise errors.IPvAnyNetworkError()</span>
<span class="gi">+</span>

<span class="gd">-pretty_email_regex = re.compile(&#39;([\\w ]*?) *&lt;(.*)&gt; *&#39;)</span>
<span class="gi">+pretty_email_regex = re.compile(r&#39;([\w ]*?) *&lt;(.*)&gt; *&#39;)</span>
<span class="w"> </span>MAX_EMAIL_LENGTH = 2048
<span class="w"> </span>&quot;&quot;&quot;Maximum length for an email.
<span class="w"> </span>A somewhat arbitrary but very generous number compared to what is allowed by most implementations.
<span class="w"> </span>&quot;&quot;&quot;


<span class="gd">-def validate_email(value: Union[str]) -&gt;Tuple[str, str]:</span>
<span class="gi">+def validate_email(value: Union[str]) -&gt; Tuple[str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Email address validation using https://pypi.org/project/email-validator/
<span class="w"> </span>    Notes:
<span class="gu">@@ -281,4 +716,32 @@ def validate_email(value: Union[str]) -&gt;Tuple[str, str]:</span>
<span class="w"> </span>    * &quot;John Doe &lt;local_part@domain.com&gt;&quot; style &quot;pretty&quot; email addresses are processed
<span class="w"> </span>    * spaces are striped from the beginning and end of addresses but no error is raised
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if email_validator is None:</span>
<span class="gi">+        import_email_validator()</span>
<span class="gi">+</span>
<span class="gi">+    if len(value) &gt; MAX_EMAIL_LENGTH:</span>
<span class="gi">+        raise errors.EmailError()</span>
<span class="gi">+</span>
<span class="gi">+    m = pretty_email_regex.fullmatch(value)</span>
<span class="gi">+    name: Union[str, None] = None</span>
<span class="gi">+    if m:</span>
<span class="gi">+        name, value = m.groups()</span>
<span class="gi">+    email = value.strip()</span>
<span class="gi">+    try:</span>
<span class="gi">+        parts = email_validator.validate_email(email, check_deliverability=False)</span>
<span class="gi">+    except email_validator.EmailNotValidError as e:</span>
<span class="gi">+        raise errors.EmailError from e</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(parts, &#39;normalized&#39;):</span>
<span class="gi">+        # email-validator &gt;= 2</span>
<span class="gi">+        email = parts.normalized</span>
<span class="gi">+        assert email is not None</span>
<span class="gi">+        name = name or parts.local_part</span>
<span class="gi">+        return name, email</span>
<span class="gi">+    else:</span>
<span class="gi">+        # email-validator &gt;1, &lt;2</span>
<span class="gi">+        at_index = email.index(&#39;@&#39;)</span>
<span class="gi">+        local_part = email[:at_index]  # RFC 5321, local part must be case-sensitive.</span>
<span class="gi">+        global_part = email[at_index:].lower()</span>
<span class="gi">+</span>
<span class="gi">+        return name or local_part, local_part + global_part</span>
<span class="gh">diff --git a/pydantic/v1/parse.py b/pydantic/v1/parse.py</span>
<span class="gh">index 1cbc25179..431d75a64 100644</span>
<span class="gd">--- a/pydantic/v1/parse.py</span>
<span class="gi">+++ b/pydantic/v1/parse.py</span>
<span class="gu">@@ -3,9 +3,64 @@ import pickle</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Any, Callable, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.types import StrBytes


<span class="w"> </span>class Protocol(str, Enum):
<span class="w"> </span>    json = &#39;json&#39;
<span class="w"> </span>    pickle = &#39;pickle&#39;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_str_bytes(</span>
<span class="gi">+    b: StrBytes,</span>
<span class="gi">+    *,</span>
<span class="gi">+    content_type: str = None,</span>
<span class="gi">+    encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+    proto: Protocol = None,</span>
<span class="gi">+    allow_pickle: bool = False,</span>
<span class="gi">+    json_loads: Callable[[str], Any] = json.loads,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="gi">+    if proto is None and content_type:</span>
<span class="gi">+        if content_type.endswith((&#39;json&#39;, &#39;javascript&#39;)):</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif allow_pickle and content_type.endswith(&#39;pickle&#39;):</span>
<span class="gi">+            proto = Protocol.pickle</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&#39;Unknown content-type: {content_type}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    proto = proto or Protocol.json</span>
<span class="gi">+</span>
<span class="gi">+    if proto == Protocol.json:</span>
<span class="gi">+        if isinstance(b, bytes):</span>
<span class="gi">+            b = b.decode(encoding)</span>
<span class="gi">+        return json_loads(b)</span>
<span class="gi">+    elif proto == Protocol.pickle:</span>
<span class="gi">+        if not allow_pickle:</span>
<span class="gi">+            raise RuntimeError(&#39;Trying to decode with pickle with allow_pickle=False&#39;)</span>
<span class="gi">+        bb = b if isinstance(b, bytes) else b.encode()</span>
<span class="gi">+        return pickle.loads(bb)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&#39;Unknown protocol: {proto}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_file(</span>
<span class="gi">+    path: Union[str, Path],</span>
<span class="gi">+    *,</span>
<span class="gi">+    content_type: str = None,</span>
<span class="gi">+    encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+    proto: Protocol = None,</span>
<span class="gi">+    allow_pickle: bool = False,</span>
<span class="gi">+    json_loads: Callable[[str], Any] = json.loads,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="gi">+    path = Path(path)</span>
<span class="gi">+    b = path.read_bytes()</span>
<span class="gi">+    if content_type is None:</span>
<span class="gi">+        if path.suffix in (&#39;.js&#39;, &#39;.json&#39;):</span>
<span class="gi">+            proto = Protocol.json</span>
<span class="gi">+        elif path.suffix == &#39;.pkl&#39;:</span>
<span class="gi">+            proto = Protocol.pickle</span>
<span class="gi">+</span>
<span class="gi">+    return load_str_bytes(</span>
<span class="gi">+        b, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=json_loads</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pydantic/v1/schema.py b/pydantic/v1/schema.py</span>
<span class="gh">index 073f563af..bac4c0ac5 100644</span>
<span class="gd">--- a/pydantic/v1/schema.py</span>
<span class="gi">+++ b/pydantic/v1/schema.py</span>
<span class="gu">@@ -7,28 +7,114 @@ from decimal import Decimal</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
<span class="w"> </span>from pathlib import Path
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, Dict, ForwardRef, FrozenSet, Generic, Iterable, List, Optional, Pattern, Sequence, Set, Tuple, Type, TypeVar, Union, cast</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    ForwardRef,</span>
<span class="gi">+    FrozenSet,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+)</span>
<span class="w"> </span>from uuid import UUID
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Annotated, Literal
<span class="gd">-from pydantic.v1.fields import MAPPING_LIKE_SHAPES, SHAPE_DEQUE, SHAPE_FROZENSET, SHAPE_GENERIC, SHAPE_ITERABLE, SHAPE_LIST, SHAPE_SEQUENCE, SHAPE_SET, SHAPE_SINGLETON, SHAPE_TUPLE, SHAPE_TUPLE_ELLIPSIS, FieldInfo, ModelField</span>
<span class="gi">+</span>
<span class="gi">+from pydantic.v1.fields import (</span>
<span class="gi">+    MAPPING_LIKE_SHAPES,</span>
<span class="gi">+    SHAPE_DEQUE,</span>
<span class="gi">+    SHAPE_FROZENSET,</span>
<span class="gi">+    SHAPE_GENERIC,</span>
<span class="gi">+    SHAPE_ITERABLE,</span>
<span class="gi">+    SHAPE_LIST,</span>
<span class="gi">+    SHAPE_SEQUENCE,</span>
<span class="gi">+    SHAPE_SET,</span>
<span class="gi">+    SHAPE_SINGLETON,</span>
<span class="gi">+    SHAPE_TUPLE,</span>
<span class="gi">+    SHAPE_TUPLE_ELLIPSIS,</span>
<span class="gi">+    FieldInfo,</span>
<span class="gi">+    ModelField,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pydantic.v1.json import pydantic_encoder
<span class="w"> </span>from pydantic.v1.networks import AnyUrl, EmailStr
<span class="gd">-from pydantic.v1.types import ConstrainedDecimal, ConstrainedFloat, ConstrainedFrozenSet, ConstrainedInt, ConstrainedList, ConstrainedSet, ConstrainedStr, SecretBytes, SecretStr, StrictBytes, StrictStr, conbytes, condecimal, confloat, confrozenset, conint, conlist, conset, constr</span>
<span class="gd">-from pydantic.v1.typing import all_literal_values, get_args, get_origin, get_sub_types, is_callable_type, is_literal_type, is_namedtuple, is_none_type, is_union</span>
<span class="gi">+from pydantic.v1.types import (</span>
<span class="gi">+    ConstrainedDecimal,</span>
<span class="gi">+    ConstrainedFloat,</span>
<span class="gi">+    ConstrainedFrozenSet,</span>
<span class="gi">+    ConstrainedInt,</span>
<span class="gi">+    ConstrainedList,</span>
<span class="gi">+    ConstrainedSet,</span>
<span class="gi">+    ConstrainedStr,</span>
<span class="gi">+    SecretBytes,</span>
<span class="gi">+    SecretStr,</span>
<span class="gi">+    StrictBytes,</span>
<span class="gi">+    StrictStr,</span>
<span class="gi">+    conbytes,</span>
<span class="gi">+    condecimal,</span>
<span class="gi">+    confloat,</span>
<span class="gi">+    confrozenset,</span>
<span class="gi">+    conint,</span>
<span class="gi">+    conlist,</span>
<span class="gi">+    conset,</span>
<span class="gi">+    constr,</span>
<span class="gi">+)</span>
<span class="gi">+from pydantic.v1.typing import (</span>
<span class="gi">+    all_literal_values,</span>
<span class="gi">+    get_args,</span>
<span class="gi">+    get_origin,</span>
<span class="gi">+    get_sub_types,</span>
<span class="gi">+    is_callable_type,</span>
<span class="gi">+    is_literal_type,</span>
<span class="gi">+    is_namedtuple,</span>
<span class="gi">+    is_none_type,</span>
<span class="gi">+    is_union,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pydantic.v1.utils import ROOT_KEY, get_model, lenient_issubclass
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.dataclasses import Dataclass
<span class="w"> </span>    from pydantic.v1.main import BaseModel
<span class="gi">+</span>
<span class="w"> </span>default_prefix = &#39;#/definitions/&#39;
<span class="w"> </span>default_ref_template = &#39;#/definitions/{model}&#39;
<span class="gi">+</span>
<span class="w"> </span>TypeModelOrEnum = Union[Type[&#39;BaseModel&#39;], Type[Enum]]
<span class="w"> </span>TypeModelSet = Set[TypeModelOrEnum]


<span class="gd">-def schema(models: Sequence[Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]]], *,</span>
<span class="gd">-    by_alias: bool=True, title: Optional[str]=None, description: Optional[</span>
<span class="gd">-    str]=None, ref_prefix: Optional[str]=None, ref_template: str=</span>
<span class="gd">-    default_ref_template) -&gt;Dict[str, Any]:</span>
<span class="gi">+def _apply_modify_schema(</span>
<span class="gi">+    modify_schema: Callable[..., None], field: Optional[ModelField], field_schema: Dict[str, Any]</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    from inspect import signature</span>
<span class="gi">+</span>
<span class="gi">+    sig = signature(modify_schema)</span>
<span class="gi">+    args = set(sig.parameters.keys())</span>
<span class="gi">+    if &#39;field&#39; in args or &#39;kwargs&#39; in args:</span>
<span class="gi">+        modify_schema(field_schema, field=field)</span>
<span class="gi">+    else:</span>
<span class="gi">+        modify_schema(field_schema)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def schema(</span>
<span class="gi">+    models: Sequence[Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]]],</span>
<span class="gi">+    *,</span>
<span class="gi">+    by_alias: bool = True,</span>
<span class="gi">+    title: Optional[str] = None,</span>
<span class="gi">+    description: Optional[str] = None,</span>
<span class="gi">+    ref_prefix: Optional[str] = None,</span>
<span class="gi">+    ref_template: str = default_ref_template,</span>
<span class="gi">+) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Process a list of models and generate a single JSON Schema with all of them defined in the ``definitions``
<span class="w"> </span>    top-level JSON key, including their sub-models.
<span class="gu">@@ -48,12 +134,37 @@ def schema(models: Sequence[Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]]], *,</span>
<span class="w"> </span>    :return: dict with the JSON Schema with a ``definitions`` top-level key including the schema definitions for
<span class="w"> </span>      the models and sub-models passed in ``models``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def model_schema(model: Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]],</span>
<span class="gd">-    by_alias: bool=True, ref_prefix: Optional[str]=None, ref_template: str=</span>
<span class="gd">-    default_ref_template) -&gt;Dict[str, Any]:</span>
<span class="gi">+    clean_models = [get_model(model) for model in models]</span>
<span class="gi">+    flat_models = get_flat_models_from_models(clean_models)</span>
<span class="gi">+    model_name_map = get_model_name_map(flat_models)</span>
<span class="gi">+    definitions = {}</span>
<span class="gi">+    output_schema: Dict[str, Any] = {}</span>
<span class="gi">+    if title:</span>
<span class="gi">+        output_schema[&#39;title&#39;] = title</span>
<span class="gi">+    if description:</span>
<span class="gi">+        output_schema[&#39;description&#39;] = description</span>
<span class="gi">+    for model in clean_models:</span>
<span class="gi">+        m_schema, m_definitions, m_nested_models = model_process_schema(</span>
<span class="gi">+            model,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            model_name_map=model_name_map,</span>
<span class="gi">+            ref_prefix=ref_prefix,</span>
<span class="gi">+            ref_template=ref_template,</span>
<span class="gi">+        )</span>
<span class="gi">+        definitions.update(m_definitions)</span>
<span class="gi">+        model_name = model_name_map[model]</span>
<span class="gi">+        definitions[model_name] = m_schema</span>
<span class="gi">+    if definitions:</span>
<span class="gi">+        output_schema[&#39;definitions&#39;] = definitions</span>
<span class="gi">+    return output_schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def model_schema(</span>
<span class="gi">+    model: Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]],</span>
<span class="gi">+    by_alias: bool = True,</span>
<span class="gi">+    ref_prefix: Optional[str] = None,</span>
<span class="gi">+    ref_template: str = default_ref_template,</span>
<span class="gi">+) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Generate a JSON Schema for one model. With all the sub-models defined in the ``definitions`` top-level
<span class="w"> </span>    JSON key.
<span class="gu">@@ -70,13 +181,53 @@ def model_schema(model: Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]],</span>
<span class="w"> </span>      sibling json file in a ``/schemas`` directory use ``&quot;/schemas/${model}.json#&quot;``.
<span class="w"> </span>    :return: dict with the JSON Schema for the passed ``model``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def field_schema(field: ModelField, *, by_alias: bool=True, model_name_map:</span>
<span class="gd">-    Dict[TypeModelOrEnum, str], ref_prefix: Optional[str]=None,</span>
<span class="gd">-    ref_template: str=default_ref_template, known_models: Optional[</span>
<span class="gd">-    TypeModelSet]=None) -&gt;Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="gi">+    model = get_model(model)</span>
<span class="gi">+    flat_models = get_flat_models_from_model(model)</span>
<span class="gi">+    model_name_map = get_model_name_map(flat_models)</span>
<span class="gi">+    model_name = model_name_map[model]</span>
<span class="gi">+    m_schema, m_definitions, nested_models = model_process_schema(</span>
<span class="gi">+        model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template</span>
<span class="gi">+    )</span>
<span class="gi">+    if model_name in nested_models:</span>
<span class="gi">+        # model_name is in Nested models, it has circular references</span>
<span class="gi">+        m_definitions[model_name] = m_schema</span>
<span class="gi">+        m_schema = get_schema_ref(model_name, ref_prefix, ref_template, False)</span>
<span class="gi">+    if m_definitions:</span>
<span class="gi">+        m_schema.update({&#39;definitions&#39;: m_definitions})</span>
<span class="gi">+    return m_schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_field_info_schema(field: ModelField, schema_overrides: bool = False) -&gt; Tuple[Dict[str, Any], bool]:</span>
<span class="gi">+    # If no title is explicitly set, we don&#39;t set title in the schema for enums.</span>
<span class="gi">+    # The behaviour is the same as `BaseModel` reference, where the default title</span>
<span class="gi">+    # is in the definitions part of the schema.</span>
<span class="gi">+    schema_: Dict[str, Any] = {}</span>
<span class="gi">+    if field.field_info.title or not lenient_issubclass(field.type_, Enum):</span>
<span class="gi">+        schema_[&#39;title&#39;] = field.field_info.title or field.alias.title().replace(&#39;_&#39;, &#39; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if field.field_info.title:</span>
<span class="gi">+        schema_overrides = True</span>
<span class="gi">+</span>
<span class="gi">+    if field.field_info.description:</span>
<span class="gi">+        schema_[&#39;description&#39;] = field.field_info.description</span>
<span class="gi">+        schema_overrides = True</span>
<span class="gi">+</span>
<span class="gi">+    if not field.required and field.default is not None and not is_callable_type(field.outer_type_):</span>
<span class="gi">+        schema_[&#39;default&#39;] = encode_default(field.default)</span>
<span class="gi">+        schema_overrides = True</span>
<span class="gi">+</span>
<span class="gi">+    return schema_, schema_overrides</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def field_schema(</span>
<span class="gi">+    field: ModelField,</span>
<span class="gi">+    *,</span>
<span class="gi">+    by_alias: bool = True,</span>
<span class="gi">+    model_name_map: Dict[TypeModelOrEnum, str],</span>
<span class="gi">+    ref_prefix: Optional[str] = None,</span>
<span class="gi">+    ref_template: str = default_ref_template,</span>
<span class="gi">+    known_models: Optional[TypeModelSet] = None,</span>
<span class="gi">+) -&gt; Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Process a Pydantic field and return a tuple with a JSON Schema for it as the first item.
<span class="w"> </span>    Also return a dictionary of definitions with models as keys and their schemas as values. If the passed field
<span class="gu">@@ -94,29 +245,81 @@ def field_schema(field: ModelField, *, by_alias: bool=True, model_name_map:</span>
<span class="w"> </span>    :param known_models: used to solve circular references
<span class="w"> </span>    :return: tuple of the schema for this field and additional definitions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-numeric_types = int, float, Decimal</span>
<span class="gd">-_str_types_attrs: Tuple[Tuple[str, Union[type, Tuple[type, ...]], str], ...</span>
<span class="gd">-    ] = ((&#39;max_length&#39;, numeric_types, &#39;maxLength&#39;), (&#39;min_length&#39;,</span>
<span class="gd">-    numeric_types, &#39;minLength&#39;), (&#39;regex&#39;, str, &#39;pattern&#39;))</span>
<span class="gd">-_numeric_types_attrs: Tuple[Tuple[str, Union[type, Tuple[type, ...]], str], ...</span>
<span class="gd">-    ] = ((&#39;gt&#39;, numeric_types, &#39;exclusiveMinimum&#39;), (&#39;lt&#39;, numeric_types,</span>
<span class="gd">-    &#39;exclusiveMaximum&#39;), (&#39;ge&#39;, numeric_types, &#39;minimum&#39;), (&#39;le&#39;,</span>
<span class="gd">-    numeric_types, &#39;maximum&#39;), (&#39;multiple_of&#39;, numeric_types, &#39;multipleOf&#39;))</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_field_schema_validations(field: ModelField) -&gt;Dict[str, Any]:</span>
<span class="gi">+    s, schema_overrides = get_field_info_schema(field)</span>
<span class="gi">+</span>
<span class="gi">+    validation_schema = get_field_schema_validations(field)</span>
<span class="gi">+    if validation_schema:</span>
<span class="gi">+        s.update(validation_schema)</span>
<span class="gi">+        schema_overrides = True</span>
<span class="gi">+</span>
<span class="gi">+    f_schema, f_definitions, f_nested_models = field_type_schema(</span>
<span class="gi">+        field,</span>
<span class="gi">+        by_alias=by_alias,</span>
<span class="gi">+        model_name_map=model_name_map,</span>
<span class="gi">+        schema_overrides=schema_overrides,</span>
<span class="gi">+        ref_prefix=ref_prefix,</span>
<span class="gi">+        ref_template=ref_template,</span>
<span class="gi">+        known_models=known_models or set(),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # $ref will only be returned when there are no schema_overrides</span>
<span class="gi">+    if &#39;$ref&#39; in f_schema:</span>
<span class="gi">+        return f_schema, f_definitions, f_nested_models</span>
<span class="gi">+    else:</span>
<span class="gi">+        s.update(f_schema)</span>
<span class="gi">+        return s, f_definitions, f_nested_models</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+numeric_types = (int, float, Decimal)</span>
<span class="gi">+_str_types_attrs: Tuple[Tuple[str, Union[type, Tuple[type, ...]], str], ...] = (</span>
<span class="gi">+    (&#39;max_length&#39;, numeric_types, &#39;maxLength&#39;),</span>
<span class="gi">+    (&#39;min_length&#39;, numeric_types, &#39;minLength&#39;),</span>
<span class="gi">+    (&#39;regex&#39;, str, &#39;pattern&#39;),</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+_numeric_types_attrs: Tuple[Tuple[str, Union[type, Tuple[type, ...]], str], ...] = (</span>
<span class="gi">+    (&#39;gt&#39;, numeric_types, &#39;exclusiveMinimum&#39;),</span>
<span class="gi">+    (&#39;lt&#39;, numeric_types, &#39;exclusiveMaximum&#39;),</span>
<span class="gi">+    (&#39;ge&#39;, numeric_types, &#39;minimum&#39;),</span>
<span class="gi">+    (&#39;le&#39;, numeric_types, &#39;maximum&#39;),</span>
<span class="gi">+    (&#39;multiple_of&#39;, numeric_types, &#39;multipleOf&#39;),</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_field_schema_validations(field: ModelField) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the JSON Schema validation keywords for a ``field`` with an annotation of
<span class="w"> </span>    a Pydantic ``FieldInfo`` with validation arguments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_model_name_map(unique_models: TypeModelSet) -&gt;Dict[TypeModelOrEnum, str</span>
<span class="gd">-    ]:</span>
<span class="gi">+    f_schema: Dict[str, Any] = {}</span>
<span class="gi">+</span>
<span class="gi">+    if lenient_issubclass(field.type_, Enum):</span>
<span class="gi">+        # schema is already updated by `enum_process_schema`; just update with field extra</span>
<span class="gi">+        if field.field_info.extra:</span>
<span class="gi">+            f_schema.update(field.field_info.extra)</span>
<span class="gi">+        return f_schema</span>
<span class="gi">+</span>
<span class="gi">+    if lenient_issubclass(field.type_, (str, bytes)):</span>
<span class="gi">+        for attr_name, t, keyword in _str_types_attrs:</span>
<span class="gi">+            attr = getattr(field.field_info, attr_name, None)</span>
<span class="gi">+            if isinstance(attr, t):</span>
<span class="gi">+                f_schema[keyword] = attr</span>
<span class="gi">+    if lenient_issubclass(field.type_, numeric_types) and not issubclass(field.type_, bool):</span>
<span class="gi">+        for attr_name, t, keyword in _numeric_types_attrs:</span>
<span class="gi">+            attr = getattr(field.field_info, attr_name, None)</span>
<span class="gi">+            if isinstance(attr, t):</span>
<span class="gi">+                f_schema[keyword] = attr</span>
<span class="gi">+    if field.field_info is not None and field.field_info.const:</span>
<span class="gi">+        f_schema[&#39;const&#39;] = field.default</span>
<span class="gi">+    if field.field_info.extra:</span>
<span class="gi">+        f_schema.update(field.field_info.extra)</span>
<span class="gi">+    modify_schema = getattr(field.outer_type_, &#39;__modify_schema__&#39;, None)</span>
<span class="gi">+    if modify_schema:</span>
<span class="gi">+        _apply_modify_schema(modify_schema, field, f_schema)</span>
<span class="gi">+    return f_schema</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_model_name_map(unique_models: TypeModelSet) -&gt; Dict[TypeModelOrEnum, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Process a set of models and generate unique names for them to be used as keys in the JSON Schema
<span class="w"> </span>    definitions. By default the names are the same as the class name. But if two models in different Python
<span class="gu">@@ -126,11 +329,24 @@ def get_model_name_map(unique_models: TypeModelSet) -&gt;Dict[TypeModelOrEnum, str</span>
<span class="w"> </span>    :param unique_models: a Python set of models
<span class="w"> </span>    :return: dict mapping models to names
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_flat_models_from_model(model: Type[&#39;BaseModel&#39;], known_models:</span>
<span class="gd">-    Optional[TypeModelSet]=None) -&gt;TypeModelSet:</span>
<span class="gi">+    name_model_map = {}</span>
<span class="gi">+    conflicting_names: Set[str] = set()</span>
<span class="gi">+    for model in unique_models:</span>
<span class="gi">+        model_name = normalize_name(model.__name__)</span>
<span class="gi">+        if model_name in conflicting_names:</span>
<span class="gi">+            model_name = get_long_model_name(model)</span>
<span class="gi">+            name_model_map[model_name] = model</span>
<span class="gi">+        elif model_name in name_model_map:</span>
<span class="gi">+            conflicting_names.add(model_name)</span>
<span class="gi">+            conflicting_model = name_model_map.pop(model_name)</span>
<span class="gi">+            name_model_map[get_long_model_name(conflicting_model)] = conflicting_model</span>
<span class="gi">+            name_model_map[get_long_model_name(model)] = model</span>
<span class="gi">+        else:</span>
<span class="gi">+            name_model_map[model_name] = model</span>
<span class="gi">+    return {v: k for k, v in name_model_map.items()}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_flat_models_from_model(model: Type[&#39;BaseModel&#39;], known_models: Optional[TypeModelSet] = None) -&gt; TypeModelSet:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a single ``model`` and generate a set with itself and all the sub-models in the tree. I.e. if you pass
<span class="w"> </span>    model ``Foo`` (subclass of Pydantic ``BaseModel``) as ``model``, and it has a field of type ``Bar`` (also
<span class="gu">@@ -141,11 +357,16 @@ def get_flat_models_from_model(model: Type[&#39;BaseModel&#39;], known_models:</span>
<span class="w"> </span>    :param known_models: used to solve circular references
<span class="w"> </span>    :return: a set with the initial model and all its sub-models
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    known_models = known_models or set()</span>
<span class="gi">+    flat_models: TypeModelSet = set()</span>
<span class="gi">+    flat_models.add(model)</span>
<span class="gi">+    known_models |= flat_models</span>
<span class="gi">+    fields = cast(Sequence[ModelField], model.__fields__.values())</span>
<span class="gi">+    flat_models |= get_flat_models_from_fields(fields, known_models=known_models)</span>
<span class="gi">+    return flat_models</span>


<span class="gd">-def get_flat_models_from_field(field: ModelField, known_models: TypeModelSet</span>
<span class="gd">-    ) -&gt;TypeModelSet:</span>
<span class="gi">+def get_flat_models_from_field(field: ModelField, known_models: TypeModelSet) -&gt; TypeModelSet:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a single Pydantic ``ModelField`` (from a model) that could have been declared as a subclass of BaseModel
<span class="w"> </span>    (so, it could be a submodel), and generate a set with its model and all the sub-models in the tree.
<span class="gu">@@ -157,11 +378,24 @@ def get_flat_models_from_field(field: ModelField, known_models: TypeModelSet</span>
<span class="w"> </span>    :param known_models: used to solve circular references
<span class="w"> </span>    :return: a set with the model used in the declaration for this field, if any, and all its sub-models
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from pydantic.v1.main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    flat_models: TypeModelSet = set()</span>
<span class="gi">+</span>
<span class="gi">+    field_type = field.type_</span>
<span class="gi">+    if lenient_issubclass(getattr(field_type, &#39;__pydantic_model__&#39;, None), BaseModel):</span>
<span class="gi">+        field_type = field_type.__pydantic_model__</span>

<span class="gi">+    if field.sub_fields and not lenient_issubclass(field_type, BaseModel):</span>
<span class="gi">+        flat_models |= get_flat_models_from_fields(field.sub_fields, known_models=known_models)</span>
<span class="gi">+    elif lenient_issubclass(field_type, BaseModel) and field_type not in known_models:</span>
<span class="gi">+        flat_models |= get_flat_models_from_model(field_type, known_models=known_models)</span>
<span class="gi">+    elif lenient_issubclass(field_type, Enum):</span>
<span class="gi">+        flat_models.add(field_type)</span>
<span class="gi">+    return flat_models</span>

<span class="gd">-def get_flat_models_from_fields(fields: Sequence[ModelField], known_models:</span>
<span class="gd">-    TypeModelSet) -&gt;TypeModelSet:</span>
<span class="gi">+</span>
<span class="gi">+def get_flat_models_from_fields(fields: Sequence[ModelField], known_models: TypeModelSet) -&gt; TypeModelSet:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a list of Pydantic  ``ModelField``s (from a model) that could have been declared as subclasses of ``BaseModel``
<span class="w"> </span>    (so, any of them could be a submodel), and generate a set with their models and all the sub-models in the tree.
<span class="gu">@@ -173,37 +407,157 @@ def get_flat_models_from_fields(fields: Sequence[ModelField], known_models:</span>
<span class="w"> </span>    :param known_models: used to solve circular references
<span class="w"> </span>    :return: a set with any model declared in the fields, and all their sub-models
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    flat_models: TypeModelSet = set()</span>
<span class="gi">+    for field in fields:</span>
<span class="gi">+        flat_models |= get_flat_models_from_field(field, known_models=known_models)</span>
<span class="gi">+    return flat_models</span>


<span class="gd">-def get_flat_models_from_models(models: Sequence[Type[&#39;BaseModel&#39;]]</span>
<span class="gd">-    ) -&gt;TypeModelSet:</span>
<span class="gi">+def get_flat_models_from_models(models: Sequence[Type[&#39;BaseModel&#39;]]) -&gt; TypeModelSet:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a list of ``models`` and generate a set with them and all their sub-models in their trees. I.e. if you pass
<span class="w"> </span>    a list of two models, ``Foo`` and ``Bar``, both subclasses of Pydantic ``BaseModel`` as models, and ``Bar`` has
<span class="w"> </span>    a field of type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def field_type_schema(field: ModelField, *, by_alias: bool, model_name_map:</span>
<span class="gd">-    Dict[TypeModelOrEnum, str], ref_template: str, schema_overrides: bool=</span>
<span class="gd">-    False, ref_prefix: Optional[str]=None, known_models: TypeModelSet) -&gt;Tuple[</span>
<span class="gd">-    Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="gi">+    flat_models: TypeModelSet = set()</span>
<span class="gi">+    for model in models:</span>
<span class="gi">+        flat_models |= get_flat_models_from_model(model)</span>
<span class="gi">+    return flat_models</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_long_model_name(model: TypeModelOrEnum) -&gt; str:</span>
<span class="gi">+    return f&#39;{model.__module__}__{model.__qualname__}&#39;.replace(&#39;.&#39;, &#39;__&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def field_type_schema(</span>
<span class="gi">+    field: ModelField,</span>
<span class="gi">+    *,</span>
<span class="gi">+    by_alias: bool,</span>
<span class="gi">+    model_name_map: Dict[TypeModelOrEnum, str],</span>
<span class="gi">+    ref_template: str,</span>
<span class="gi">+    schema_overrides: bool = False,</span>
<span class="gi">+    ref_prefix: Optional[str] = None,</span>
<span class="gi">+    known_models: TypeModelSet,</span>
<span class="gi">+) -&gt; Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Used by ``field_schema()``, you probably should be using that function.

<span class="w"> </span>    Take a single ``field`` and generate the schema for its type only, not including additional
<span class="w"> </span>    information as title, etc. Also return additional schema definitions, from sub-models.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def model_process_schema(model: TypeModelOrEnum, *, by_alias: bool=True,</span>
<span class="gd">-    model_name_map: Dict[TypeModelOrEnum, str], ref_prefix: Optional[str]=</span>
<span class="gd">-    None, ref_template: str=default_ref_template, known_models: Optional[</span>
<span class="gd">-    TypeModelSet]=None, field: Optional[ModelField]=None) -&gt;Tuple[Dict[str,</span>
<span class="gd">-    Any], Dict[str, Any], Set[str]]:</span>
<span class="gi">+    from pydantic.v1.main import BaseModel  # noqa: F811</span>
<span class="gi">+</span>
<span class="gi">+    definitions = {}</span>
<span class="gi">+    nested_models: Set[str] = set()</span>
<span class="gi">+    f_schema: Dict[str, Any]</span>
<span class="gi">+    if field.shape in {</span>
<span class="gi">+        SHAPE_LIST,</span>
<span class="gi">+        SHAPE_TUPLE_ELLIPSIS,</span>
<span class="gi">+        SHAPE_SEQUENCE,</span>
<span class="gi">+        SHAPE_SET,</span>
<span class="gi">+        SHAPE_FROZENSET,</span>
<span class="gi">+        SHAPE_ITERABLE,</span>
<span class="gi">+        SHAPE_DEQUE,</span>
<span class="gi">+    }:</span>
<span class="gi">+        items_schema, f_definitions, f_nested_models = field_singleton_schema(</span>
<span class="gi">+            field,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            model_name_map=model_name_map,</span>
<span class="gi">+            ref_prefix=ref_prefix,</span>
<span class="gi">+            ref_template=ref_template,</span>
<span class="gi">+            known_models=known_models,</span>
<span class="gi">+        )</span>
<span class="gi">+        definitions.update(f_definitions)</span>
<span class="gi">+        nested_models.update(f_nested_models)</span>
<span class="gi">+        f_schema = {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: items_schema}</span>
<span class="gi">+        if field.shape in {SHAPE_SET, SHAPE_FROZENSET}:</span>
<span class="gi">+            f_schema[&#39;uniqueItems&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+    elif field.shape in MAPPING_LIKE_SHAPES:</span>
<span class="gi">+        f_schema = {&#39;type&#39;: &#39;object&#39;}</span>
<span class="gi">+        key_field = cast(ModelField, field.key_field)</span>
<span class="gi">+        regex = getattr(key_field.type_, &#39;regex&#39;, None)</span>
<span class="gi">+        items_schema, f_definitions, f_nested_models = field_singleton_schema(</span>
<span class="gi">+            field,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            model_name_map=model_name_map,</span>
<span class="gi">+            ref_prefix=ref_prefix,</span>
<span class="gi">+            ref_template=ref_template,</span>
<span class="gi">+            known_models=known_models,</span>
<span class="gi">+        )</span>
<span class="gi">+        definitions.update(f_definitions)</span>
<span class="gi">+        nested_models.update(f_nested_models)</span>
<span class="gi">+        if regex:</span>
<span class="gi">+            # Dict keys have a regex pattern</span>
<span class="gi">+            # items_schema might be a schema or empty dict, add it either way</span>
<span class="gi">+            f_schema[&#39;patternProperties&#39;] = {ConstrainedStr._get_pattern(regex): items_schema}</span>
<span class="gi">+        if items_schema:</span>
<span class="gi">+            # The dict values are not simply Any, so they need a schema</span>
<span class="gi">+            f_schema[&#39;additionalProperties&#39;] = items_schema</span>
<span class="gi">+    elif field.shape == SHAPE_TUPLE or (field.shape == SHAPE_GENERIC and not issubclass(field.type_, BaseModel)):</span>
<span class="gi">+        sub_schema = []</span>
<span class="gi">+        sub_fields = cast(List[ModelField], field.sub_fields)</span>
<span class="gi">+        for sf in sub_fields:</span>
<span class="gi">+            sf_schema, sf_definitions, sf_nested_models = field_type_schema(</span>
<span class="gi">+                sf,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                model_name_map=model_name_map,</span>
<span class="gi">+                ref_prefix=ref_prefix,</span>
<span class="gi">+                ref_template=ref_template,</span>
<span class="gi">+                known_models=known_models,</span>
<span class="gi">+            )</span>
<span class="gi">+            definitions.update(sf_definitions)</span>
<span class="gi">+            nested_models.update(sf_nested_models)</span>
<span class="gi">+            sub_schema.append(sf_schema)</span>
<span class="gi">+</span>
<span class="gi">+        sub_fields_len = len(sub_fields)</span>
<span class="gi">+        if field.shape == SHAPE_GENERIC:</span>
<span class="gi">+            all_of_schemas = sub_schema[0] if sub_fields_len == 1 else {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: sub_schema}</span>
<span class="gi">+            f_schema = {&#39;allOf&#39;: [all_of_schemas]}</span>
<span class="gi">+        else:</span>
<span class="gi">+            f_schema = {</span>
<span class="gi">+                &#39;type&#39;: &#39;array&#39;,</span>
<span class="gi">+                &#39;minItems&#39;: sub_fields_len,</span>
<span class="gi">+                &#39;maxItems&#39;: sub_fields_len,</span>
<span class="gi">+            }</span>
<span class="gi">+            if sub_fields_len &gt;= 1:</span>
<span class="gi">+                f_schema[&#39;items&#39;] = sub_schema</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert field.shape in {SHAPE_SINGLETON, SHAPE_GENERIC}, field.shape</span>
<span class="gi">+        f_schema, f_definitions, f_nested_models = field_singleton_schema(</span>
<span class="gi">+            field,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            model_name_map=model_name_map,</span>
<span class="gi">+            schema_overrides=schema_overrides,</span>
<span class="gi">+            ref_prefix=ref_prefix,</span>
<span class="gi">+            ref_template=ref_template,</span>
<span class="gi">+            known_models=known_models,</span>
<span class="gi">+        )</span>
<span class="gi">+        definitions.update(f_definitions)</span>
<span class="gi">+        nested_models.update(f_nested_models)</span>
<span class="gi">+</span>
<span class="gi">+    # check field type to avoid repeated calls to the same __modify_schema__ method</span>
<span class="gi">+    if field.type_ != field.outer_type_:</span>
<span class="gi">+        if field.shape == SHAPE_GENERIC:</span>
<span class="gi">+            field_type = field.type_</span>
<span class="gi">+        else:</span>
<span class="gi">+            field_type = field.outer_type_</span>
<span class="gi">+        modify_schema = getattr(field_type, &#39;__modify_schema__&#39;, None)</span>
<span class="gi">+        if modify_schema:</span>
<span class="gi">+            _apply_modify_schema(modify_schema, field, f_schema)</span>
<span class="gi">+    return f_schema, definitions, nested_models</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def model_process_schema(</span>
<span class="gi">+    model: TypeModelOrEnum,</span>
<span class="gi">+    *,</span>
<span class="gi">+    by_alias: bool = True,</span>
<span class="gi">+    model_name_map: Dict[TypeModelOrEnum, str],</span>
<span class="gi">+    ref_prefix: Optional[str] = None,</span>
<span class="gi">+    ref_template: str = default_ref_template,</span>
<span class="gi">+    known_models: Optional[TypeModelSet] = None,</span>
<span class="gi">+    field: Optional[ModelField] = None,</span>
<span class="gi">+) -&gt; Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Used by ``model_schema()``, you probably should be using that function.

<span class="gu">@@ -211,105 +565,442 @@ def model_process_schema(model: TypeModelOrEnum, *, by_alias: bool=True,</span>
<span class="w"> </span>    sub-models of the returned schema will be referenced, but their definitions will not be included in the schema. All
<span class="w"> </span>    the definitions are returned as the second value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def model_type_schema(model: Type[&#39;BaseModel&#39;], *, by_alias: bool,</span>
<span class="gd">-    model_name_map: Dict[TypeModelOrEnum, str], ref_template: str,</span>
<span class="gd">-    ref_prefix: Optional[str]=None, known_models: TypeModelSet) -&gt;Tuple[</span>
<span class="gd">-    Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="gi">+    from inspect import getdoc, signature</span>
<span class="gi">+</span>
<span class="gi">+    known_models = known_models or set()</span>
<span class="gi">+    if lenient_issubclass(model, Enum):</span>
<span class="gi">+        model = cast(Type[Enum], model)</span>
<span class="gi">+        s = enum_process_schema(model, field=field)</span>
<span class="gi">+        return s, {}, set()</span>
<span class="gi">+    model = cast(Type[&#39;BaseModel&#39;], model)</span>
<span class="gi">+    s = {&#39;title&#39;: model.__config__.title or model.__name__}</span>
<span class="gi">+    doc = getdoc(model)</span>
<span class="gi">+    if doc:</span>
<span class="gi">+        s[&#39;description&#39;] = doc</span>
<span class="gi">+    known_models.add(model)</span>
<span class="gi">+    m_schema, m_definitions, nested_models = model_type_schema(</span>
<span class="gi">+        model,</span>
<span class="gi">+        by_alias=by_alias,</span>
<span class="gi">+        model_name_map=model_name_map,</span>
<span class="gi">+        ref_prefix=ref_prefix,</span>
<span class="gi">+        ref_template=ref_template,</span>
<span class="gi">+        known_models=known_models,</span>
<span class="gi">+    )</span>
<span class="gi">+    s.update(m_schema)</span>
<span class="gi">+    schema_extra = model.__config__.schema_extra</span>
<span class="gi">+    if callable(schema_extra):</span>
<span class="gi">+        if len(signature(schema_extra).parameters) == 1:</span>
<span class="gi">+            schema_extra(s)</span>
<span class="gi">+        else:</span>
<span class="gi">+            schema_extra(s, model)</span>
<span class="gi">+    else:</span>
<span class="gi">+        s.update(schema_extra)</span>
<span class="gi">+    return s, m_definitions, nested_models</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def model_type_schema(</span>
<span class="gi">+    model: Type[&#39;BaseModel&#39;],</span>
<span class="gi">+    *,</span>
<span class="gi">+    by_alias: bool,</span>
<span class="gi">+    model_name_map: Dict[TypeModelOrEnum, str],</span>
<span class="gi">+    ref_template: str,</span>
<span class="gi">+    ref_prefix: Optional[str] = None,</span>
<span class="gi">+    known_models: TypeModelSet,</span>
<span class="gi">+) -&gt; Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    You probably should be using ``model_schema()``, this function is indirectly used by that function.

<span class="w"> </span>    Take a single ``model`` and generate the schema for its type only, not including additional
<span class="w"> </span>    information as title, etc. Also return additional schema definitions, from sub-models.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def enum_process_schema(enum: Type[Enum], *, field: Optional[ModelField]=None</span>
<span class="gd">-    ) -&gt;Dict[str, Any]:</span>
<span class="gi">+    properties = {}</span>
<span class="gi">+    required = []</span>
<span class="gi">+    definitions: Dict[str, Any] = {}</span>
<span class="gi">+    nested_models: Set[str] = set()</span>
<span class="gi">+    for k, f in model.__fields__.items():</span>
<span class="gi">+        try:</span>
<span class="gi">+            f_schema, f_definitions, f_nested_models = field_schema(</span>
<span class="gi">+                f,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                model_name_map=model_name_map,</span>
<span class="gi">+                ref_prefix=ref_prefix,</span>
<span class="gi">+                ref_template=ref_template,</span>
<span class="gi">+                known_models=known_models,</span>
<span class="gi">+            )</span>
<span class="gi">+        except SkipField as skip:</span>
<span class="gi">+            warnings.warn(skip.message, UserWarning)</span>
<span class="gi">+            continue</span>
<span class="gi">+        definitions.update(f_definitions)</span>
<span class="gi">+        nested_models.update(f_nested_models)</span>
<span class="gi">+        if by_alias:</span>
<span class="gi">+            properties[f.alias] = f_schema</span>
<span class="gi">+            if f.required:</span>
<span class="gi">+                required.append(f.alias)</span>
<span class="gi">+        else:</span>
<span class="gi">+            properties[k] = f_schema</span>
<span class="gi">+            if f.required:</span>
<span class="gi">+                required.append(k)</span>
<span class="gi">+    if ROOT_KEY in properties:</span>
<span class="gi">+        out_schema = properties[ROOT_KEY]</span>
<span class="gi">+        out_schema[&#39;title&#39;] = model.__config__.title or model.__name__</span>
<span class="gi">+    else:</span>
<span class="gi">+        out_schema = {&#39;type&#39;: &#39;object&#39;, &#39;properties&#39;: properties}</span>
<span class="gi">+        if required:</span>
<span class="gi">+            out_schema[&#39;required&#39;] = required</span>
<span class="gi">+    if model.__config__.extra == &#39;forbid&#39;:</span>
<span class="gi">+        out_schema[&#39;additionalProperties&#39;] = False</span>
<span class="gi">+    return out_schema, definitions, nested_models</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def enum_process_schema(enum: Type[Enum], *, field: Optional[ModelField] = None) -&gt; Dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a single `enum` and generate its schema.

<span class="w"> </span>    This is similar to the `model_process_schema` function, but applies to ``Enum`` objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def field_singleton_sub_fields_schema(field: ModelField, *, by_alias: bool,</span>
<span class="gd">-    model_name_map: Dict[TypeModelOrEnum, str], ref_template: str,</span>
<span class="gd">-    schema_overrides: bool=False, ref_prefix: Optional[str]=None,</span>
<span class="gd">-    known_models: TypeModelSet) -&gt;Tuple[Dict[str, Any], Dict[str, Any], Set</span>
<span class="gd">-    [str]]:</span>
<span class="gi">+    import inspect</span>
<span class="gi">+</span>
<span class="gi">+    schema_: Dict[str, Any] = {</span>
<span class="gi">+        &#39;title&#39;: enum.__name__,</span>
<span class="gi">+        # Python assigns all enums a default docstring value of &#39;An enumeration&#39;, so</span>
<span class="gi">+        # all enums will have a description field even if not explicitly provided.</span>
<span class="gi">+        &#39;description&#39;: inspect.cleandoc(enum.__doc__ or &#39;An enumeration.&#39;),</span>
<span class="gi">+        # Add enum values and the enum field type to the schema.</span>
<span class="gi">+        &#39;enum&#39;: [item.value for item in cast(Iterable[Enum], enum)],</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    add_field_type_to_schema(enum, schema_)</span>
<span class="gi">+</span>
<span class="gi">+    modify_schema = getattr(enum, &#39;__modify_schema__&#39;, None)</span>
<span class="gi">+    if modify_schema:</span>
<span class="gi">+        _apply_modify_schema(modify_schema, field, schema_)</span>
<span class="gi">+</span>
<span class="gi">+    return schema_</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def field_singleton_sub_fields_schema(</span>
<span class="gi">+    field: ModelField,</span>
<span class="gi">+    *,</span>
<span class="gi">+    by_alias: bool,</span>
<span class="gi">+    model_name_map: Dict[TypeModelOrEnum, str],</span>
<span class="gi">+    ref_template: str,</span>
<span class="gi">+    schema_overrides: bool = False,</span>
<span class="gi">+    ref_prefix: Optional[str] = None,</span>
<span class="gi">+    known_models: TypeModelSet,</span>
<span class="gi">+) -&gt; Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This function is indirectly used by ``field_schema()``, you probably should be using that function.

<span class="w"> </span>    Take a list of Pydantic ``ModelField`` from the declaration of a type with parameters, and generate their
<span class="w"> </span>    schema. I.e., fields used as &quot;type parameters&quot;, like ``str`` and ``int`` in ``Tuple[str, int]``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-field_class_to_schema: Tuple[Tuple[Any, Dict[str, Any]], ...] = ((Path, {</span>
<span class="gd">-    &#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;path&#39;}), (datetime, {&#39;type&#39;: &#39;string&#39;,</span>
<span class="gd">-    &#39;format&#39;: &#39;date-time&#39;}), (date, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;date&#39;}),</span>
<span class="gd">-    (time, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;time&#39;}), (timedelta, {&#39;type&#39;:</span>
<span class="gd">-    &#39;number&#39;, &#39;format&#39;: &#39;time-delta&#39;}), (IPv4Network, {&#39;type&#39;: &#39;string&#39;,</span>
<span class="gd">-    &#39;format&#39;: &#39;ipv4network&#39;}), (IPv6Network, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;:</span>
<span class="gd">-    &#39;ipv6network&#39;}), (IPv4Interface, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;:</span>
<span class="gd">-    &#39;ipv4interface&#39;}), (IPv6Interface, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;:</span>
<span class="gd">-    &#39;ipv6interface&#39;}), (IPv4Address, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv4&#39;}),</span>
<span class="gd">-    (IPv6Address, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv6&#39;}), (Pattern, {&#39;type&#39;:</span>
<span class="gd">-    &#39;string&#39;, &#39;format&#39;: &#39;regex&#39;}), (str, {&#39;type&#39;: &#39;string&#39;}), (bytes, {</span>
<span class="gd">-    &#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;binary&#39;}), (bool, {&#39;type&#39;: &#39;boolean&#39;}), (</span>
<span class="gd">-    int, {&#39;type&#39;: &#39;integer&#39;}), (float, {&#39;type&#39;: &#39;number&#39;}), (Decimal, {</span>
<span class="gd">-    &#39;type&#39;: &#39;number&#39;}), (UUID, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;uuid&#39;}), (dict,</span>
<span class="gd">-    {&#39;type&#39;: &#39;object&#39;}), (list, {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: {}}), (tuple, {</span>
<span class="gd">-    &#39;type&#39;: &#39;array&#39;, &#39;items&#39;: {}}), (set, {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: {},</span>
<span class="gd">-    &#39;uniqueItems&#39;: True}), (frozenset, {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: {},</span>
<span class="gd">-    &#39;uniqueItems&#39;: True}))</span>
<span class="gi">+    sub_fields = cast(List[ModelField], field.sub_fields)</span>
<span class="gi">+    definitions = {}</span>
<span class="gi">+    nested_models: Set[str] = set()</span>
<span class="gi">+    if len(sub_fields) == 1:</span>
<span class="gi">+        return field_type_schema(</span>
<span class="gi">+            sub_fields[0],</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            model_name_map=model_name_map,</span>
<span class="gi">+            schema_overrides=schema_overrides,</span>
<span class="gi">+            ref_prefix=ref_prefix,</span>
<span class="gi">+            ref_template=ref_template,</span>
<span class="gi">+            known_models=known_models,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        s: Dict[str, Any] = {}</span>
<span class="gi">+        # https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminator-object</span>
<span class="gi">+        field_has_discriminator: bool = field.discriminator_key is not None</span>
<span class="gi">+        if field_has_discriminator:</span>
<span class="gi">+            assert field.sub_fields_mapping is not None</span>
<span class="gi">+</span>
<span class="gi">+            discriminator_models_refs: Dict[str, Union[str, Dict[str, Any]]] = {}</span>
<span class="gi">+</span>
<span class="gi">+            for discriminator_value, sub_field in field.sub_fields_mapping.items():</span>
<span class="gi">+                if isinstance(discriminator_value, Enum):</span>
<span class="gi">+                    discriminator_value = str(discriminator_value.value)</span>
<span class="gi">+                # sub_field is either a `BaseModel` or directly an `Annotated` `Union` of many</span>
<span class="gi">+                if is_union(get_origin(sub_field.type_)):</span>
<span class="gi">+                    sub_models = get_sub_types(sub_field.type_)</span>
<span class="gi">+                    discriminator_models_refs[discriminator_value] = {</span>
<span class="gi">+                        model_name_map[sub_model]: get_schema_ref(</span>
<span class="gi">+                            model_name_map[sub_model], ref_prefix, ref_template, False</span>
<span class="gi">+                        )</span>
<span class="gi">+                        for sub_model in sub_models</span>
<span class="gi">+                    }</span>
<span class="gi">+                else:</span>
<span class="gi">+                    sub_field_type = sub_field.type_</span>
<span class="gi">+                    if hasattr(sub_field_type, &#39;__pydantic_model__&#39;):</span>
<span class="gi">+                        sub_field_type = sub_field_type.__pydantic_model__</span>
<span class="gi">+</span>
<span class="gi">+                    discriminator_model_name = model_name_map[sub_field_type]</span>
<span class="gi">+                    discriminator_model_ref = get_schema_ref(discriminator_model_name, ref_prefix, ref_template, False)</span>
<span class="gi">+                    discriminator_models_refs[discriminator_value] = discriminator_model_ref[&#39;$ref&#39;]</span>
<span class="gi">+</span>
<span class="gi">+            s[&#39;discriminator&#39;] = {</span>
<span class="gi">+                &#39;propertyName&#39;: field.discriminator_alias,</span>
<span class="gi">+                &#39;mapping&#39;: discriminator_models_refs,</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        sub_field_schemas = []</span>
<span class="gi">+        for sf in sub_fields:</span>
<span class="gi">+            sub_schema, sub_definitions, sub_nested_models = field_type_schema(</span>
<span class="gi">+                sf,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                model_name_map=model_name_map,</span>
<span class="gi">+                schema_overrides=schema_overrides,</span>
<span class="gi">+                ref_prefix=ref_prefix,</span>
<span class="gi">+                ref_template=ref_template,</span>
<span class="gi">+                known_models=known_models,</span>
<span class="gi">+            )</span>
<span class="gi">+            definitions.update(sub_definitions)</span>
<span class="gi">+            if schema_overrides and &#39;allOf&#39; in sub_schema:</span>
<span class="gi">+                # if the sub_field is a referenced schema we only need the referenced</span>
<span class="gi">+                # object. Otherwise we will end up with several allOf inside anyOf/oneOf.</span>
<span class="gi">+                # See https://github.com/pydantic/pydantic/issues/1209</span>
<span class="gi">+                sub_schema = sub_schema[&#39;allOf&#39;][0]</span>
<span class="gi">+</span>
<span class="gi">+            if sub_schema.keys() == {&#39;discriminator&#39;, &#39;oneOf&#39;}:</span>
<span class="gi">+                # we don&#39;t want discriminator information inside oneOf choices, this is dealt with elsewhere</span>
<span class="gi">+                sub_schema.pop(&#39;discriminator&#39;)</span>
<span class="gi">+            sub_field_schemas.append(sub_schema)</span>
<span class="gi">+            nested_models.update(sub_nested_models)</span>
<span class="gi">+        s[&#39;oneOf&#39; if field_has_discriminator else &#39;anyOf&#39;] = sub_field_schemas</span>
<span class="gi">+        return s, definitions, nested_models</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Order is important, e.g. subclasses of str must go before str</span>
<span class="gi">+# this is used only for standard library types, custom types should use __modify_schema__ instead</span>
<span class="gi">+field_class_to_schema: Tuple[Tuple[Any, Dict[str, Any]], ...] = (</span>
<span class="gi">+    (Path, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;path&#39;}),</span>
<span class="gi">+    (datetime, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;date-time&#39;}),</span>
<span class="gi">+    (date, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;date&#39;}),</span>
<span class="gi">+    (time, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;time&#39;}),</span>
<span class="gi">+    (timedelta, {&#39;type&#39;: &#39;number&#39;, &#39;format&#39;: &#39;time-delta&#39;}),</span>
<span class="gi">+    (IPv4Network, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv4network&#39;}),</span>
<span class="gi">+    (IPv6Network, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv6network&#39;}),</span>
<span class="gi">+    (IPv4Interface, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv4interface&#39;}),</span>
<span class="gi">+    (IPv6Interface, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv6interface&#39;}),</span>
<span class="gi">+    (IPv4Address, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv4&#39;}),</span>
<span class="gi">+    (IPv6Address, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;ipv6&#39;}),</span>
<span class="gi">+    (Pattern, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;regex&#39;}),</span>
<span class="gi">+    (str, {&#39;type&#39;: &#39;string&#39;}),</span>
<span class="gi">+    (bytes, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;binary&#39;}),</span>
<span class="gi">+    (bool, {&#39;type&#39;: &#39;boolean&#39;}),</span>
<span class="gi">+    (int, {&#39;type&#39;: &#39;integer&#39;}),</span>
<span class="gi">+    (float, {&#39;type&#39;: &#39;number&#39;}),</span>
<span class="gi">+    (Decimal, {&#39;type&#39;: &#39;number&#39;}),</span>
<span class="gi">+    (UUID, {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;uuid&#39;}),</span>
<span class="gi">+    (dict, {&#39;type&#39;: &#39;object&#39;}),</span>
<span class="gi">+    (list, {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: {}}),</span>
<span class="gi">+    (tuple, {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: {}}),</span>
<span class="gi">+    (set, {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: {}, &#39;uniqueItems&#39;: True}),</span>
<span class="gi">+    (frozenset, {&#39;type&#39;: &#39;array&#39;, &#39;items&#39;: {}, &#39;uniqueItems&#39;: True}),</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>json_scheme = {&#39;type&#39;: &#39;string&#39;, &#39;format&#39;: &#39;json-string&#39;}


<span class="gd">-def add_field_type_to_schema(field_type: Any, schema_: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+def add_field_type_to_schema(field_type: Any, schema_: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Update the given `schema` with the type-specific metadata for the given `field_type`.

<span class="w"> </span>    This function looks through `field_class_to_schema` for a class that matches the given `field_type`,
<span class="w"> </span>    and then modifies the given `schema` with the information from that type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def field_singleton_schema(field: ModelField, *, by_alias: bool,</span>
<span class="gd">-    model_name_map: Dict[TypeModelOrEnum, str], ref_template: str,</span>
<span class="gd">-    schema_overrides: bool=False, ref_prefix: Optional[str]=None,</span>
<span class="gd">-    known_models: TypeModelSet) -&gt;Tuple[Dict[str, Any], Dict[str, Any], Set</span>
<span class="gd">-    [str]]:</span>
<span class="gi">+    for type_, t_schema in field_class_to_schema:</span>
<span class="gi">+        # Fallback for `typing.Pattern` and `re.Pattern` as they are not a valid class</span>
<span class="gi">+        if lenient_issubclass(field_type, type_) or field_type is type_ is Pattern:</span>
<span class="gi">+            schema_.update(t_schema)</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_schema_ref(name: str, ref_prefix: Optional[str], ref_template: str, schema_overrides: bool) -&gt; Dict[str, Any]:</span>
<span class="gi">+    if ref_prefix:</span>
<span class="gi">+        schema_ref = {&#39;$ref&#39;: ref_prefix + name}</span>
<span class="gi">+    else:</span>
<span class="gi">+        schema_ref = {&#39;$ref&#39;: ref_template.format(model=name)}</span>
<span class="gi">+    return {&#39;allOf&#39;: [schema_ref]} if schema_overrides else schema_ref</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def field_singleton_schema(  # noqa: C901 (ignore complexity)</span>
<span class="gi">+    field: ModelField,</span>
<span class="gi">+    *,</span>
<span class="gi">+    by_alias: bool,</span>
<span class="gi">+    model_name_map: Dict[TypeModelOrEnum, str],</span>
<span class="gi">+    ref_template: str,</span>
<span class="gi">+    schema_overrides: bool = False,</span>
<span class="gi">+    ref_prefix: Optional[str] = None,</span>
<span class="gi">+    known_models: TypeModelSet,</span>
<span class="gi">+) -&gt; Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This function is indirectly used by ``field_schema()``, you should probably be using that function.

<span class="w"> </span>    Take a single Pydantic ``ModelField``, and return its schema and any additional definitions from sub-models.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    from pydantic.v1.main import BaseModel</span>

<span class="gd">-def multitypes_literal_field_for_schema(values: Tuple[Any, ...], field:</span>
<span class="gd">-    ModelField) -&gt;ModelField:</span>
<span class="gi">+    definitions: Dict[str, Any] = {}</span>
<span class="gi">+    nested_models: Set[str] = set()</span>
<span class="gi">+    field_type = field.type_</span>
<span class="gi">+</span>
<span class="gi">+    # Recurse into this field if it contains sub_fields and is NOT a</span>
<span class="gi">+    # BaseModel OR that BaseModel is a const</span>
<span class="gi">+    if field.sub_fields and (</span>
<span class="gi">+        (field.field_info and field.field_info.const) or not lenient_issubclass(field_type, BaseModel)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return field_singleton_sub_fields_schema(</span>
<span class="gi">+            field,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            model_name_map=model_name_map,</span>
<span class="gi">+            schema_overrides=schema_overrides,</span>
<span class="gi">+            ref_prefix=ref_prefix,</span>
<span class="gi">+            ref_template=ref_template,</span>
<span class="gi">+            known_models=known_models,</span>
<span class="gi">+        )</span>
<span class="gi">+    if field_type is Any or field_type is object or field_type.__class__ == TypeVar or get_origin(field_type) is type:</span>
<span class="gi">+        return {}, definitions, nested_models  # no restrictions</span>
<span class="gi">+    if is_none_type(field_type):</span>
<span class="gi">+        return {&#39;type&#39;: &#39;null&#39;}, definitions, nested_models</span>
<span class="gi">+    if is_callable_type(field_type):</span>
<span class="gi">+        raise SkipField(f&#39;Callable {field.name} was excluded from schema since JSON schema has no equivalent type.&#39;)</span>
<span class="gi">+    f_schema: Dict[str, Any] = {}</span>
<span class="gi">+    if field.field_info is not None and field.field_info.const:</span>
<span class="gi">+        f_schema[&#39;const&#39;] = field.default</span>
<span class="gi">+</span>
<span class="gi">+    if is_literal_type(field_type):</span>
<span class="gi">+        values = tuple(x.value if isinstance(x, Enum) else x for x in all_literal_values(field_type))</span>
<span class="gi">+</span>
<span class="gi">+        if len({v.__class__ for v in values}) &gt; 1:</span>
<span class="gi">+            return field_schema(</span>
<span class="gi">+                multitypes_literal_field_for_schema(values, field),</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                model_name_map=model_name_map,</span>
<span class="gi">+                ref_prefix=ref_prefix,</span>
<span class="gi">+                ref_template=ref_template,</span>
<span class="gi">+                known_models=known_models,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # All values have the same type</span>
<span class="gi">+        field_type = values[0].__class__</span>
<span class="gi">+        f_schema[&#39;enum&#39;] = list(values)</span>
<span class="gi">+        add_field_type_to_schema(field_type, f_schema)</span>
<span class="gi">+    elif lenient_issubclass(field_type, Enum):</span>
<span class="gi">+        enum_name = model_name_map[field_type]</span>
<span class="gi">+        f_schema, schema_overrides = get_field_info_schema(field, schema_overrides)</span>
<span class="gi">+        f_schema.update(get_schema_ref(enum_name, ref_prefix, ref_template, schema_overrides))</span>
<span class="gi">+        definitions[enum_name] = enum_process_schema(field_type, field=field)</span>
<span class="gi">+    elif is_namedtuple(field_type):</span>
<span class="gi">+        sub_schema, *_ = model_process_schema(</span>
<span class="gi">+            field_type.__pydantic_model__,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            model_name_map=model_name_map,</span>
<span class="gi">+            ref_prefix=ref_prefix,</span>
<span class="gi">+            ref_template=ref_template,</span>
<span class="gi">+            known_models=known_models,</span>
<span class="gi">+            field=field,</span>
<span class="gi">+        )</span>
<span class="gi">+        items_schemas = list(sub_schema[&#39;properties&#39;].values())</span>
<span class="gi">+        f_schema.update(</span>
<span class="gi">+            {</span>
<span class="gi">+                &#39;type&#39;: &#39;array&#39;,</span>
<span class="gi">+                &#39;items&#39;: items_schemas,</span>
<span class="gi">+                &#39;minItems&#39;: len(items_schemas),</span>
<span class="gi">+                &#39;maxItems&#39;: len(items_schemas),</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="gi">+    elif not hasattr(field_type, &#39;__pydantic_model__&#39;):</span>
<span class="gi">+        add_field_type_to_schema(field_type, f_schema)</span>
<span class="gi">+</span>
<span class="gi">+        modify_schema = getattr(field_type, &#39;__modify_schema__&#39;, None)</span>
<span class="gi">+        if modify_schema:</span>
<span class="gi">+            _apply_modify_schema(modify_schema, field, f_schema)</span>
<span class="gi">+</span>
<span class="gi">+    if f_schema:</span>
<span class="gi">+        return f_schema, definitions, nested_models</span>
<span class="gi">+</span>
<span class="gi">+    # Handle dataclass-based models</span>
<span class="gi">+    if lenient_issubclass(getattr(field_type, &#39;__pydantic_model__&#39;, None), BaseModel):</span>
<span class="gi">+        field_type = field_type.__pydantic_model__</span>
<span class="gi">+</span>
<span class="gi">+    if issubclass(field_type, BaseModel):</span>
<span class="gi">+        model_name = model_name_map[field_type]</span>
<span class="gi">+        if field_type not in known_models:</span>
<span class="gi">+            sub_schema, sub_definitions, sub_nested_models = model_process_schema(</span>
<span class="gi">+                field_type,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                model_name_map=model_name_map,</span>
<span class="gi">+                ref_prefix=ref_prefix,</span>
<span class="gi">+                ref_template=ref_template,</span>
<span class="gi">+                known_models=known_models,</span>
<span class="gi">+                field=field,</span>
<span class="gi">+            )</span>
<span class="gi">+            definitions.update(sub_definitions)</span>
<span class="gi">+            definitions[model_name] = sub_schema</span>
<span class="gi">+            nested_models.update(sub_nested_models)</span>
<span class="gi">+        else:</span>
<span class="gi">+            nested_models.add(model_name)</span>
<span class="gi">+        schema_ref = get_schema_ref(model_name, ref_prefix, ref_template, schema_overrides)</span>
<span class="gi">+        return schema_ref, definitions, nested_models</span>
<span class="gi">+</span>
<span class="gi">+    # For generics with no args</span>
<span class="gi">+    args = get_args(field_type)</span>
<span class="gi">+    if args is not None and not args and Generic in field_type.__bases__:</span>
<span class="gi">+        return f_schema, definitions, nested_models</span>
<span class="gi">+</span>
<span class="gi">+    raise ValueError(f&#39;Value not declarable with JSON Schema, field: {field}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def multitypes_literal_field_for_schema(values: Tuple[Any, ...], field: ModelField) -&gt; ModelField:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    To support `Literal` with values of different types, we split it into multiple `Literal` with same type
<span class="w"> </span>    e.g. `Literal[&#39;qwe&#39;, &#39;asd&#39;, 1, 2]` becomes `Union[Literal[&#39;qwe&#39;, &#39;asd&#39;], Literal[1, 2]]`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    literal_distinct_types = defaultdict(list)</span>
<span class="gi">+    for v in values:</span>
<span class="gi">+        literal_distinct_types[v.__class__].append(v)</span>
<span class="gi">+    distinct_literals = (Literal[tuple(same_type_values)] for same_type_values in literal_distinct_types.values())</span>
<span class="gi">+</span>
<span class="gi">+    return ModelField(</span>
<span class="gi">+        name=field.name,</span>
<span class="gi">+        type_=Union[tuple(distinct_literals)],  # type: ignore</span>
<span class="gi">+        class_validators=field.class_validators,</span>
<span class="gi">+        model_config=field.model_config,</span>
<span class="gi">+        default=field.default,</span>
<span class="gi">+        required=field.required,</span>
<span class="gi">+        alias=field.alias,</span>
<span class="gi">+        field_info=field.field_info,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def encode_default(dft: Any) -&gt; Any:</span>
<span class="gi">+    from pydantic.v1.main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(dft, BaseModel) or is_dataclass(dft):</span>
<span class="gi">+        dft = cast(&#39;dict[str, Any]&#39;, pydantic_encoder(dft))</span>

<span class="gi">+    if isinstance(dft, dict):</span>
<span class="gi">+        return {encode_default(k): encode_default(v) for k, v in dft.items()}</span>
<span class="gi">+    elif isinstance(dft, Enum):</span>
<span class="gi">+        return dft.value</span>
<span class="gi">+    elif isinstance(dft, (int, float, str)):</span>
<span class="gi">+        return dft</span>
<span class="gi">+    elif isinstance(dft, (list, tuple)):</span>
<span class="gi">+        t = dft.__class__</span>
<span class="gi">+        seq_args = (encode_default(v) for v in dft)</span>
<span class="gi">+        return t(*seq_args) if is_namedtuple(t) else t(seq_args)</span>
<span class="gi">+    elif dft is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        return pydantic_encoder(dft)</span>

<span class="gd">-_map_types_constraint: Dict[Any, Callable[..., type]] = {int: conint, float:</span>
<span class="gd">-    confloat, Decimal: condecimal}</span>

<span class="gi">+_map_types_constraint: Dict[Any, Callable[..., type]] = {int: conint, float: confloat, Decimal: condecimal}</span>

<span class="gd">-def get_annotation_from_field_info(annotation: Any, field_info: FieldInfo,</span>
<span class="gd">-    field_name: str, validate_assignment: bool=False) -&gt;Type[Any]:</span>
<span class="gi">+</span>
<span class="gi">+def get_annotation_from_field_info(</span>
<span class="gi">+    annotation: Any, field_info: FieldInfo, field_name: str, validate_assignment: bool = False</span>
<span class="gi">+) -&gt; Type[Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get an annotation with validation implemented for numbers and strings based on the field_info.
<span class="w"> </span>    :param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``
<span class="gu">@@ -318,11 +1009,25 @@ def get_annotation_from_field_info(annotation: Any, field_info: FieldInfo,</span>
<span class="w"> </span>    :param validate_assignment: default False, flag for BaseModel Config value of validate_assignment
<span class="w"> </span>    :return: the same ``annotation`` if unmodified or a new annotation with validation in place
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    constraints = field_info.get_constraints()</span>
<span class="gi">+    used_constraints: Set[str] = set()</span>
<span class="gi">+    if constraints:</span>
<span class="gi">+        annotation, used_constraints = get_annotation_with_constraints(annotation, field_info)</span>
<span class="gi">+    if validate_assignment:</span>
<span class="gi">+        used_constraints.add(&#39;allow_mutation&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    unused_constraints = constraints - used_constraints</span>
<span class="gi">+    if unused_constraints:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            f&#39;On field &quot;{field_name}&quot; the following field constraints are set but not enforced: &#39;</span>
<span class="gi">+            f&#39;{&quot;, &quot;.join(unused_constraints)}. &#39;</span>
<span class="gi">+            f&#39;\nFor more details see https://docs.pydantic.dev/usage/schema/#unenforced-field-constraints&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return annotation</span>


<span class="gd">-def get_annotation_with_constraints(annotation: Any, field_info: FieldInfo</span>
<span class="gd">-    ) -&gt;Tuple[Type[Any], Set[str]]:</span>
<span class="gi">+def get_annotation_with_constraints(annotation: Any, field_info: FieldInfo) -&gt; Tuple[Type[Any], Set[str]]:  # noqa: C901</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get an annotation with used constraints implemented for numbers and strings based on the field_info.

<span class="gu">@@ -330,14 +1035,123 @@ def get_annotation_with_constraints(annotation: Any, field_info: FieldInfo</span>
<span class="w"> </span>    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema
<span class="w"> </span>    :return: the same ``annotation`` if unmodified or a new annotation along with the used constraints.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def normalize_name(name: str) -&gt;str:</span>
<span class="gi">+    used_constraints: Set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+    def go(type_: Any) -&gt; Type[Any]:</span>
<span class="gi">+        if (</span>
<span class="gi">+            is_literal_type(type_)</span>
<span class="gi">+            or isinstance(type_, ForwardRef)</span>
<span class="gi">+            or lenient_issubclass(type_, (ConstrainedList, ConstrainedSet, ConstrainedFrozenSet))</span>
<span class="gi">+        ):</span>
<span class="gi">+            return type_</span>
<span class="gi">+        origin = get_origin(type_)</span>
<span class="gi">+        if origin is not None:</span>
<span class="gi">+            args: Tuple[Any, ...] = get_args(type_)</span>
<span class="gi">+            if any(isinstance(a, ForwardRef) for a in args):</span>
<span class="gi">+                # forward refs cause infinite recursion below</span>
<span class="gi">+                return type_</span>
<span class="gi">+</span>
<span class="gi">+            if origin is Annotated:</span>
<span class="gi">+                return go(args[0])</span>
<span class="gi">+            if is_union(origin):</span>
<span class="gi">+                return Union[tuple(go(a) for a in args)]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            if issubclass(origin, List) and (</span>
<span class="gi">+                field_info.min_items is not None</span>
<span class="gi">+                or field_info.max_items is not None</span>
<span class="gi">+                or field_info.unique_items is not None</span>
<span class="gi">+            ):</span>
<span class="gi">+                used_constraints.update({&#39;min_items&#39;, &#39;max_items&#39;, &#39;unique_items&#39;})</span>
<span class="gi">+                return conlist(</span>
<span class="gi">+                    go(args[0]),</span>
<span class="gi">+                    min_items=field_info.min_items,</span>
<span class="gi">+                    max_items=field_info.max_items,</span>
<span class="gi">+                    unique_items=field_info.unique_items,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if issubclass(origin, Set) and (field_info.min_items is not None or field_info.max_items is not None):</span>
<span class="gi">+                used_constraints.update({&#39;min_items&#39;, &#39;max_items&#39;})</span>
<span class="gi">+                return conset(go(args[0]), min_items=field_info.min_items, max_items=field_info.max_items)</span>
<span class="gi">+</span>
<span class="gi">+            if issubclass(origin, FrozenSet) and (field_info.min_items is not None or field_info.max_items is not None):</span>
<span class="gi">+                used_constraints.update({&#39;min_items&#39;, &#39;max_items&#39;})</span>
<span class="gi">+                return confrozenset(go(args[0]), min_items=field_info.min_items, max_items=field_info.max_items)</span>
<span class="gi">+</span>
<span class="gi">+            for t in (Tuple, List, Set, FrozenSet, Sequence):</span>
<span class="gi">+                if issubclass(origin, t):  # type: ignore</span>
<span class="gi">+                    return t[tuple(go(a) for a in args)]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            if issubclass(origin, Dict):</span>
<span class="gi">+                return Dict[args[0], go(args[1])]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        attrs: Optional[Tuple[str, ...]] = None</span>
<span class="gi">+        constraint_func: Optional[Callable[..., type]] = None</span>
<span class="gi">+        if isinstance(type_, type):</span>
<span class="gi">+            if issubclass(type_, (SecretStr, SecretBytes)):</span>
<span class="gi">+                attrs = (&#39;max_length&#39;, &#39;min_length&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                def constraint_func(**kw: Any) -&gt; Type[Any]:  # noqa: F811</span>
<span class="gi">+                    return type(type_.__name__, (type_,), kw)</span>
<span class="gi">+</span>
<span class="gi">+            elif issubclass(type_, str) and not issubclass(type_, (EmailStr, AnyUrl)):</span>
<span class="gi">+                attrs = (&#39;max_length&#39;, &#39;min_length&#39;, &#39;regex&#39;)</span>
<span class="gi">+                if issubclass(type_, StrictStr):</span>
<span class="gi">+</span>
<span class="gi">+                    def constraint_func(**kw: Any) -&gt; Type[Any]:</span>
<span class="gi">+                        return type(type_.__name__, (type_,), kw)</span>
<span class="gi">+</span>
<span class="gi">+                else:</span>
<span class="gi">+                    constraint_func = constr</span>
<span class="gi">+            elif issubclass(type_, bytes):</span>
<span class="gi">+                attrs = (&#39;max_length&#39;, &#39;min_length&#39;, &#39;regex&#39;)</span>
<span class="gi">+                if issubclass(type_, StrictBytes):</span>
<span class="gi">+</span>
<span class="gi">+                    def constraint_func(**kw: Any) -&gt; Type[Any]:</span>
<span class="gi">+                        return type(type_.__name__, (type_,), kw)</span>
<span class="gi">+</span>
<span class="gi">+                else:</span>
<span class="gi">+                    constraint_func = conbytes</span>
<span class="gi">+            elif issubclass(type_, numeric_types) and not issubclass(</span>
<span class="gi">+                type_,</span>
<span class="gi">+                (</span>
<span class="gi">+                    ConstrainedInt,</span>
<span class="gi">+                    ConstrainedFloat,</span>
<span class="gi">+                    ConstrainedDecimal,</span>
<span class="gi">+                    ConstrainedList,</span>
<span class="gi">+                    ConstrainedSet,</span>
<span class="gi">+                    ConstrainedFrozenSet,</span>
<span class="gi">+                    bool,</span>
<span class="gi">+                ),</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Is numeric type</span>
<span class="gi">+                attrs = (&#39;gt&#39;, &#39;lt&#39;, &#39;ge&#39;, &#39;le&#39;, &#39;multiple_of&#39;)</span>
<span class="gi">+                if issubclass(type_, float):</span>
<span class="gi">+                    attrs += (&#39;allow_inf_nan&#39;,)</span>
<span class="gi">+                if issubclass(type_, Decimal):</span>
<span class="gi">+                    attrs += (&#39;max_digits&#39;, &#39;decimal_places&#39;)</span>
<span class="gi">+                numeric_type = next(t for t in numeric_types if issubclass(type_, t))  # pragma: no branch</span>
<span class="gi">+                constraint_func = _map_types_constraint[numeric_type]</span>
<span class="gi">+</span>
<span class="gi">+        if attrs:</span>
<span class="gi">+            used_constraints.update(set(attrs))</span>
<span class="gi">+            kwargs = {</span>
<span class="gi">+                attr_name: attr</span>
<span class="gi">+                for attr_name, attr in ((attr_name, getattr(field_info, attr_name)) for attr_name in attrs)</span>
<span class="gi">+                if attr is not None</span>
<span class="gi">+            }</span>
<span class="gi">+            if kwargs:</span>
<span class="gi">+                constraint_func = cast(Callable[..., type], constraint_func)</span>
<span class="gi">+                return constraint_func(**kwargs)</span>
<span class="gi">+        return type_</span>
<span class="gi">+</span>
<span class="gi">+    return go(annotation), used_constraints</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def normalize_name(name: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Normalizes the given name. This can be applied to either a model *or* enum.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return re.sub(r&#39;[^a-zA-Z0-9.\-_]&#39;, &#39;_&#39;, name)</span>


<span class="w"> </span>class SkipField(Exception):
<span class="gu">@@ -345,5 +1159,5 @@ class SkipField(Exception):</span>
<span class="w"> </span>    Utility exception used to exclude fields from schema.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str) -&gt; None:</span>
<span class="w"> </span>        self.message = message
<span class="gh">diff --git a/pydantic/v1/tools.py b/pydantic/v1/tools.py</span>
<span class="gh">index d15515365..6838a23ec 100644</span>
<span class="gd">--- a/pydantic/v1/tools.py</span>
<span class="gi">+++ b/pydantic/v1/tools.py</span>
<span class="gu">@@ -2,24 +2,91 @@ import json</span>
<span class="w"> </span>from functools import lru_cache
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Optional, Type, TypeVar, Union
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.parse import Protocol, load_file, load_str_bytes
<span class="w"> </span>from pydantic.v1.types import StrBytes
<span class="w"> </span>from pydantic.v1.typing import display_as_type
<span class="gd">-__all__ = (&#39;parse_file_as&#39;, &#39;parse_obj_as&#39;, &#39;parse_raw_as&#39;, &#39;schema_of&#39;,</span>
<span class="gd">-    &#39;schema_json_of&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;parse_file_as&#39;, &#39;parse_obj_as&#39;, &#39;parse_raw_as&#39;, &#39;schema_of&#39;, &#39;schema_json_of&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>NameFactory = Union[str, Callable[[Type[Any]], str]]
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.typing import DictStrAny
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _generate_parsing_type_name(type_: Any) -&gt; str:</span>
<span class="gi">+    return f&#39;ParsingModel[{display_as_type(type_)}]&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@lru_cache(maxsize=2048)</span>
<span class="gi">+def _get_parsing_type(type_: Any, *, type_name: Optional[NameFactory] = None) -&gt; Any:</span>
<span class="gi">+    from pydantic.v1.main import create_model</span>
<span class="gi">+</span>
<span class="gi">+    if type_name is None:</span>
<span class="gi">+        type_name = _generate_parsing_type_name</span>
<span class="gi">+    if not isinstance(type_name, str):</span>
<span class="gi">+        type_name = type_name(type_)</span>
<span class="gi">+    return create_model(type_name, __root__=(type_, ...))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)


<span class="gd">-def schema_of(type_: Any, *, title: Optional[NameFactory]=None, **</span>
<span class="gd">-    schema_kwargs: Any) -&gt;&#39;DictStrAny&#39;:</span>
<span class="gi">+def parse_obj_as(type_: Type[T], obj: Any, *, type_name: Optional[NameFactory] = None) -&gt; T:</span>
<span class="gi">+    model_type = _get_parsing_type(type_, type_name=type_name)  # type: ignore[arg-type]</span>
<span class="gi">+    return model_type(__root__=obj).__root__</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_file_as(</span>
<span class="gi">+    type_: Type[T],</span>
<span class="gi">+    path: Union[str, Path],</span>
<span class="gi">+    *,</span>
<span class="gi">+    content_type: str = None,</span>
<span class="gi">+    encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+    proto: Protocol = None,</span>
<span class="gi">+    allow_pickle: bool = False,</span>
<span class="gi">+    json_loads: Callable[[str], Any] = json.loads,</span>
<span class="gi">+    type_name: Optional[NameFactory] = None,</span>
<span class="gi">+) -&gt; T:</span>
<span class="gi">+    obj = load_file(</span>
<span class="gi">+        path,</span>
<span class="gi">+        proto=proto,</span>
<span class="gi">+        content_type=content_type,</span>
<span class="gi">+        encoding=encoding,</span>
<span class="gi">+        allow_pickle=allow_pickle,</span>
<span class="gi">+        json_loads=json_loads,</span>
<span class="gi">+    )</span>
<span class="gi">+    return parse_obj_as(type_, obj, type_name=type_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_raw_as(</span>
<span class="gi">+    type_: Type[T],</span>
<span class="gi">+    b: StrBytes,</span>
<span class="gi">+    *,</span>
<span class="gi">+    content_type: str = None,</span>
<span class="gi">+    encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+    proto: Protocol = None,</span>
<span class="gi">+    allow_pickle: bool = False,</span>
<span class="gi">+    json_loads: Callable[[str], Any] = json.loads,</span>
<span class="gi">+    type_name: Optional[NameFactory] = None,</span>
<span class="gi">+) -&gt; T:</span>
<span class="gi">+    obj = load_str_bytes(</span>
<span class="gi">+        b,</span>
<span class="gi">+        proto=proto,</span>
<span class="gi">+        content_type=content_type,</span>
<span class="gi">+        encoding=encoding,</span>
<span class="gi">+        allow_pickle=allow_pickle,</span>
<span class="gi">+        json_loads=json_loads,</span>
<span class="gi">+    )</span>
<span class="gi">+    return parse_obj_as(type_, obj, type_name=type_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def schema_of(type_: Any, *, title: Optional[NameFactory] = None, **schema_kwargs: Any) -&gt; &#39;DictStrAny&#39;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a JSON schema (as dict) for the passed model or dynamically generated one&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _get_parsing_type(type_, type_name=title).schema(**schema_kwargs)</span>


<span class="gd">-def schema_json_of(type_: Any, *, title: Optional[NameFactory]=None, **</span>
<span class="gd">-    schema_json_kwargs: Any) -&gt;str:</span>
<span class="gi">+def schema_json_of(type_: Any, *, title: Optional[NameFactory] = None, **schema_json_kwargs: Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a JSON schema (as JSON) for the passed model or dynamically generated one&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _get_parsing_type(type_, type_name=title).schema_json(**schema_json_kwargs)</span>
<span class="gh">diff --git a/pydantic/v1/types.py b/pydantic/v1/types.py</span>
<span class="gh">index 5c45c9e09..0cd789a44 100644</span>
<span class="gd">--- a/pydantic/v1/types.py</span>
<span class="gi">+++ b/pydantic/v1/types.py</span>
<span class="gu">@@ -7,25 +7,109 @@ from decimal import Decimal, InvalidOperation</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from types import new_class
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, ClassVar, Dict, FrozenSet, List, Optional, Pattern, Set, Tuple, Type, TypeVar, Union, cast, overload</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    ClassVar,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    FrozenSet,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    overload,</span>
<span class="gi">+)</span>
<span class="w"> </span>from uuid import UUID
<span class="w"> </span>from weakref import WeakSet
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1 import errors
<span class="w"> </span>from pydantic.v1.datetime_parse import parse_date
<span class="w"> </span>from pydantic.v1.utils import import_string, update_not_none
<span class="gd">-from pydantic.v1.validators import bytes_validator, constr_length_validator, constr_lower, constr_strip_whitespace, constr_upper, decimal_validator, float_finite_validator, float_validator, frozenset_validator, int_validator, list_validator, number_multiple_validator, number_size_validator, path_exists_validator, path_validator, set_validator, str_validator, strict_bytes_validator, strict_float_validator, strict_int_validator, strict_str_validator</span>
<span class="gd">-__all__ = [&#39;NoneStr&#39;, &#39;NoneBytes&#39;, &#39;StrBytes&#39;, &#39;NoneStrBytes&#39;, &#39;StrictStr&#39;,</span>
<span class="gd">-    &#39;ConstrainedBytes&#39;, &#39;conbytes&#39;, &#39;ConstrainedList&#39;, &#39;conlist&#39;,</span>
<span class="gd">-    &#39;ConstrainedSet&#39;, &#39;conset&#39;, &#39;ConstrainedFrozenSet&#39;, &#39;confrozenset&#39;,</span>
<span class="gd">-    &#39;ConstrainedStr&#39;, &#39;constr&#39;, &#39;PyObject&#39;, &#39;ConstrainedInt&#39;, &#39;conint&#39;,</span>
<span class="gd">-    &#39;PositiveInt&#39;, &#39;NegativeInt&#39;, &#39;NonNegativeInt&#39;, &#39;NonPositiveInt&#39;,</span>
<span class="gd">-    &#39;ConstrainedFloat&#39;, &#39;confloat&#39;, &#39;PositiveFloat&#39;, &#39;NegativeFloat&#39;,</span>
<span class="gd">-    &#39;NonNegativeFloat&#39;, &#39;NonPositiveFloat&#39;, &#39;FiniteFloat&#39;,</span>
<span class="gd">-    &#39;ConstrainedDecimal&#39;, &#39;condecimal&#39;, &#39;UUID1&#39;, &#39;UUID3&#39;, &#39;UUID4&#39;, &#39;UUID5&#39;,</span>
<span class="gd">-    &#39;FilePath&#39;, &#39;DirectoryPath&#39;, &#39;Json&#39;, &#39;JsonWrapper&#39;, &#39;SecretField&#39;,</span>
<span class="gd">-    &#39;SecretStr&#39;, &#39;SecretBytes&#39;, &#39;StrictBool&#39;, &#39;StrictBytes&#39;, &#39;StrictInt&#39;,</span>
<span class="gd">-    &#39;StrictFloat&#39;, &#39;PaymentCardNumber&#39;, &#39;ByteSize&#39;, &#39;PastDate&#39;,</span>
<span class="gd">-    &#39;FutureDate&#39;, &#39;ConstrainedDate&#39;, &#39;condate&#39;]</span>
<span class="gi">+from pydantic.v1.validators import (</span>
<span class="gi">+    bytes_validator,</span>
<span class="gi">+    constr_length_validator,</span>
<span class="gi">+    constr_lower,</span>
<span class="gi">+    constr_strip_whitespace,</span>
<span class="gi">+    constr_upper,</span>
<span class="gi">+    decimal_validator,</span>
<span class="gi">+    float_finite_validator,</span>
<span class="gi">+    float_validator,</span>
<span class="gi">+    frozenset_validator,</span>
<span class="gi">+    int_validator,</span>
<span class="gi">+    list_validator,</span>
<span class="gi">+    number_multiple_validator,</span>
<span class="gi">+    number_size_validator,</span>
<span class="gi">+    path_exists_validator,</span>
<span class="gi">+    path_validator,</span>
<span class="gi">+    set_validator,</span>
<span class="gi">+    str_validator,</span>
<span class="gi">+    strict_bytes_validator,</span>
<span class="gi">+    strict_float_validator,</span>
<span class="gi">+    strict_int_validator,</span>
<span class="gi">+    strict_str_validator,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &#39;NoneStr&#39;,</span>
<span class="gi">+    &#39;NoneBytes&#39;,</span>
<span class="gi">+    &#39;StrBytes&#39;,</span>
<span class="gi">+    &#39;NoneStrBytes&#39;,</span>
<span class="gi">+    &#39;StrictStr&#39;,</span>
<span class="gi">+    &#39;ConstrainedBytes&#39;,</span>
<span class="gi">+    &#39;conbytes&#39;,</span>
<span class="gi">+    &#39;ConstrainedList&#39;,</span>
<span class="gi">+    &#39;conlist&#39;,</span>
<span class="gi">+    &#39;ConstrainedSet&#39;,</span>
<span class="gi">+    &#39;conset&#39;,</span>
<span class="gi">+    &#39;ConstrainedFrozenSet&#39;,</span>
<span class="gi">+    &#39;confrozenset&#39;,</span>
<span class="gi">+    &#39;ConstrainedStr&#39;,</span>
<span class="gi">+    &#39;constr&#39;,</span>
<span class="gi">+    &#39;PyObject&#39;,</span>
<span class="gi">+    &#39;ConstrainedInt&#39;,</span>
<span class="gi">+    &#39;conint&#39;,</span>
<span class="gi">+    &#39;PositiveInt&#39;,</span>
<span class="gi">+    &#39;NegativeInt&#39;,</span>
<span class="gi">+    &#39;NonNegativeInt&#39;,</span>
<span class="gi">+    &#39;NonPositiveInt&#39;,</span>
<span class="gi">+    &#39;ConstrainedFloat&#39;,</span>
<span class="gi">+    &#39;confloat&#39;,</span>
<span class="gi">+    &#39;PositiveFloat&#39;,</span>
<span class="gi">+    &#39;NegativeFloat&#39;,</span>
<span class="gi">+    &#39;NonNegativeFloat&#39;,</span>
<span class="gi">+    &#39;NonPositiveFloat&#39;,</span>
<span class="gi">+    &#39;FiniteFloat&#39;,</span>
<span class="gi">+    &#39;ConstrainedDecimal&#39;,</span>
<span class="gi">+    &#39;condecimal&#39;,</span>
<span class="gi">+    &#39;UUID1&#39;,</span>
<span class="gi">+    &#39;UUID3&#39;,</span>
<span class="gi">+    &#39;UUID4&#39;,</span>
<span class="gi">+    &#39;UUID5&#39;,</span>
<span class="gi">+    &#39;FilePath&#39;,</span>
<span class="gi">+    &#39;DirectoryPath&#39;,</span>
<span class="gi">+    &#39;Json&#39;,</span>
<span class="gi">+    &#39;JsonWrapper&#39;,</span>
<span class="gi">+    &#39;SecretField&#39;,</span>
<span class="gi">+    &#39;SecretStr&#39;,</span>
<span class="gi">+    &#39;SecretBytes&#39;,</span>
<span class="gi">+    &#39;StrictBool&#39;,</span>
<span class="gi">+    &#39;StrictBytes&#39;,</span>
<span class="gi">+    &#39;StrictInt&#39;,</span>
<span class="gi">+    &#39;StrictFloat&#39;,</span>
<span class="gi">+    &#39;PaymentCardNumber&#39;,</span>
<span class="gi">+    &#39;ByteSize&#39;,</span>
<span class="gi">+    &#39;PastDate&#39;,</span>
<span class="gi">+    &#39;FutureDate&#39;,</span>
<span class="gi">+    &#39;ConstrainedDate&#39;,</span>
<span class="gi">+    &#39;condate&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>NoneStr = Optional[str]
<span class="w"> </span>NoneBytes = Optional[bytes]
<span class="w"> </span>StrBytes = Union[str, bytes]
<span class="gu">@@ -35,54 +119,84 @@ OptionalIntFloat = Union[OptionalInt, float]</span>
<span class="w"> </span>OptionalIntFloatDecimal = Union[OptionalIntFloat, Decimal]
<span class="w"> </span>OptionalDate = Optional[date]
<span class="w"> </span>StrIntFloat = Union[str, int, float]
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Annotated
<span class="gi">+</span>
<span class="w"> </span>    from pydantic.v1.dataclasses import Dataclass
<span class="w"> </span>    from pydantic.v1.main import BaseModel
<span class="w"> </span>    from pydantic.v1.typing import CallableGenerator
<span class="gi">+</span>
<span class="w"> </span>    ModelOrDc = Type[Union[BaseModel, Dataclass]]
<span class="gi">+</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)
<span class="w"> </span>_DEFINED_TYPES: &#39;WeakSet[type]&#39; = WeakSet()


<span class="gd">-class ConstrainedNumberMeta(type):</span>
<span class="gi">+@overload</span>
<span class="gi">+def _registered(typ: Type[T]) -&gt; Type[T]:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def _registered(typ: &#39;ConstrainedNumberMeta&#39;) -&gt; &#39;ConstrainedNumberMeta&#39;:</span>
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _registered(typ: Union[Type[T], &#39;ConstrainedNumberMeta&#39;]) -&gt; Union[Type[T], &#39;ConstrainedNumberMeta&#39;]:</span>
<span class="gi">+    # In order to generate valid examples of constrained types, Hypothesis needs</span>
<span class="gi">+    # to inspect the type object - so we keep a weakref to each contype object</span>
<span class="gi">+    # until it can be registered.  When (or if) our Hypothesis plugin is loaded,</span>
<span class="gi">+    # it monkeypatches this function.</span>
<span class="gi">+    # If Hypothesis is never used, the total effect is to keep a weak reference</span>
<span class="gi">+    # which has minimal memory usage and doesn&#39;t even affect garbage collection.</span>
<span class="gi">+    _DEFINED_TYPES.add(typ)</span>
<span class="gi">+    return typ</span>

<span class="gd">-    def __new__(cls, name: str, bases: Any, dct: Dict[str, Any]</span>
<span class="gd">-        ) -&gt;&#39;ConstrainedInt&#39;:</span>
<span class="gi">+</span>
<span class="gi">+class ConstrainedNumberMeta(type):</span>
<span class="gi">+    def __new__(cls, name: str, bases: Any, dct: Dict[str, Any]) -&gt; &#39;ConstrainedInt&#39;:  # type: ignore</span>
<span class="w"> </span>        new_cls = cast(&#39;ConstrainedInt&#39;, type.__new__(cls, name, bases, dct))
<span class="gi">+</span>
<span class="w"> </span>        if new_cls.gt is not None and new_cls.ge is not None:
<span class="gd">-            raise errors.ConfigError(</span>
<span class="gd">-                &#39;bounds gt and ge cannot be specified at the same time&#39;)</span>
<span class="gi">+            raise errors.ConfigError(&#39;bounds gt and ge cannot be specified at the same time&#39;)</span>
<span class="w"> </span>        if new_cls.lt is not None and new_cls.le is not None:
<span class="gd">-            raise errors.ConfigError(</span>
<span class="gd">-                &#39;bounds lt and le cannot be specified at the same time&#39;)</span>
<span class="gd">-        return _registered(new_cls)</span>
<span class="gi">+            raise errors.ConfigError(&#39;bounds lt and le cannot be specified at the same time&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return _registered(new_cls)  # type: ignore</span>
<span class="gi">+</span>

<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BOOLEAN TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    StrictBool = bool
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class StrictBool(int):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        StrictBool to allow for bools which are not type-coerced.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="w"> </span>        @classmethod
<span class="gd">-        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>            field_schema.update(type=&#39;boolean&#39;)

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+        def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>            yield cls.validate

<span class="w"> </span>        @classmethod
<span class="gd">-        def validate(cls, value: Any) -&gt;bool:</span>
<span class="gi">+        def validate(cls, value: Any) -&gt; bool:</span>
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            Ensure that we only allow bools.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if isinstance(value, bool):</span>
<span class="gi">+                return value</span>
<span class="gi">+</span>
<span class="gi">+            raise errors.StrictBoolError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INTEGER TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>


<span class="w"> </span>class ConstrainedInt(int, metaclass=ConstrainedNumberMeta):
<span class="gu">@@ -94,18 +208,37 @@ class ConstrainedInt(int, metaclass=ConstrainedNumberMeta):</span>
<span class="w"> </span>    multiple_of: OptionalInt = None

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, exclusiveMinimum=cls.gt,</span>
<span class="gd">-            exclusiveMaximum=cls.lt, minimum=cls.ge, maximum=cls.le,</span>
<span class="gd">-            multipleOf=cls.multiple_of)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(</span>
<span class="gi">+            field_schema,</span>
<span class="gi">+            exclusiveMinimum=cls.gt,</span>
<span class="gi">+            exclusiveMaximum=cls.lt,</span>
<span class="gi">+            minimum=cls.ge,</span>
<span class="gi">+            maximum=cls.le,</span>
<span class="gi">+            multipleOf=cls.multiple_of,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield strict_int_validator if cls.strict else int_validator
<span class="w"> </span>        yield number_size_validator
<span class="w"> </span>        yield number_multiple_validator


<span class="gi">+def conint(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strict: bool = False,</span>
<span class="gi">+    gt: Optional[int] = None,</span>
<span class="gi">+    ge: Optional[int] = None,</span>
<span class="gi">+    lt: Optional[int] = None,</span>
<span class="gi">+    le: Optional[int] = None,</span>
<span class="gi">+    multiple_of: Optional[int] = None,</span>
<span class="gi">+) -&gt; Type[int]:</span>
<span class="gi">+    # use kwargs then define conf in a dict to aid with IDE type hinting</span>
<span class="gi">+    namespace = dict(strict=strict, gt=gt, ge=ge, lt=lt, le=le, multiple_of=multiple_of)</span>
<span class="gi">+    return type(&#39;ConstrainedIntValue&#39;, (ConstrainedInt,), namespace)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    PositiveInt = int
<span class="w"> </span>    NegativeInt = int
<span class="gu">@@ -114,27 +247,25 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    StrictInt = int
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class PositiveInt(ConstrainedInt):
<span class="w"> </span>        gt = 0

<span class="gd">-</span>
<span class="w"> </span>    class NegativeInt(ConstrainedInt):
<span class="w"> </span>        lt = 0

<span class="gd">-</span>
<span class="w"> </span>    class NonPositiveInt(ConstrainedInt):
<span class="w"> </span>        le = 0

<span class="gd">-</span>
<span class="w"> </span>    class NonNegativeInt(ConstrainedInt):
<span class="w"> </span>        ge = 0

<span class="gd">-</span>
<span class="w"> </span>    class StrictInt(ConstrainedInt):
<span class="w"> </span>        strict = True


<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FLOAT TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class ConstrainedFloat(float, metaclass=ConstrainedNumberMeta):
<span class="w"> </span>    strict: bool = False
<span class="w"> </span>    gt: OptionalIntFloat = None
<span class="gu">@@ -145,10 +276,16 @@ class ConstrainedFloat(float, metaclass=ConstrainedNumberMeta):</span>
<span class="w"> </span>    allow_inf_nan: Optional[bool] = None

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, exclusiveMinimum=cls.gt,</span>
<span class="gd">-            exclusiveMaximum=cls.lt, minimum=cls.ge, maximum=cls.le,</span>
<span class="gd">-            multipleOf=cls.multiple_of)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(</span>
<span class="gi">+            field_schema,</span>
<span class="gi">+            exclusiveMinimum=cls.gt,</span>
<span class="gi">+            exclusiveMaximum=cls.lt,</span>
<span class="gi">+            minimum=cls.ge,</span>
<span class="gi">+            maximum=cls.le,</span>
<span class="gi">+            multipleOf=cls.multiple_of,</span>
<span class="gi">+        )</span>
<span class="gi">+        # Modify constraints to account for differences between IEEE floats and JSON</span>
<span class="w"> </span>        if field_schema.get(&#39;exclusiveMinimum&#39;) == -math.inf:
<span class="w"> </span>            del field_schema[&#39;exclusiveMinimum&#39;]
<span class="w"> </span>        if field_schema.get(&#39;minimum&#39;) == -math.inf:
<span class="gu">@@ -159,13 +296,28 @@ class ConstrainedFloat(float, metaclass=ConstrainedNumberMeta):</span>
<span class="w"> </span>            del field_schema[&#39;maximum&#39;]

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield strict_float_validator if cls.strict else float_validator
<span class="w"> </span>        yield number_size_validator
<span class="w"> </span>        yield number_multiple_validator
<span class="w"> </span>        yield float_finite_validator


<span class="gi">+def confloat(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strict: bool = False,</span>
<span class="gi">+    gt: float = None,</span>
<span class="gi">+    ge: float = None,</span>
<span class="gi">+    lt: float = None,</span>
<span class="gi">+    le: float = None,</span>
<span class="gi">+    multiple_of: float = None,</span>
<span class="gi">+    allow_inf_nan: Optional[bool] = None,</span>
<span class="gi">+) -&gt; Type[float]:</span>
<span class="gi">+    # use kwargs then define conf in a dict to aid with IDE type hinting</span>
<span class="gi">+    namespace = dict(strict=strict, gt=gt, ge=ge, lt=lt, le=le, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan)</span>
<span class="gi">+    return type(&#39;ConstrainedFloatValue&#39;, (ConstrainedFloat,), namespace)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    PositiveFloat = float
<span class="w"> </span>    NegativeFloat = float
<span class="gu">@@ -175,31 +327,28 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    FiniteFloat = float
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class PositiveFloat(ConstrainedFloat):
<span class="w"> </span>        gt = 0

<span class="gd">-</span>
<span class="w"> </span>    class NegativeFloat(ConstrainedFloat):
<span class="w"> </span>        lt = 0

<span class="gd">-</span>
<span class="w"> </span>    class NonPositiveFloat(ConstrainedFloat):
<span class="w"> </span>        le = 0

<span class="gd">-</span>
<span class="w"> </span>    class NonNegativeFloat(ConstrainedFloat):
<span class="w"> </span>        ge = 0

<span class="gd">-</span>
<span class="w"> </span>    class StrictFloat(ConstrainedFloat):
<span class="w"> </span>        strict = True

<span class="gd">-</span>
<span class="w"> </span>    class FiniteFloat(ConstrainedFloat):
<span class="w"> </span>        allow_inf_nan = False


<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTES TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class ConstrainedBytes(bytes):
<span class="w"> </span>    strip_whitespace = False
<span class="w"> </span>    to_upper = False
<span class="gu">@@ -209,12 +358,11 @@ class ConstrainedBytes(bytes):</span>
<span class="w"> </span>    strict: bool = False

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, minLength=cls.min_length, maxLength=</span>
<span class="gd">-            cls.max_length)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(field_schema, minLength=cls.min_length, maxLength=cls.max_length)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield strict_bytes_validator if cls.strict else bytes_validator
<span class="w"> </span>        yield constr_strip_whitespace
<span class="w"> </span>        yield constr_upper
<span class="gu">@@ -222,15 +370,38 @@ class ConstrainedBytes(bytes):</span>
<span class="w"> </span>        yield constr_length_validator


<span class="gi">+def conbytes(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strip_whitespace: bool = False,</span>
<span class="gi">+    to_upper: bool = False,</span>
<span class="gi">+    to_lower: bool = False,</span>
<span class="gi">+    min_length: Optional[int] = None,</span>
<span class="gi">+    max_length: Optional[int] = None,</span>
<span class="gi">+    strict: bool = False,</span>
<span class="gi">+) -&gt; Type[bytes]:</span>
<span class="gi">+    # use kwargs then define conf in a dict to aid with IDE type hinting</span>
<span class="gi">+    namespace = dict(</span>
<span class="gi">+        strip_whitespace=strip_whitespace,</span>
<span class="gi">+        to_upper=to_upper,</span>
<span class="gi">+        to_lower=to_lower,</span>
<span class="gi">+        min_length=min_length,</span>
<span class="gi">+        max_length=max_length,</span>
<span class="gi">+        strict=strict,</span>
<span class="gi">+    )</span>
<span class="gi">+    return _registered(type(&#39;ConstrainedBytesValue&#39;, (ConstrainedBytes,), namespace))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    StrictBytes = bytes
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class StrictBytes(ConstrainedBytes):
<span class="w"> </span>        strict = True


<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ STRING TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class ConstrainedStr(str):
<span class="w"> </span>    strip_whitespace = False
<span class="w"> </span>    to_upper = False
<span class="gu">@@ -242,12 +413,16 @@ class ConstrainedStr(str):</span>
<span class="w"> </span>    strict = False

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, minLength=cls.min_length, maxLength=</span>
<span class="gd">-            cls.max_length, pattern=cls.regex and cls._get_pattern(cls.regex))</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(</span>
<span class="gi">+            field_schema,</span>
<span class="gi">+            minLength=cls.min_length,</span>
<span class="gi">+            maxLength=cls.max_length,</span>
<span class="gi">+            pattern=cls.regex and cls._get_pattern(cls.regex),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield strict_str_validator if cls.strict else str_validator
<span class="w"> </span>        yield constr_strip_whitespace
<span class="w"> </span>        yield constr_upper
<span class="gu">@@ -255,82 +430,239 @@ class ConstrainedStr(str):</span>
<span class="w"> </span>        yield constr_length_validator
<span class="w"> </span>        yield cls.validate

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: Union[str]) -&gt; Union[str]:</span>
<span class="gi">+        if cls.curtail_length and len(value) &gt; cls.curtail_length:</span>
<span class="gi">+            value = value[: cls.curtail_length]</span>
<span class="gi">+</span>
<span class="gi">+        if cls.regex:</span>
<span class="gi">+            if not re.match(cls.regex, value):</span>
<span class="gi">+                raise errors.StrRegexError(pattern=cls._get_pattern(cls.regex))</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_pattern(regex: Union[str, Pattern[str]]) -&gt; str:</span>
<span class="gi">+        return regex if isinstance(regex, str) else regex.pattern</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constr(</span>
<span class="gi">+    *,</span>
<span class="gi">+    strip_whitespace: bool = False,</span>
<span class="gi">+    to_upper: bool = False,</span>
<span class="gi">+    to_lower: bool = False,</span>
<span class="gi">+    strict: bool = False,</span>
<span class="gi">+    min_length: Optional[int] = None,</span>
<span class="gi">+    max_length: Optional[int] = None,</span>
<span class="gi">+    curtail_length: Optional[int] = None,</span>
<span class="gi">+    regex: Optional[str] = None,</span>
<span class="gi">+) -&gt; Type[str]:</span>
<span class="gi">+    # use kwargs then define conf in a dict to aid with IDE type hinting</span>
<span class="gi">+    namespace = dict(</span>
<span class="gi">+        strip_whitespace=strip_whitespace,</span>
<span class="gi">+        to_upper=to_upper,</span>
<span class="gi">+        to_lower=to_lower,</span>
<span class="gi">+        strict=strict,</span>
<span class="gi">+        min_length=min_length,</span>
<span class="gi">+        max_length=max_length,</span>
<span class="gi">+        curtail_length=curtail_length,</span>
<span class="gi">+        regex=regex and re.compile(regex),</span>
<span class="gi">+    )</span>
<span class="gi">+    return _registered(type(&#39;ConstrainedStrValue&#39;, (ConstrainedStr,), namespace))</span>
<span class="gi">+</span>

<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    StrictStr = str
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class StrictStr(ConstrainedStr):
<span class="w"> </span>        strict = True


<span class="gd">-class ConstrainedSet(set):</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SET TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This types superclass should be Set[T], but cython chokes on that...</span>
<span class="gi">+class ConstrainedSet(set):  # type: ignore</span>
<span class="gi">+    # Needed for pydantic to detect that this is a set</span>
<span class="w"> </span>    __origin__ = set
<span class="gd">-    __args__: Set[Type[T]]</span>
<span class="gi">+    __args__: Set[Type[T]]  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>    min_items: Optional[int] = None
<span class="w"> </span>    max_items: Optional[int] = None
<span class="gd">-    item_type: Type[T]</span>
<span class="gi">+    item_type: Type[T]  # type: ignore</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.set_length_validator

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.</span>
<span class="gd">-            max_items)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.max_items)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def set_length_validator(cls, v: &#39;Optional[Set[T]]&#39;) -&gt; &#39;Optional[Set[T]]&#39;:</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        v = set_validator(v)</span>
<span class="gi">+        v_len = len(v)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.min_items is not None and v_len &lt; cls.min_items:</span>
<span class="gi">+            raise errors.SetMinLengthError(limit_value=cls.min_items)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.max_items is not None and v_len &gt; cls.max_items:</span>
<span class="gi">+            raise errors.SetMaxLengthError(limit_value=cls.max_items)</span>
<span class="gi">+</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>

<span class="gi">+def conset(item_type: Type[T], *, min_items: Optional[int] = None, max_items: Optional[int] = None) -&gt; Type[Set[T]]:</span>
<span class="gi">+    # __args__ is needed to conform to typing generics api</span>
<span class="gi">+    namespace = {&#39;min_items&#39;: min_items, &#39;max_items&#39;: max_items, &#39;item_type&#39;: item_type, &#39;__args__&#39;: [item_type]}</span>
<span class="gi">+    # We use new_class to be able to deal with Generic types</span>
<span class="gi">+    return new_class(&#39;ConstrainedSetValue&#39;, (ConstrainedSet,), {}, lambda ns: ns.update(namespace))</span>

<span class="gd">-class ConstrainedFrozenSet(frozenset):</span>
<span class="gi">+</span>
<span class="gi">+# This types superclass should be FrozenSet[T], but cython chokes on that...</span>
<span class="gi">+class ConstrainedFrozenSet(frozenset):  # type: ignore</span>
<span class="gi">+    # Needed for pydantic to detect that this is a set</span>
<span class="w"> </span>    __origin__ = frozenset
<span class="gd">-    __args__: FrozenSet[Type[T]]</span>
<span class="gi">+    __args__: FrozenSet[Type[T]]  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>    min_items: Optional[int] = None
<span class="w"> </span>    max_items: Optional[int] = None
<span class="gd">-    item_type: Type[T]</span>
<span class="gi">+    item_type: Type[T]  # type: ignore</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.frozenset_length_validator

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.</span>
<span class="gd">-            max_items)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.max_items)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def frozenset_length_validator(cls, v: &#39;Optional[FrozenSet[T]]&#39;) -&gt; &#39;Optional[FrozenSet[T]]&#39;:</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        v = frozenset_validator(v)</span>
<span class="gi">+        v_len = len(v)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.min_items is not None and v_len &lt; cls.min_items:</span>
<span class="gi">+            raise errors.FrozenSetMinLengthError(limit_value=cls.min_items)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.max_items is not None and v_len &gt; cls.max_items:</span>
<span class="gi">+            raise errors.FrozenSetMaxLengthError(limit_value=cls.max_items)</span>
<span class="gi">+</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def confrozenset(</span>
<span class="gi">+    item_type: Type[T], *, min_items: Optional[int] = None, max_items: Optional[int] = None</span>
<span class="gi">+) -&gt; Type[FrozenSet[T]]:</span>
<span class="gi">+    # __args__ is needed to conform to typing generics api</span>
<span class="gi">+    namespace = {&#39;min_items&#39;: min_items, &#39;max_items&#39;: max_items, &#39;item_type&#39;: item_type, &#39;__args__&#39;: [item_type]}</span>
<span class="gi">+    # We use new_class to be able to deal with Generic types</span>
<span class="gi">+    return new_class(&#39;ConstrainedFrozenSetValue&#39;, (ConstrainedFrozenSet,), {}, lambda ns: ns.update(namespace))</span>


<span class="gd">-class ConstrainedList(list):</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LIST TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This types superclass should be List[T], but cython chokes on that...</span>
<span class="gi">+class ConstrainedList(list):  # type: ignore</span>
<span class="gi">+    # Needed for pydantic to detect that this is a list</span>
<span class="w"> </span>    __origin__ = list
<span class="gd">-    __args__: Tuple[Type[T], ...]</span>
<span class="gi">+    __args__: Tuple[Type[T], ...]  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>    min_items: Optional[int] = None
<span class="w"> </span>    max_items: Optional[int] = None
<span class="w"> </span>    unique_items: Optional[bool] = None
<span class="gd">-    item_type: Type[T]</span>
<span class="gi">+    item_type: Type[T]  # type: ignore</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.list_length_validator
<span class="w"> </span>        if cls.unique_items:
<span class="w"> </span>            yield cls.unique_items_validator

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.</span>
<span class="gd">-            max_items, uniqueItems=cls.unique_items)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.max_items, uniqueItems=cls.unique_items)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def list_length_validator(cls, v: &#39;Optional[List[T]]&#39;) -&gt; &#39;Optional[List[T]]&#39;:</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        v = list_validator(v)</span>
<span class="gi">+        v_len = len(v)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.min_items is not None and v_len &lt; cls.min_items:</span>
<span class="gi">+            raise errors.ListMinLengthError(limit_value=cls.min_items)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.max_items is not None and v_len &gt; cls.max_items:</span>
<span class="gi">+            raise errors.ListMaxLengthError(limit_value=cls.max_items)</span>
<span class="gi">+</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def unique_items_validator(cls, v: &#39;Optional[List[T]]&#39;) -&gt; &#39;Optional[List[T]]&#39;:</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        for i, value in enumerate(v, start=1):</span>
<span class="gi">+            if value in v[i:]:</span>
<span class="gi">+                raise errors.ListUniqueItemsError()</span>
<span class="gi">+</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def conlist(</span>
<span class="gi">+    item_type: Type[T], *, min_items: Optional[int] = None, max_items: Optional[int] = None, unique_items: bool = None</span>
<span class="gi">+) -&gt; Type[List[T]]:</span>
<span class="gi">+    # __args__ is needed to conform to typing generics api</span>
<span class="gi">+    namespace = dict(</span>
<span class="gi">+        min_items=min_items, max_items=max_items, unique_items=unique_items, item_type=item_type, __args__=(item_type,)</span>
<span class="gi">+    )</span>
<span class="gi">+    # We use new_class to be able to deal with Generic types</span>
<span class="gi">+    return new_class(&#39;ConstrainedListValue&#39;, (ConstrainedList,), {}, lambda ns: ns.update(namespace))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PYOBJECT TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>


<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    PyObject = Callable[..., Any]
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class PyObject:
<span class="w"> </span>        validate_always = True

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+        def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>            yield cls.validate

<span class="gi">+        @classmethod</span>
<span class="gi">+        def validate(cls, value: Any) -&gt; Any:</span>
<span class="gi">+            if isinstance(value, Callable):</span>
<span class="gi">+                return value</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = str_validator(value)</span>
<span class="gi">+            except errors.StrError:</span>
<span class="gi">+                raise errors.PyObjectError(error_message=&#39;value is neither a valid import path not a valid callable&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                return import_string(value)</span>
<span class="gi">+            except ImportError as e:</span>
<span class="gi">+                raise errors.PyObjectError(error_message=str(e))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DECIMAL TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>

<span class="w"> </span>class ConstrainedDecimal(Decimal, metaclass=ConstrainedNumberMeta):
<span class="w"> </span>    gt: OptionalIntFloatDecimal = None
<span class="gu">@@ -342,18 +674,82 @@ class ConstrainedDecimal(Decimal, metaclass=ConstrainedNumberMeta):</span>
<span class="w"> </span>    multiple_of: OptionalIntFloatDecimal = None

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, exclusiveMinimum=cls.gt,</span>
<span class="gd">-            exclusiveMaximum=cls.lt, minimum=cls.ge, maximum=cls.le,</span>
<span class="gd">-            multipleOf=cls.multiple_of)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(</span>
<span class="gi">+            field_schema,</span>
<span class="gi">+            exclusiveMinimum=cls.gt,</span>
<span class="gi">+            exclusiveMaximum=cls.lt,</span>
<span class="gi">+            minimum=cls.ge,</span>
<span class="gi">+            maximum=cls.le,</span>
<span class="gi">+            multipleOf=cls.multiple_of,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield decimal_validator
<span class="w"> </span>        yield number_size_validator
<span class="w"> </span>        yield number_multiple_validator
<span class="w"> </span>        yield cls.validate

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: Decimal) -&gt; Decimal:</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_value = value.normalize()</span>
<span class="gi">+        except InvalidOperation:</span>
<span class="gi">+            normalized_value = value</span>
<span class="gi">+        digit_tuple, exponent = normalized_value.as_tuple()[1:]</span>
<span class="gi">+        if exponent in {&#39;F&#39;, &#39;n&#39;, &#39;N&#39;}:</span>
<span class="gi">+            raise errors.DecimalIsNotFiniteError()</span>
<span class="gi">+</span>
<span class="gi">+        if exponent &gt;= 0:</span>
<span class="gi">+            # A positive exponent adds that many trailing zeros.</span>
<span class="gi">+            digits = len(digit_tuple) + exponent</span>
<span class="gi">+            decimals = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If the absolute value of the negative exponent is larger than the</span>
<span class="gi">+            # number of digits, then it&#39;s the same as the number of digits,</span>
<span class="gi">+            # because it&#39;ll consume all of the digits in digit_tuple and then</span>
<span class="gi">+            # add abs(exponent) - len(digit_tuple) leading zeros after the</span>
<span class="gi">+            # decimal point.</span>
<span class="gi">+            if abs(exponent) &gt; len(digit_tuple):</span>
<span class="gi">+                digits = decimals = abs(exponent)</span>
<span class="gi">+            else:</span>
<span class="gi">+                digits = len(digit_tuple)</span>
<span class="gi">+                decimals = abs(exponent)</span>
<span class="gi">+        whole_digits = digits - decimals</span>
<span class="gi">+</span>
<span class="gi">+        if cls.max_digits is not None and digits &gt; cls.max_digits:</span>
<span class="gi">+            raise errors.DecimalMaxDigitsError(max_digits=cls.max_digits)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.decimal_places is not None and decimals &gt; cls.decimal_places:</span>
<span class="gi">+            raise errors.DecimalMaxPlacesError(decimal_places=cls.decimal_places)</span>
<span class="gi">+</span>
<span class="gi">+        if cls.max_digits is not None and cls.decimal_places is not None:</span>
<span class="gi">+            expected = cls.max_digits - cls.decimal_places</span>
<span class="gi">+            if whole_digits &gt; expected:</span>
<span class="gi">+                raise errors.DecimalWholeDigitsError(whole_digits=expected)</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def condecimal(</span>
<span class="gi">+    *,</span>
<span class="gi">+    gt: Decimal = None,</span>
<span class="gi">+    ge: Decimal = None,</span>
<span class="gi">+    lt: Decimal = None,</span>
<span class="gi">+    le: Decimal = None,</span>
<span class="gi">+    max_digits: Optional[int] = None,</span>
<span class="gi">+    decimal_places: Optional[int] = None,</span>
<span class="gi">+    multiple_of: Decimal = None,</span>
<span class="gi">+) -&gt; Type[Decimal]:</span>
<span class="gi">+    # use kwargs then define conf in a dict to aid with IDE type hinting</span>
<span class="gi">+    namespace = dict(</span>
<span class="gi">+        gt=gt, ge=ge, lt=lt, le=le, max_digits=max_digits, decimal_places=decimal_places, multiple_of=multiple_of</span>
<span class="gi">+    )</span>
<span class="gi">+    return type(&#39;ConstrainedDecimalValue&#39;, (ConstrainedDecimal,), namespace)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UUID TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    UUID1 = UUID
<span class="gu">@@ -362,83 +758,95 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    UUID5 = UUID
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class UUID1(UUID):
<span class="w"> </span>        _required_version = 1

<span class="w"> </span>        @classmethod
<span class="gd">-        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-            field_schema.update(type=&#39;string&#39;, format=</span>
<span class="gd">-                f&#39;uuid{cls._required_version}&#39;)</span>
<span class="gd">-</span>
<span class="gi">+        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+            field_schema.update(type=&#39;string&#39;, format=f&#39;uuid{cls._required_version}&#39;)</span>

<span class="w"> </span>    class UUID3(UUID1):
<span class="w"> </span>        _required_version = 3

<span class="gd">-</span>
<span class="w"> </span>    class UUID4(UUID1):
<span class="w"> </span>        _required_version = 4

<span class="gd">-</span>
<span class="w"> </span>    class UUID5(UUID1):
<span class="w"> </span>        _required_version = 5
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PATH TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    FilePath = Path
<span class="w"> </span>    DirectoryPath = Path
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class FilePath(Path):
<span class="gd">-</span>
<span class="w"> </span>        @classmethod
<span class="gd">-        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>            field_schema.update(format=&#39;file-path&#39;)

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+        def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>            yield path_validator
<span class="w"> </span>            yield path_exists_validator
<span class="w"> </span>            yield cls.validate

<span class="gi">+        @classmethod</span>
<span class="gi">+        def validate(cls, value: Path) -&gt; Path:</span>
<span class="gi">+            if not value.is_file():</span>
<span class="gi">+                raise errors.PathNotAFileError(path=value)</span>
<span class="gi">+</span>
<span class="gi">+            return value</span>

<span class="w"> </span>    class DirectoryPath(Path):
<span class="gd">-</span>
<span class="w"> </span>        @classmethod
<span class="gd">-        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>            field_schema.update(format=&#39;directory-path&#39;)

<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+        def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>            yield path_validator
<span class="w"> </span>            yield path_exists_validator
<span class="w"> </span>            yield cls.validate

<span class="gi">+        @classmethod</span>
<span class="gi">+        def validate(cls, value: Path) -&gt; Path:</span>
<span class="gi">+            if not value.is_dir():</span>
<span class="gi">+                raise errors.PathNotADirectoryError(path=value)</span>
<span class="gi">+</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ JSON TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>

<span class="w"> </span>class JsonWrapper:
<span class="w"> </span>    pass


<span class="w"> </span>class JsonMeta(type):
<span class="gd">-</span>
<span class="gd">-    def __getitem__(self, t: Type[Any]) -&gt;Type[JsonWrapper]:</span>
<span class="gi">+    def __getitem__(self, t: Type[Any]) -&gt; Type[JsonWrapper]:</span>
<span class="w"> </span>        if t is Any:
<span class="gd">-            return Json</span>
<span class="gd">-        return _registered(type(&#39;JsonWrapperValue&#39;, (JsonWrapper,), {</span>
<span class="gd">-            &#39;inner_type&#39;: t}))</span>
<span class="gi">+            return Json  # allow Json[Any] to replecate plain Json</span>
<span class="gi">+        return _registered(type(&#39;JsonWrapperValue&#39;, (JsonWrapper,), {&#39;inner_type&#39;: t}))</span>


<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    Json = Annotated[T, ...]</span>
<span class="gd">-else:</span>
<span class="gi">+    Json = Annotated[T, ...]  # Json[list[str]] will be recognized by type checkers as list[str]</span>

<span class="gi">+else:</span>

<span class="w"> </span>    class Json(metaclass=JsonMeta):
<span class="gd">-</span>
<span class="w"> </span>        @classmethod
<span class="gd">-        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gi">+        def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>            field_schema.update(type=&#39;string&#39;, format=&#39;json-string&#39;)


<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SECRET TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class SecretField(abc.ABC):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,
<span class="gu">@@ -450,72 +858,120 @@ class SecretField(abc.ABC):</span>
<span class="w"> </span>          https://github.com/cython/cython/issues/2753).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, self.__class__) and self.get_secret_value(</span>
<span class="gd">-            ) == other.get_secret_value()</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return &#39;**********&#39; if self.get_secret_value() else &#39;&#39;

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.get_secret_value())

<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def get_secret_value(self) -&gt; Any:  # pragma: no cover</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>

<span class="w"> </span>class SecretStr(SecretField):
<span class="w"> </span>    min_length: OptionalInt = None
<span class="w"> </span>    max_length: OptionalInt = None

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, type=&#39;string&#39;, writeOnly=True, format</span>
<span class="gd">-            =&#39;password&#39;, minLength=cls.min_length, maxLength=cls.max_length)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(</span>
<span class="gi">+            field_schema,</span>
<span class="gi">+            type=&#39;string&#39;,</span>
<span class="gi">+            writeOnly=True,</span>
<span class="gi">+            format=&#39;password&#39;,</span>
<span class="gi">+            minLength=cls.min_length,</span>
<span class="gi">+            maxLength=cls.max_length,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.validate
<span class="w"> </span>        yield constr_length_validator

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: Any) -&gt; &#39;SecretStr&#39;:</span>
<span class="gi">+        if isinstance(value, cls):</span>
<span class="gi">+            return value</span>
<span class="gi">+        value = str_validator(value)</span>
<span class="gi">+        return cls(value)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, value: str):
<span class="w"> </span>        self._secret_value = value

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&quot;SecretStr(&#39;{self}&#39;)&quot;

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._secret_value)

<span class="gi">+    def display(self) -&gt; str:</span>
<span class="gi">+        warnings.warn(&#39;`secret_str.display()` is deprecated, use `str(secret_str)` instead&#39;, DeprecationWarning)</span>
<span class="gi">+        return str(self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_secret_value(self) -&gt; str:</span>
<span class="gi">+        return self._secret_value</span>
<span class="gi">+</span>

<span class="w"> </span>class SecretBytes(SecretField):
<span class="w"> </span>    min_length: OptionalInt = None
<span class="w"> </span>    max_length: OptionalInt = None

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, type=&#39;string&#39;, writeOnly=True, format</span>
<span class="gd">-            =&#39;password&#39;, minLength=cls.min_length, maxLength=cls.max_length)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(</span>
<span class="gi">+            field_schema,</span>
<span class="gi">+            type=&#39;string&#39;,</span>
<span class="gi">+            writeOnly=True,</span>
<span class="gi">+            format=&#39;password&#39;,</span>
<span class="gi">+            minLength=cls.min_length,</span>
<span class="gi">+            maxLength=cls.max_length,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.validate
<span class="w"> </span>        yield constr_length_validator

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: Any) -&gt; &#39;SecretBytes&#39;:</span>
<span class="gi">+        if isinstance(value, cls):</span>
<span class="gi">+            return value</span>
<span class="gi">+        value = bytes_validator(value)</span>
<span class="gi">+        return cls(value)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, value: bytes):
<span class="w"> </span>        self._secret_value = value

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&quot;SecretBytes(b&#39;{self}&#39;)&quot;

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._secret_value)

<span class="gi">+    def display(self) -&gt; str:</span>
<span class="gi">+        warnings.warn(&#39;`secret_bytes.display()` is deprecated, use `str(secret_bytes)` instead&#39;, DeprecationWarning)</span>
<span class="gi">+        return str(self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_secret_value(self) -&gt; bytes:</span>
<span class="gi">+        return self._secret_value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PAYMENT CARD TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>

<span class="w"> </span>class PaymentCardBrand(str, Enum):
<span class="gi">+    # If you add another card type, please also add it to the</span>
<span class="gi">+    # Hypothesis strategy in `pydantic._hypothesis_plugin`.</span>
<span class="w"> </span>    amex = &#39;American Express&#39;
<span class="w"> </span>    mastercard = &#39;Mastercard&#39;
<span class="w"> </span>    visa = &#39;Visa&#39;
<span class="w"> </span>    other = &#39;other&#39;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.value


<span class="gu">@@ -523,6 +979,7 @@ class PaymentCardNumber(str):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Based on: https://en.wikipedia.org/wiki/Payment_card_number
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    strip_whitespace: ClassVar[bool] = True
<span class="w"> </span>    min_length: ClassVar[int] = 12
<span class="w"> </span>    max_length: ClassVar[int] = 19
<span class="gu">@@ -536,7 +993,7 @@ class PaymentCardNumber(str):</span>
<span class="w"> </span>        self.brand = self._get_brand(card_number)

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield str_validator
<span class="w"> </span>        yield constr_strip_whitespace
<span class="w"> </span>        yield constr_length_validator
<span class="gu">@@ -545,59 +1002,180 @@ class PaymentCardNumber(str):</span>
<span class="w"> </span>        yield cls
<span class="w"> </span>        yield cls.validate_length_for_brand

<span class="gi">+    @property</span>
<span class="gi">+    def masked(self) -&gt; str:</span>
<span class="gi">+        num_masked = len(self) - 10  # len(bin) + len(last4) == 10</span>
<span class="gi">+        return f&#39;{self.bin}{&quot;*&quot; * num_masked}{self.last4}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate_digits(cls, card_number: str) -&gt; str:</span>
<span class="gi">+        if not card_number.isdigit():</span>
<span class="gi">+            raise errors.NotDigitError</span>
<span class="gi">+        return card_number</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def validate_luhn_check_digit(cls, card_number: str) -&gt;str:</span>
<span class="gi">+    def validate_luhn_check_digit(cls, card_number: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Based on: https://en.wikipedia.org/wiki/Luhn_algorithm
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sum_ = int(card_number[-1])</span>
<span class="gi">+        length = len(card_number)</span>
<span class="gi">+        parity = length % 2</span>
<span class="gi">+        for i in range(length - 1):</span>
<span class="gi">+            digit = int(card_number[i])</span>
<span class="gi">+            if i % 2 == parity:</span>
<span class="gi">+                digit *= 2</span>
<span class="gi">+            if digit &gt; 9:</span>
<span class="gi">+                digit -= 9</span>
<span class="gi">+            sum_ += digit</span>
<span class="gi">+        valid = sum_ % 10 == 0</span>
<span class="gi">+        if not valid:</span>
<span class="gi">+            raise errors.LuhnValidationError</span>
<span class="gi">+        return card_number</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def validate_length_for_brand(cls, card_number: &#39;PaymentCardNumber&#39;</span>
<span class="gd">-        ) -&gt;&#39;PaymentCardNumber&#39;:</span>
<span class="gi">+    def validate_length_for_brand(cls, card_number: &#39;PaymentCardNumber&#39;) -&gt; &#39;PaymentCardNumber&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Validate length based on BIN for major brands:
<span class="w"> </span>        https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-BYTE_SIZES = {&#39;b&#39;: 1, &#39;kb&#39;: 10 ** 3, &#39;mb&#39;: 10 ** 6, &#39;gb&#39;: 10 ** 9, &#39;tb&#39;: 10 **</span>
<span class="gd">-    12, &#39;pb&#39;: 10 ** 15, &#39;eb&#39;: 10 ** 18, &#39;kib&#39;: 2 ** 10, &#39;mib&#39;: 2 ** 20,</span>
<span class="gd">-    &#39;gib&#39;: 2 ** 30, &#39;tib&#39;: 2 ** 40, &#39;pib&#39;: 2 ** 50, &#39;eib&#39;: 2 ** 60}</span>
<span class="gd">-BYTE_SIZES.update({k.lower()[0]: v for k, v in BYTE_SIZES.items() if &#39;i&#39; not in</span>
<span class="gd">-    k})</span>
<span class="gd">-byte_string_re = re.compile(&#39;^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?&#39;, re.IGNORECASE)</span>
<span class="gi">+        required_length: Union[None, int, str] = None</span>
<span class="gi">+        if card_number.brand in PaymentCardBrand.mastercard:</span>
<span class="gi">+            required_length = 16</span>
<span class="gi">+            valid = len(card_number) == required_length</span>
<span class="gi">+        elif card_number.brand == PaymentCardBrand.visa:</span>
<span class="gi">+            required_length = &#39;13, 16 or 19&#39;</span>
<span class="gi">+            valid = len(card_number) in {13, 16, 19}</span>
<span class="gi">+        elif card_number.brand == PaymentCardBrand.amex:</span>
<span class="gi">+            required_length = 15</span>
<span class="gi">+            valid = len(card_number) == required_length</span>
<span class="gi">+        else:</span>
<span class="gi">+            valid = True</span>
<span class="gi">+        if not valid:</span>
<span class="gi">+            raise errors.InvalidLengthForBrand(brand=card_number.brand, required_length=required_length)</span>
<span class="gi">+        return card_number</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_brand(card_number: str) -&gt; PaymentCardBrand:</span>
<span class="gi">+        if card_number[0] == &#39;4&#39;:</span>
<span class="gi">+            brand = PaymentCardBrand.visa</span>
<span class="gi">+        elif 51 &lt;= int(card_number[:2]) &lt;= 55:</span>
<span class="gi">+            brand = PaymentCardBrand.mastercard</span>
<span class="gi">+        elif card_number[:2] in {&#39;34&#39;, &#39;37&#39;}:</span>
<span class="gi">+            brand = PaymentCardBrand.amex</span>
<span class="gi">+        else:</span>
<span class="gi">+            brand = PaymentCardBrand.other</span>
<span class="gi">+        return brand</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTE SIZE TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="gi">+</span>
<span class="gi">+BYTE_SIZES = {</span>
<span class="gi">+    &#39;b&#39;: 1,</span>
<span class="gi">+    &#39;kb&#39;: 10**3,</span>
<span class="gi">+    &#39;mb&#39;: 10**6,</span>
<span class="gi">+    &#39;gb&#39;: 10**9,</span>
<span class="gi">+    &#39;tb&#39;: 10**12,</span>
<span class="gi">+    &#39;pb&#39;: 10**15,</span>
<span class="gi">+    &#39;eb&#39;: 10**18,</span>
<span class="gi">+    &#39;kib&#39;: 2**10,</span>
<span class="gi">+    &#39;mib&#39;: 2**20,</span>
<span class="gi">+    &#39;gib&#39;: 2**30,</span>
<span class="gi">+    &#39;tib&#39;: 2**40,</span>
<span class="gi">+    &#39;pib&#39;: 2**50,</span>
<span class="gi">+    &#39;eib&#39;: 2**60,</span>
<span class="gi">+}</span>
<span class="gi">+BYTE_SIZES.update({k.lower()[0]: v for k, v in BYTE_SIZES.items() if &#39;i&#39; not in k})</span>
<span class="gi">+byte_string_re = re.compile(r&#39;^\s*(\d*\.?\d+)\s*(\w+)?&#39;, re.IGNORECASE)</span>


<span class="w"> </span>class ByteSize(int):
<span class="gd">-</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield cls.validate

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, v: StrIntFloat) -&gt; &#39;ByteSize&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return cls(int(v))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        str_match = byte_string_re.match(str(v))</span>
<span class="gi">+        if str_match is None:</span>
<span class="gi">+            raise errors.InvalidByteSize()</span>
<span class="gi">+</span>
<span class="gi">+        scalar, unit = str_match.groups()</span>
<span class="gi">+        if unit is None:</span>
<span class="gi">+            unit = &#39;b&#39;</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            unit_mult = BYTE_SIZES[unit.lower()]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise errors.InvalidByteSizeUnit(unit=unit)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(int(float(scalar) * unit_mult))</span>
<span class="gi">+</span>
<span class="gi">+    def human_readable(self, decimal: bool = False) -&gt; str:</span>
<span class="gi">+        if decimal:</span>
<span class="gi">+            divisor = 1000</span>
<span class="gi">+            units = [&#39;B&#39;, &#39;KB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;]</span>
<span class="gi">+            final_unit = &#39;EB&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            divisor = 1024</span>
<span class="gi">+            units = [&#39;B&#39;, &#39;KiB&#39;, &#39;MiB&#39;, &#39;GiB&#39;, &#39;TiB&#39;, &#39;PiB&#39;]</span>
<span class="gi">+            final_unit = &#39;EiB&#39;</span>
<span class="gi">+</span>
<span class="gi">+        num = float(self)</span>
<span class="gi">+        for unit in units:</span>
<span class="gi">+            if abs(num) &lt; divisor:</span>
<span class="gi">+                return f&#39;{num:0.1f}{unit}&#39;</span>
<span class="gi">+            num /= divisor</span>
<span class="gi">+</span>
<span class="gi">+        return f&#39;{num:0.1f}{final_unit}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def to(self, unit: str) -&gt; float:</span>
<span class="gi">+        try:</span>
<span class="gi">+            unit_div = BYTE_SIZES[unit.lower()]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise errors.InvalidByteSizeUnit(unit=unit)</span>
<span class="gi">+</span>
<span class="gi">+        return self / unit_div</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DATE TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    PastDate = date
<span class="w"> </span>    FutureDate = date
<span class="w"> </span>else:

<span class="gd">-</span>
<span class="w"> </span>    class PastDate(date):
<span class="gd">-</span>
<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+        def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>            yield parse_date
<span class="w"> </span>            yield cls.validate

<span class="gi">+        @classmethod</span>
<span class="gi">+        def validate(cls, value: date) -&gt; date:</span>
<span class="gi">+            if value &gt;= date.today():</span>
<span class="gi">+                raise errors.DateNotInThePastError()</span>

<span class="gd">-    class FutureDate(date):</span>
<span class="gi">+            return value</span>

<span class="gi">+    class FutureDate(date):</span>
<span class="w"> </span>        @classmethod
<span class="gd">-        def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+        def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>            yield parse_date
<span class="w"> </span>            yield cls.validate

<span class="gi">+        @classmethod</span>
<span class="gi">+        def validate(cls, value: date) -&gt; date:</span>
<span class="gi">+            if value &lt;= date.today():</span>
<span class="gi">+                raise errors.DateNotInTheFutureError()</span>
<span class="gi">+</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>

<span class="w"> </span>class ConstrainedDate(date, metaclass=ConstrainedNumberMeta):
<span class="w"> </span>    gt: OptionalDate = None
<span class="gu">@@ -606,11 +1184,22 @@ class ConstrainedDate(date, metaclass=ConstrainedNumberMeta):</span>
<span class="w"> </span>    le: OptionalDate = None

<span class="w"> </span>    @classmethod
<span class="gd">-    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt;None:</span>
<span class="gd">-        update_not_none(field_schema, exclusiveMinimum=cls.gt,</span>
<span class="gd">-            exclusiveMaximum=cls.lt, minimum=cls.ge, maximum=cls.le)</span>
<span class="gi">+    def __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:</span>
<span class="gi">+        update_not_none(field_schema, exclusiveMinimum=cls.gt, exclusiveMaximum=cls.lt, minimum=cls.ge, maximum=cls.le)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:</span>
<span class="gi">+    def __get_validators__(cls) -&gt; &#39;CallableGenerator&#39;:</span>
<span class="w"> </span>        yield parse_date
<span class="w"> </span>        yield number_size_validator
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def condate(</span>
<span class="gi">+    *,</span>
<span class="gi">+    gt: date = None,</span>
<span class="gi">+    ge: date = None,</span>
<span class="gi">+    lt: date = None,</span>
<span class="gi">+    le: date = None,</span>
<span class="gi">+) -&gt; Type[date]:</span>
<span class="gi">+    # use kwargs then define conf in a dict to aid with IDE type hinting</span>
<span class="gi">+    namespace = dict(gt=gt, ge=ge, lt=lt, le=le)</span>
<span class="gi">+    return type(&#39;ConstrainedDateValue&#39;, (ConstrainedDate,), namespace)</span>
<span class="gh">diff --git a/pydantic/v1/typing.py b/pydantic/v1/typing.py</span>
<span class="gh">index 72034371e..7dd341ce0 100644</span>
<span class="gd">--- a/pydantic/v1/typing.py</span>
<span class="gi">+++ b/pydantic/v1/typing.py</span>
<span class="gu">@@ -2,66 +2,168 @@ import sys</span>
<span class="w"> </span>import typing
<span class="w"> </span>from collections.abc import Callable
<span class="w"> </span>from os import PathLike
<span class="gd">-from typing import TYPE_CHECKING, AbstractSet, Any, Callable as TypingCallable, ClassVar, Dict, ForwardRef, Generator, Iterable, List, Mapping, NewType, Optional, Sequence, Set, Tuple, Type, TypeVar, Union, _eval_type, cast, get_type_hints</span>
<span class="gd">-from typing_extensions import Annotated, Final, Literal, NotRequired as TypedDictNotRequired, Required as TypedDictRequired</span>
<span class="gi">+from typing import (  # type: ignore</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    AbstractSet,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable as TypingCallable,</span>
<span class="gi">+    ClassVar,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    ForwardRef,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    NewType,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    _eval_type,</span>
<span class="gi">+    cast,</span>
<span class="gi">+    get_type_hints,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+from typing_extensions import (</span>
<span class="gi">+    Annotated,</span>
<span class="gi">+    Final,</span>
<span class="gi">+    Literal,</span>
<span class="gi">+    NotRequired as TypedDictNotRequired,</span>
<span class="gi">+    Required as TypedDictRequired,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    from typing import _TypingBase as typing_base</span>
<span class="gi">+    from typing import _TypingBase as typing_base  # type: ignore</span>
<span class="w"> </span>except ImportError:
<span class="gd">-    from typing import _Final as typing_base</span>
<span class="gi">+    from typing import _Final as typing_base  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    from typing import GenericAlias as TypingGenericAlias</span>
<span class="gi">+    from typing import GenericAlias as TypingGenericAlias  # type: ignore</span>
<span class="w"> </span>except ImportError:
<span class="gi">+    # python &lt; 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)</span>
<span class="w"> </span>    TypingGenericAlias = ()
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    from types import UnionType as TypesUnionType</span>
<span class="gi">+    from types import UnionType as TypesUnionType  # type: ignore</span>
<span class="w"> </span>except ImportError:
<span class="gi">+    # python &lt; 3.10 does not have UnionType (str | int, byte | bool and so on)</span>
<span class="w"> </span>    TypesUnionType = ()
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 9):
<span class="gi">+</span>
<span class="gi">+    def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -&gt; Any:</span>
<span class="gi">+        return type_._evaluate(globalns, localns)</span>
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -&gt; Any:</span>
<span class="gi">+        # Even though it is the right signature for python 3.9, mypy complains with</span>
<span class="gi">+        # `error: Too many arguments for &quot;_evaluate&quot; of &quot;ForwardRef&quot;` hence the cast...</span>
<span class="gi">+        # Python 3.13/3.12.4+ made `recursive_guard` a kwarg, so name it explicitly to avoid:</span>
<span class="gi">+        # TypeError: ForwardRef._evaluate() missing 1 required keyword-only argument: &#39;recursive_guard&#39;</span>
<span class="gi">+        return cast(Any, type_)._evaluate(globalns, localns, recursive_guard=set())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 9):
<span class="gi">+    # Ensure we always get all the whole `Annotated` hint, not just the annotated type.</span>
<span class="gi">+    # For 3.7 to 3.8, `get_type_hints` doesn&#39;t recognize `typing_extensions.Annotated`,</span>
<span class="gi">+    # so it already returns the full annotation</span>
<span class="w"> </span>    get_all_type_hints = get_type_hints
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    def get_all_type_hints(obj: Any, globalns: Any = None, localns: Any = None) -&gt; Any:</span>
<span class="gi">+        return get_type_hints(obj, globalns, localns, include_extras=True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_T = TypeVar(&#39;_T&#39;)
<span class="gi">+</span>
<span class="w"> </span>AnyCallable = TypingCallable[..., Any]
<span class="w"> </span>NoArgAnyCallable = TypingCallable[[], Any]
<span class="gi">+</span>
<span class="gi">+# workaround for https://github.com/python/mypy/issues/9496</span>
<span class="w"> </span>AnyArgTCallable = TypingCallable[..., _T]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Annotated[...] is implemented by returning an instance of one of these classes, depending on</span>
<span class="gi">+# python/typing_extensions version.</span>
<span class="w"> </span>AnnotatedTypeNames = {&#39;AnnotatedMeta&#39;, &#39;_AnnotatedAlias&#39;}
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>LITERAL_TYPES: Set[Any] = {Literal}
<span class="w"> </span>if hasattr(typing, &#39;Literal&#39;):
<span class="w"> </span>    LITERAL_TYPES.add(typing.Literal)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 8):
<span class="gi">+</span>
<span class="gi">+    def get_origin(t: Type[Any]) -&gt; Optional[Type[Any]]:</span>
<span class="gi">+        if type(t).__name__ in AnnotatedTypeNames:</span>
<span class="gi">+            # weirdly this is a runtime requirement, as well as for mypy</span>
<span class="gi">+            return cast(Type[Any], Annotated)</span>
<span class="gi">+        return getattr(t, &#39;__origin__&#39;, None)</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    from typing import get_origin as _typing_get_origin

<span class="gd">-    def get_origin(tp: Type[Any]) -&gt;Optional[Type[Any]]:</span>
<span class="gi">+    def get_origin(tp: Type[Any]) -&gt; Optional[Type[Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        We can&#39;t directly use `typing.get_origin` since we need a fallback to support
<span class="w"> </span>        custom generic classes like `ConstrainedList`
<span class="w"> </span>        It should be useless once https://github.com/cython/cython/issues/3537 is
<span class="w"> </span>        solved and https://github.com/pydantic/pydantic/pull/1753 is merged.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if type(tp).__name__ in AnnotatedTypeNames:</span>
<span class="gi">+            return cast(Type[Any], Annotated)  # mypy complains about _SpecialForm</span>
<span class="gi">+        return _typing_get_origin(tp) or getattr(tp, &#39;__origin__&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 8):
<span class="w"> </span>    from typing import _GenericAlias

<span class="gd">-    def get_args(t: Type[Any]) -&gt;Tuple[Any, ...]:</span>
<span class="gi">+    def get_args(t: Type[Any]) -&gt; Tuple[Any, ...]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compatibility version of get_args for python 3.7.

<span class="w"> </span>        Mostly compatible with the python 3.8 `typing` module version
<span class="w"> </span>        and able to handle almost all use cases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if type(t).__name__ in AnnotatedTypeNames:</span>
<span class="gi">+            return t.__args__ + t.__metadata__</span>
<span class="gi">+        if isinstance(t, _GenericAlias):</span>
<span class="gi">+            res = t.__args__</span>
<span class="gi">+            if t.__origin__ is Callable and res and res[0] is not Ellipsis:</span>
<span class="gi">+                res = (list(res[:-1]), res[-1])</span>
<span class="gi">+            return res</span>
<span class="gi">+        return getattr(t, &#39;__args__&#39;, ())</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    from typing import get_args as _typing_get_args

<span class="gd">-    def _generic_get_args(tp: Type[Any]) -&gt;Tuple[Any, ...]:</span>
<span class="gi">+    def _generic_get_args(tp: Type[Any]) -&gt; Tuple[Any, ...]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        In python 3.9, `typing.Dict`, `typing.List`, ...
<span class="w"> </span>        do have an empty `__args__` by default (instead of the generic ~T for example).
<span class="w"> </span>        In order to still support `Dict` for example and consider it as `Dict[Any, Any]`,
<span class="w"> </span>        we retrieve the `_nparams` value that tells us how many parameters it needs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_args(tp: Type[Any]) -&gt;Tuple[Any, ...]:</span>
<span class="gi">+        if hasattr(tp, &#39;_nparams&#39;):</span>
<span class="gi">+            return (Any,) * tp._nparams</span>
<span class="gi">+        # Special case for `tuple[()]`, which used to return ((),) with `typing.Tuple`</span>
<span class="gi">+        # in python 3.10- but now returns () for `tuple` and `Tuple`.</span>
<span class="gi">+        # This will probably be clarified in pydantic v2</span>
<span class="gi">+        try:</span>
<span class="gi">+            if tp == Tuple[()] or sys.version_info &gt;= (3, 9) and tp == tuple[()]:  # type: ignore[misc]</span>
<span class="gi">+                return ((),)</span>
<span class="gi">+        # there is a TypeError when compiled with cython</span>
<span class="gi">+        except TypeError:  # pragma: no cover</span>
<span class="gi">+            pass</span>
<span class="gi">+        return ()</span>
<span class="gi">+</span>
<span class="gi">+    def get_args(tp: Type[Any]) -&gt; Tuple[Any, ...]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get type arguments with all substitutions performed.

<span class="w"> </span>        For unions, basic simplifications used by Union constructor are performed.
<span class="gu">@@ -72,22 +174,29 @@ else:</span>
<span class="w"> </span>            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
<span class="w"> </span>            get_args(Callable[[], T][int]) == ([], int)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if type(tp).__name__ in AnnotatedTypeNames:</span>
<span class="gi">+            return tp.__args__ + tp.__metadata__</span>
<span class="gi">+        # the fallback is needed for the same reasons as `get_origin` (see above)</span>
<span class="gi">+        return _typing_get_args(tp) or getattr(tp, &#39;__args__&#39;, ()) or _generic_get_args(tp)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 9):

<span class="gd">-    def convert_generics(tp: Type[Any]) -&gt;Type[Any]:</span>
<span class="gi">+    def convert_generics(tp: Type[Any]) -&gt; Type[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Python 3.9 and older only supports generics from `typing` module.
<span class="w"> </span>        They convert strings to ForwardRef automatically.

<span class="w"> </span>        Examples::
<span class="w"> </span>            typing.List[&#39;Hero&#39;] == typing.List[ForwardRef(&#39;Hero&#39;)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return tp</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gd">-    from typing import _UnionGenericAlias</span>
<span class="gi">+    from typing import _UnionGenericAlias  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>    from typing_extensions import _AnnotatedAlias

<span class="gd">-    def convert_generics(tp: Type[Any]) -&gt;Type[Any]:</span>
<span class="gi">+    def convert_generics(tp: Type[Any]) -&gt; Type[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Recursively searches for `str` type hints and replaces them with ForwardRef.

<span class="gu">@@ -97,16 +206,60 @@ else:</span>
<span class="w"> </span>            convert_generics(typing.Dict[&#39;Hero&#39;, &#39;Team&#39;]) == typing.Dict[ForwardRef(&#39;Hero&#39;), ForwardRef(&#39;Team&#39;)]
<span class="w"> </span>            convert_generics(list[str | &#39;Hero&#39;] | int) == list[str | ForwardRef(&#39;Hero&#39;)] | int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        origin = get_origin(tp)</span>
<span class="gi">+        if not origin or not hasattr(tp, &#39;__args__&#39;):</span>
<span class="gi">+            return tp</span>
<span class="gi">+</span>
<span class="gi">+        args = get_args(tp)</span>
<span class="gi">+</span>
<span class="gi">+        # typing.Annotated needs special treatment</span>
<span class="gi">+        if origin is Annotated:</span>
<span class="gi">+            return _AnnotatedAlias(convert_generics(args[0]), args[1:])</span>
<span class="gi">+</span>
<span class="gi">+        # recursively replace `str` instances inside of `GenericAlias` with `ForwardRef(arg)`</span>
<span class="gi">+        converted = tuple(</span>
<span class="gi">+            ForwardRef(arg) if isinstance(arg, str) and isinstance(tp, TypingGenericAlias) else convert_generics(arg)</span>
<span class="gi">+            for arg in args</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if converted == args:</span>
<span class="gi">+            return tp</span>
<span class="gi">+        elif isinstance(tp, TypingGenericAlias):</span>
<span class="gi">+            return TypingGenericAlias(origin, converted)</span>
<span class="gi">+        elif isinstance(tp, TypesUnionType):</span>
<span class="gi">+            # recreate types.UnionType (PEP604, Python &gt;= 3.10)</span>
<span class="gi">+            return _UnionGenericAlias(origin, converted)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                setattr(tp, &#39;__args__&#39;, converted)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            return tp</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 10):
<span class="gd">-    WithArgsTypes = TypingGenericAlias,</span>
<span class="gi">+</span>
<span class="gi">+    def is_union(tp: Optional[Type[Any]]) -&gt; bool:</span>
<span class="gi">+        return tp is Union</span>
<span class="gi">+</span>
<span class="gi">+    WithArgsTypes = (TypingGenericAlias,)</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    import types
<span class="w"> </span>    import typing
<span class="gd">-    WithArgsTypes = typing._GenericAlias, types.GenericAlias, types.UnionType</span>
<span class="gi">+</span>
<span class="gi">+    def is_union(tp: Optional[Type[Any]]) -&gt; bool:</span>
<span class="gi">+        return tp is Union or tp is types.UnionType  # noqa: E721</span>
<span class="gi">+</span>
<span class="gi">+    WithArgsTypes = (typing._GenericAlias, types.GenericAlias, types.UnionType)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>StrPath = Union[str, PathLike]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pydantic.v1.fields import ModelField
<span class="gi">+</span>
<span class="w"> </span>    TupleGenerator = Generator[Tuple[str, Any], None, None]
<span class="w"> </span>    DictStrAny = Dict[str, Any]
<span class="w"> </span>    DictAny = Dict[Any, Any]
<span class="gu">@@ -118,116 +271,338 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    MappingIntStrAny = Mapping[IntStr, Any]
<span class="w"> </span>    CallableGenerator = Generator[AnyCallable, None, None]
<span class="w"> </span>    ReprArgs = Sequence[Tuple[Optional[str], Any]]
<span class="gi">+</span>
<span class="w"> </span>    MYPY = False
<span class="w"> </span>    if MYPY:
<span class="w"> </span>        AnyClassMethod = classmethod[Any]
<span class="w"> </span>    else:
<span class="gi">+        # classmethod[TargetType, CallableParamSpecType, CallableReturnType]</span>
<span class="w"> </span>        AnyClassMethod = classmethod[Any, Any, Any]
<span class="gd">-__all__ = (&#39;AnyCallable&#39;, &#39;NoArgAnyCallable&#39;, &#39;NoneType&#39;, &#39;is_none_type&#39;,</span>
<span class="gd">-    &#39;display_as_type&#39;, &#39;resolve_annotations&#39;, &#39;is_callable_type&#39;,</span>
<span class="gd">-    &#39;is_literal_type&#39;, &#39;all_literal_values&#39;, &#39;is_namedtuple&#39;,</span>
<span class="gd">-    &#39;is_typeddict&#39;, &#39;is_typeddict_special&#39;, &#39;is_new_type&#39;,</span>
<span class="gd">-    &#39;new_type_supertype&#39;, &#39;is_classvar&#39;, &#39;is_finalvar&#39;,</span>
<span class="gd">-    &#39;update_field_forward_refs&#39;, &#39;update_model_forward_refs&#39;,</span>
<span class="gd">-    &#39;TupleGenerator&#39;, &#39;DictStrAny&#39;, &#39;DictAny&#39;, &#39;SetStr&#39;, &#39;ListStr&#39;,</span>
<span class="gd">-    &#39;IntStr&#39;, &#39;AbstractSetIntStr&#39;, &#39;DictIntStrAny&#39;, &#39;CallableGenerator&#39;,</span>
<span class="gd">-    &#39;ReprArgs&#39;, &#39;AnyClassMethod&#39;, &#39;CallableGenerator&#39;, &#39;WithArgsTypes&#39;,</span>
<span class="gd">-    &#39;get_args&#39;, &#39;get_origin&#39;, &#39;get_sub_types&#39;, &#39;typing_base&#39;,</span>
<span class="gd">-    &#39;get_all_type_hints&#39;, &#39;is_union&#39;, &#39;StrPath&#39;, &#39;MappingIntStrAny&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &#39;AnyCallable&#39;,</span>
<span class="gi">+    &#39;NoArgAnyCallable&#39;,</span>
<span class="gi">+    &#39;NoneType&#39;,</span>
<span class="gi">+    &#39;is_none_type&#39;,</span>
<span class="gi">+    &#39;display_as_type&#39;,</span>
<span class="gi">+    &#39;resolve_annotations&#39;,</span>
<span class="gi">+    &#39;is_callable_type&#39;,</span>
<span class="gi">+    &#39;is_literal_type&#39;,</span>
<span class="gi">+    &#39;all_literal_values&#39;,</span>
<span class="gi">+    &#39;is_namedtuple&#39;,</span>
<span class="gi">+    &#39;is_typeddict&#39;,</span>
<span class="gi">+    &#39;is_typeddict_special&#39;,</span>
<span class="gi">+    &#39;is_new_type&#39;,</span>
<span class="gi">+    &#39;new_type_supertype&#39;,</span>
<span class="gi">+    &#39;is_classvar&#39;,</span>
<span class="gi">+    &#39;is_finalvar&#39;,</span>
<span class="gi">+    &#39;update_field_forward_refs&#39;,</span>
<span class="gi">+    &#39;update_model_forward_refs&#39;,</span>
<span class="gi">+    &#39;TupleGenerator&#39;,</span>
<span class="gi">+    &#39;DictStrAny&#39;,</span>
<span class="gi">+    &#39;DictAny&#39;,</span>
<span class="gi">+    &#39;SetStr&#39;,</span>
<span class="gi">+    &#39;ListStr&#39;,</span>
<span class="gi">+    &#39;IntStr&#39;,</span>
<span class="gi">+    &#39;AbstractSetIntStr&#39;,</span>
<span class="gi">+    &#39;DictIntStrAny&#39;,</span>
<span class="gi">+    &#39;CallableGenerator&#39;,</span>
<span class="gi">+    &#39;ReprArgs&#39;,</span>
<span class="gi">+    &#39;AnyClassMethod&#39;,</span>
<span class="gi">+    &#39;CallableGenerator&#39;,</span>
<span class="gi">+    &#39;WithArgsTypes&#39;,</span>
<span class="gi">+    &#39;get_args&#39;,</span>
<span class="gi">+    &#39;get_origin&#39;,</span>
<span class="gi">+    &#39;get_sub_types&#39;,</span>
<span class="gi">+    &#39;typing_base&#39;,</span>
<span class="gi">+    &#39;get_all_type_hints&#39;,</span>
<span class="gi">+    &#39;is_union&#39;,</span>
<span class="gi">+    &#39;StrPath&#39;,</span>
<span class="gi">+    &#39;MappingIntStrAny&#39;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>NoneType = None.__class__
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>NONE_TYPES: Tuple[Any, Any, Any] = (None, NoneType, Literal[None])
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 8):
<span class="gi">+    # Even though this implementation is slower, we need it for python 3.7:</span>
<span class="gi">+    # In python 3.7 &quot;Literal&quot; is not a builtin type and uses a different</span>
<span class="gi">+    # mechanism.</span>
<span class="gi">+    # for this reason `Literal[None] is Literal[None]` evaluates to `False`,</span>
<span class="gi">+    # breaking the faster implementation used for the other python versions.</span>
<span class="gi">+</span>
<span class="gi">+    def is_none_type(type_: Any) -&gt; bool:</span>
<span class="gi">+        return type_ in NONE_TYPES</span>
<span class="gi">+</span>
<span class="w"> </span>elif sys.version_info[:2] == (3, 8):

<span class="gi">+    def is_none_type(type_: Any) -&gt; bool:</span>
<span class="gi">+        for none_type in NONE_TYPES:</span>
<span class="gi">+            if type_ is none_type:</span>
<span class="gi">+                return True</span>
<span class="gi">+        # With python 3.8, specifically 3.8.10, Literal &quot;is&quot; check sare very flakey</span>
<span class="gi">+        # can change on very subtle changes like use of types in other modules,</span>
<span class="gi">+        # hopefully this check avoids that issue.</span>
<span class="gi">+        if is_literal_type(type_):  # pragma: no cover</span>
<span class="gi">+            return all_literal_values(type_) == (None,)</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+else:</span>
<span class="gi">+</span>
<span class="gi">+    def is_none_type(type_: Any) -&gt; bool:</span>
<span class="gi">+        return type_ in NONE_TYPES</span>
<span class="gi">+</span>

<span class="gd">-def resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name:</span>
<span class="gd">-    Optional[str]) -&gt;Dict[str, Type[Any]]:</span>
<span class="gi">+def display_as_type(v: Type[Any]) -&gt; str:</span>
<span class="gi">+    if not isinstance(v, typing_base) and not isinstance(v, WithArgsTypes) and not isinstance(v, type):</span>
<span class="gi">+        v = v.__class__</span>
<span class="gi">+</span>
<span class="gi">+    if is_union(get_origin(v)):</span>
<span class="gi">+        return f&#39;Union[{&quot;, &quot;.join(map(display_as_type, get_args(v)))}]&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(v, WithArgsTypes):</span>
<span class="gi">+        # Generic alias are constructs like `list[int]`</span>
<span class="gi">+        return str(v).replace(&#39;typing.&#39;, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return v.__name__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        # happens with typing objects</span>
<span class="gi">+        return str(v).replace(&#39;typing.&#39;, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name: Optional[str]) -&gt; Dict[str, Type[Any]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Partially taken from typing.get_type_hints.

<span class="w"> </span>    Resolve string or ForwardRef annotations into type objects if possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def all_literal_values(type_: Type[Any]) -&gt;Tuple[Any, ...]:</span>
<span class="gi">+    base_globals: Optional[Dict[str, Any]] = None</span>
<span class="gi">+    if module_name:</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = sys.modules[module_name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            base_globals = module.__dict__</span>
<span class="gi">+</span>
<span class="gi">+    annotations = {}</span>
<span class="gi">+    for name, value in raw_annotations.items():</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            if (3, 10) &gt; sys.version_info &gt;= (3, 9, 8) or sys.version_info &gt;= (3, 10, 1):</span>
<span class="gi">+                value = ForwardRef(value, is_argument=False, is_class=True)</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = ForwardRef(value, is_argument=False)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if sys.version_info &gt;= (3, 13):</span>
<span class="gi">+                value = _eval_type(value, base_globals, None, type_params=())</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = _eval_type(value, base_globals, None)</span>
<span class="gi">+        except NameError:</span>
<span class="gi">+            # this is ok, it can be fixed with update_forward_refs</span>
<span class="gi">+            pass</span>
<span class="gi">+        annotations[name] = value</span>
<span class="gi">+    return annotations</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_callable_type(type_: Type[Any]) -&gt; bool:</span>
<span class="gi">+    return type_ is Callable or get_origin(type_) is Callable</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_literal_type(type_: Type[Any]) -&gt; bool:</span>
<span class="gi">+    return Literal is not None and get_origin(type_) in LITERAL_TYPES</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def literal_values(type_: Type[Any]) -&gt; Tuple[Any, ...]:</span>
<span class="gi">+    return get_args(type_)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def all_literal_values(type_: Type[Any]) -&gt; Tuple[Any, ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This method is used to retrieve all Literal values as
<span class="w"> </span>    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)
<span class="w"> </span>    e.g. `Literal[Literal[Literal[1, 2, 3], &quot;foo&quot;], 5, None]`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_literal_type(type_):</span>
<span class="gi">+        return (type_,)</span>
<span class="gi">+</span>
<span class="gi">+    values = literal_values(type_)</span>
<span class="gi">+    return tuple(x for value in values for x in all_literal_values(value))</span>


<span class="gd">-def is_namedtuple(type_: Type[Any]) -&gt;bool:</span>
<span class="gi">+def is_namedtuple(type_: Type[Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if a given class is a named tuple.
<span class="w"> </span>    It can be either a `typing.NamedTuple` or `collections.namedtuple`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from pydantic.v1.utils import lenient_issubclass</span>
<span class="gi">+</span>
<span class="gi">+    return lenient_issubclass(type_, tuple) and hasattr(type_, &#39;_fields&#39;)</span>


<span class="gd">-def is_typeddict(type_: Type[Any]) -&gt;bool:</span>
<span class="gi">+def is_typeddict(type_: Type[Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if a given class is a typed dict (from `typing` or `typing_extensions`)
<span class="w"> </span>    In 3.10, there will be a public method (https://docs.python.org/3.10/library/typing.html#typing.is_typeddict)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from pydantic.v1.utils import lenient_issubclass</span>
<span class="gi">+</span>
<span class="gi">+    return lenient_issubclass(type_, dict) and hasattr(type_, &#39;__total__&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_typeddict_special(type_: Any) -&gt; bool:</span>
<span class="gi">+    return type_ is TypedDictRequired or type_ is TypedDictNotRequired</span>


<span class="gd">-def is_typeddict_special(type_: Any) -&gt;bool:</span>
<span class="gi">+def is_typeddict_special(type_: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if type is a TypedDict special form (Required or NotRequired).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _check_typeddict_special(type_) or _check_typeddict_special(get_origin(type_))</span>


<span class="w"> </span>test_type = NewType(&#39;test_type&#39;, str)


<span class="gd">-def is_new_type(type_: Type[Any]) -&gt;bool:</span>
<span class="gi">+def is_new_type(type_: Type[Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether type_ was created using typing.NewType
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(type_, test_type.__class__) and hasattr(type_, &#39;__supertype__&#39;)  # type: ignore</span>


<span class="gd">-def _check_finalvar(v: Optional[Type[Any]]) -&gt;bool:</span>
<span class="gi">+def new_type_supertype(type_: Type[Any]) -&gt; Type[Any]:</span>
<span class="gi">+    while hasattr(type_, &#39;__supertype__&#39;):</span>
<span class="gi">+        type_ = type_.__supertype__</span>
<span class="gi">+    return type_</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_classvar(v: Optional[Type[Any]]) -&gt; bool:</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return v.__class__ == ClassVar.__class__ and getattr(v, &#39;_name&#39;, None) == &#39;ClassVar&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_finalvar(v: Optional[Type[Any]]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if a given type is a `typing.Final` type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return v.__class__ == Final.__class__ and (sys.version_info &lt; (3, 8) or getattr(v, &#39;_name&#39;, None) == &#39;Final&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_classvar(ann_type: Type[Any]) -&gt; bool:</span>
<span class="gi">+    if _check_classvar(ann_type) or _check_classvar(get_origin(ann_type)):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # this is an ugly workaround for class vars that contain forward references and are therefore themselves</span>
<span class="gi">+    # forward references, see #3679</span>
<span class="gi">+    if ann_type.__class__ == ForwardRef and ann_type.__forward_arg__.startswith(&#39;ClassVar[&#39;):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_finalvar(ann_type: Type[Any]) -&gt; bool:</span>
<span class="gi">+    return _check_finalvar(ann_type) or _check_finalvar(get_origin(ann_type))</span>


<span class="gd">-def update_field_forward_refs(field: &#39;ModelField&#39;, globalns: Any, localns: Any</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+def update_field_forward_refs(field: &#39;ModelField&#39;, globalns: Any, localns: Any) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Try to update ForwardRefs on fields based on this ModelField, globalns and localns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def update_model_forward_refs(model: Type[Any], fields: Iterable[</span>
<span class="gd">-    &#39;ModelField&#39;], json_encoders: Dict[Union[Type[Any], str, ForwardRef],</span>
<span class="gd">-    AnyCallable], localns: &#39;DictStrAny&#39;, exc_to_suppress: Tuple[Type[</span>
<span class="gd">-    BaseException], ...]=()) -&gt;None:</span>
<span class="gi">+    prepare = False</span>
<span class="gi">+    if field.type_.__class__ == ForwardRef:</span>
<span class="gi">+        prepare = True</span>
<span class="gi">+        field.type_ = evaluate_forwardref(field.type_, globalns, localns or None)</span>
<span class="gi">+    if field.outer_type_.__class__ == ForwardRef:</span>
<span class="gi">+        prepare = True</span>
<span class="gi">+        field.outer_type_ = evaluate_forwardref(field.outer_type_, globalns, localns or None)</span>
<span class="gi">+    if prepare:</span>
<span class="gi">+        field.prepare()</span>
<span class="gi">+</span>
<span class="gi">+    if field.sub_fields:</span>
<span class="gi">+        for sub_f in field.sub_fields:</span>
<span class="gi">+            update_field_forward_refs(sub_f, globalns=globalns, localns=localns)</span>
<span class="gi">+</span>
<span class="gi">+    if field.discriminator_key is not None:</span>
<span class="gi">+        field.prepare_discriminated_union_sub_fields()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def update_model_forward_refs(</span>
<span class="gi">+    model: Type[Any],</span>
<span class="gi">+    fields: Iterable[&#39;ModelField&#39;],</span>
<span class="gi">+    json_encoders: Dict[Union[Type[Any], str, ForwardRef], AnyCallable],</span>
<span class="gi">+    localns: &#39;DictStrAny&#39;,</span>
<span class="gi">+    exc_to_suppress: Tuple[Type[BaseException], ...] = (),</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Try to update model fields ForwardRefs based on model and localns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if model.__module__ in sys.modules:</span>
<span class="gi">+        globalns = sys.modules[model.__module__].__dict__.copy()</span>
<span class="gi">+    else:</span>
<span class="gi">+        globalns = {}</span>
<span class="gi">+</span>
<span class="gi">+    globalns.setdefault(model.__name__, model)</span>
<span class="gi">+</span>
<span class="gi">+    for f in fields:</span>
<span class="gi">+        try:</span>
<span class="gi">+            update_field_forward_refs(f, globalns=globalns, localns=localns)</span>
<span class="gi">+        except exc_to_suppress:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    for key in set(json_encoders.keys()):</span>
<span class="gi">+        if isinstance(key, str):</span>
<span class="gi">+            fr: ForwardRef = ForwardRef(key)</span>
<span class="gi">+        elif isinstance(key, ForwardRef):</span>
<span class="gi">+            fr = key</span>
<span class="gi">+        else:</span>
<span class="gi">+            continue</span>

<span class="gi">+        try:</span>
<span class="gi">+            new_key = evaluate_forwardref(fr, globalns, localns or None)</span>
<span class="gi">+        except exc_to_suppress:  # pragma: no cover</span>
<span class="gi">+            continue</span>

<span class="gd">-def get_class(type_: Type[Any]) -&gt;Union[None, bool, Type[Any]]:</span>
<span class="gi">+        json_encoders[new_key] = json_encoders.pop(key)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_class(type_: Type[Any]) -&gt; Union[None, bool, Type[Any]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Tries to get the class of a Type[T] annotation. Returns True if Type is used
<span class="w"> </span>    without brackets. Otherwise returns None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if type_ is type:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if get_origin(type_) is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    args = get_args(type_)</span>
<span class="gi">+    if not args or not isinstance(args[0], type):</span>
<span class="gi">+        return True</span>
<span class="gi">+    else:</span>
<span class="gi">+        return args[0]</span>


<span class="gd">-def get_sub_types(tp: Any) -&gt;List[Any]:</span>
<span class="gi">+def get_sub_types(tp: Any) -&gt; List[Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return all the types that are allowed by type `tp`
<span class="w"> </span>    `tp` can be a `Union` of allowed types or an `Annotated` type
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    origin = get_origin(tp)</span>
<span class="gi">+    if origin is Annotated:</span>
<span class="gi">+        return get_sub_types(get_args(tp)[0])</span>
<span class="gi">+    elif is_union(origin):</span>
<span class="gi">+        return [x for t in get_args(tp) for x in get_sub_types(t)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return [tp]</span>
<span class="gh">diff --git a/pydantic/v1/utils.py b/pydantic/v1/utils.py</span>
<span class="gh">index effb78d4d..a09997bc5 100644</span>
<span class="gd">--- a/pydantic/v1/utils.py</span>
<span class="gi">+++ b/pydantic/v1/utils.py</span>
<span class="gu">@@ -5,107 +5,346 @@ from collections import OrderedDict, defaultdict, deque</span>
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from itertools import islice, zip_longest
<span class="w"> </span>from types import BuiltinFunctionType, CodeType, FunctionType, GeneratorType, LambdaType, ModuleType
<span class="gd">-from typing import TYPE_CHECKING, AbstractSet, Any, Callable, Collection, Dict, Generator, Iterable, Iterator, List, Mapping, NoReturn, Optional, Set, Tuple, Type, TypeVar, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    AbstractSet,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Collection,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    NoReturn,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from typing_extensions import Annotated
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1.errors import ConfigError
<span class="gd">-from pydantic.v1.typing import NoneType, WithArgsTypes, all_literal_values, display_as_type, get_args, get_origin, is_literal_type, is_union</span>
<span class="gi">+from pydantic.v1.typing import (</span>
<span class="gi">+    NoneType,</span>
<span class="gi">+    WithArgsTypes,</span>
<span class="gi">+    all_literal_values,</span>
<span class="gi">+    display_as_type,</span>
<span class="gi">+    get_args,</span>
<span class="gi">+    get_origin,</span>
<span class="gi">+    is_literal_type,</span>
<span class="gi">+    is_union,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pydantic.v1.version import version_info
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from inspect import Signature
<span class="w"> </span>    from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>    from pydantic.v1.config import BaseConfig
<span class="w"> </span>    from pydantic.v1.dataclasses import Dataclass
<span class="w"> </span>    from pydantic.v1.fields import ModelField
<span class="w"> </span>    from pydantic.v1.main import BaseModel
<span class="w"> </span>    from pydantic.v1.typing import AbstractSetIntStr, DictIntStrAny, IntStr, MappingIntStrAny, ReprArgs
<span class="gd">-    RichReprResult = Iterable[Union[Any, Tuple[Any], Tuple[str, Any], Tuple</span>
<span class="gd">-        [str, Any, Any]]]</span>
<span class="gd">-__all__ = (&#39;import_string&#39;, &#39;sequence_like&#39;, &#39;validate_field_name&#39;,</span>
<span class="gd">-    &#39;lenient_isinstance&#39;, &#39;lenient_issubclass&#39;, &#39;in_ipython&#39;,</span>
<span class="gd">-    &#39;is_valid_identifier&#39;, &#39;deep_update&#39;, &#39;update_not_none&#39;,</span>
<span class="gd">-    &#39;almost_equal_floats&#39;, &#39;get_model&#39;, &#39;to_camel&#39;, &#39;is_valid_field&#39;,</span>
<span class="gd">-    &#39;smart_deepcopy&#39;, &#39;PyObjectStr&#39;, &#39;Representation&#39;, &#39;GetterDict&#39;,</span>
<span class="gd">-    &#39;ValueItems&#39;, &#39;version_info&#39;, &#39;ClassAttribute&#39;, &#39;path_type&#39;, &#39;ROOT_KEY&#39;,</span>
<span class="gd">-    &#39;get_unique_discriminator_alias&#39;, &#39;get_discriminator_alias_and_values&#39;,</span>
<span class="gd">-    &#39;DUNDER_ATTRIBUTES&#39;)</span>
<span class="gd">-ROOT_KEY = &#39;__root__&#39;</span>
<span class="gd">-IMMUTABLE_NON_COLLECTIONS_TYPES: Set[Type[Any]] = {int, float, complex, str,</span>
<span class="gd">-    bool, bytes, type, NoneType, FunctionType, BuiltinFunctionType,</span>
<span class="gd">-    LambdaType, weakref.ref, CodeType, ModuleType, NotImplemented.__class__,</span>
<span class="gd">-    Ellipsis.__class__}</span>
<span class="gd">-BUILTIN_COLLECTIONS: Set[Type[Any]] = {list, set, tuple, frozenset, dict,</span>
<span class="gd">-    OrderedDict, defaultdict, deque}</span>

<span class="gi">+    RichReprResult = Iterable[Union[Any, Tuple[Any], Tuple[str, Any], Tuple[str, Any, Any]]]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &#39;import_string&#39;,</span>
<span class="gi">+    &#39;sequence_like&#39;,</span>
<span class="gi">+    &#39;validate_field_name&#39;,</span>
<span class="gi">+    &#39;lenient_isinstance&#39;,</span>
<span class="gi">+    &#39;lenient_issubclass&#39;,</span>
<span class="gi">+    &#39;in_ipython&#39;,</span>
<span class="gi">+    &#39;is_valid_identifier&#39;,</span>
<span class="gi">+    &#39;deep_update&#39;,</span>
<span class="gi">+    &#39;update_not_none&#39;,</span>
<span class="gi">+    &#39;almost_equal_floats&#39;,</span>
<span class="gi">+    &#39;get_model&#39;,</span>
<span class="gi">+    &#39;to_camel&#39;,</span>
<span class="gi">+    &#39;is_valid_field&#39;,</span>
<span class="gi">+    &#39;smart_deepcopy&#39;,</span>
<span class="gi">+    &#39;PyObjectStr&#39;,</span>
<span class="gi">+    &#39;Representation&#39;,</span>
<span class="gi">+    &#39;GetterDict&#39;,</span>
<span class="gi">+    &#39;ValueItems&#39;,</span>
<span class="gi">+    &#39;version_info&#39;,  # required here to match behaviour in v1.3</span>
<span class="gi">+    &#39;ClassAttribute&#39;,</span>
<span class="gi">+    &#39;path_type&#39;,</span>
<span class="gi">+    &#39;ROOT_KEY&#39;,</span>
<span class="gi">+    &#39;get_unique_discriminator_alias&#39;,</span>
<span class="gi">+    &#39;get_discriminator_alias_and_values&#39;,</span>
<span class="gi">+    &#39;DUNDER_ATTRIBUTES&#39;,</span>
<span class="gi">+)</span>

<span class="gd">-def import_string(dotted_path: str) -&gt;Any:</span>
<span class="gi">+ROOT_KEY = &#39;__root__&#39;</span>
<span class="gi">+# these are types that are returned unchanged by deepcopy</span>
<span class="gi">+IMMUTABLE_NON_COLLECTIONS_TYPES: Set[Type[Any]] = {</span>
<span class="gi">+    int,</span>
<span class="gi">+    float,</span>
<span class="gi">+    complex,</span>
<span class="gi">+    str,</span>
<span class="gi">+    bool,</span>
<span class="gi">+    bytes,</span>
<span class="gi">+    type,</span>
<span class="gi">+    NoneType,</span>
<span class="gi">+    FunctionType,</span>
<span class="gi">+    BuiltinFunctionType,</span>
<span class="gi">+    LambdaType,</span>
<span class="gi">+    weakref.ref,</span>
<span class="gi">+    CodeType,</span>
<span class="gi">+    # note: including ModuleType will differ from behaviour of deepcopy by not producing error.</span>
<span class="gi">+    # It might be not a good idea in general, but considering that this function used only internally</span>
<span class="gi">+    # against default values of fields, this will allow to actually have a field with module as default value</span>
<span class="gi">+    ModuleType,</span>
<span class="gi">+    NotImplemented.__class__,</span>
<span class="gi">+    Ellipsis.__class__,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# these are types that if empty, might be copied with simple copy() instead of deepcopy()</span>
<span class="gi">+BUILTIN_COLLECTIONS: Set[Type[Any]] = {</span>
<span class="gi">+    list,</span>
<span class="gi">+    set,</span>
<span class="gi">+    tuple,</span>
<span class="gi">+    frozenset,</span>
<span class="gi">+    dict,</span>
<span class="gi">+    OrderedDict,</span>
<span class="gi">+    defaultdict,</span>
<span class="gi">+    deque,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def import_string(dotted_path: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Stolen approximately from django. Import a dotted module path and return the attribute/class designated by the
<span class="w"> </span>    last name in the path. Raise ImportError if the import fails.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from importlib import import_module</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_path, class_name = dotted_path.strip(&#39; &#39;).rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise ImportError(f&#39;&quot;{dotted_path}&quot; doesn\&#39;t look like a module path&#39;) from e</span>

<span class="gi">+    module = import_module(module_path)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return getattr(module, class_name)</span>
<span class="gi">+    except AttributeError as e:</span>
<span class="gi">+        raise ImportError(f&#39;Module &quot;{module_path}&quot; does not define a &quot;{class_name}&quot; attribute&#39;) from e</span>

<span class="gd">-def truncate(v: Union[str], *, max_len: int=80) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def truncate(v: Union[str], *, max_len: int = 80) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Truncate a value and add a unicode ellipsis (three dots) to the end if it was too long
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(&#39;`truncate` is no-longer used by pydantic and is deprecated&#39;, DeprecationWarning)</span>
<span class="gi">+    if isinstance(v, str) and len(v) &gt; (max_len - 2):</span>
<span class="gi">+        # -3 so quote + string + … + quote has correct length</span>
<span class="gi">+        return (v[: (max_len - 3)] + &#39;…&#39;).__repr__()</span>
<span class="gi">+    try:</span>
<span class="gi">+        v = v.__repr__()</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        v = v.__class__.__repr__(v)  # in case v is a type</span>
<span class="gi">+    if len(v) &gt; max_len:</span>
<span class="gi">+        v = v[: max_len - 1] + &#39;…&#39;</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>

<span class="gi">+def sequence_like(v: Any) -&gt; bool:</span>
<span class="gi">+    return isinstance(v, (list, tuple, set, frozenset, GeneratorType, deque))</span>

<span class="gd">-def validate_field_name(bases: List[Type[&#39;BaseModel&#39;]], field_name: str</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def validate_field_name(bases: List[Type[&#39;BaseModel&#39;]], field_name: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Ensure that the field&#39;s name does not shadow an existing attribute of the model.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for base in bases:</span>
<span class="gi">+        if getattr(base, field_name, None):</span>
<span class="gi">+            raise NameError(</span>
<span class="gi">+                f&#39;Field name &quot;{field_name}&quot; shadows a BaseModel attribute; &#39;</span>
<span class="gi">+                f&#39;use a different field name with &quot;alias=\&#39;{field_name}\&#39;&quot;.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lenient_isinstance(o: Any, class_or_tuple: Union[Type[Any], Tuple[Type[Any], ...], None]) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return isinstance(o, class_or_tuple)  # type: ignore[arg-type]</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lenient_issubclass(cls: Any, class_or_tuple: Union[Type[Any], Tuple[Type[Any], ...], None]) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return isinstance(cls, type) and issubclass(cls, class_or_tuple)  # type: ignore[arg-type]</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        if isinstance(cls, WithArgsTypes):</span>
<span class="gi">+            return False</span>
<span class="gi">+        raise  # pragma: no cover</span>


<span class="gd">-def in_ipython() -&gt;bool:</span>
<span class="gi">+def in_ipython() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether we&#39;re in an ipython environment, including jupyter notebooks.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        eval(&#39;__IPYTHON__&#39;)</span>
<span class="gi">+    except NameError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:  # pragma: no cover</span>
<span class="gi">+        return True</span>


<span class="gd">-def is_valid_identifier(identifier: str) -&gt;bool:</span>
<span class="gi">+def is_valid_identifier(identifier: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks that a string is a valid identifier and not a Python keyword.
<span class="w"> </span>    :param identifier: The identifier to test.
<span class="w"> </span>    :return: True if the identifier is valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return identifier.isidentifier() and not keyword.iskeyword(identifier)</span>


<span class="w"> </span>KeyType = TypeVar(&#39;KeyType&#39;)


<span class="gd">-def almost_equal_floats(value_1: float, value_2: float, *, delta: float=1e-08</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def deep_update(mapping: Dict[KeyType, Any], *updating_mappings: Dict[KeyType, Any]) -&gt; Dict[KeyType, Any]:</span>
<span class="gi">+    updated_mapping = mapping.copy()</span>
<span class="gi">+    for updating_mapping in updating_mappings:</span>
<span class="gi">+        for k, v in updating_mapping.items():</span>
<span class="gi">+            if k in updated_mapping and isinstance(updated_mapping[k], dict) and isinstance(v, dict):</span>
<span class="gi">+                updated_mapping[k] = deep_update(updated_mapping[k], v)</span>
<span class="gi">+            else:</span>
<span class="gi">+                updated_mapping[k] = v</span>
<span class="gi">+    return updated_mapping</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def update_not_none(mapping: Dict[Any, Any], **update: Any) -&gt; None:</span>
<span class="gi">+    mapping.update({k: v for k, v in update.items() if v is not None})</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def almost_equal_floats(value_1: float, value_2: float, *, delta: float = 1e-8) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return True if two floats are almost equal
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return abs(value_1 - value_2) &lt;= delta</span>


<span class="gd">-def generate_model_signature(init: Callable[..., None], fields: Dict[str,</span>
<span class="gd">-    &#39;ModelField&#39;], config: Type[&#39;BaseConfig&#39;]) -&gt;&#39;Signature&#39;:</span>
<span class="gi">+def generate_model_signature(</span>
<span class="gi">+    init: Callable[..., None], fields: Dict[str, &#39;ModelField&#39;], config: Type[&#39;BaseConfig&#39;]</span>
<span class="gi">+) -&gt; &#39;Signature&#39;:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Generate signature for model based on its fields
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from inspect import Parameter, Signature, signature</span>
<span class="gi">+</span>
<span class="gi">+    from pydantic.v1.config import Extra</span>
<span class="gi">+</span>
<span class="gi">+    present_params = signature(init).parameters.values()</span>
<span class="gi">+    merged_params: Dict[str, Parameter] = {}</span>
<span class="gi">+    var_kw = None</span>
<span class="gi">+    use_var_kw = False</span>
<span class="gi">+</span>
<span class="gi">+    for param in islice(present_params, 1, None):  # skip self arg</span>
<span class="gi">+        if param.kind is param.VAR_KEYWORD:</span>
<span class="gi">+            var_kw = param</span>
<span class="gi">+            continue</span>
<span class="gi">+        merged_params[param.name] = param</span>
<span class="gi">+</span>
<span class="gi">+    if var_kw:  # if custom init has no var_kw, fields which are not declared in it cannot be passed through</span>
<span class="gi">+        allow_names = config.allow_population_by_field_name</span>
<span class="gi">+        for field_name, field in fields.items():</span>
<span class="gi">+            param_name = field.alias</span>
<span class="gi">+            if field_name in merged_params or param_name in merged_params:</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif not is_valid_identifier(param_name):</span>
<span class="gi">+                if allow_names and is_valid_identifier(field_name):</span>
<span class="gi">+                    param_name = field_name</span>
<span class="gi">+                else:</span>
<span class="gi">+                    use_var_kw = True</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            # TODO: replace annotation with actual expected types once #1055 solved</span>
<span class="gi">+            kwargs = {&#39;default&#39;: field.default} if not field.required else {}</span>
<span class="gi">+            merged_params[param_name] = Parameter(</span>
<span class="gi">+                param_name, Parameter.KEYWORD_ONLY, annotation=field.annotation, **kwargs</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    if config.extra is Extra.allow:</span>
<span class="gi">+        use_var_kw = True</span>
<span class="gi">+</span>
<span class="gi">+    if var_kw and use_var_kw:</span>
<span class="gi">+        # Make sure the parameter for extra kwargs</span>
<span class="gi">+        # does not have the same name as a field</span>
<span class="gi">+        default_model_signature = [</span>
<span class="gi">+            (&#39;__pydantic_self__&#39;, Parameter.POSITIONAL_OR_KEYWORD),</span>
<span class="gi">+            (&#39;data&#39;, Parameter.VAR_KEYWORD),</span>
<span class="gi">+        ]</span>
<span class="gi">+        if [(p.name, p.kind) for p in present_params] == default_model_signature:</span>
<span class="gi">+            # if this is the standard model signature, use extra_data as the extra args name</span>
<span class="gi">+            var_kw_name = &#39;extra_data&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            # else start from var_kw</span>
<span class="gi">+            var_kw_name = var_kw.name</span>
<span class="gi">+</span>
<span class="gi">+        # generate a name that&#39;s definitely unique</span>
<span class="gi">+        while var_kw_name in fields:</span>
<span class="gi">+            var_kw_name += &#39;_&#39;</span>
<span class="gi">+        merged_params[var_kw_name] = var_kw.replace(name=var_kw_name)</span>
<span class="gi">+</span>
<span class="gi">+    return Signature(parameters=list(merged_params.values()), return_annotation=None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_model(obj: Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]]) -&gt; Type[&#39;BaseModel&#39;]:</span>
<span class="gi">+    from pydantic.v1.main import BaseModel</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        model_cls = obj.__pydantic_model__  # type: ignore</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        model_cls = obj</span>
<span class="gi">+</span>
<span class="gi">+    if not issubclass(model_cls, BaseModel):</span>
<span class="gi">+        raise TypeError(&#39;Unsupported type, must be either BaseModel or dataclass&#39;)</span>
<span class="gi">+    return model_cls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_camel(string: str) -&gt; str:</span>
<span class="gi">+    return &#39;&#39;.join(word.capitalize() for word in string.split(&#39;_&#39;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_lower_camel(string: str) -&gt; str:</span>
<span class="gi">+    if len(string) &gt;= 1:</span>
<span class="gi">+        pascal_string = to_camel(string)</span>
<span class="gi">+        return pascal_string[0].lower() + pascal_string[1:]</span>
<span class="gi">+    return string.lower()</span>


<span class="w"> </span>T = TypeVar(&#39;T&#39;)


<span class="gd">-def unique_list(input_list: Union[List[T], Tuple[T, ...]], *, name_factory:</span>
<span class="gd">-    Callable[[T], str]=str) -&gt;List[T]:</span>
<span class="gi">+def unique_list(</span>
<span class="gi">+    input_list: Union[List[T], Tuple[T, ...]],</span>
<span class="gi">+    *,</span>
<span class="gi">+    name_factory: Callable[[T], str] = str,</span>
<span class="gi">+) -&gt; List[T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Make a list unique while maintaining order.
<span class="w"> </span>    We update the list if another one with the same name is set
<span class="w"> </span>    (e.g. root validator overridden in subclass)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result: List[T] = []</span>
<span class="gi">+    result_names: List[str] = []</span>
<span class="gi">+    for v in input_list:</span>
<span class="gi">+        v_name = name_factory(v)</span>
<span class="gi">+        if v_name not in result_names:</span>
<span class="gi">+            result_names.append(v_name)</span>
<span class="gi">+            result.append(v)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result[result_names.index(v_name)] = v</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class PyObjectStr(str):
<span class="gu">@@ -114,7 +353,7 @@ class PyObjectStr(str):</span>
<span class="w"> </span>    representation of something that valid (or pseudo-valid) python.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self)


<span class="gu">@@ -125,9 +364,10 @@ class Representation:</span>
<span class="w"> </span>    __pretty__ is used by [devtools](https://python-devtools.helpmanual.io/) to provide human readable representations
<span class="w"> </span>    of objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__: Tuple[str, ...] = tuple()

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.

<span class="gu">@@ -138,18 +378,16 @@ class Representation:</span>
<span class="w"> </span>        attrs = ((s, getattr(self, s)) for s in self.__slots__)
<span class="w"> </span>        return [(a, v) for a, v in attrs if v is not None]

<span class="gd">-    def __repr_name__(self) -&gt;str:</span>
<span class="gi">+    def __repr_name__(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Name of the instance&#39;s class, used in __repr__.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self.__class__.__name__

<span class="gd">-    def __repr_str__(self, join_str: str) -&gt;str:</span>
<span class="gd">-        return join_str.join(repr(v) if a is None else f&#39;{a}={v!r}&#39; for a,</span>
<span class="gd">-            v in self.__repr_args__())</span>
<span class="gi">+    def __repr_str__(self, join_str: str) -&gt; str:</span>
<span class="gi">+        return join_str.join(repr(v) if a is None else f&#39;{a}={v!r}&#39; for a, v in self.__repr_args__())</span>

<span class="gd">-    def __pretty__(self, fmt: Callable[[Any], Any], **kwargs: Any) -&gt;Generator[</span>
<span class="gd">-        Any, None, None]:</span>
<span class="gi">+    def __pretty__(self, fmt: Callable[[Any], Any], **kwargs: Any) -&gt; Generator[Any, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used by devtools (https://python-devtools.helpmanual.io/) to provide a human readable representations of objects
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -164,13 +402,13 @@ class Representation:</span>
<span class="w"> </span>        yield -1
<span class="w"> </span>        yield &#39;)&#39;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.__repr_str__(&#39; &#39;)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&quot;{self.__repr_name__()}({self.__repr_str__(&#39;, &#39;)})&quot;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&#39;{self.__repr_name__()}({self.__repr_str__(&quot;, &quot;)})&#39;</span>

<span class="gd">-    def __rich_repr__(self) -&gt;&#39;RichReprResult&#39;:</span>
<span class="gi">+    def __rich_repr__(self) -&gt; &#39;RichReprResult&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get fields for Rich library&quot;&quot;&quot;
<span class="w"> </span>        for name, field_repr in self.__repr_args__():
<span class="w"> </span>            if name is None:
<span class="gu">@@ -185,48 +423,59 @@ class GetterDict(Representation):</span>

<span class="w"> </span>    We can&#39;t inherit from Mapping[str, Any] because it upsets cython so we have to implement all methods ourselves.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_obj&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&#39;_obj&#39;,)</span>

<span class="w"> </span>    def __init__(self, obj: Any):
<span class="w"> </span>        self._obj = obj

<span class="gd">-    def __getitem__(self, key: str) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, key: str) -&gt; Any:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return getattr(self._obj, key)
<span class="w"> </span>        except AttributeError as e:
<span class="w"> </span>            raise KeyError(key) from e

<span class="gd">-    def extra_keys(self) -&gt;Set[Any]:</span>
<span class="gi">+    def get(self, key: Any, default: Any = None) -&gt; Any:</span>
<span class="gi">+        return getattr(self._obj, key, default)</span>
<span class="gi">+</span>
<span class="gi">+    def extra_keys(self) -&gt; Set[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        We don&#39;t want to get any other attributes of obj if the model didn&#39;t explicitly ask for them
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return set()</span>

<span class="gd">-    def keys(self) -&gt;List[Any]:</span>
<span class="gi">+    def keys(self) -&gt; List[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Keys of the pseudo dictionary, uses a list not set so order information can be maintained like python
<span class="w"> </span>        dictionaries.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self)</span>
<span class="gi">+</span>
<span class="gi">+    def values(self) -&gt; List[Any]:</span>
<span class="gi">+        return [self[k] for k in self]</span>

<span class="gd">-    def __iter__(self) -&gt;Iterator[str]:</span>
<span class="gi">+    def items(self) -&gt; Iterator[Tuple[str, Any]]:</span>
<span class="gi">+        for k in self:</span>
<span class="gi">+            yield k, self.get(k)</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[str]:</span>
<span class="w"> </span>        for name in dir(self._obj):
<span class="w"> </span>            if not name.startswith(&#39;_&#39;):
<span class="w"> </span>                yield name

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return sum(1 for _ in self)

<span class="gd">-    def __contains__(self, item: Any) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, item: Any) -&gt; bool:</span>
<span class="w"> </span>        return item in self.keys()

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        return dict(self) == dict(other.items())

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="w"> </span>        return [(None, dict(self))]

<span class="gd">-    def __repr_name__(self) -&gt;str:</span>
<span class="gi">+    def __repr_name__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;GetterDict[{display_as_type(self._obj)}]&#39;


<span class="gu">@@ -234,41 +483,43 @@ class ValueItems(Representation):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Class for more convenient calculation of excluded or included fields on values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_items&#39;, &#39;_type&#39;</span>

<span class="gd">-    def __init__(self, value: Any, items: Union[&#39;AbstractSetIntStr&#39;,</span>
<span class="gd">-        &#39;MappingIntStrAny&#39;]) -&gt;None:</span>
<span class="gi">+    __slots__ = (&#39;_items&#39;, &#39;_type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, value: Any, items: Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]) -&gt; None:</span>
<span class="w"> </span>        items = self._coerce_items(items)
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(value, (list, tuple)):
<span class="w"> </span>            items = self._normalize_indexes(items, len(value))
<span class="gi">+</span>
<span class="w"> </span>        self._items: &#39;MappingIntStrAny&#39; = items

<span class="gd">-    def is_excluded(self, item: Any) -&gt;bool:</span>
<span class="gi">+    def is_excluded(self, item: Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Check if item is fully excluded.

<span class="w"> </span>        :param item: key or index of a value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.is_true(self._items.get(item))</span>

<span class="gd">-    def is_included(self, item: Any) -&gt;bool:</span>
<span class="gi">+    def is_included(self, item: Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Check if value is contained in self._items

<span class="w"> </span>        :param item: key or index of value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return item in self._items</span>

<span class="gd">-    def for_element(self, e: &#39;IntStr&#39;) -&gt;Optional[Union[&#39;AbstractSetIntStr&#39;,</span>
<span class="gd">-        &#39;MappingIntStrAny&#39;]]:</span>
<span class="gi">+    def for_element(self, e: &#39;IntStr&#39;) -&gt; Optional[Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param e: key or index of element on value
<span class="w"> </span>        :return: raw values for element if self._items is dict and contain needed element
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _normalize_indexes(self, items: &#39;MappingIntStrAny&#39;, v_length: int</span>
<span class="gd">-        ) -&gt;&#39;DictIntStrAny&#39;:</span>
<span class="gi">+        item = self._items.get(e)</span>
<span class="gi">+        return item if not self.is_true(item) else None</span>
<span class="gi">+</span>
<span class="gi">+    def _normalize_indexes(self, items: &#39;MappingIntStrAny&#39;, v_length: int) -&gt; &#39;DictIntStrAny&#39;:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param items: dict or set of indexes which will be normalized
<span class="w"> </span>        :param v_length: length of sequence indexes of which will be
<span class="gu">@@ -278,10 +529,37 @@ class ValueItems(Representation):</span>
<span class="w"> </span>        &gt;&gt;&gt; self._normalize_indexes({&#39;__all__&#39;: True}, 4)
<span class="w"> </span>        {0: True, 1: True, 2: True, 3: True}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        normalized_items: &#39;DictIntStrAny&#39; = {}</span>
<span class="gi">+        all_items = None</span>
<span class="gi">+        for i, v in items.items():</span>
<span class="gi">+            if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or self.is_true(v)):</span>
<span class="gi">+                raise TypeError(f&#39;Unexpected type of exclude value for index &quot;{i}&quot; {v.__class__}&#39;)</span>
<span class="gi">+            if i == &#39;__all__&#39;:</span>
<span class="gi">+                all_items = self._coerce_value(v)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(i, int):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &#39;Excluding fields from a sequence of sub-models or dicts must be performed index-wise: &#39;</span>
<span class="gi">+                    &#39;expected integer keys or keyword &quot;__all__&quot;&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            normalized_i = v_length + i if i &lt; 0 else i</span>
<span class="gi">+            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))</span>
<span class="gi">+</span>
<span class="gi">+        if not all_items:</span>
<span class="gi">+            return normalized_items</span>
<span class="gi">+        if self.is_true(all_items):</span>
<span class="gi">+            for i in range(v_length):</span>
<span class="gi">+                normalized_items.setdefault(i, ...)</span>
<span class="gi">+            return normalized_items</span>
<span class="gi">+        for i in range(v_length):</span>
<span class="gi">+            normalized_item = normalized_items.setdefault(i, {})</span>
<span class="gi">+            if not self.is_true(normalized_item):</span>
<span class="gi">+                normalized_items[i] = self.merge(all_items, normalized_item)</span>
<span class="gi">+        return normalized_items</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def merge(cls, base: Any, override: Any, intersect: bool=False) -&gt;Any:</span>
<span class="gi">+    def merge(cls, base: Any, override: Any, intersect: bool = False) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Merge a ``base`` item with an ``override`` item.

<span class="gu">@@ -296,9 +574,54 @@ class ValueItems(Representation):</span>
<span class="w"> </span>        set to ``False`` (default) and on the intersection of keys if
<span class="w"> </span>        ``intersect`` is set to ``True``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        override = cls._coerce_value(override)</span>
<span class="gi">+        base = cls._coerce_value(base)</span>
<span class="gi">+        if override is None:</span>
<span class="gi">+            return base</span>
<span class="gi">+        if cls.is_true(base) or base is None:</span>
<span class="gi">+            return override</span>
<span class="gi">+        if cls.is_true(override):</span>
<span class="gi">+            return base if intersect else override</span>
<span class="gi">+</span>
<span class="gi">+        # intersection or union of keys while preserving ordering:</span>
<span class="gi">+        if intersect:</span>
<span class="gi">+            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]</span>
<span class="gi">+        else:</span>
<span class="gi">+            merge_keys = list(base) + [k for k in override if k not in base]</span>
<span class="gi">+</span>
<span class="gi">+        merged: &#39;DictIntStrAny&#39; = {}</span>
<span class="gi">+        for k in merge_keys:</span>
<span class="gi">+            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)</span>
<span class="gi">+            if merged_item is not None:</span>
<span class="gi">+                merged[k] = merged_item</span>
<span class="gi">+</span>
<span class="gi">+        return merged</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _coerce_items(items: Union[&#39;AbstractSetIntStr&#39;, &#39;MappingIntStrAny&#39;]) -&gt; &#39;MappingIntStrAny&#39;:</span>
<span class="gi">+        if isinstance(items, Mapping):</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif isinstance(items, AbstractSet):</span>
<span class="gi">+            items = dict.fromkeys(items, ...)</span>
<span class="gi">+        else:</span>
<span class="gi">+            class_name = getattr(items, &#39;__class__&#39;, &#39;???&#39;)</span>
<span class="gi">+            assert_never(</span>
<span class="gi">+                items,</span>
<span class="gi">+                f&#39;Unexpected type of exclude value {class_name}&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+        return items</span>

<span class="gd">-    def __repr_args__(self) -&gt;&#39;ReprArgs&#39;:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _coerce_value(cls, value: Any) -&gt; Any:</span>
<span class="gi">+        if value is None or cls.is_true(value):</span>
<span class="gi">+            return value</span>
<span class="gi">+        return cls._coerce_items(value)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def is_true(v: Any) -&gt; bool:</span>
<span class="gi">+        return v is True or v is ...</span>
<span class="gi">+</span>
<span class="gi">+    def __repr_args__(self) -&gt; &#39;ReprArgs&#39;:</span>
<span class="w"> </span>        return [(None, self._items)]


<span class="gu">@@ -306,50 +629,95 @@ class ClassAttribute:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Hide class attribute from its instances
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;name&#39;, &#39;value&#39;</span>

<span class="gd">-    def __init__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;name&#39;,</span>
<span class="gi">+        &#39;value&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.value = value

<span class="gd">-    def __get__(self, instance: Any, owner: Type[Any]) -&gt;None:</span>
<span class="gi">+    def __get__(self, instance: Any, owner: Type[Any]) -&gt; None:</span>
<span class="w"> </span>        if instance is None:
<span class="w"> </span>            return self.value
<span class="gd">-        raise AttributeError(</span>
<span class="gd">-            f&#39;{self.name!r} attribute of {owner.__name__!r} is class-only&#39;)</span>
<span class="gi">+        raise AttributeError(f&#39;{self.name!r} attribute of {owner.__name__!r} is class-only&#39;)</span>


<span class="gd">-path_types = {&#39;is_dir&#39;: &#39;directory&#39;, &#39;is_file&#39;: &#39;file&#39;, &#39;is_mount&#39;:</span>
<span class="gd">-    &#39;mount point&#39;, &#39;is_symlink&#39;: &#39;symlink&#39;, &#39;is_block_device&#39;:</span>
<span class="gd">-    &#39;block device&#39;, &#39;is_char_device&#39;: &#39;char device&#39;, &#39;is_fifo&#39;: &#39;FIFO&#39;,</span>
<span class="gd">-    &#39;is_socket&#39;: &#39;socket&#39;}</span>
<span class="gi">+path_types = {</span>
<span class="gi">+    &#39;is_dir&#39;: &#39;directory&#39;,</span>
<span class="gi">+    &#39;is_file&#39;: &#39;file&#39;,</span>
<span class="gi">+    &#39;is_mount&#39;: &#39;mount point&#39;,</span>
<span class="gi">+    &#39;is_symlink&#39;: &#39;symlink&#39;,</span>
<span class="gi">+    &#39;is_block_device&#39;: &#39;block device&#39;,</span>
<span class="gi">+    &#39;is_char_device&#39;: &#39;char device&#39;,</span>
<span class="gi">+    &#39;is_fifo&#39;: &#39;FIFO&#39;,</span>
<span class="gi">+    &#39;is_socket&#39;: &#39;socket&#39;,</span>
<span class="gi">+}</span>


<span class="gd">-def path_type(p: &#39;Path&#39;) -&gt;str:</span>
<span class="gi">+def path_type(p: &#39;Path&#39;) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Find out what sort of thing a path is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert p.exists(), &#39;path does not exist&#39;</span>
<span class="gi">+    for method, name in path_types.items():</span>
<span class="gi">+        if getattr(p, method)():</span>
<span class="gi">+            return name</span>
<span class="gi">+</span>
<span class="gi">+    return &#39;unknown&#39;</span>


<span class="w"> </span>Obj = TypeVar(&#39;Obj&#39;)


<span class="gd">-def smart_deepcopy(obj: Obj) -&gt;Obj:</span>
<span class="gi">+def smart_deepcopy(obj: Obj) -&gt; Obj:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return type as is for immutable built-in types
<span class="w"> </span>    Use obj.copy() for built-in empty collections
<span class="w"> </span>    Use copy.deepcopy() for non-empty collections and unknown objects
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    obj_type = obj.__class__</span>
<span class="gi">+    if obj_type in IMMUTABLE_NON_COLLECTIONS_TYPES:</span>
<span class="gi">+        return obj  # fastest case: obj is immutable and not collection therefore will not be copied anyway</span>
<span class="gi">+    try:</span>
<span class="gi">+        if not obj and obj_type in BUILTIN_COLLECTIONS:</span>
<span class="gi">+            # faster way for empty collections, no need to copy its members</span>
<span class="gi">+            return obj if obj_type is tuple else obj.copy()  # type: ignore  # tuple doesn&#39;t have copy method</span>
<span class="gi">+    except (TypeError, ValueError, RuntimeError):</span>
<span class="gi">+        # do we really dare to catch ALL errors? Seems a bit risky</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return deepcopy(obj)  # slowest way when we actually might need a deepcopy</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_valid_field(name: str) -&gt; bool:</span>
<span class="gi">+    if not name.startswith(&#39;_&#39;):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return ROOT_KEY == name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DUNDER_ATTRIBUTES = {</span>
<span class="gi">+    &#39;__annotations__&#39;,</span>
<span class="gi">+    &#39;__classcell__&#39;,</span>
<span class="gi">+    &#39;__doc__&#39;,</span>
<span class="gi">+    &#39;__module__&#39;,</span>
<span class="gi">+    &#39;__orig_bases__&#39;,</span>
<span class="gi">+    &#39;__orig_class__&#39;,</span>
<span class="gi">+    &#39;__qualname__&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_valid_private_name(name: str) -&gt; bool:</span>
<span class="gi">+    return not is_valid_field(name) and name not in DUNDER_ATTRIBUTES</span>


<span class="gd">-DUNDER_ATTRIBUTES = {&#39;__annotations__&#39;, &#39;__classcell__&#39;, &#39;__doc__&#39;,</span>
<span class="gd">-    &#39;__module__&#39;, &#39;__orig_bases__&#39;, &#39;__orig_class__&#39;, &#39;__qualname__&#39;}</span>
<span class="w"> </span>_EMPTY = object()


<span class="gd">-def all_identical(left: Iterable[Any], right: Iterable[Any]) -&gt;bool:</span>
<span class="gi">+def all_identical(left: Iterable[Any], right: Iterable[Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check that the items of `left` are the same objects as those in `right`.

<span class="gu">@@ -359,29 +727,77 @@ def all_identical(left: Iterable[Any], right: Iterable[Any]) -&gt;bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; all_identical([a, b, [a]], [a, b, [a]])  # new list object, while &quot;equal&quot; is not &quot;identical&quot;
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for left_item, right_item in zip_longest(left, right, fillvalue=_EMPTY):</span>
<span class="gi">+        if left_item is not right_item:</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>


<span class="gd">-def assert_never(obj: NoReturn, msg: str) -&gt;NoReturn:</span>
<span class="gi">+def assert_never(obj: NoReturn, msg: str) -&gt; NoReturn:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Helper to make sure that we have covered all possible types.

<span class="w"> </span>    This is mostly useful for ``mypy``, docs:
<span class="w"> </span>    https://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    raise TypeError(msg)</span>


<span class="gd">-def get_unique_discriminator_alias(all_aliases: Collection[str],</span>
<span class="gd">-    discriminator_key: str) -&gt;str:</span>
<span class="gi">+def get_unique_discriminator_alias(all_aliases: Collection[str], discriminator_key: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Validate that all aliases are the same and if that&#39;s the case return the alias&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    unique_aliases = set(all_aliases)</span>
<span class="gi">+    if len(unique_aliases) &gt; 1:</span>
<span class="gi">+        raise ConfigError(</span>
<span class="gi">+            f&#39;Aliases for discriminator {discriminator_key!r} must be the same (got {&quot;, &quot;.join(sorted(all_aliases))})&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+    return unique_aliases.pop()</span>


<span class="gd">-def get_discriminator_alias_and_values(tp: Any, discriminator_key: str</span>
<span class="gd">-    ) -&gt;Tuple[str, Tuple[str, ...]]:</span>
<span class="gi">+def get_discriminator_alias_and_values(tp: Any, discriminator_key: str) -&gt; Tuple[str, Tuple[str, ...]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get alias and all valid values in the `Literal` type of the discriminator field
<span class="w"> </span>    `tp` can be a `BaseModel` class or directly an `Annotated` `Union` of many.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    is_root_model = getattr(tp, &#39;__custom_root_type__&#39;, False)</span>
<span class="gi">+</span>
<span class="gi">+    if get_origin(tp) is Annotated:</span>
<span class="gi">+        tp = get_args(tp)[0]</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(tp, &#39;__pydantic_model__&#39;):</span>
<span class="gi">+        tp = tp.__pydantic_model__</span>
<span class="gi">+</span>
<span class="gi">+    if is_union(get_origin(tp)):</span>
<span class="gi">+        alias, all_values = _get_union_alias_and_all_values(tp, discriminator_key)</span>
<span class="gi">+        return alias, tuple(v for values in all_values for v in values)</span>
<span class="gi">+    elif is_root_model:</span>
<span class="gi">+        union_type = tp.__fields__[ROOT_KEY].type_</span>
<span class="gi">+        alias, all_values = _get_union_alias_and_all_values(union_type, discriminator_key)</span>
<span class="gi">+</span>
<span class="gi">+        if len(set(all_values)) &gt; 1:</span>
<span class="gi">+            raise ConfigError(</span>
<span class="gi">+                f&#39;Field {discriminator_key!r} is not the same for all submodels of {display_as_type(tp)!r}&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return alias, all_values[0]</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            t_discriminator_type = tp.__fields__[discriminator_key].type_</span>
<span class="gi">+        except AttributeError as e:</span>
<span class="gi">+            raise TypeError(f&#39;Type {tp.__name__!r} is not a valid `BaseModel` or `dataclass`&#39;) from e</span>
<span class="gi">+        except KeyError as e:</span>
<span class="gi">+            raise ConfigError(f&#39;Model {tp.__name__!r} needs a discriminator field for key {discriminator_key!r}&#39;) from e</span>
<span class="gi">+</span>
<span class="gi">+        if not is_literal_type(t_discriminator_type):</span>
<span class="gi">+            raise ConfigError(f&#39;Field {discriminator_key!r} of model {tp.__name__!r} needs to be a `Literal`&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return tp.__fields__[discriminator_key].alias, all_literal_values(t_discriminator_type)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_union_alias_and_all_values(</span>
<span class="gi">+    union_type: Type[Any], discriminator_key: str</span>
<span class="gi">+) -&gt; Tuple[str, Tuple[Tuple[str, ...], ...]]:</span>
<span class="gi">+    zipped_aliases_values = [get_discriminator_alias_and_values(t, discriminator_key) for t in get_args(union_type)]</span>
<span class="gi">+    # unzip: [(&#39;alias_a&#39;,(&#39;v1&#39;, &#39;v2)), (&#39;alias_b&#39;, (&#39;v3&#39;,))] =&gt; [(&#39;alias_a&#39;, &#39;alias_b&#39;), ((&#39;v1&#39;, &#39;v2&#39;), (&#39;v3&#39;,))]</span>
<span class="gi">+    all_aliases, all_values = zip(*zipped_aliases_values)</span>
<span class="gi">+    return get_unique_discriminator_alias(all_aliases, discriminator_key), all_values</span>
<span class="gh">diff --git a/pydantic/v1/validators.py b/pydantic/v1/validators.py</span>
<span class="gh">index fd53f500c..7c39aa9a7 100644</span>
<span class="gd">--- a/pydantic/v1/validators.py</span>
<span class="gi">+++ b/pydantic/v1/validators.py</span>
<span class="gu">@@ -7,99 +7,759 @@ from decimal import Decimal, DecimalException</span>
<span class="w"> </span>from enum import Enum, IntEnum
<span class="w"> </span>from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
<span class="w"> </span>from pathlib import Path
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, Deque, Dict, ForwardRef, FrozenSet, Generator, Hashable, List, NamedTuple, Pattern, Set, Tuple, Type, TypeVar, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Deque,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    ForwardRef,</span>
<span class="gi">+    FrozenSet,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Hashable,</span>
<span class="gi">+    List,</span>
<span class="gi">+    NamedTuple,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="w"> </span>from uuid import UUID
<span class="gi">+</span>
<span class="w"> </span>from pydantic.v1 import errors
<span class="w"> </span>from pydantic.v1.datetime_parse import parse_date, parse_datetime, parse_duration, parse_time
<span class="gd">-from pydantic.v1.typing import AnyCallable, all_literal_values, display_as_type, get_class, is_callable_type, is_literal_type, is_namedtuple, is_none_type, is_typeddict</span>
<span class="gi">+from pydantic.v1.typing import (</span>
<span class="gi">+    AnyCallable,</span>
<span class="gi">+    all_literal_values,</span>
<span class="gi">+    display_as_type,</span>
<span class="gi">+    get_class,</span>
<span class="gi">+    is_callable_type,</span>
<span class="gi">+    is_literal_type,</span>
<span class="gi">+    is_namedtuple,</span>
<span class="gi">+    is_none_type,</span>
<span class="gi">+    is_typeddict,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pydantic.v1.utils import almost_equal_floats, lenient_issubclass, sequence_like
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Literal, TypedDict
<span class="gi">+</span>
<span class="w"> </span>    from pydantic.v1.config import BaseConfig
<span class="w"> </span>    from pydantic.v1.fields import ModelField
<span class="w"> </span>    from pydantic.v1.types import ConstrainedDecimal, ConstrainedFloat, ConstrainedInt
<span class="gd">-    ConstrainedNumber = Union[ConstrainedDecimal, ConstrainedFloat,</span>
<span class="gd">-        ConstrainedInt]</span>
<span class="gi">+</span>
<span class="gi">+    ConstrainedNumber = Union[ConstrainedDecimal, ConstrainedFloat, ConstrainedInt]</span>
<span class="w"> </span>    AnyOrderedDict = OrderedDict[Any, Any]
<span class="w"> </span>    Number = Union[int, float, Decimal]
<span class="w"> </span>    StrBytes = Union[str, bytes]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def str_validator(v: Any) -&gt; Union[str]:</span>
<span class="gi">+    if isinstance(v, str):</span>
<span class="gi">+        if isinstance(v, Enum):</span>
<span class="gi">+            return v.value</span>
<span class="gi">+        else:</span>
<span class="gi">+            return v</span>
<span class="gi">+    elif isinstance(v, (float, int, Decimal)):</span>
<span class="gi">+        # is there anything else we want to add here? If you think so, create an issue.</span>
<span class="gi">+        return str(v)</span>
<span class="gi">+    elif isinstance(v, (bytes, bytearray)):</span>
<span class="gi">+        return v.decode()</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise errors.StrError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def strict_str_validator(v: Any) -&gt; Union[str]:</span>
<span class="gi">+    if isinstance(v, str) and not isinstance(v, Enum):</span>
<span class="gi">+        return v</span>
<span class="gi">+    raise errors.StrError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def bytes_validator(v: Any) -&gt; Union[bytes]:</span>
<span class="gi">+    if isinstance(v, bytes):</span>
<span class="gi">+        return v</span>
<span class="gi">+    elif isinstance(v, bytearray):</span>
<span class="gi">+        return bytes(v)</span>
<span class="gi">+    elif isinstance(v, str):</span>
<span class="gi">+        return v.encode()</span>
<span class="gi">+    elif isinstance(v, (float, int, Decimal)):</span>
<span class="gi">+        return str(v).encode()</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise errors.BytesError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def strict_bytes_validator(v: Any) -&gt; Union[bytes]:</span>
<span class="gi">+    if isinstance(v, bytes):</span>
<span class="gi">+        return v</span>
<span class="gi">+    elif isinstance(v, bytearray):</span>
<span class="gi">+        return bytes(v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise errors.BytesError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>BOOL_FALSE = {0, &#39;0&#39;, &#39;off&#39;, &#39;f&#39;, &#39;false&#39;, &#39;n&#39;, &#39;no&#39;}
<span class="w"> </span>BOOL_TRUE = {1, &#39;1&#39;, &#39;on&#39;, &#39;t&#39;, &#39;true&#39;, &#39;y&#39;, &#39;yes&#39;}
<span class="gd">-max_str_int = 4300</span>


<span class="gd">-def constant_validator(v: &#39;Any&#39;, field: &#39;ModelField&#39;) -&gt;&#39;Any&#39;:</span>
<span class="gi">+def bool_validator(v: Any) -&gt; bool:</span>
<span class="gi">+    if v is True or v is False:</span>
<span class="gi">+        return v</span>
<span class="gi">+    if isinstance(v, bytes):</span>
<span class="gi">+        v = v.decode()</span>
<span class="gi">+    if isinstance(v, str):</span>
<span class="gi">+        v = v.lower()</span>
<span class="gi">+    try:</span>
<span class="gi">+        if v in BOOL_TRUE:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if v in BOOL_FALSE:</span>
<span class="gi">+            return False</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        raise errors.BoolError()</span>
<span class="gi">+    raise errors.BoolError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# matches the default limit cpython, see https://github.com/python/cpython/pull/96500</span>
<span class="gi">+max_str_int = 4_300</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def int_validator(v: Any) -&gt; int:</span>
<span class="gi">+    if isinstance(v, int) and not (v is True or v is False):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    # see https://github.com/pydantic/pydantic/issues/1477 and in turn, https://github.com/python/cpython/issues/95778</span>
<span class="gi">+    # this check should be unnecessary once patch releases are out for 3.7, 3.8, 3.9 and 3.10</span>
<span class="gi">+    # but better to check here until then.</span>
<span class="gi">+    # NOTICE: this does not fully protect user from the DOS risk since the standard library JSON implementation</span>
<span class="gi">+    # (and other std lib modules like xml) use `int()` and are likely called before this, the best workaround is to</span>
<span class="gi">+    # 1. update to the latest patch release of python once released, 2. use a different JSON library like ujson</span>
<span class="gi">+    if isinstance(v, (str, bytes, bytearray)) and len(v) &gt; max_str_int:</span>
<span class="gi">+        raise errors.IntegerError()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return int(v)</span>
<span class="gi">+    except (TypeError, ValueError, OverflowError):</span>
<span class="gi">+        raise errors.IntegerError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def strict_int_validator(v: Any) -&gt; int:</span>
<span class="gi">+    if isinstance(v, int) and not (v is True or v is False):</span>
<span class="gi">+        return v</span>
<span class="gi">+    raise errors.IntegerError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def float_validator(v: Any) -&gt; float:</span>
<span class="gi">+    if isinstance(v, float):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return float(v)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        raise errors.FloatError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def strict_float_validator(v: Any) -&gt; float:</span>
<span class="gi">+    if isinstance(v, float):</span>
<span class="gi">+        return v</span>
<span class="gi">+    raise errors.FloatError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def float_finite_validator(v: &#39;Number&#39;, field: &#39;ModelField&#39;, config: &#39;BaseConfig&#39;) -&gt; &#39;Number&#39;:</span>
<span class="gi">+    allow_inf_nan = getattr(field.type_, &#39;allow_inf_nan&#39;, None)</span>
<span class="gi">+    if allow_inf_nan is None:</span>
<span class="gi">+        allow_inf_nan = config.allow_inf_nan</span>
<span class="gi">+</span>
<span class="gi">+    if allow_inf_nan is False and (math.isnan(v) or math.isinf(v)):</span>
<span class="gi">+        raise errors.NumberNotFiniteError()</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def number_multiple_validator(v: &#39;Number&#39;, field: &#39;ModelField&#39;) -&gt; &#39;Number&#39;:</span>
<span class="gi">+    field_type: ConstrainedNumber = field.type_</span>
<span class="gi">+    if field_type.multiple_of is not None:</span>
<span class="gi">+        mod = float(v) / float(field_type.multiple_of) % 1</span>
<span class="gi">+        if not almost_equal_floats(mod, 0.0) and not almost_equal_floats(mod, 1.0):</span>
<span class="gi">+            raise errors.NumberNotMultipleError(multiple_of=field_type.multiple_of)</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def number_size_validator(v: &#39;Number&#39;, field: &#39;ModelField&#39;) -&gt; &#39;Number&#39;:</span>
<span class="gi">+    field_type: ConstrainedNumber = field.type_</span>
<span class="gi">+    if field_type.gt is not None and not v &gt; field_type.gt:</span>
<span class="gi">+        raise errors.NumberNotGtError(limit_value=field_type.gt)</span>
<span class="gi">+    elif field_type.ge is not None and not v &gt;= field_type.ge:</span>
<span class="gi">+        raise errors.NumberNotGeError(limit_value=field_type.ge)</span>
<span class="gi">+</span>
<span class="gi">+    if field_type.lt is not None and not v &lt; field_type.lt:</span>
<span class="gi">+        raise errors.NumberNotLtError(limit_value=field_type.lt)</span>
<span class="gi">+    if field_type.le is not None and not v &lt;= field_type.le:</span>
<span class="gi">+        raise errors.NumberNotLeError(limit_value=field_type.le)</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constant_validator(v: &#39;Any&#39;, field: &#39;ModelField&#39;) -&gt; &#39;Any&#39;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Validate ``const`` fields.

<span class="w"> </span>    The value provided for a ``const`` field must be equal to the default value
<span class="w"> </span>    of the field. This is to support the keyword of the same name in JSON
<span class="w"> </span>    Schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if v != field.default:</span>
<span class="gi">+        raise errors.WrongConstantError(given=v, permitted=[field.default])</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def anystr_length_validator(v: &#39;StrBytes&#39;, config: &#39;BaseConfig&#39;) -&gt; &#39;StrBytes&#39;:</span>
<span class="gi">+    v_len = len(v)</span>
<span class="gi">+</span>
<span class="gi">+    min_length = config.min_anystr_length</span>
<span class="gi">+    if v_len &lt; min_length:</span>
<span class="gi">+        raise errors.AnyStrMinLengthError(limit_value=min_length)</span>
<span class="gi">+</span>
<span class="gi">+    max_length = config.max_anystr_length</span>
<span class="gi">+    if max_length is not None and v_len &gt; max_length:</span>
<span class="gi">+        raise errors.AnyStrMaxLengthError(limit_value=max_length)</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def anystr_strip_whitespace(v: &#39;StrBytes&#39;) -&gt; &#39;StrBytes&#39;:</span>
<span class="gi">+    return v.strip()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def anystr_upper(v: &#39;StrBytes&#39;) -&gt; &#39;StrBytes&#39;:</span>
<span class="gi">+    return v.upper()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def anystr_lower(v: &#39;StrBytes&#39;) -&gt; &#39;StrBytes&#39;:</span>
<span class="gi">+    return v.lower()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ordered_dict_validator(v: Any) -&gt; &#39;AnyOrderedDict&#39;:</span>
<span class="gi">+    if isinstance(v, OrderedDict):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return OrderedDict(v)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        raise errors.DictError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def dict_validator(v: Any) -&gt; Dict[Any, Any]:</span>
<span class="gi">+    if isinstance(v, dict):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return dict(v)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        raise errors.DictError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def list_validator(v: Any) -&gt; List[Any]:</span>
<span class="gi">+    if isinstance(v, list):</span>
<span class="gi">+        return v</span>
<span class="gi">+    elif sequence_like(v):</span>
<span class="gi">+        return list(v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise errors.ListError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tuple_validator(v: Any) -&gt; Tuple[Any, ...]:</span>
<span class="gi">+    if isinstance(v, tuple):</span>
<span class="gi">+        return v</span>
<span class="gi">+    elif sequence_like(v):</span>
<span class="gi">+        return tuple(v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise errors.TupleError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_validator(v: Any) -&gt; Set[Any]:</span>
<span class="gi">+    if isinstance(v, set):</span>
<span class="gi">+        return v</span>
<span class="gi">+    elif sequence_like(v):</span>
<span class="gi">+        return set(v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise errors.SetError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def frozenset_validator(v: Any) -&gt; FrozenSet[Any]:</span>
<span class="gi">+    if isinstance(v, frozenset):</span>
<span class="gi">+        return v</span>
<span class="gi">+    elif sequence_like(v):</span>
<span class="gi">+        return frozenset(v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise errors.FrozenSetError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def deque_validator(v: Any) -&gt; Deque[Any]:</span>
<span class="gi">+    if isinstance(v, deque):</span>
<span class="gi">+        return v</span>
<span class="gi">+    elif sequence_like(v):</span>
<span class="gi">+        return deque(v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise errors.DequeError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def enum_member_validator(v: Any, field: &#39;ModelField&#39;, config: &#39;BaseConfig&#39;) -&gt; Enum:</span>
<span class="gi">+    try:</span>
<span class="gi">+        enum_v = field.type_(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # field.type_ should be an enum, so will be iterable</span>
<span class="gi">+        raise errors.EnumMemberError(enum_values=list(field.type_))</span>
<span class="gi">+    return enum_v.value if config.use_enum_values else enum_v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def uuid_validator(v: Any, field: &#39;ModelField&#39;) -&gt; UUID:</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(v, str):</span>
<span class="gi">+            v = UUID(v)</span>
<span class="gi">+        elif isinstance(v, (bytes, bytearray)):</span>
<span class="gi">+            try:</span>
<span class="gi">+                v = UUID(v.decode())</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                # 16 bytes in big-endian order as the bytes argument fail</span>
<span class="gi">+                # the above check</span>
<span class="gi">+                v = UUID(bytes=v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.UUIDError()</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(v, UUID):</span>
<span class="gi">+        raise errors.UUIDError()</span>
<span class="gi">+</span>
<span class="gi">+    required_version = getattr(field.type_, &#39;_required_version&#39;, None)</span>
<span class="gi">+    if required_version and v.version != required_version:</span>
<span class="gi">+        raise errors.UUIDVersionError(required_version=required_version)</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def decimal_validator(v: Any) -&gt; Decimal:</span>
<span class="gi">+    if isinstance(v, Decimal):</span>
<span class="gi">+        return v</span>
<span class="gi">+    elif isinstance(v, (bytes, bytearray)):</span>
<span class="gi">+        v = v.decode()</span>
<span class="gi">+</span>
<span class="gi">+    v = str(v).strip()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        v = Decimal(v)</span>
<span class="gi">+    except DecimalException:</span>
<span class="gi">+        raise errors.DecimalError()</span>
<span class="gi">+</span>
<span class="gi">+    if not v.is_finite():</span>
<span class="gi">+        raise errors.DecimalIsNotFiniteError()</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def hashable_validator(v: Any) -&gt; Hashable:</span>
<span class="gi">+    if isinstance(v, Hashable):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    raise errors.HashableError()</span>
<span class="gi">+</span>

<span class="gi">+def ip_v4_address_validator(v: Any) -&gt; IPv4Address:</span>
<span class="gi">+    if isinstance(v, IPv4Address):</span>
<span class="gi">+        return v</span>

<span class="gd">-def ip_v4_network_validator(v: Any) -&gt;IPv4Network:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv4Address(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.IPv4AddressError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_v6_address_validator(v: Any) -&gt; IPv6Address:</span>
<span class="gi">+    if isinstance(v, IPv6Address):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv6Address(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.IPv6AddressError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_v4_network_validator(v: Any) -&gt; IPv4Network:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Assume IPv4Network initialised with a default ``strict`` argument

<span class="w"> </span>    See more:
<span class="w"> </span>    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(v, IPv4Network):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv4Network(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.IPv4NetworkError()</span>


<span class="gd">-def ip_v6_network_validator(v: Any) -&gt;IPv6Network:</span>
<span class="gi">+def ip_v6_network_validator(v: Any) -&gt; IPv6Network:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Assume IPv6Network initialised with a default ``strict`` argument

<span class="w"> </span>    See more:
<span class="w"> </span>    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(v, IPv6Network):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv6Network(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.IPv6NetworkError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ip_v4_interface_validator(v: Any) -&gt; IPv4Interface:</span>
<span class="gi">+    if isinstance(v, IPv4Interface):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv4Interface(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.IPv4InterfaceError()</span>
<span class="gi">+</span>

<span class="gi">+def ip_v6_interface_validator(v: Any) -&gt; IPv6Interface:</span>
<span class="gi">+    if isinstance(v, IPv6Interface):</span>
<span class="gi">+        return v</span>

<span class="gd">-def callable_validator(v: Any) -&gt;AnyCallable:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv6Interface(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.IPv6InterfaceError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def path_validator(v: Any) -&gt; Path:</span>
<span class="gi">+    if isinstance(v, Path):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Path(v)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        raise errors.PathError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def path_exists_validator(v: Any) -&gt; Path:</span>
<span class="gi">+    if not v.exists():</span>
<span class="gi">+        raise errors.PathNotExistsError(path=v)</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def callable_validator(v: Any) -&gt; AnyCallable:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Perform a simple check if the value is callable.

<span class="w"> </span>    Note: complete matching of argument type hints and return types is not performed
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if callable(v):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    raise errors.CallableError(value=v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def enum_validator(v: Any) -&gt; Enum:</span>
<span class="gi">+    if isinstance(v, Enum):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    raise errors.EnumError(value=v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def int_enum_validator(v: Any) -&gt; IntEnum:</span>
<span class="gi">+    if isinstance(v, IntEnum):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    raise errors.IntEnumError(value=v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_literal_validator(type_: Any) -&gt; Callable[[Any], Any]:</span>
<span class="gi">+    permitted_choices = all_literal_values(type_)</span>
<span class="gi">+</span>
<span class="gi">+    # To have a O(1) complexity and still return one of the values set inside the `Literal`,</span>
<span class="gi">+    # we create a dict with the set values (a set causes some problems with the way intersection works).</span>
<span class="gi">+    # In some cases the set value and checked value can indeed be different (see `test_literal_validator_str_enum`)</span>
<span class="gi">+    allowed_choices = {v: v for v in permitted_choices}</span>
<span class="gi">+</span>
<span class="gi">+    def literal_validator(v: Any) -&gt; Any:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return allowed_choices[v]</span>
<span class="gi">+        except (KeyError, TypeError):</span>
<span class="gi">+            raise errors.WrongConstantError(given=v, permitted=permitted_choices)</span>
<span class="gi">+</span>
<span class="gi">+    return literal_validator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constr_length_validator(v: &#39;StrBytes&#39;, field: &#39;ModelField&#39;, config: &#39;BaseConfig&#39;) -&gt; &#39;StrBytes&#39;:</span>
<span class="gi">+    v_len = len(v)</span>
<span class="gi">+</span>
<span class="gi">+    min_length = field.type_.min_length if field.type_.min_length is not None else config.min_anystr_length</span>
<span class="gi">+    if v_len &lt; min_length:</span>
<span class="gi">+        raise errors.AnyStrMinLengthError(limit_value=min_length)</span>
<span class="gi">+</span>
<span class="gi">+    max_length = field.type_.max_length if field.type_.max_length is not None else config.max_anystr_length</span>
<span class="gi">+    if max_length is not None and v_len &gt; max_length:</span>
<span class="gi">+        raise errors.AnyStrMaxLengthError(limit_value=max_length)</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constr_strip_whitespace(v: &#39;StrBytes&#39;, field: &#39;ModelField&#39;, config: &#39;BaseConfig&#39;) -&gt; &#39;StrBytes&#39;:</span>
<span class="gi">+    strip_whitespace = field.type_.strip_whitespace or config.anystr_strip_whitespace</span>
<span class="gi">+    if strip_whitespace:</span>
<span class="gi">+        v = v.strip()</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constr_upper(v: &#39;StrBytes&#39;, field: &#39;ModelField&#39;, config: &#39;BaseConfig&#39;) -&gt; &#39;StrBytes&#39;:</span>
<span class="gi">+    upper = field.type_.to_upper or config.anystr_upper</span>
<span class="gi">+    if upper:</span>
<span class="gi">+        v = v.upper()</span>
<span class="gi">+</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constr_lower(v: &#39;StrBytes&#39;, field: &#39;ModelField&#39;, config: &#39;BaseConfig&#39;) -&gt; &#39;StrBytes&#39;:</span>
<span class="gi">+    lower = field.type_.to_lower or config.anystr_lower</span>
<span class="gi">+    if lower:</span>
<span class="gi">+        v = v.lower()</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_json(v: Any, config: &#39;BaseConfig&#39;) -&gt; Any:</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        # pass None through to other validators</span>
<span class="gi">+        return v</span>
<span class="gi">+    try:</span>
<span class="gi">+        return config.json_loads(v)  # type: ignore</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.JsonError()</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        raise errors.JsonTypeError()</span>


<span class="w"> </span>T = TypeVar(&#39;T&#39;)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_arbitrary_type_validator(type_: Type[T]) -&gt; Callable[[T], T]:</span>
<span class="gi">+    def arbitrary_type_validator(v: Any) -&gt; T:</span>
<span class="gi">+        if isinstance(v, type_):</span>
<span class="gi">+            return v</span>
<span class="gi">+        raise errors.ArbitraryTypeError(expected_arbitrary_type=type_)</span>
<span class="gi">+</span>
<span class="gi">+    return arbitrary_type_validator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_class_validator(type_: Type[T]) -&gt; Callable[[Any], Type[T]]:</span>
<span class="gi">+    def class_validator(v: Any) -&gt; Type[T]:</span>
<span class="gi">+        if lenient_issubclass(v, type_):</span>
<span class="gi">+            return v</span>
<span class="gi">+        raise errors.SubclassError(expected_class=type_)</span>
<span class="gi">+</span>
<span class="gi">+    return class_validator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def any_class_validator(v: Any) -&gt; Type[T]:</span>
<span class="gi">+    if isinstance(v, type):</span>
<span class="gi">+        return v</span>
<span class="gi">+    raise errors.ClassError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def none_validator(v: Any) -&gt; &#39;Literal[None]&#39;:</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return v</span>
<span class="gi">+    raise errors.NotNoneError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pattern_validator(v: Any) -&gt; Pattern[str]:</span>
<span class="gi">+    if isinstance(v, Pattern):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    str_value = str_validator(v)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return re.compile(str_value)</span>
<span class="gi">+    except re.error:</span>
<span class="gi">+        raise errors.PatternError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>NamedTupleT = TypeVar(&#39;NamedTupleT&#39;, bound=NamedTuple)


<span class="gd">-class IfConfig:</span>
<span class="gi">+def make_namedtuple_validator(</span>
<span class="gi">+    namedtuple_cls: Type[NamedTupleT], config: Type[&#39;BaseConfig&#39;]</span>
<span class="gi">+) -&gt; Callable[[Tuple[Any, ...]], NamedTupleT]:</span>
<span class="gi">+    from pydantic.v1.annotated_types import create_model_from_namedtuple</span>

<span class="gd">-    def __init__(self, validator: AnyCallable, *config_attr_names: str,</span>
<span class="gd">-        ignored_value: Any=False) -&gt;None:</span>
<span class="gi">+    NamedTupleModel = create_model_from_namedtuple(</span>
<span class="gi">+        namedtuple_cls,</span>
<span class="gi">+        __config__=config,</span>
<span class="gi">+        __module__=namedtuple_cls.__module__,</span>
<span class="gi">+    )</span>
<span class="gi">+    namedtuple_cls.__pydantic_model__ = NamedTupleModel  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    def namedtuple_validator(values: Tuple[Any, ...]) -&gt; NamedTupleT:</span>
<span class="gi">+        annotations = NamedTupleModel.__annotations__</span>
<span class="gi">+</span>
<span class="gi">+        if len(values) &gt; len(annotations):</span>
<span class="gi">+            raise errors.ListMaxLengthError(limit_value=len(annotations))</span>
<span class="gi">+</span>
<span class="gi">+        dict_values: Dict[str, Any] = dict(zip(annotations, values))</span>
<span class="gi">+        validated_dict_values: Dict[str, Any] = dict(NamedTupleModel(**dict_values))</span>
<span class="gi">+        return namedtuple_cls(**validated_dict_values)</span>
<span class="gi">+</span>
<span class="gi">+    return namedtuple_validator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_typeddict_validator(</span>
<span class="gi">+    typeddict_cls: Type[&#39;TypedDict&#39;], config: Type[&#39;BaseConfig&#39;]  # type: ignore[valid-type]</span>
<span class="gi">+) -&gt; Callable[[Any], Dict[str, Any]]:</span>
<span class="gi">+    from pydantic.v1.annotated_types import create_model_from_typeddict</span>
<span class="gi">+</span>
<span class="gi">+    TypedDictModel = create_model_from_typeddict(</span>
<span class="gi">+        typeddict_cls,</span>
<span class="gi">+        __config__=config,</span>
<span class="gi">+        __module__=typeddict_cls.__module__,</span>
<span class="gi">+    )</span>
<span class="gi">+    typeddict_cls.__pydantic_model__ = TypedDictModel  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    def typeddict_validator(values: &#39;TypedDict&#39;) -&gt; Dict[str, Any]:  # type: ignore[valid-type]</span>
<span class="gi">+        return TypedDictModel.parse_obj(values).dict(exclude_unset=True)</span>
<span class="gi">+</span>
<span class="gi">+    return typeddict_validator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class IfConfig:</span>
<span class="gi">+    def __init__(self, validator: AnyCallable, *config_attr_names: str, ignored_value: Any = False) -&gt; None:</span>
<span class="w"> </span>        self.validator = validator
<span class="w"> </span>        self.config_attr_names = config_attr_names
<span class="w"> </span>        self.ignored_value = ignored_value

<span class="gi">+    def check(self, config: Type[&#39;BaseConfig&#39;]) -&gt; bool:</span>
<span class="gi">+        return any(getattr(config, name) not in {None, self.ignored_value} for name in self.config_attr_names)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# order is important here, for example: bool is a subclass of int so has to come first, datetime before date same,</span>
<span class="gi">+# IPv4Interface before IPv4Address, etc</span>
<span class="gi">+_VALIDATORS: List[Tuple[Type[Any], List[Any]]] = [</span>
<span class="gi">+    (IntEnum, [int_validator, enum_member_validator]),</span>
<span class="gi">+    (Enum, [enum_member_validator]),</span>
<span class="gi">+    (</span>
<span class="gi">+        str,</span>
<span class="gi">+        [</span>
<span class="gi">+            str_validator,</span>
<span class="gi">+            IfConfig(anystr_strip_whitespace, &#39;anystr_strip_whitespace&#39;),</span>
<span class="gi">+            IfConfig(anystr_upper, &#39;anystr_upper&#39;),</span>
<span class="gi">+            IfConfig(anystr_lower, &#39;anystr_lower&#39;),</span>
<span class="gi">+            IfConfig(anystr_length_validator, &#39;min_anystr_length&#39;, &#39;max_anystr_length&#39;),</span>
<span class="gi">+        ],</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        bytes,</span>
<span class="gi">+        [</span>
<span class="gi">+            bytes_validator,</span>
<span class="gi">+            IfConfig(anystr_strip_whitespace, &#39;anystr_strip_whitespace&#39;),</span>
<span class="gi">+            IfConfig(anystr_upper, &#39;anystr_upper&#39;),</span>
<span class="gi">+            IfConfig(anystr_lower, &#39;anystr_lower&#39;),</span>
<span class="gi">+            IfConfig(anystr_length_validator, &#39;min_anystr_length&#39;, &#39;max_anystr_length&#39;),</span>
<span class="gi">+        ],</span>
<span class="gi">+    ),</span>
<span class="gi">+    (bool, [bool_validator]),</span>
<span class="gi">+    (int, [int_validator]),</span>
<span class="gi">+    (float, [float_validator, IfConfig(float_finite_validator, &#39;allow_inf_nan&#39;, ignored_value=True)]),</span>
<span class="gi">+    (Path, [path_validator]),</span>
<span class="gi">+    (datetime, [parse_datetime]),</span>
<span class="gi">+    (date, [parse_date]),</span>
<span class="gi">+    (time, [parse_time]),</span>
<span class="gi">+    (timedelta, [parse_duration]),</span>
<span class="gi">+    (OrderedDict, [ordered_dict_validator]),</span>
<span class="gi">+    (dict, [dict_validator]),</span>
<span class="gi">+    (list, [list_validator]),</span>
<span class="gi">+    (tuple, [tuple_validator]),</span>
<span class="gi">+    (set, [set_validator]),</span>
<span class="gi">+    (frozenset, [frozenset_validator]),</span>
<span class="gi">+    (deque, [deque_validator]),</span>
<span class="gi">+    (UUID, [uuid_validator]),</span>
<span class="gi">+    (Decimal, [decimal_validator]),</span>
<span class="gi">+    (IPv4Interface, [ip_v4_interface_validator]),</span>
<span class="gi">+    (IPv6Interface, [ip_v6_interface_validator]),</span>
<span class="gi">+    (IPv4Address, [ip_v4_address_validator]),</span>
<span class="gi">+    (IPv6Address, [ip_v6_address_validator]),</span>
<span class="gi">+    (IPv4Network, [ip_v4_network_validator]),</span>
<span class="gi">+    (IPv6Network, [ip_v6_network_validator]),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_validators(  # noqa: C901 (ignore complexity)</span>
<span class="gi">+    type_: Type[Any], config: Type[&#39;BaseConfig&#39;]</span>
<span class="gi">+) -&gt; Generator[AnyCallable, None, None]:</span>
<span class="gi">+    from pydantic.v1.dataclasses import is_builtin_dataclass, make_dataclass_validator</span>
<span class="gi">+</span>
<span class="gi">+    if type_ is Any or type_ is object:</span>
<span class="gi">+        return</span>
<span class="gi">+    type_type = type_.__class__</span>
<span class="gi">+    if type_type == ForwardRef or type_type == TypeVar:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if is_none_type(type_):</span>
<span class="gi">+        yield none_validator</span>
<span class="gi">+        return</span>
<span class="gi">+    if type_ is Pattern or type_ is re.Pattern:</span>
<span class="gi">+        yield pattern_validator</span>
<span class="gi">+        return</span>
<span class="gi">+    if type_ is Hashable or type_ is CollectionsHashable:</span>
<span class="gi">+        yield hashable_validator</span>
<span class="gi">+        return</span>
<span class="gi">+    if is_callable_type(type_):</span>
<span class="gi">+        yield callable_validator</span>
<span class="gi">+        return</span>
<span class="gi">+    if is_literal_type(type_):</span>
<span class="gi">+        yield make_literal_validator(type_)</span>
<span class="gi">+        return</span>
<span class="gi">+    if is_builtin_dataclass(type_):</span>
<span class="gi">+        yield from make_dataclass_validator(type_, config)</span>
<span class="gi">+        return</span>
<span class="gi">+    if type_ is Enum:</span>
<span class="gi">+        yield enum_validator</span>
<span class="gi">+        return</span>
<span class="gi">+    if type_ is IntEnum:</span>
<span class="gi">+        yield int_enum_validator</span>
<span class="gi">+        return</span>
<span class="gi">+    if is_namedtuple(type_):</span>
<span class="gi">+        yield tuple_validator</span>
<span class="gi">+        yield make_namedtuple_validator(type_, config)</span>
<span class="gi">+        return</span>
<span class="gi">+    if is_typeddict(type_):</span>
<span class="gi">+        yield make_typeddict_validator(type_, config)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    class_ = get_class(type_)</span>
<span class="gi">+    if class_ is not None:</span>
<span class="gi">+        if class_ is not Any and isinstance(class_, type):</span>
<span class="gi">+            yield make_class_validator(class_)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield any_class_validator</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for val_type, validators in _VALIDATORS:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if issubclass(type_, val_type):</span>
<span class="gi">+                for v in validators:</span>
<span class="gi">+                    if isinstance(v, IfConfig):</span>
<span class="gi">+                        if v.check(config):</span>
<span class="gi">+                            yield v.validator</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield v</span>
<span class="gi">+                return</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            raise RuntimeError(f&#39;error checking inheritance of {type_!r} (type: {display_as_type(type_)})&#39;)</span>

<span class="gd">-_VALIDATORS: List[Tuple[Type[Any], List[Any]]] = [(IntEnum, [int_validator,</span>
<span class="gd">-    enum_member_validator]), (Enum, [enum_member_validator]), (str, [</span>
<span class="gd">-    str_validator, IfConfig(anystr_strip_whitespace,</span>
<span class="gd">-    &#39;anystr_strip_whitespace&#39;), IfConfig(anystr_upper, &#39;anystr_upper&#39;),</span>
<span class="gd">-    IfConfig(anystr_lower, &#39;anystr_lower&#39;), IfConfig(</span>
<span class="gd">-    anystr_length_validator, &#39;min_anystr_length&#39;, &#39;max_anystr_length&#39;)]), (</span>
<span class="gd">-    bytes, [bytes_validator, IfConfig(anystr_strip_whitespace,</span>
<span class="gd">-    &#39;anystr_strip_whitespace&#39;), IfConfig(anystr_upper, &#39;anystr_upper&#39;),</span>
<span class="gd">-    IfConfig(anystr_lower, &#39;anystr_lower&#39;), IfConfig(</span>
<span class="gd">-    anystr_length_validator, &#39;min_anystr_length&#39;, &#39;max_anystr_length&#39;)]), (</span>
<span class="gd">-    bool, [bool_validator]), (int, [int_validator]), (float, [</span>
<span class="gd">-    float_validator, IfConfig(float_finite_validator, &#39;allow_inf_nan&#39;,</span>
<span class="gd">-    ignored_value=True)]), (Path, [path_validator]), (datetime, [</span>
<span class="gd">-    parse_datetime]), (date, [parse_date]), (time, [parse_time]), (</span>
<span class="gd">-    timedelta, [parse_duration]), (OrderedDict, [ordered_dict_validator]),</span>
<span class="gd">-    (dict, [dict_validator]), (list, [list_validator]), (tuple, [</span>
<span class="gd">-    tuple_validator]), (set, [set_validator]), (frozenset, [</span>
<span class="gd">-    frozenset_validator]), (deque, [deque_validator]), (UUID, [</span>
<span class="gd">-    uuid_validator]), (Decimal, [decimal_validator]), (IPv4Interface, [</span>
<span class="gd">-    ip_v4_interface_validator]), (IPv6Interface, [ip_v6_interface_validator</span>
<span class="gd">-    ]), (IPv4Address, [ip_v4_address_validator]), (IPv6Address, [</span>
<span class="gd">-    ip_v6_address_validator]), (IPv4Network, [ip_v4_network_validator]), (</span>
<span class="gd">-    IPv6Network, [ip_v6_network_validator])]</span>
<span class="gi">+    if config.arbitrary_types_allowed:</span>
<span class="gi">+        yield make_arbitrary_type_validator(type_)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise RuntimeError(f&#39;no validator found for {type_}, see `arbitrary_types_allowed` in Config&#39;)</span>
<span class="gh">diff --git a/pydantic/v1/version.py b/pydantic/v1/version.py</span>
<span class="gh">index a33537cac..8127c1139 100644</span>
<span class="gd">--- a/pydantic/v1/version.py</span>
<span class="gi">+++ b/pydantic/v1/version.py</span>
<span class="gu">@@ -1,11 +1,38 @@</span>
<span class="w"> </span>__all__ = &#39;compiled&#39;, &#39;VERSION&#39;, &#39;version_info&#39;
<span class="gi">+</span>
<span class="w"> </span>VERSION = &#39;1.10.17&#39;
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    import cython</span>
<span class="gi">+    import cython  # type: ignore</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    compiled: bool = False
<span class="gd">-else:</span>
<span class="gi">+else:  # pragma: no cover</span>
<span class="w"> </span>    try:
<span class="w"> </span>        compiled = cython.compiled
<span class="w"> </span>    except AttributeError:
<span class="w"> </span>        compiled = False
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def version_info() -&gt; str:</span>
<span class="gi">+    import platform</span>
<span class="gi">+    import sys</span>
<span class="gi">+    from importlib import import_module</span>
<span class="gi">+    from pathlib import Path</span>
<span class="gi">+</span>
<span class="gi">+    optional_deps = []</span>
<span class="gi">+    for p in (&#39;devtools&#39;, &#39;dotenv&#39;, &#39;email-validator&#39;, &#39;typing-extensions&#39;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            import_module(p.replace(&#39;-&#39;, &#39;_&#39;))</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        optional_deps.append(p)</span>
<span class="gi">+</span>
<span class="gi">+    info = {</span>
<span class="gi">+        &#39;pydantic version&#39;: VERSION,</span>
<span class="gi">+        &#39;pydantic compiled&#39;: compiled,</span>
<span class="gi">+        &#39;install path&#39;: Path(__file__).resolve().parent,</span>
<span class="gi">+        &#39;python version&#39;: sys.version,</span>
<span class="gi">+        &#39;platform&#39;: platform.platform(),</span>
<span class="gi">+        &#39;optional deps. installed&#39;: optional_deps,</span>
<span class="gi">+    }</span>
<span class="gi">+    return &#39;\n&#39;.join(&#39;{:&gt;30} {}&#39;.format(k + &#39;:&#39;, str(v).replace(&#39;\n&#39;, &#39; &#39;)) for k, v in info.items())</span>
<span class="gh">diff --git a/pydantic/validate_call_decorator.py b/pydantic/validate_call_decorator.py</span>
<span class="gh">index 5eb2596ae..5314c9207 100644</span>
<span class="gd">--- a/pydantic/validate_call_decorator.py</span>
<span class="gi">+++ b/pydantic/validate_call_decorator.py</span>
<span class="gu">@@ -1,17 +1,37 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Decorator for validating function calls.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, TypeVar, overload
<span class="gi">+</span>
<span class="w"> </span>from ._internal import _typing_extra, _validate_call
<span class="gd">-__all__ = &#39;validate_call&#39;,</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;validate_call&#39;,)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .config import ConfigDict
<span class="gi">+</span>
<span class="w"> </span>    AnyCallableT = TypeVar(&#39;AnyCallableT&#39;, bound=Callable[..., Any])


<span class="gd">-def validate_call(func: (AnyCallableT | None)=None, /, *, config: (</span>
<span class="gd">-    ConfigDict | None)=None, validate_return: bool=False) -&gt;(AnyCallableT |</span>
<span class="gd">-    Callable[[AnyCallableT], AnyCallableT]):</span>
<span class="gi">+@overload</span>
<span class="gi">+def validate_call(</span>
<span class="gi">+    *, config: ConfigDict | None = None, validate_return: bool = False</span>
<span class="gi">+) -&gt; Callable[[AnyCallableT], AnyCallableT]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def validate_call(func: AnyCallableT, /) -&gt; AnyCallableT: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_call(</span>
<span class="gi">+    func: AnyCallableT | None = None,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *,</span>
<span class="gi">+    config: ConfigDict | None = None,</span>
<span class="gi">+    validate_return: bool = False,</span>
<span class="gi">+) -&gt; AnyCallableT | Callable[[AnyCallableT], AnyCallableT]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Usage docs: https://docs.pydantic.dev/2.8/concepts/validation_decorator/

<span class="w"> </span>    Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value.
<span class="gu">@@ -26,4 +46,24 @@ def validate_call(func: (AnyCallableT | None)=None, /, *, config: (</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The decorated function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    local_ns = _typing_extra.parent_frame_namespace()</span>
<span class="gi">+</span>
<span class="gi">+    def validate(function: AnyCallableT) -&gt; AnyCallableT:</span>
<span class="gi">+        if isinstance(function, (classmethod, staticmethod)):</span>
<span class="gi">+            name = type(function).__name__</span>
<span class="gi">+            raise TypeError(f&#39;The `@{name}` decorator should be applied after `@validate_call` (put `@{name}` on top)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        validate_call_wrapper = _validate_call.ValidateCallWrapper(function, config, validate_return, local_ns)</span>
<span class="gi">+</span>
<span class="gi">+        @functools.wraps(function)</span>
<span class="gi">+        def wrapper_function(*args, **kwargs):</span>
<span class="gi">+            return validate_call_wrapper(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        wrapper_function.raw_function = function  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper_function  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    if func:</span>
<span class="gi">+        return validate(func)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return validate</span>
<span class="gh">diff --git a/pydantic/validators.py b/pydantic/validators.py</span>
<span class="gh">index 83d7de7a2..7921b04f0 100644</span>
<span class="gd">--- a/pydantic/validators.py</span>
<span class="gi">+++ b/pydantic/validators.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `validators` module is a backport module from V1.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._migration import getattr_migration
<span class="gi">+</span>
<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/version.py b/pydantic/version.py</span>
<span class="gh">index d63da2aeb..fa69a3a8f 100644</span>
<span class="gd">--- a/pydantic/version.py</span>
<span class="gi">+++ b/pydantic/version.py</span>
<span class="gu">@@ -1,24 +1,69 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The `version` module holds the version information for Pydantic.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>__all__ = &#39;VERSION&#39;, &#39;version_info&#39;
<span class="gi">+</span>
<span class="w"> </span>VERSION = &#39;2.8.2&#39;
<span class="w"> </span>&quot;&quot;&quot;The version of Pydantic.&quot;&quot;&quot;


<span class="gd">-def version_short() -&gt;str:</span>
<span class="gi">+def version_short() -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the `major.minor` part of Pydantic version.

<span class="w"> </span>    It returns &#39;2.1&#39; if Pydantic version is &#39;2.1.1&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;.&#39;.join(VERSION.split(&#39;.&#39;)[:2])</span>


<span class="gd">-def version_info() -&gt;str:</span>
<span class="gi">+def version_info() -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return complete version information for Pydantic and its dependencies.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import importlib.metadata as importlib_metadata</span>
<span class="gi">+    import os</span>
<span class="gi">+    import platform</span>
<span class="gi">+    import sys</span>
<span class="gi">+    from pathlib import Path</span>
<span class="gi">+</span>
<span class="gi">+    import pydantic_core._pydantic_core as pdc</span>
<span class="gi">+</span>
<span class="gi">+    from ._internal import _git as git</span>
<span class="gi">+</span>
<span class="gi">+    # get data about packages that are closely related to pydantic, use pydantic or often conflict with pydantic</span>
<span class="gi">+    package_names = {</span>
<span class="gi">+        &#39;email-validator&#39;,</span>
<span class="gi">+        &#39;fastapi&#39;,</span>
<span class="gi">+        &#39;mypy&#39;,</span>
<span class="gi">+        &#39;pydantic-extra-types&#39;,</span>
<span class="gi">+        &#39;pydantic-settings&#39;,</span>
<span class="gi">+        &#39;pyright&#39;,</span>
<span class="gi">+        &#39;typing_extensions&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+    related_packages = []</span>
<span class="gi">+</span>
<span class="gi">+    for dist in importlib_metadata.distributions():</span>
<span class="gi">+        name = dist.metadata[&#39;Name&#39;]</span>
<span class="gi">+        if name in package_names:</span>
<span class="gi">+            related_packages.append(f&#39;{name}-{dist.version}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    pydantic_dir = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))</span>
<span class="gi">+    most_recent_commit = (</span>
<span class="gi">+        git.git_revision(pydantic_dir) if git.is_git_repo(pydantic_dir) and git.have_git() else &#39;unknown&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    info = {</span>
<span class="gi">+        &#39;pydantic version&#39;: VERSION,</span>
<span class="gi">+        &#39;pydantic-core version&#39;: pdc.__version__,</span>
<span class="gi">+        &#39;pydantic-core build&#39;: getattr(pdc, &#39;build_info&#39;, None) or pdc.build_profile,</span>
<span class="gi">+        &#39;install path&#39;: Path(__file__).resolve().parent,</span>
<span class="gi">+        &#39;python version&#39;: sys.version,</span>
<span class="gi">+        &#39;platform&#39;: platform.platform(),</span>
<span class="gi">+        &#39;related packages&#39;: &#39; &#39;.join(related_packages),</span>
<span class="gi">+        &#39;commit&#39;: most_recent_commit,</span>
<span class="gi">+    }</span>
<span class="gi">+    return &#39;\n&#39;.join(&#39;{:&gt;30} {}&#39;.format(k + &#39;:&#39;, str(v).replace(&#39;\n&#39;, &#39; &#39;)) for k, v in info.items())</span>


<span class="gd">-def parse_mypy_version(version: str) -&gt;tuple[int, ...]:</span>
<span class="gi">+def parse_mypy_version(version: str) -&gt; tuple[int, ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse mypy string version to tuple of ints.

<span class="w"> </span>    It parses normal version like `0.930` and extra info followed by a `+` sign
<span class="gu">@@ -30,4 +75,4 @@ def parse_mypy_version(version: str) -&gt;tuple[int, ...]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A tuple of ints. e.g. (0, 930).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return tuple(map(int, version.partition(&#39;+&#39;)[0].split(&#39;.&#39;)))</span>
<span class="gh">diff --git a/pydantic/warnings.py b/pydantic/warnings.py</span>
<span class="gh">index 0d1b0a6a5..ea9fa6dc9 100644</span>
<span class="gd">--- a/pydantic/warnings.py</span>
<span class="gi">+++ b/pydantic/warnings.py</span>
<span class="gu">@@ -1,8 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Pydantic-specific warnings.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations as _annotations
<span class="gi">+</span>
<span class="w"> </span>from .version import version_short
<span class="gd">-__all__ = (&#39;PydanticDeprecatedSince20&#39;, &#39;PydanticDeprecationWarning&#39;,</span>
<span class="gd">-    &#39;PydanticDeprecatedSince26&#39;, &#39;PydanticExperimentalWarning&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &#39;PydanticDeprecatedSince20&#39;,</span>
<span class="gi">+    &#39;PydanticDeprecationWarning&#39;,</span>
<span class="gi">+    &#39;PydanticDeprecatedSince26&#39;,</span>
<span class="gi">+    &#39;PydanticExperimentalWarning&#39;,</span>
<span class="gi">+)</span>


<span class="w"> </span>class PydanticDeprecationWarning(DeprecationWarning):
<span class="gu">@@ -16,40 +23,40 @@ class PydanticDeprecationWarning(DeprecationWarning):</span>
<span class="w"> </span>        since: Pydantic version in what the deprecation was introduced.
<span class="w"> </span>        expected_removal: Pydantic version in what the corresponding functionality expected to be removed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    message: str
<span class="w"> </span>    since: tuple[int, int]
<span class="w"> </span>    expected_removal: tuple[int, int]

<span class="gd">-    def __init__(self, message: str, *args: object, since: tuple[int, int],</span>
<span class="gd">-        expected_removal: (tuple[int, int] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int, int] | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message, *args)
<span class="w"> </span>        self.message = message.rstrip(&#39;.&#39;)
<span class="w"> </span>        self.since = since
<span class="gd">-        self.expected_removal = (expected_removal if expected_removal is not</span>
<span class="gd">-            None else (since[0] + 1, 0))</span>
<span class="gi">+        self.expected_removal = expected_removal if expected_removal is not None else (since[0] + 1, 0)</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        message = (
<span class="gd">-            f&#39;{self.message}. Deprecated in Pydantic V{self.since[0]}.{self.since[1]} to be removed in V{self.expected_removal[0]}.{self.expected_removal[1]}.&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&#39;{self.message}. Deprecated in Pydantic V{self.since[0]}.{self.since[1]}&#39;</span>
<span class="gi">+            f&#39; to be removed in V{self.expected_removal[0]}.{self.expected_removal[1]}.&#39;</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if self.since == (2, 0):
<span class="gd">-            message += (</span>
<span class="gd">-                f&#39; See Pydantic V2 Migration Guide at https://errors.pydantic.dev/{version_short()}/migration/&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            message += f&#39; See Pydantic V2 Migration Guide at https://errors.pydantic.dev/{version_short()}/migration/&#39;</span>
<span class="w"> </span>        return message


<span class="w"> </span>class PydanticDeprecatedSince20(PydanticDeprecationWarning):
<span class="w"> </span>    &quot;&quot;&quot;A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.0.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, *args: object) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, *args: object) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message, *args, since=(2, 0), expected_removal=(3, 0))


<span class="w"> </span>class PydanticDeprecatedSince26(PydanticDeprecationWarning):
<span class="w"> </span>    &quot;&quot;&quot;A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.6.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, *args: object) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, *args: object) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message, *args, since=(2, 0), expected_removal=(3, 0))
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>