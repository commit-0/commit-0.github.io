
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin geopandas - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-geopandas" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin geopandas
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-geopandas"><strong>Claude Sonnet 3.5 - Fill-in</strong>: geopandas</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/geopandas/conftest.py&#39;.
geopandas/__init__.py:1: in &lt;module&gt;
    from geopandas._config import options
geopandas/_config.py:66: in &lt;module&gt;
    , validator=_validate_display_precision, callback=None)
E   NameError: name &#39;_validate_display_precision&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/geopandas/_compat.py b/geopandas/_compat.py</span>
<span class="gh">index 2c7e74f..a3eec3a 100644</span>
<span class="gd">--- a/geopandas/_compat.py</span>
<span class="gi">+++ b/geopandas/_compat.py</span>
<span class="gu">@@ -33,7 +33,15 @@ def import_optional_dependency(name: str, extra: str=&#39;&#39;):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    module
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = importlib.import_module(name)</span>
<span class="gi">+        return module</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        if extra:</span>
<span class="gi">+            msg = f&quot;Missing optional dependency &#39;{name}&#39;. {extra}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = f&quot;Missing optional dependency &#39;{name}&#39;. Use pip or conda to install {name}.&quot;</span>
<span class="gi">+        raise ImportError(msg) from None</span>


<span class="w"> </span>try:
<span class="gh">diff --git a/geopandas/_decorator.py b/geopandas/_decorator.py</span>
<span class="gh">index d242f70..1a16327 100644</span>
<span class="gd">--- a/geopandas/_decorator.py</span>
<span class="gi">+++ b/geopandas/_decorator.py</span>
<span class="gu">@@ -20,4 +20,21 @@ def doc(*docstrings: Union[str, Callable], **params) -&gt;Callable:</span>
<span class="w"> </span>    **params
<span class="w"> </span>        The string which would be used to format docstring template.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func: Callable) -&gt;Callable:</span>
<span class="gi">+        # Store original docstrings</span>
<span class="gi">+        func._docstring_components = list(docstrings)</span>
<span class="gi">+</span>
<span class="gi">+        # Concatenate and process docstrings</span>
<span class="gi">+        doc = func.__doc__ or &quot;&quot;</span>
<span class="gi">+        for docstring in docstrings:</span>
<span class="gi">+            if callable(docstring):</span>
<span class="gi">+                doc += dedent(docstring.__doc__ or &quot;&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                doc += dedent(docstring)</span>
<span class="gi">+</span>
<span class="gi">+        # Perform string substitution</span>
<span class="gi">+        func.__doc__ = doc.format(**params)</span>
<span class="gi">+</span>
<span class="gi">+        return func</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/geopandas/_version.py b/geopandas/_version.py</span>
<span class="gh">index 61aaa9f..b933b9d 100644</span>
<span class="gd">--- a/geopandas/_version.py</span>
<span class="gi">+++ b/geopandas/_version.py</span>
<span class="gu">@@ -10,7 +10,15 @@ import functools</span>

<span class="w"> </span>def get_keywords() -&gt;Dict[str, str]:
<span class="w"> </span>    &quot;&quot;&quot;Get the keywords needed to look up the version information.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # these strings will be replaced by git during git-archive.</span>
<span class="gi">+    # setup.py/versioneer.py will grep for the variable names, so they must</span>
<span class="gi">+    # each be defined on a line of their own. _version.py will just call</span>
<span class="gi">+    # get_keywords().</span>
<span class="gi">+    git_refnames = &quot;$Format:%d$&quot;</span>
<span class="gi">+    git_full = &quot;$Format:%H$&quot;</span>
<span class="gi">+    git_date = &quot;$Format:%ci$&quot;</span>
<span class="gi">+    keywords = {&quot;refnames&quot;: git_refnames, &quot;full&quot;: git_full, &quot;date&quot;: git_date}</span>
<span class="gi">+    return keywords</span>


<span class="w"> </span>class VersioneerConfig:
<span class="gu">@@ -25,7 +33,15 @@ class VersioneerConfig:</span>

<span class="w"> </span>def get_config() -&gt;VersioneerConfig:
<span class="w"> </span>    &quot;&quot;&quot;Create, populate and return the VersioneerConfig() object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # these strings are filled in when &#39;setup.py versioneer&#39; creates _version.py</span>
<span class="gi">+    cfg = VersioneerConfig()</span>
<span class="gi">+    cfg.VCS = &quot;git&quot;</span>
<span class="gi">+    cfg.style = &quot;pep440&quot;</span>
<span class="gi">+    cfg.tag_prefix = &quot;v&quot;</span>
<span class="gi">+    cfg.parentdir_prefix = &quot;geopandas-&quot;</span>
<span class="gi">+    cfg.versionfile_source = &quot;geopandas/_version.py&quot;</span>
<span class="gi">+    cfg.verbose = False</span>
<span class="gi">+    return cfg</span>


<span class="w"> </span>class NotThisMethod(Exception):
<span class="gu">@@ -38,14 +54,49 @@ HANDLERS: Dict[str, Dict[str, Callable]] = {}</span>

<span class="w"> </span>def register_vcs_handler(vcs: str, method: str) -&gt;Callable:
<span class="w"> </span>    &quot;&quot;&quot;Create decorator to mark a method as the handler of a VCS.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorate(f):</span>
<span class="gi">+        &quot;&quot;&quot;Store f in HANDLERS[vcs][method].&quot;&quot;&quot;</span>
<span class="gi">+        if vcs not in HANDLERS:</span>
<span class="gi">+            HANDLERS[vcs] = {}</span>
<span class="gi">+        HANDLERS[vcs][method] = f</span>
<span class="gi">+        return f</span>
<span class="gi">+    return decorate</span>


<span class="w"> </span>def run_command(commands: List[str], args: List[str], cwd: Optional[str]=
<span class="w"> </span>    None, verbose: bool=False, hide_stderr: bool=False, env: Optional[Dict[
<span class="w"> </span>    str, str]]=None) -&gt;Tuple[Optional[str], Optional[int]]:
<span class="w"> </span>    &quot;&quot;&quot;Call the given command(s).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert isinstance(commands, list)</span>
<span class="gi">+    p = None</span>
<span class="gi">+    for c in commands:</span>
<span class="gi">+        try:</span>
<span class="gi">+            dispcmd = str([c] + args)</span>
<span class="gi">+            # remember shell=False, so use git.cmd on windows, not just git</span>
<span class="gi">+            p = subprocess.Popen([c] + args, cwd=cwd, env=env,</span>
<span class="gi">+                                 stdout=subprocess.PIPE,</span>
<span class="gi">+                                 stderr=(subprocess.PIPE if hide_stderr</span>
<span class="gi">+                                         else None))</span>
<span class="gi">+            break</span>
<span class="gi">+        except EnvironmentError:</span>
<span class="gi">+            e = sys.exc_info()[1]</span>
<span class="gi">+            if e.errno == errno.ENOENT:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if verbose:</span>
<span class="gi">+                print(&quot;unable to run %s&quot; % dispcmd)</span>
<span class="gi">+                print(e)</span>
<span class="gi">+            return None, None</span>
<span class="gi">+    else:</span>
<span class="gi">+        if verbose:</span>
<span class="gi">+            print(&quot;unable to find command, tried %s&quot; % (commands,))</span>
<span class="gi">+        return None, None</span>
<span class="gi">+    stdout = p.communicate()[0].strip().decode()</span>
<span class="gi">+    if p.returncode != 0:</span>
<span class="gi">+        if verbose:</span>
<span class="gi">+            print(&quot;unable to run %s (error)&quot; % dispcmd)</span>
<span class="gi">+            print(&quot;stdout was %s&quot; % stdout)</span>
<span class="gi">+        return None, p.returncode</span>
<span class="gi">+    return stdout, p.returncode</span>


<span class="w"> </span>def versions_from_parentdir(parentdir_prefix: str, root: str, verbose: bool
<span class="gu">@@ -56,20 +107,102 @@ def versions_from_parentdir(parentdir_prefix: str, root: str, verbose: bool</span>
<span class="w"> </span>    the project name and a version string. We will also support searching up
<span class="w"> </span>    two directory levels for an appropriately named parent directory
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rootdirs = []</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(3):</span>
<span class="gi">+        dirname = os.path.basename(root)</span>
<span class="gi">+        if dirname.startswith(parentdir_prefix):</span>
<span class="gi">+            return {&quot;version&quot;: dirname[len(parentdir_prefix):],</span>
<span class="gi">+                    &quot;full-revisionid&quot;: None,</span>
<span class="gi">+                    &quot;dirty&quot;: False, &quot;error&quot;: None, &quot;date&quot;: None}</span>
<span class="gi">+        else:</span>
<span class="gi">+            rootdirs.append(root)</span>
<span class="gi">+            root = os.path.dirname(root)</span>
<span class="gi">+</span>
<span class="gi">+    if verbose:</span>
<span class="gi">+        print(&quot;Tried directories %s but none started with prefix %s&quot; %</span>
<span class="gi">+              (str(rootdirs), parentdir_prefix))</span>
<span class="gi">+    raise NotThisMethod(&quot;rootdir doesn&#39;t start with parentdir_prefix&quot;)</span>


<span class="w"> </span>@register_vcs_handler(&#39;git&#39;, &#39;get_keywords&#39;)
<span class="w"> </span>def git_get_keywords(versionfile_abs: str) -&gt;Dict[str, str]:
<span class="w"> </span>    &quot;&quot;&quot;Extract version information from the given file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # the code embedded in _version.py can just fetch the value of these</span>
<span class="gi">+    # keywords. When used from setup.py, we don&#39;t want to import _version.py,</span>
<span class="gi">+    # so we do it with a regexp instead. This function is not used from</span>
<span class="gi">+    # _version.py.</span>
<span class="gi">+    keywords = {}</span>
<span class="gi">+    try:</span>
<span class="gi">+        f = open(versionfile_abs, &quot;r&quot;)</span>
<span class="gi">+        for line in f.readlines():</span>
<span class="gi">+            if line.strip().startswith(&quot;git_refnames =&quot;):</span>
<span class="gi">+                mo = re.search(r&#39;=\s*&quot;(.*)&quot;&#39;, line)</span>
<span class="gi">+                if mo:</span>
<span class="gi">+                    keywords[&quot;refnames&quot;] = mo.group(1)</span>
<span class="gi">+            if line.strip().startswith(&quot;git_full =&quot;):</span>
<span class="gi">+                mo = re.search(r&#39;=\s*&quot;(.*)&quot;&#39;, line)</span>
<span class="gi">+                if mo:</span>
<span class="gi">+                    keywords[&quot;full&quot;] = mo.group(1)</span>
<span class="gi">+            if line.strip().startswith(&quot;git_date =&quot;):</span>
<span class="gi">+                mo = re.search(r&#39;=\s*&quot;(.*)&quot;&#39;, line)</span>
<span class="gi">+                if mo:</span>
<span class="gi">+                    keywords[&quot;date&quot;] = mo.group(1)</span>
<span class="gi">+        f.close()</span>
<span class="gi">+    except EnvironmentError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    return keywords</span>


<span class="w"> </span>@register_vcs_handler(&#39;git&#39;, &#39;keywords&#39;)
<span class="w"> </span>def git_versions_from_keywords(keywords: Dict[str, str], tag_prefix: str,
<span class="w"> </span>    verbose: bool) -&gt;Dict[str, Any]:
<span class="w"> </span>    &quot;&quot;&quot;Get version information from git keywords.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not keywords:</span>
<span class="gi">+        raise NotThisMethod(&quot;no keywords at all, weird&quot;)</span>
<span class="gi">+    date = keywords.get(&quot;date&quot;)</span>
<span class="gi">+    if date is not None:</span>
<span class="gi">+        # git-2.2.0 added &quot;%cI&quot;, which expands to an ISO-8601 format</span>
<span class="gi">+        date = date.strip().replace(&quot; &quot;, &quot;T&quot;, 1).replace(&quot; &quot;, &quot;&quot;, 1)</span>
<span class="gi">+    refnames = keywords[&quot;refnames&quot;].strip()</span>
<span class="gi">+    if refnames.startswith(&quot;$Format&quot;):</span>
<span class="gi">+        if verbose:</span>
<span class="gi">+            print(&quot;keywords are unexpanded, not using&quot;)</span>
<span class="gi">+        raise NotThisMethod(&quot;unexpanded keywords, not a git-archive tarball&quot;)</span>
<span class="gi">+    refs = set([r.strip() for r in refnames.strip(&quot;()&quot;).split(&quot;,&quot;)])</span>
<span class="gi">+    # starting in git-1.8.3, tags are listed as &quot;tag: foo-1.0&quot; instead of</span>
<span class="gi">+    # just &quot;foo-1.0&quot;. If we see a &quot;tag: &quot; prefix, prefer those.</span>
<span class="gi">+    TAG = &quot;tag: &quot;</span>
<span class="gi">+    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])</span>
<span class="gi">+    if not tags:</span>
<span class="gi">+        # Either we&#39;re using git &lt; 1.8.3, or there really are no tags. We use</span>
<span class="gi">+        # a heuristic: assume all version tags have a digit. The old git %d</span>
<span class="gi">+        # expansion behaves like git log --decorate=short and strips out the</span>
<span class="gi">+        # refs/heads/ and refs/tags/ prefixes that would let us distinguish</span>
<span class="gi">+        # between branches and tags. By ignoring refnames without digits, we</span>
<span class="gi">+        # filter out many common branch names like &quot;release&quot; and</span>
<span class="gi">+        # &quot;stabilization&quot;, as well as &quot;HEAD&quot; and &quot;master&quot;.</span>
<span class="gi">+        tags = set([r for r in refs if re.search(r&#39;\d&#39;, r)])</span>
<span class="gi">+        if verbose:</span>
<span class="gi">+            print(&quot;discarding &#39;%s&#39;, no digits&quot; % &quot;,&quot;.join(refs - tags))</span>
<span class="gi">+    if verbose:</span>
<span class="gi">+        print(&quot;likely tags: %s&quot; % &quot;,&quot;.join(sorted(tags)))</span>
<span class="gi">+    for ref in sorted(tags):</span>
<span class="gi">+        # sorting will prefer e.g. &quot;2.0&quot; over &quot;2.0rc1&quot;</span>
<span class="gi">+        if ref.startswith(tag_prefix):</span>
<span class="gi">+            r = ref[len(tag_prefix):]</span>
<span class="gi">+            if verbose:</span>
<span class="gi">+                print(&quot;picking %s&quot; % r)</span>
<span class="gi">+            return {&quot;version&quot;: r,</span>
<span class="gi">+                    &quot;full-revisionid&quot;: keywords[&quot;full&quot;].strip(),</span>
<span class="gi">+                    &quot;dirty&quot;: False, &quot;error&quot;: None,</span>
<span class="gi">+                    &quot;date&quot;: date}</span>
<span class="gi">+    # no suitable tags, so version is &quot;0+unknown&quot;, but full hex is still there</span>
<span class="gi">+    if verbose:</span>
<span class="gi">+        print(&quot;no suitable tags, using unknown + full revision id&quot;)</span>
<span class="gi">+    return {&quot;version&quot;: &quot;0+unknown&quot;,</span>
<span class="gi">+            &quot;full-revisionid&quot;: keywords[&quot;full&quot;].strip(),</span>
<span class="gi">+            &quot;dirty&quot;: False, &quot;error&quot;: &quot;no suitable tags&quot;, &quot;date&quot;: None}</span>


<span class="w"> </span>@register_vcs_handler(&#39;git&#39;, &#39;pieces_from_vcs&#39;)
<span class="gu">@@ -81,12 +214,95 @@ def git_pieces_from_vcs(tag_prefix: str, root: str, verbose: bool, runner:</span>
<span class="w"> </span>    expanded, and _version.py hasn&#39;t already been rewritten with a short
<span class="w"> </span>    version string, meaning we&#39;re inside a checked out source tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    GITS = [&quot;git&quot;]</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        GITS = [&quot;git.cmd&quot;, &quot;git.exe&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    out, rc = runner(GITS, [&quot;rev-parse&quot;, &quot;--git-dir&quot;], cwd=root,</span>
<span class="gi">+                     hide_stderr=True)</span>
<span class="gi">+    if rc != 0:</span>
<span class="gi">+        if verbose:</span>
<span class="gi">+            print(&quot;Directory %s not under git control&quot; % root)</span>
<span class="gi">+        raise NotThisMethod(&quot;&#39;git rev-parse --git-dir&#39; returned error&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]</span>
<span class="gi">+    # if there isn&#39;t one, this yields HEX[-dirty] (no NUM)</span>
<span class="gi">+    describe_out, rc = runner(GITS, [&quot;describe&quot;, &quot;--tags&quot;, &quot;--dirty&quot;,</span>
<span class="gi">+                                     &quot;--always&quot;, &quot;--long&quot;,</span>
<span class="gi">+                                     &quot;--match&quot;, &quot;%s*&quot; % tag_prefix],</span>
<span class="gi">+                              cwd=root)</span>
<span class="gi">+    # --long was added in git-1.5.5</span>
<span class="gi">+    if describe_out is None:</span>
<span class="gi">+        raise NotThisMethod(&quot;&#39;git describe&#39; failed&quot;)</span>
<span class="gi">+    describe_out = describe_out.strip()</span>
<span class="gi">+    full_out, rc = runner(GITS, [&quot;rev-parse&quot;, &quot;HEAD&quot;], cwd=root)</span>
<span class="gi">+    if full_out is None:</span>
<span class="gi">+        raise NotThisMethod(&quot;&#39;git rev-parse&#39; failed&quot;)</span>
<span class="gi">+    full_out = full_out.strip()</span>
<span class="gi">+</span>
<span class="gi">+    pieces = {}</span>
<span class="gi">+    pieces[&quot;long&quot;] = full_out</span>
<span class="gi">+    pieces[&quot;short&quot;] = full_out[:7]  # maybe improved later</span>
<span class="gi">+    pieces[&quot;error&quot;] = None</span>
<span class="gi">+</span>
<span class="gi">+    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]</span>
<span class="gi">+    # TAG might have hyphens.</span>
<span class="gi">+    git_describe = describe_out</span>
<span class="gi">+</span>
<span class="gi">+    # look for -dirty suffix</span>
<span class="gi">+    dirty = git_describe.endswith(&quot;-dirty&quot;)</span>
<span class="gi">+    pieces[&quot;dirty&quot;] = dirty</span>
<span class="gi">+    if dirty:</span>
<span class="gi">+        git_describe = git_describe[:git_describe.rindex(&quot;-dirty&quot;)]</span>
<span class="gi">+</span>
<span class="gi">+    # now we have TAG-NUM-gHEX or HEX</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;-&quot; in git_describe:</span>
<span class="gi">+        # TAG-NUM-gHEX</span>
<span class="gi">+        mo = re.search(r&#39;^(.+)-(\d+)-g([0-9a-f]+)$&#39;, git_describe)</span>
<span class="gi">+        if not mo:</span>
<span class="gi">+            # unparseable. Maybe git-describe is misbehaving?</span>
<span class="gi">+            pieces[&quot;error&quot;] = (&quot;unable to parse git-describe output: &#39;%s&#39;&quot;</span>
<span class="gi">+                               % describe_out)</span>
<span class="gi">+            return pieces</span>
<span class="gi">+</span>
<span class="gi">+        # tag</span>
<span class="gi">+        full_tag = mo.group(1)</span>
<span class="gi">+        if not full_tag.startswith(tag_prefix):</span>
<span class="gi">+            if verbose:</span>
<span class="gi">+                fmt = &quot;tag &#39;%s&#39; doesn&#39;t start with prefix &#39;%s&#39;&quot;</span>
<span class="gi">+                print(fmt % (full_tag, tag_prefix))</span>
<span class="gi">+            pieces[&quot;error&quot;] = (&quot;tag &#39;%s&#39; doesn&#39;t start with prefix &#39;%s&#39;&quot;</span>
<span class="gi">+                               % (full_tag, tag_prefix))</span>
<span class="gi">+            return pieces</span>
<span class="gi">+        pieces[&quot;closest-tag&quot;] = full_tag[len(tag_prefix):]</span>
<span class="gi">+</span>
<span class="gi">+        # distance: number of commits since tag</span>
<span class="gi">+        pieces[&quot;distance&quot;] = int(mo.group(2))</span>
<span class="gi">+</span>
<span class="gi">+        # commit: short hex revision ID</span>
<span class="gi">+        pieces[&quot;short&quot;] = mo.group(3)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        # HEX: no tags</span>
<span class="gi">+        pieces[&quot;closest-tag&quot;] = None</span>
<span class="gi">+        count_out, rc = runner(GITS, [&quot;rev-list&quot;, &quot;HEAD&quot;, &quot;--count&quot;],</span>
<span class="gi">+                               cwd=root)</span>
<span class="gi">+        pieces[&quot;distance&quot;] = int(count_out)  # total number of commits</span>
<span class="gi">+</span>
<span class="gi">+    # commit date: see ISO-8601 comment in git_versions_from_keywords()</span>
<span class="gi">+    date = runner(GITS, [&quot;show&quot;, &quot;-s&quot;, &quot;--format=%ci&quot;, &quot;HEAD&quot;],</span>
<span class="gi">+                  cwd=root)[0].strip()</span>
<span class="gi">+    pieces[&quot;date&quot;] = date.strip().replace(&quot; &quot;, &quot;T&quot;, 1).replace(&quot; &quot;, &quot;&quot;, 1)</span>
<span class="gi">+</span>
<span class="gi">+    return pieces</span>


<span class="w"> </span>def plus_or_dot(pieces: Dict[str, Any]) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Return a + if we don&#39;t already have one, else return a .&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;+&quot; in pieces.get(&quot;closest-tag&quot;, &quot;&quot;):</span>
<span class="gi">+        return &quot;.&quot;</span>
<span class="gi">+    return &quot;+&quot;</span>


<span class="w"> </span>def render_pep440(pieces: Dict[str, Any]) -&gt;str:
<span class="gu">@@ -98,7 +314,20 @@ def render_pep440(pieces: Dict[str, Any]) -&gt;str:</span>
<span class="w"> </span>    Exceptions:
<span class="w"> </span>    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pieces[&quot;closest-tag&quot;]:</span>
<span class="gi">+        rendered = pieces[&quot;closest-tag&quot;]</span>
<span class="gi">+        if pieces[&quot;distance&quot;] or pieces[&quot;dirty&quot;]:</span>
<span class="gi">+            rendered += plus_or_dot(pieces)</span>
<span class="gi">+            rendered += &quot;%d.g%s&quot; % (pieces[&quot;distance&quot;], pieces[&quot;short&quot;])</span>
<span class="gi">+            if pieces[&quot;dirty&quot;]:</span>
<span class="gi">+                rendered += &quot;.dirty&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # exception #1</span>
<span class="gi">+        rendered = &quot;0+untagged.%d.g%s&quot; % (pieces[&quot;distance&quot;],</span>
<span class="gi">+                                          pieces[&quot;short&quot;])</span>
<span class="gi">+        if pieces[&quot;dirty&quot;]:</span>
<span class="gi">+            rendered += &quot;.dirty&quot;</span>
<span class="gi">+    return rendered</span>


<span class="w"> </span>def render_pep440_branch(pieces: Dict[str, Any]) -&gt;str:
<span class="gu">@@ -110,7 +339,24 @@ def render_pep440_branch(pieces: Dict[str, Any]) -&gt;str:</span>
<span class="w"> </span>    Exceptions:
<span class="w"> </span>    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pieces[&quot;closest-tag&quot;]:</span>
<span class="gi">+        rendered = pieces[&quot;closest-tag&quot;]</span>
<span class="gi">+        if pieces[&quot;distance&quot;] or pieces[&quot;dirty&quot;]:</span>
<span class="gi">+            rendered += &quot;.dev0&quot;</span>
<span class="gi">+            rendered += plus_or_dot(pieces)</span>
<span class="gi">+            rendered += &quot;%d.g%s&quot; % (pieces[&quot;distance&quot;], pieces[&quot;short&quot;])</span>
<span class="gi">+            if pieces[&quot;dirty&quot;]:</span>
<span class="gi">+                rendered += &quot;.dirty&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # exception #1</span>
<span class="gi">+        rendered = &quot;0&quot;</span>
<span class="gi">+        if pieces[&quot;distance&quot;] or pieces[&quot;dirty&quot;]:</span>
<span class="gi">+            rendered += &quot;.dev0&quot;</span>
<span class="gi">+            rendered += &quot;+untagged.%d.g%s&quot; % (pieces[&quot;distance&quot;],</span>
<span class="gi">+                                              pieces[&quot;short&quot;])</span>
<span class="gi">+            if pieces[&quot;dirty&quot;]:</span>
<span class="gi">+                rendered += &quot;.dirty&quot;</span>
<span class="gi">+    return rendered</span>


<span class="w"> </span>def pep440_split_post(ver: str) -&gt;Tuple[str, Optional[int]]:
<span class="gh">diff --git a/geopandas/array.py b/geopandas/array.py</span>
<span class="gh">index 3f1cc54..44ac545 100644</span>
<span class="gd">--- a/geopandas/array.py</span>
<span class="gi">+++ b/geopandas/array.py</span>
<span class="gu">@@ -41,14 +41,26 @@ def _check_crs(left, right, allow_none=False):</span>

<span class="w"> </span>    If allow_none is True, empty CRS is treated as the same.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if allow_none and (left is None or right is None):</span>
<span class="gi">+        return True</span>
<span class="gi">+    elif left is None or right is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        return left == right</span>


<span class="w"> </span>def _crs_mismatch_warn(left, right, stacklevel=3):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Raise a CRS mismatch warning with the information on the assigned CRS.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        f&quot;CRS mismatch between the CRS of left geometries and right geometries.\n&quot;</span>
<span class="gi">+        f&quot;Left CRS: {left}\n&quot;</span>
<span class="gi">+        f&quot;Right CRS: {right}\n&quot;</span>
<span class="gi">+        &quot;Use `to_crs()` to reproject geometries to the same CRS before comparison.&quot;,</span>
<span class="gi">+        UserWarning,</span>
<span class="gi">+        stacklevel=stacklevel</span>
<span class="gi">+    )</span>


<span class="w"> </span>def isna(value):
<span class="gu">@@ -58,7 +70,7 @@ def isna(value):</span>
<span class="w"> </span>    Custom version that only works for scalars (returning True or False),
<span class="w"> </span>    as `pd.isna` also works for array-like input returning a boolean array.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is None or (isinstance(value, float) and np.isnan(value)) or pd.isna(value)</span>


<span class="w"> </span>def from_shapely(data, crs=None):
<span class="gu">@@ -77,14 +89,30 @@ def from_shapely(data, crs=None):</span>
<span class="w"> </span>        such as an authority string (eg &quot;EPSG:4326&quot;) or a WKT string.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(data, np.ndarray):</span>
<span class="gi">+        data = np.array(data, dtype=object)</span>
<span class="gi">+    </span>
<span class="gi">+    if data.ndim != 1:</span>
<span class="gi">+        raise ValueError(&quot;Only 1-dimensional input is supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Validate that all elements are shapely geometries or None</span>
<span class="gi">+    for geom in data:</span>
<span class="gi">+        if geom is not None and not isinstance(geom, BaseGeometry):</span>
<span class="gi">+            raise TypeError(f&quot;Invalid geometry object {geom}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return GeometryArray(data, crs=crs)</span>


<span class="w"> </span>def to_shapely(geoms):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert GeometryArray to numpy object array of shapely objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(geoms, GeometryArray):</span>
<span class="gi">+        return geoms._data</span>
<span class="gi">+    elif isinstance(geoms, np.ndarray):</span>
<span class="gi">+        return geoms</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Input must be a GeometryArray or numpy array&quot;)</span>


<span class="w"> </span>def from_wkb(data, crs=None, on_invalid=&#39;raise&#39;):
<span class="gu">@@ -106,14 +134,48 @@ def from_wkb(data, crs=None, on_invalid=&#39;raise&#39;):</span>
<span class="w"> </span>        - ignore: invalid WKB geometries will be returned as None without a warning.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import shapely.wkb</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(data, np.ndarray):</span>
<span class="gi">+        data = np.array(data, dtype=object)</span>
<span class="gi">+</span>
<span class="gi">+    geoms = []</span>
<span class="gi">+    for wkb in data:</span>
<span class="gi">+        try:</span>
<span class="gi">+            geom = shapely.wkb.loads(wkb)</span>
<span class="gi">+            geoms.append(geom)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            if on_invalid == &#39;raise&#39;:</span>
<span class="gi">+                raise ValueError(f&quot;Invalid WKB geometry: {e}&quot;)</span>
<span class="gi">+            elif on_invalid == &#39;warn&#39;:</span>
<span class="gi">+                warnings.warn(f&quot;Invalid WKB geometry: {e}&quot;, UserWarning)</span>
<span class="gi">+                geoms.append(None)</span>
<span class="gi">+            elif on_invalid == &#39;ignore&#39;:</span>
<span class="gi">+                geoms.append(None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;Invalid value for on_invalid&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return GeometryArray(np.array(geoms, dtype=object), crs=crs)</span>


<span class="w"> </span>def to_wkb(geoms, hex=False, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert GeometryArray to a numpy object array of WKB objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import shapely.wkb</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(geoms, GeometryArray):</span>
<span class="gi">+        geoms = geoms._data</span>
<span class="gi">+</span>
<span class="gi">+    wkb_objects = []</span>
<span class="gi">+    for geom in geoms:</span>
<span class="gi">+        if geom is None:</span>
<span class="gi">+            wkb_objects.append(None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            wkb = shapely.wkb.dumps(geom, hex=hex, **kwargs)</span>
<span class="gi">+            wkb_objects.append(wkb)</span>
<span class="gi">+</span>
<span class="gi">+    return np.array(wkb_objects, dtype=object)</span>


<span class="w"> </span>def from_wkt(data, crs=None, on_invalid=&#39;raise&#39;):
<span class="gh">diff --git a/geopandas/explore.py b/geopandas/explore.py</span>
<span class="gh">index dbf38bd..269566f 100644</span>
<span class="gd">--- a/geopandas/explore.py</span>
<span class="gi">+++ b/geopandas/explore.py</span>
<span class="gu">@@ -227,7 +227,24 @@ def _explore(df, column=None, cmap=None, color=None, m=None, tiles=</span>

<span class="w"> </span>def _tooltip_popup(type, fields, gdf, **kwds):
<span class="w"> </span>    &quot;&quot;&quot;get tooltip or popup&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from folium.features import GeoJsonTooltip, GeoJsonPopup</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(fields, bool):</span>
<span class="gi">+        if fields:</span>
<span class="gi">+            fields = gdf.columns.drop(gdf.geometry.name).tolist()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+    elif isinstance(fields, int):</span>
<span class="gi">+        fields = gdf.columns.drop(gdf.geometry.name).tolist()[:fields]</span>
<span class="gi">+    elif isinstance(fields, str):</span>
<span class="gi">+        fields = [fields]</span>
<span class="gi">+    </span>
<span class="gi">+    if type == &#39;tooltip&#39;:</span>
<span class="gi">+        return GeoJsonTooltip(fields=fields, **kwds)</span>
<span class="gi">+    elif type == &#39;popup&#39;:</span>
<span class="gi">+        return GeoJsonPopup(fields=fields, **kwds)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Type must be either &#39;tooltip&#39; or &#39;popup&#39;&quot;)</span>


<span class="w"> </span>def _categorical_legend(m, title, categories, colors):
<span class="gu">@@ -251,7 +268,52 @@ def _categorical_legend(m, title, categories, colors):</span>
<span class="w"> </span>    colors : list-like
<span class="w"> </span>        list of colors (in the same order as categories)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from branca.element import Template, MacroElement</span>
<span class="gi">+</span>
<span class="gi">+    template = &quot;&quot;&quot;</span>
<span class="gi">+    {% macro html(this, kwargs) %}</span>
<span class="gi">+    &lt;div style=&quot;</span>
<span class="gi">+        position: fixed; </span>
<span class="gi">+        bottom: 50px; </span>
<span class="gi">+        right: 50px; </span>
<span class="gi">+        width: 120px; </span>
<span class="gi">+        height: 90px; </span>
<span class="gi">+        z-index:9999; </span>
<span class="gi">+        font-size:14px;</span>
<span class="gi">+        &quot;&gt;</span>
<span class="gi">+        &lt;p&gt;&lt;a style=&quot;color: #0000ff; text-decoration: none; font-weight: bold; font-size: 14px;&quot; href=&quot;#&quot; onclick=&quot;toggle_legend(); return false;&quot;&gt;Toggle Legend&lt;/a&gt;&lt;/p&gt;</span>
<span class="gi">+        &lt;div id=&quot;legend&quot; style=&quot;background-color: #fff; padding: 10px; display:none;&quot;&gt;</span>
<span class="gi">+            &lt;div style=&#39;padding:3px; font-weight: bold;&#39;&gt;</span>
<span class="gi">+                {{ this.title }}</span>
<span class="gi">+            &lt;/div&gt;</span>
<span class="gi">+            {% for label, color in this.categories_colors %}</span>
<span class="gi">+            &lt;div&gt;</span>
<span class="gi">+                &lt;span style=&#39;background-color: {{ color }}; border: 1px solid #000; display: inline-block; width: 12px; height: 12px;&#39;&gt;&lt;/span&gt;</span>
<span class="gi">+                &lt;span style=&#39;padding-left:5px;&#39;&gt;{{ label }}&lt;/span&gt;</span>
<span class="gi">+            &lt;/div&gt;</span>
<span class="gi">+            {% endfor %}</span>
<span class="gi">+        &lt;/div&gt;</span>
<span class="gi">+    &lt;/div&gt;</span>
<span class="gi">+</span>
<span class="gi">+    &lt;script&gt;</span>
<span class="gi">+    function toggle_legend() {</span>
<span class="gi">+        var legend = document.getElementById(&#39;legend&#39;);</span>
<span class="gi">+        if (legend.style.display === &#39;none&#39;) {</span>
<span class="gi">+            legend.style.display = &#39;block&#39;;</span>
<span class="gi">+        } else {</span>
<span class="gi">+            legend.style.display = &#39;none&#39;;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+    &lt;/script&gt;</span>
<span class="gi">+    {% endmacro %}</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    macro = MacroElement()</span>
<span class="gi">+    macro._template = Template(template)</span>
<span class="gi">+    macro.title = title</span>
<span class="gi">+    macro.categories_colors = list(zip(categories, colors))</span>
<span class="gi">+</span>
<span class="gi">+    m.get_root().add_child(macro)</span>


<span class="w"> </span>def _explore_geoseries(s, color=None, m=None, tiles=&#39;OpenStreetMap&#39;, attr=
<span class="gh">diff --git a/geopandas/geoseries.py b/geopandas/geoseries.py</span>
<span class="gh">index 38c4ecf..30c4981 100644</span>
<span class="gd">--- a/geopandas/geoseries.py</span>
<span class="gi">+++ b/geopandas/geoseries.py</span>
<span class="gu">@@ -193,7 +193,7 @@ class GeoSeries(GeoPandasBase, Series):</span>
<span class="w"> </span>        GeoSeries.z

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Series([geom.x if geom else None for geom in self], index=self.index)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def y(self) -&gt;Series:
<span class="gu">@@ -221,7 +221,7 @@ class GeoSeries(GeoPandasBase, Series):</span>
<span class="w"> </span>        GeoSeries.z

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Series([geom.y if geom else None for geom in self], index=self.index)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def z(self) -&gt;Series:
<span class="gu">@@ -249,7 +249,7 @@ class GeoSeries(GeoPandasBase, Series):</span>
<span class="w"> </span>        GeoSeries.y

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Series([geom.z if geom and hasattr(geom, &#39;z&#39;) else None for geom in self], index=self.index)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_file(cls, filename: (os.PathLike | typing.IO), **kwargs
<span class="gu">@@ -602,7 +602,7 @@ class GeoSeries(GeoPandasBase, Series):</span>
<span class="w"> </span>        GeoSeries.notna : inverse of isna
<span class="w"> </span>        GeoSeries.is_empty : detect empty geometries
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Series([geom is None for geom in self], index=self.index)</span>

<span class="w"> </span>    def isnull(self) -&gt;Series:
<span class="w"> </span>        &quot;&quot;&quot;Alias for `isna` method. See `isna` for more detail.&quot;&quot;&quot;
<span class="gu">@@ -647,7 +647,7 @@ class GeoSeries(GeoPandasBase, Series):</span>
<span class="w"> </span>        GeoSeries.isna : inverse of notna
<span class="w"> </span>        GeoSeries.is_empty : detect empty geometries
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Series([geom is not None for geom in self], index=self.index)</span>

<span class="w"> </span>    def notnull(self) -&gt;Series:
<span class="w"> </span>        &quot;&quot;&quot;Alias for `notna` method. See `notna` for more detail.&quot;&quot;&quot;
<span class="gh">diff --git a/geopandas/io/_geoarrow.py b/geopandas/io/_geoarrow.py</span>
<span class="gh">index cb4401f..b8eb457 100644</span>
<span class="gd">--- a/geopandas/io/_geoarrow.py</span>
<span class="gi">+++ b/geopandas/io/_geoarrow.py</span>
<span class="gu">@@ -101,7 +101,52 @@ def geopandas_to_arrow(df, index=None, geometry_encoding=&#39;WKB&#39;, interleaved</span>
<span class="w"> </span>        specify the keyword).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(df, GeoDataFrame):</span>
<span class="gi">+        raise ValueError(&quot;Input must be a GeoDataFrame&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Handle index</span>
<span class="gi">+    if index is None:</span>
<span class="gi">+        index = not isinstance(df.index, pd.RangeIndex)</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert DataFrame to Arrow table</span>
<span class="gi">+    table = pa.Table.from_pandas(df, preserve_index=index)</span>
<span class="gi">+    </span>
<span class="gi">+    # Handle geometry column</span>
<span class="gi">+    geom_col = df.geometry.name</span>
<span class="gi">+    geom_array = df.geometry.values</span>
<span class="gi">+    </span>
<span class="gi">+    if geometry_encoding == &#39;WKB&#39;:</span>
<span class="gi">+        wkb_array = pa.array(geom_array.to_wkb())</span>
<span class="gi">+        field = pa.field(geom_col, pa.binary())</span>
<span class="gi">+        table = table.set_column(table.schema.get_field_index(geom_col), field, wkb_array)</span>
<span class="gi">+    elif geometry_encoding == &#39;geoarrow&#39;:</span>
<span class="gi">+        if include_z is None:</span>
<span class="gi">+            include_z = geom_array.has_z.any()</span>
<span class="gi">+        </span>
<span class="gi">+        coord_type = pa.float64()</span>
<span class="gi">+        if interleaved:</span>
<span class="gi">+            coords = [g.coords[:] for g in geom_array]</span>
<span class="gi">+            if include_z:</span>
<span class="gi">+                coords_array = pa.list_(pa.list_(coord_type, 3))</span>
<span class="gi">+            else:</span>
<span class="gi">+                coords_array = pa.list_(pa.list_(coord_type, 2))</span>
<span class="gi">+            coords_array = pa.array(coords, type=coords_array)</span>
<span class="gi">+        else:</span>
<span class="gi">+            x, y = zip(*[(c[0], c[1]) for g in geom_array for c in g.coords])</span>
<span class="gi">+            if include_z:</span>
<span class="gi">+                z = [c[2] if len(c) &gt; 2 else float(&#39;nan&#39;) for g in geom_array for c in g.coords]</span>
<span class="gi">+                coords_array = pa.StructArray.from_arrays([pa.array(x), pa.array(y), pa.array(z)], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span>
<span class="gi">+            else:</span>
<span class="gi">+                coords_array = pa.StructArray.from_arrays([pa.array(x), pa.array(y)], [&#39;x&#39;, &#39;y&#39;])</span>
<span class="gi">+        </span>
<span class="gi">+        geom_type = pa.array([g.geom_type for g in geom_array], pa.string())</span>
<span class="gi">+        field = pa.field(geom_col, pa.struct([(&#39;type&#39;, pa.string()), (&#39;coordinates&#39;, coords_array.type)]))</span>
<span class="gi">+        geoarrow_array = pa.StructArray.from_arrays([geom_type, coords_array], [&#39;type&#39;, &#39;coordinates&#39;])</span>
<span class="gi">+        table = table.set_column(table.schema.get_field_index(geom_col), field, geoarrow_array)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Invalid geometry_encoding. Must be &#39;WKB&#39; or &#39;geoarrow&#39;&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    return table</span>


<span class="w"> </span>def arrow_to_geopandas(table, geometry=None):
<span class="gu">@@ -121,7 +166,55 @@ def arrow_to_geopandas(table, geometry=None):</span>
<span class="w"> </span>    GeoDataFrame

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(table, pa.Table):</span>
<span class="gi">+        raise ValueError(&quot;Input must be a pyarrow.Table&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Convert Arrow table to pandas DataFrame</span>
<span class="gi">+    df = table.to_pandas()</span>
<span class="gi">+</span>
<span class="gi">+    # Find geometry column</span>
<span class="gi">+    if geometry is None:</span>
<span class="gi">+        geometry_columns = [field.name for field in table.schema if </span>
<span class="gi">+                            isinstance(field.type, pa.BinaryType) or </span>
<span class="gi">+                            (isinstance(field.type, pa.StructType) and &#39;type&#39; in field.type.names and &#39;coordinates&#39; in field.type.names)]</span>
<span class="gi">+        if not geometry_columns:</span>
<span class="gi">+            raise ValueError(&quot;No geometry column found in the Arrow table&quot;)</span>
<span class="gi">+        geometry = geometry_columns[0]</span>
<span class="gi">+    elif geometry not in table.column_names:</span>
<span class="gi">+        raise ValueError(f&quot;Specified geometry column &#39;{geometry}&#39; not found in the Arrow table&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Convert geometry column</span>
<span class="gi">+    if isinstance(table.field(geometry).type, pa.BinaryType):</span>
<span class="gi">+        # WKB encoding</span>
<span class="gi">+        df[geometry] = from_wkb(df[geometry])</span>
<span class="gi">+    elif isinstance(table.field(geometry).type, pa.StructType):</span>
<span class="gi">+        # GeoArrow encoding</span>
<span class="gi">+        geom_array = table[geometry]</span>
<span class="gi">+        geom_type = geom_array.field(&#39;type&#39;).to_pylist()</span>
<span class="gi">+        coords = geom_array.field(&#39;coordinates&#39;).to_pylist()</span>
<span class="gi">+        </span>
<span class="gi">+        geometries = []</span>
<span class="gi">+        for gtype, coord in zip(geom_type, coords):</span>
<span class="gi">+            if gtype == &#39;Point&#39;:</span>
<span class="gi">+                geometries.append(shapely.Point(coord[0]))</span>
<span class="gi">+            elif gtype == &#39;LineString&#39;:</span>
<span class="gi">+                geometries.append(shapely.LineString(coord))</span>
<span class="gi">+            elif gtype == &#39;Polygon&#39;:</span>
<span class="gi">+                geometries.append(shapely.Polygon(coord[0], coord[1:]))</span>
<span class="gi">+            elif gtype == &#39;MultiPoint&#39;:</span>
<span class="gi">+                geometries.append(shapely.MultiPoint(coord))</span>
<span class="gi">+            elif gtype == &#39;MultiLineString&#39;:</span>
<span class="gi">+                geometries.append(shapely.MultiLineString(coord))</span>
<span class="gi">+            elif gtype == &#39;MultiPolygon&#39;:</span>
<span class="gi">+                geometries.append(shapely.MultiPolygon([shapely.Polygon(p[0], p[1:]) for p in coord]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(f&quot;Unsupported geometry type: {gtype}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        df[geometry] = from_shapely(geometries)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported geometry encoding for column &#39;{geometry}&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return GeoDataFrame(df, geometry=geometry)</span>


<span class="w"> </span>def arrow_to_geometry_array(arr):
<span class="gu">@@ -131,7 +224,34 @@ def arrow_to_geometry_array(arr):</span>

<span class="w"> </span>    Specifically for GeoSeries.from_arrow.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(arr, pa.BinaryArray):</span>
<span class="gi">+        # WKB encoding</span>
<span class="gi">+        return from_wkb(arr.to_pylist())</span>
<span class="gi">+    elif isinstance(arr, pa.StructArray):</span>
<span class="gi">+        # GeoArrow encoding</span>
<span class="gi">+        geom_type = arr.field(&#39;type&#39;).to_pylist()</span>
<span class="gi">+        coords = arr.field(&#39;coordinates&#39;).to_pylist()</span>
<span class="gi">+        </span>
<span class="gi">+        geometries = []</span>
<span class="gi">+        for gtype, coord in zip(geom_type, coords):</span>
<span class="gi">+            if gtype == &#39;Point&#39;:</span>
<span class="gi">+                geometries.append(shapely.Point(coord[0]))</span>
<span class="gi">+            elif gtype == &#39;LineString&#39;:</span>
<span class="gi">+                geometries.append(shapely.LineString(coord))</span>
<span class="gi">+            elif gtype == &#39;Polygon&#39;:</span>
<span class="gi">+                geometries.append(shapely.Polygon(coord[0], coord[1:]))</span>
<span class="gi">+            elif gtype == &#39;MultiPoint&#39;:</span>
<span class="gi">+                geometries.append(shapely.MultiPoint(coord))</span>
<span class="gi">+            elif gtype == &#39;MultiLineString&#39;:</span>
<span class="gi">+                geometries.append(shapely.MultiLineString(coord))</span>
<span class="gi">+            elif gtype == &#39;MultiPolygon&#39;:</span>
<span class="gi">+                geometries.append(shapely.MultiPolygon([shapely.Polygon(p[0], p[1:]) for p in coord]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(f&quot;Unsupported geometry type: {gtype}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        return from_shapely(geometries)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Unsupported Arrow array type for geometry conversion&quot;)</span>


<span class="w"> </span>def construct_shapely_array(arr: pa.Array, extension_name: str):
<span class="gu">@@ -140,4 +260,28 @@ def construct_shapely_array(arr: pa.Array, extension_name: str):</span>
<span class="w"> </span>    with GeoArrow extension type.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(arr, pa.Array):</span>
<span class="gi">+        raise ValueError(&quot;Input must be a pyarrow.Array&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if extension_name not in GEOARROW_ENCODINGS:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported GeoArrow encoding: {extension_name}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    geom_type = GeometryType[extension_name.upper()]</span>
<span class="gi">+    coords = arr.field(&#39;coordinates&#39;).to_pylist()</span>
<span class="gi">+</span>
<span class="gi">+    geometries = []</span>
<span class="gi">+    for coord in coords:</span>
<span class="gi">+        if geom_type == GeometryType.POINT:</span>
<span class="gi">+            geometries.append(shapely.Point(coord))</span>
<span class="gi">+        elif geom_type == GeometryType.LINESTRING:</span>
<span class="gi">+            geometries.append(shapely.LineString(coord))</span>
<span class="gi">+        elif geom_type == GeometryType.POLYGON:</span>
<span class="gi">+            geometries.append(shapely.Polygon(coord[0], coord[1:]))</span>
<span class="gi">+        elif geom_type == GeometryType.MULTIPOINT:</span>
<span class="gi">+            geometries.append(shapely.MultiPoint(coord))</span>
<span class="gi">+        elif geom_type == GeometryType.MULTILINESTRING:</span>
<span class="gi">+            geometries.append(shapely.MultiLineString(coord))</span>
<span class="gi">+        elif geom_type == GeometryType.MULTIPOLYGON:</span>
<span class="gi">+            geometries.append(shapely.MultiPolygon([shapely.Polygon(p[0], p[1:]) for p in coord]))</span>
<span class="gi">+</span>
<span class="gi">+    return np.array(geometries, dtype=object)</span>
<span class="gh">diff --git a/geopandas/io/arrow.py b/geopandas/io/arrow.py</span>
<span class="gh">index defcba9..52f9590 100644</span>
<span class="gd">--- a/geopandas/io/arrow.py</span>
<span class="gi">+++ b/geopandas/io/arrow.py</span>
<span class="gu">@@ -26,7 +26,22 @@ def _remove_id_from_member_of_ensembles(json_dict):</span>

<span class="w"> </span>    Mimicking the patch to GDAL from https://github.com/OSGeo/gdal/pull/5872
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(json_dict, dict):</span>
<span class="gi">+        if &quot;datum&quot; in json_dict:</span>
<span class="gi">+            datum = json_dict[&quot;datum&quot;]</span>
<span class="gi">+            if isinstance(datum, dict) and &quot;ensemble&quot; in datum:</span>
<span class="gi">+                ensemble = datum[&quot;ensemble&quot;]</span>
<span class="gi">+                if isinstance(ensemble, dict) and &quot;members&quot; in ensemble:</span>
<span class="gi">+                    members = ensemble[&quot;members&quot;]</span>
<span class="gi">+                    if isinstance(members, list):</span>
<span class="gi">+                        for member in members:</span>
<span class="gi">+                            if isinstance(member, dict):</span>
<span class="gi">+                                member.pop(&quot;id&quot;, None)</span>
<span class="gi">+        for value in json_dict.values():</span>
<span class="gi">+            _remove_id_from_member_of_ensembles(value)</span>
<span class="gi">+    elif isinstance(json_dict, list):</span>
<span class="gi">+        for item in json_dict:</span>
<span class="gi">+            _remove_id_from_member_of_ensembles(item)</span>


<span class="w"> </span>_geometry_type_names = [&#39;Point&#39;, &#39;LineString&#39;, &#39;LineString&#39;, &#39;Polygon&#39;,
<span class="gu">@@ -39,7 +54,7 @@ def _get_geometry_types(series):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get unique geometry types from a GeoSeries.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(series.geom_type.unique())</span>


<span class="w"> </span>def _create_metadata(df, schema_version=None, geometry_encoding=None,
<span class="gu">@@ -61,7 +76,40 @@ def _create_metadata(df, schema_version=None, geometry_encoding=None,</span>
<span class="w"> </span>    -------
<span class="w"> </span>    dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if schema_version is None:</span>
<span class="gi">+        schema_version = SUPPORTED_VERSIONS[-1]</span>
<span class="gi">+    </span>
<span class="gi">+    if schema_version not in SUPPORTED_VERSIONS:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported schema version: {schema_version}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    geometry_columns = df.select_dtypes(include=[&#39;geometry&#39;]).columns</span>
<span class="gi">+    if len(geometry_columns) == 0:</span>
<span class="gi">+        raise ValueError(&quot;No geometry column found in GeoDataFrame&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    primary_geometry = df.geometry.name</span>
<span class="gi">+    </span>
<span class="gi">+    metadata = {</span>
<span class="gi">+        &quot;version&quot;: schema_version,</span>
<span class="gi">+        &quot;primary_column&quot;: primary_geometry,</span>
<span class="gi">+        &quot;columns&quot;: {}</span>
<span class="gi">+    }</span>
<span class="gi">+    </span>
<span class="gi">+    for col in geometry_columns:</span>
<span class="gi">+        col_metadata = {</span>
<span class="gi">+            &quot;encoding&quot;: geometry_encoding or &quot;WKB&quot;,</span>
<span class="gi">+            &quot;geometry_types&quot;: _get_geometry_types(df[col])</span>
<span class="gi">+        }</span>
<span class="gi">+        </span>
<span class="gi">+        if df[col].crs:</span>
<span class="gi">+            col_metadata[&quot;crs&quot;] = df[col].crs.to_wkt()</span>
<span class="gi">+        </span>
<span class="gi">+        if write_covering_bbox:</span>
<span class="gi">+            bounds = df[col].total_bounds</span>
<span class="gi">+            col_metadata[&quot;bbox&quot;] = [bounds[0], bounds[1], bounds[2], bounds[3]]</span>
<span class="gi">+        </span>
<span class="gi">+        metadata[&quot;columns&quot;][col] = col_metadata</span>
<span class="gi">+    </span>
<span class="gi">+    return metadata</span>


<span class="w"> </span>def _encode_metadata(metadata):
<span class="gh">diff --git a/geopandas/io/file.py b/geopandas/io/file.py</span>
<span class="gh">index 43101f2..7438f90 100644</span>
<span class="gd">--- a/geopandas/io/file.py</span>
<span class="gi">+++ b/geopandas/io/file.py</span>
<span class="gu">@@ -36,12 +36,15 @@ _EXTENSION_TO_DRIVER = {&#39;.bna&#39;: &#39;BNA&#39;, &#39;.dxf&#39;: &#39;DXF&#39;, &#39;.csv&#39;: &#39;CSV&#39;, &#39;.shp&#39;:</span>

<span class="w"> </span>def _expand_user(path):
<span class="w"> </span>    &quot;&quot;&quot;Expand paths that use ~.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.path.expanduser(path)</span>


<span class="w"> </span>def _is_url(url):
<span class="w"> </span>    &quot;&quot;&quot;Check to see if *url* has a valid protocol.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return parse_url(url).scheme in _VALID_URLS</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def _read_file(filename, bbox=None, mask=None, columns=None, rows=None,
<span class="gu">@@ -88,27 +91,6 @@ def _read_file(filename, bbox=None, mask=None, columns=None, rows=None,</span>
<span class="w"> </span>        arguments are passed to fiona.open`. For more information on possible
<span class="w"> </span>        keywords, type: ``import pyogrio; help(pyogrio.write_dataframe)``.

<span class="gd">-</span>
<span class="gd">-    Examples</span>
<span class="gd">-    --------</span>
<span class="gd">-    &gt;&gt;&gt; df = geopandas.read_file(&quot;nybb.shp&quot;)  # doctest: +SKIP</span>
<span class="gd">-</span>
<span class="gd">-    Specifying layer of GPKG:</span>
<span class="gd">-</span>
<span class="gd">-    &gt;&gt;&gt; df = geopandas.read_file(&quot;file.gpkg&quot;, layer=&#39;cities&#39;)  # doctest: +SKIP</span>
<span class="gd">-</span>
<span class="gd">-    Reading only first 10 rows:</span>
<span class="gd">-</span>
<span class="gd">-    &gt;&gt;&gt; df = geopandas.read_file(&quot;nybb.shp&quot;, rows=10)  # doctest: +SKIP</span>
<span class="gd">-</span>
<span class="gd">-    Reading only geometries intersecting ``mask``:</span>
<span class="gd">-</span>
<span class="gd">-    &gt;&gt;&gt; df = geopandas.read_file(&quot;nybb.shp&quot;, mask=polygon)  # doctest: +SKIP</span>
<span class="gd">-</span>
<span class="gd">-    Reading only geometries intersecting ``bbox``:</span>
<span class="gd">-</span>
<span class="gd">-    &gt;&gt;&gt; df = geopandas.read_file(&quot;nybb.shp&quot;, bbox=(0, 0, 10, 20))  # doctest: +SKIP</span>
<span class="gd">-</span>
<span class="w"> </span>    Returns
<span class="w"> </span>    -------
<span class="w"> </span>    :obj:`geopandas.GeoDataFrame` or :obj:`pandas.DataFrame` :
<span class="gu">@@ -131,14 +113,47 @@ def _read_file(filename, bbox=None, mask=None, columns=None, rows=None,</span>
<span class="w"> </span>    (https://gdal.org/user/virtual_file_systems.html#vsicurl-http-https-ftp-files-random-access).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if engine is None:</span>
<span class="gi">+        engine = &quot;pyogrio&quot; if pyogrio is not None else &quot;fiona&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if engine == &quot;pyogrio&quot;:</span>
<span class="gi">+        if pyogrio is None:</span>
<span class="gi">+            raise ImportError(&quot;pyogrio is required to use the pyogrio engine&quot;)</span>
<span class="gi">+        return pyogrio.read_dataframe(filename, bbox=bbox, mask=mask, columns=columns, rows=rows, **kwargs)</span>
<span class="gi">+    elif engine == &quot;fiona&quot;:</span>
<span class="gi">+        if fiona is None:</span>
<span class="gi">+            raise ImportError(&quot;fiona is required to use the fiona engine&quot;)</span>
<span class="gi">+        with fiona.open(filename, **kwargs) as source:</span>
<span class="gi">+            crs = source.crs</span>
<span class="gi">+            driver = source.driver</span>
<span class="gi">+            if columns is None:</span>
<span class="gi">+                columns = list(source.schema[&#39;properties&#39;].keys())</span>
<span class="gi">+            if bbox is not None:</span>
<span class="gi">+                source = source.filter(bbox=bbox)</span>
<span class="gi">+            if mask is not None:</span>
<span class="gi">+                source = source.filter(mask=mask)</span>
<span class="gi">+            if rows is not None:</span>
<span class="gi">+                if isinstance(rows, int):</span>
<span class="gi">+                    source = list(source)[:rows]</span>
<span class="gi">+                elif isinstance(rows, slice):</span>
<span class="gi">+                    source = list(source)[rows]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(&quot;rows must be an integer or a slice object&quot;)</span>
<span class="gi">+            gdf = GeoDataFrame.from_features(source, crs=crs, columns=columns)</span>
<span class="gi">+            gdf.crs = crs</span>
<span class="gi">+            return gdf</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;engine must be either &#39;pyogrio&#39; or &#39;fiona&#39;&quot;)</span>


<span class="w"> </span>def _detect_driver(path):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Attempt to auto-detect driver based on the extension
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _EXTENSION_TO_DRIVER[os.path.splitext(path)[1].lower()]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def _to_file(df, filename, driver=None, schema=None, index=None, mode=&#39;w&#39;,
<span class="gu">@@ -214,14 +229,40 @@ def _to_file(df, filename, driver=None, schema=None, index=None, mode=&#39;w&#39;,</span>
<span class="w"> </span>    may fail. In this case, the proper encoding can be specified explicitly
<span class="w"> </span>    by using the encoding keyword parameter, e.g. ``encoding=&#39;utf-8&#39;``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if engine is None:</span>
<span class="gi">+        engine = &quot;pyogrio&quot; if pyogrio is not None else &quot;fiona&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if driver is None:</span>
<span class="gi">+        driver = _detect_driver(filename)</span>
<span class="gi">+</span>
<span class="gi">+    if engine == &quot;pyogrio&quot;:</span>
<span class="gi">+        if pyogrio is None:</span>
<span class="gi">+            raise ImportError(&quot;pyogrio is required to use the pyogrio engine&quot;)</span>
<span class="gi">+        pyogrio.write_dataframe(df, filename, driver=driver, crs=crs, mode=mode, metadata=metadata, **kwargs)</span>
<span class="gi">+    elif engine == &quot;fiona&quot;:</span>
<span class="gi">+        if fiona is None:</span>
<span class="gi">+            raise ImportError(&quot;fiona is required to use the fiona engine&quot;)</span>
<span class="gi">+        if schema is None:</span>
<span class="gi">+            schema = _geometry_types(df)</span>
<span class="gi">+        with fiona.open(filename, mode, driver=driver, crs=crs, schema=schema, **kwargs) as colxn:</span>
<span class="gi">+            colxn.writerecords(df.iterfeatures())</span>
<span class="gi">+            if metadata:</span>
<span class="gi">+                colxn.update_metadata(metadata)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;engine must be either &#39;pyogrio&#39; or &#39;fiona&#39;&quot;)</span>


<span class="w"> </span>def _geometry_types(df):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Determine the geometry types in the GeoDataFrame for the schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    geom_types = set(df.geometry.geom_type)</span>
<span class="gi">+    if len(geom_types) == 1:</span>
<span class="gi">+        return list(geom_types)[0]</span>
<span class="gi">+    elif len(geom_types) &gt; 1:</span>
<span class="gi">+        return &quot;GeometryCollection&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def _list_layers(filename) -&gt;pd.DataFrame:
<span class="gu">@@ -245,4 +286,11 @@ def _list_layers(filename) -&gt;pd.DataFrame:</span>
<span class="w"> </span>    pandas.DataFrame
<span class="w"> </span>        A DataFrame with columns &quot;name&quot; and &quot;geometry_type&quot; and one row per layer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pyogrio is not None:</span>
<span class="gi">+        return pyogrio.list_layers(filename)</span>
<span class="gi">+    elif fiona is not None:</span>
<span class="gi">+        with fiona.open(filename) as src:</span>
<span class="gi">+            layers = [{&quot;name&quot;: layer, &quot;geometry_type&quot;: src.schema[&quot;geometry&quot;]} for layer in src.layers]</span>
<span class="gi">+        return pd.DataFrame(layers)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ImportError(&quot;Either pyogrio or fiona is required to list layers&quot;)</span>
<span class="gh">diff --git a/geopandas/io/sql.py b/geopandas/io/sql.py</span>
<span class="gh">index 1255461..b57d5a0 100644</span>
<span class="gd">--- a/geopandas/io/sql.py</span>
<span class="gi">+++ b/geopandas/io/sql.py</span>
<span class="gu">@@ -24,7 +24,14 @@ def _get_conn(conn_or_engine):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    Connection
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(conn_or_engine, &#39;begin&#39;):</span>
<span class="gi">+        # It&#39;s an Engine</span>
<span class="gi">+        with conn_or_engine.begin() as conn:</span>
<span class="gi">+            yield conn</span>
<span class="gi">+    else:</span>
<span class="gi">+        # It&#39;s a Connection</span>
<span class="gi">+        with conn_or_engine.begin():</span>
<span class="gi">+            yield conn_or_engine</span>


<span class="w"> </span>def _df_to_geodf(df, geom_col=&#39;geom&#39;, crs=None, con=None):
<span class="gu">@@ -50,7 +57,22 @@ def _df_to_geodf(df, geom_col=&#39;geom&#39;, crs=None, con=None):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    GeoDataFrame
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if geom_col not in df:</span>
<span class="gi">+        raise ValueError(f&quot;Column {geom_col} not found in DataFrame&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    df[geom_col] = df[geom_col].apply(lambda x: shapely.wkb.loads(x, hex=True))</span>
<span class="gi">+    </span>
<span class="gi">+    gdf = GeoDataFrame(df, geometry=geom_col, crs=crs)</span>
<span class="gi">+    </span>
<span class="gi">+    if crs is None and con is not None:</span>
<span class="gi">+        # Try to determine CRS from the database</span>
<span class="gi">+        with _get_conn(con) as conn:</span>
<span class="gi">+            query = f&quot;SELECT ST_SRID({geom_col}) FROM ({df.name}) AS t LIMIT 1&quot;</span>
<span class="gi">+            srid = conn.execute(query).scalar()</span>
<span class="gi">+            if srid:</span>
<span class="gi">+                gdf.crs = f&quot;EPSG:{srid}&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    return gdf</span>


<span class="w"> </span>def _read_postgis(sql, con, geom_col=&#39;geom&#39;, crs=None, index_col=None,
<span class="gu">@@ -102,7 +124,25 @@ def _read_postgis(sql, con, geom_col=&#39;geom&#39;, crs=None, index_col=None,</span>
<span class="w"> </span>    &gt;&gt;&gt; sql = &quot;SELECT ST_AsBinary(geom) AS geom, highway FROM roads&quot;
<span class="w"> </span>    &gt;&gt;&gt; df = geopandas.read_postgis(sql, con)  # doctest: +SKIP
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(sql, str):</span>
<span class="gi">+        raise ValueError(&quot;sql must be a string&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    with _get_conn(con) as conn:</span>
<span class="gi">+        if chunksize is not None:</span>
<span class="gi">+            df_iter = pd.read_sql(</span>
<span class="gi">+                sql, conn, index_col=index_col, coerce_float=coerce_float,</span>
<span class="gi">+                params=params, parse_dates=parse_dates, chunksize=chunksize</span>
<span class="gi">+            )</span>
<span class="gi">+            return (</span>
<span class="gi">+                _df_to_geodf(df, geom_col, crs, conn)</span>
<span class="gi">+                for df in df_iter</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            df = pd.read_sql(</span>
<span class="gi">+                sql, conn, index_col=index_col, coerce_float=coerce_float,</span>
<span class="gi">+                params=params, parse_dates=parse_dates</span>
<span class="gi">+            )</span>
<span class="gi">+            return _df_to_geodf(df, geom_col, crs, conn)</span>


<span class="w"> </span>def _get_geometry_type(gdf):
<span class="gu">@@ -124,19 +164,37 @@ def _get_geometry_type(gdf):</span>
<span class="w"> </span>     - if any of the geometries has Z-coordinate, all records will
<span class="w"> </span>       be written with 3D.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    geom_types = set(gdf.geometry.type)</span>
<span class="gi">+    </span>
<span class="gi">+    if len(geom_types) == 1:</span>
<span class="gi">+        geom_type = geom_types.pop()</span>
<span class="gi">+        if geom_type == &#39;LinearRing&#39;:</span>
<span class="gi">+            return &#39;LineString&#39;</span>
<span class="gi">+        return geom_type</span>
<span class="gi">+    </span>
<span class="gi">+    if geom_types.issubset({&#39;Polygon&#39;, &#39;MultiPolygon&#39;}):</span>
<span class="gi">+        return &#39;Polygon&#39;</span>
<span class="gi">+    if geom_types.issubset({&#39;Point&#39;, &#39;LineString&#39;}):</span>
<span class="gi">+        return &#39;Geometry&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    return &#39;Geometry&#39;</span>


<span class="w"> </span>def _get_srid_from_crs(gdf):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get EPSG code from CRS if available. If not, return 0.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if gdf.crs is None:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    try:</span>
<span class="gi">+        return gdf.crs.to_epsg() or 0</span>
<span class="gi">+    except:</span>
<span class="gi">+        return 0</span>


<span class="w"> </span>def _convert_to_ewkb(gdf, geom_name, srid):
<span class="w"> </span>    &quot;&quot;&quot;Convert geometries to ewkb.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return gdf[geom_name].apply(lambda geom: shapely.wkb.dumps(geom, hex=True, srid=srid))</span>


<span class="w"> </span>def _write_postgis(gdf, name, con, schema=None, if_exists=&#39;fail&#39;, index=
<span class="gu">@@ -183,4 +241,49 @@ def _write_postgis(gdf, name, con, schema=None, if_exists=&#39;fail&#39;, index=</span>
<span class="w"> </span>    &gt;&gt;&gt; engine = create_engine(&quot;postgresql://myusername:mypassword@myhost:5432/mydatabase&quot;;)  # doctest: +SKIP
<span class="w"> </span>    &gt;&gt;&gt; gdf.to_postgis(&quot;my_table&quot;, engine)  # doctest: +SKIP
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from sqlalchemy.types import VARCHAR, FLOAT, INTEGER, BOOLEAN, DATE, DATETIME</span>
<span class="gi">+</span>
<span class="gi">+    if not pd.io.sql.is_sqlalchemy_connectable(con):</span>
<span class="gi">+        raise ValueError(&quot;The connection must be a SQLAlchemy connectable.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Get geometry column name</span>
<span class="gi">+    geom_col = gdf.geometry.name</span>
<span class="gi">+</span>
<span class="gi">+    # Get geometry type</span>
<span class="gi">+    geom_type = _get_geometry_type(gdf)</span>
<span class="gi">+</span>
<span class="gi">+    # Get SRID</span>
<span class="gi">+    srid = _get_srid_from_crs(gdf)</span>
<span class="gi">+</span>
<span class="gi">+    # Convert geometries to EWKB</span>
<span class="gi">+    gdf = gdf.copy()</span>
<span class="gi">+    gdf[geom_col] = _convert_to_ewkb(gdf, geom_col, srid)</span>
<span class="gi">+</span>
<span class="gi">+    # Prepare column types</span>
<span class="gi">+    if dtype is None:</span>
<span class="gi">+        dtype = {}</span>
<span class="gi">+    for column, dtype in gdf.dtypes.items():</span>
<span class="gi">+        if column == geom_col:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if dtype == &#39;object&#39;:</span>
<span class="gi">+            dtype[column] = VARCHAR</span>
<span class="gi">+        elif dtype == &#39;float64&#39;:</span>
<span class="gi">+            dtype[column] = FLOAT</span>
<span class="gi">+        elif dtype == &#39;int64&#39;:</span>
<span class="gi">+            dtype[column] = INTEGER</span>
<span class="gi">+        elif dtype == &#39;bool&#39;:</span>
<span class="gi">+            dtype[column] = BOOLEAN</span>
<span class="gi">+        elif dtype == &#39;datetime64[ns]&#39;:</span>
<span class="gi">+            dtype[column] = DATETIME</span>
<span class="gi">+        elif dtype == &#39;date&#39;:</span>
<span class="gi">+            dtype[column] = DATE</span>
<span class="gi">+</span>
<span class="gi">+    # Add geometry column type</span>
<span class="gi">+    from geoalchemy2 import Geometry</span>
<span class="gi">+    dtype[geom_col] = Geometry(geometry_type=geom_type, srid=srid)</span>
<span class="gi">+</span>
<span class="gi">+    # Write to PostGIS</span>
<span class="gi">+    with _get_conn(con) as connection:</span>
<span class="gi">+        gdf.to_sql(name, connection, schema=schema, if_exists=if_exists,</span>
<span class="gi">+                   index=index, index_label=index_label, chunksize=chunksize,</span>
<span class="gi">+                   dtype=dtype)</span>
<span class="gh">diff --git a/geopandas/io/tests/generate_legacy_storage_files.py b/geopandas/io/tests/generate_legacy_storage_files.py</span>
<span class="gh">index 9b4e042..4fcced4 100644</span>
<span class="gd">--- a/geopandas/io/tests/generate_legacy_storage_files.py</span>
<span class="gi">+++ b/geopandas/io/tests/generate_legacy_storage_files.py</span>
<span class="gu">@@ -29,8 +29,43 @@ import geopandas</span>

<span class="w"> </span>def create_pickle_data():
<span class="w"> </span>    &quot;&quot;&quot;create the pickle data&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Create a simple GeoDataFrame</span>
<span class="gi">+    df = pd.DataFrame({</span>
<span class="gi">+        &#39;name&#39;: [&#39;Point A&#39;, &#39;Point B&#39;, &#39;Point C&#39;],</span>
<span class="gi">+        &#39;value&#39;: [1, 2, 3]</span>
<span class="gi">+    })</span>
<span class="gi">+    geometry = [Point(0, 0), Point(1, 1), Point(2, 2)]</span>
<span class="gi">+    gdf = geopandas.GeoDataFrame(df, geometry=geometry)</span>
<span class="gi">+    return gdf</span>

<span class="gi">+def main():</span>
<span class="gi">+    if len(sys.argv) != 3:</span>
<span class="gi">+        print(&quot;Usage: python generate_legacy_storage_files.py &lt;output_dir&gt; &lt;storage_format&gt;&quot;)</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+    output_dir = sys.argv[1]</span>
<span class="gi">+    storage_format = sys.argv[2]</span>
<span class="gi">+</span>
<span class="gi">+    if storage_format != &#39;pickle&#39;:</span>
<span class="gi">+        print(&quot;Only &#39;pickle&#39; storage format is supported.&quot;)</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+    if not os.path.exists(output_dir):</span>
<span class="gi">+        os.makedirs(output_dir)</span>
<span class="gi">+</span>
<span class="gi">+    data = create_pickle_data()</span>
<span class="gi">+    </span>
<span class="gi">+    # Generate filename based on Python version and platform</span>
<span class="gi">+    py_version = f&quot;{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}&quot;</span>
<span class="gi">+    platform_name = platform.platform().lower()</span>
<span class="gi">+    filename = f&quot;gdf-{py_version}-{platform_name}.pickle&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    filepath = os.path.join(output_dir, filename)</span>
<span class="gi">+    </span>
<span class="gi">+    with open(filepath, &#39;wb&#39;) as f:</span>
<span class="gi">+        pickle.dump(data, f, protocol=pickle.HIGHEST_PROTOCOL)</span>
<span class="gi">+    </span>
<span class="gi">+    print(f&quot;Pickle file created: {filepath}&quot;)</span>

<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="w"> </span>    main()
<span class="gh">diff --git a/geopandas/io/tests/test_arrow.py b/geopandas/io/tests/test_arrow.py</span>
<span class="gh">index a5dbeb1..fbaf7a9 100644</span>
<span class="gd">--- a/geopandas/io/tests/test_arrow.py</span>
<span class="gi">+++ b/geopandas/io/tests/test_arrow.py</span>
<span class="gu">@@ -31,19 +31,55 @@ def test_roundtrip(tmpdir, file_format, test_dataset, request):</span>
<span class="w"> </span>    &quot;&quot;&quot;Writing to parquet should not raise errors, and should not alter original
<span class="w"> </span>    GeoDataFrame
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gdf = request.getfixturevalue(test_dataset)</span>
<span class="gi">+    tmp_file = str(tmpdir.join(f&quot;test.{file_format}&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    if file_format == &quot;parquet&quot;:</span>
<span class="gi">+        gdf.to_parquet(tmp_file)</span>
<span class="gi">+        result = read_parquet(tmp_file)</span>
<span class="gi">+    elif file_format == &quot;feather&quot;:</span>
<span class="gi">+        gdf.to_feather(tmp_file)</span>
<span class="gi">+        result = read_feather(tmp_file)</span>
<span class="gi">+    </span>
<span class="gi">+    assert_geodataframe_equal(gdf, result)</span>


<span class="w"> </span>def test_index(tmpdir, file_format, naturalearth_lowres):
<span class="w"> </span>    &quot;&quot;&quot;Setting index=`True` should preserve index in output, and
<span class="w"> </span>    setting index=`False` should drop index from output.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gdf = naturalearth_lowres.set_index(&#39;name&#39;)</span>
<span class="gi">+    tmp_file = str(tmpdir.join(f&quot;test.{file_format}&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    if file_format == &quot;parquet&quot;:</span>
<span class="gi">+        gdf.to_parquet(tmp_file, index=True)</span>
<span class="gi">+        result_with_index = read_parquet(tmp_file)</span>
<span class="gi">+        gdf.to_parquet(tmp_file, index=False)</span>
<span class="gi">+        result_without_index = read_parquet(tmp_file)</span>
<span class="gi">+    elif file_format == &quot;feather&quot;:</span>
<span class="gi">+        gdf.to_feather(tmp_file, index=True)</span>
<span class="gi">+        result_with_index = read_feather(tmp_file)</span>
<span class="gi">+        gdf.to_feather(tmp_file, index=False)</span>
<span class="gi">+        result_without_index = read_feather(tmp_file)</span>
<span class="gi">+    </span>
<span class="gi">+    assert_geodataframe_equal(gdf, result_with_index)</span>
<span class="gi">+    assert result_without_index.index.name is None</span>
<span class="gi">+    assert_geodataframe_equal(gdf.reset_index(drop=True), result_without_index)</span>


<span class="w"> </span>def test_column_order(tmpdir, file_format, naturalearth_lowres):
<span class="w"> </span>    &quot;&quot;&quot;The order of columns should be preserved in the output.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gdf = naturalearth_lowres[[&#39;name&#39;, &#39;pop_est&#39;, &#39;continent&#39;, &#39;geometry&#39;]]</span>
<span class="gi">+    tmp_file = str(tmpdir.join(f&quot;test.{file_format}&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    if file_format == &quot;parquet&quot;:</span>
<span class="gi">+        gdf.to_parquet(tmp_file)</span>
<span class="gi">+        result = read_parquet(tmp_file)</span>
<span class="gi">+    elif file_format == &quot;feather&quot;:</span>
<span class="gi">+        gdf.to_feather(tmp_file)</span>
<span class="gi">+        result = read_feather(tmp_file)</span>
<span class="gi">+    </span>
<span class="gi">+    assert list(gdf.columns) == list(result.columns)</span>


<span class="w"> </span>@pytest.mark.parametrize(&#39;compression&#39;, [&#39;snappy&#39;, &#39;gzip&#39;, &#39;brotli&#39;, None])
<span class="gu">@@ -51,7 +87,10 @@ def test_parquet_compression(compression, tmpdir, naturalearth_lowres):</span>
<span class="w"> </span>    &quot;&quot;&quot;Using compression options should not raise errors, and should
<span class="w"> </span>    return identical GeoDataFrame.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tmp_file = str(tmpdir.join(&quot;test.parquet&quot;))</span>
<span class="gi">+    naturalearth_lowres.to_parquet(tmp_file, compression=compression)</span>
<span class="gi">+    result = read_parquet(tmp_file)</span>
<span class="gi">+    assert_geodataframe_equal(naturalearth_lowres, result)</span>


<span class="w"> </span>@pytest.mark.skipif(Version(pyarrow.__version__) &lt; Version(&#39;0.17.0&#39;),
<span class="gu">@@ -61,21 +100,43 @@ def test_feather_compression(compression, tmpdir, naturalearth_lowres):</span>
<span class="w"> </span>    &quot;&quot;&quot;Using compression options should not raise errors, and should
<span class="w"> </span>    return identical GeoDataFrame.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tmp_file = str(tmpdir.join(&quot;test.feather&quot;))</span>
<span class="gi">+    naturalearth_lowres.to_feather(tmp_file, compression=compression)</span>
<span class="gi">+    result = read_feather(tmp_file)</span>
<span class="gi">+    assert_geodataframe_equal(naturalearth_lowres, result)</span>


<span class="w"> </span>def test_parquet_multiple_geom_cols(tmpdir, file_format, naturalearth_lowres):
<span class="w"> </span>    &quot;&quot;&quot;If multiple geometry columns are present when written to parquet,
<span class="w"> </span>    they should all be returned as such when read from parquet.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gdf = naturalearth_lowres.copy()</span>
<span class="gi">+    gdf[&#39;geometry2&#39;] = gdf.geometry.centroid</span>
<span class="gi">+    tmp_file = str(tmpdir.join(f&quot;test.{file_format}&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    if file_format == &quot;parquet&quot;:</span>
<span class="gi">+        gdf.to_parquet(tmp_file)</span>
<span class="gi">+        result = read_parquet(tmp_file)</span>
<span class="gi">+    elif file_format == &quot;feather&quot;:</span>
<span class="gi">+        gdf.to_feather(tmp_file)</span>
<span class="gi">+        result = read_feather(tmp_file)</span>
<span class="gi">+    </span>
<span class="gi">+    assert isinstance(result, GeoDataFrame)</span>
<span class="gi">+    assert isinstance(result[&#39;geometry&#39;], geopandas.GeoSeries)</span>
<span class="gi">+    assert isinstance(result[&#39;geometry2&#39;], geopandas.GeoSeries)</span>
<span class="gi">+    assert_geodataframe_equal(gdf, result)</span>


<span class="w"> </span>def test_parquet_missing_metadata(tmpdir, naturalearth_lowres):
<span class="w"> </span>    &quot;&quot;&quot;Missing geo metadata, such as from a parquet file created
<span class="w"> </span>    from a pandas DataFrame, will raise a ValueError.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    df = DataFrame(naturalearth_lowres.drop(columns=[&#39;geometry&#39;]))</span>
<span class="gi">+    tmp_file = str(tmpdir.join(&quot;test.parquet&quot;))</span>
<span class="gi">+    df.to_parquet(tmp_file)</span>
<span class="gi">+    </span>
<span class="gi">+    with pytest.raises(ValueError, match=&quot;Missing geo metadata in Parquet file.&quot;):</span>
<span class="gi">+        read_parquet(tmp_file)</span>


<span class="w"> </span>def test_parquet_missing_metadata2(tmpdir):
<span class="gu">@@ -83,7 +144,15 @@ def test_parquet_missing_metadata2(tmpdir):</span>
<span class="w"> </span>    from a pyarrow Table (which will also not contain pandas metadata),
<span class="w"> </span>    will raise a ValueError.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    table = pyarrow.Table.from_arrays(</span>
<span class="gi">+        [pyarrow.array([1, 2, 3]), pyarrow.array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])],</span>
<span class="gi">+        names=[&#39;col1&#39;, &#39;col2&#39;]</span>
<span class="gi">+    )</span>
<span class="gi">+    tmp_file = str(tmpdir.join(&quot;test.parquet&quot;))</span>
<span class="gi">+    pq.write_table(table, tmp_file)</span>
<span class="gi">+    </span>
<span class="gi">+    with pytest.raises(ValueError, match=&quot;Missing geo metadata in Parquet file.&quot;):</span>
<span class="gi">+        read_parquet(tmp_file)</span>


<span class="w"> </span>@pytest.mark.parametrize(&#39;geo_meta,error&#39;, [({&#39;geo&#39;: b&#39;&#39;},
<span class="gu">@@ -99,34 +168,87 @@ def test_parquet_invalid_metadata(tmpdir, geo_meta, error, naturalearth_lowres</span>
<span class="w"> </span>    This requires writing the parquet file directly below, so that we can
<span class="w"> </span>    control the metadata that is written for this test.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tmp_file = str(tmpdir.join(&quot;test.parquet&quot;))</span>
<span class="gi">+    table = pyarrow.Table.from_pandas(naturalearth_lowres)</span>
<span class="gi">+    </span>
<span class="gi">+    # Write the parquet file with custom metadata</span>
<span class="gi">+    pq.write_table(table, tmp_file, metadata=geo_meta)</span>
<span class="gi">+    </span>
<span class="gi">+    with pytest.raises(ValueError, match=error):</span>
<span class="gi">+        read_parquet(tmp_file)</span>


<span class="w"> </span>def test_subset_columns(tmpdir, file_format, naturalearth_lowres):
<span class="w"> </span>    &quot;&quot;&quot;Reading a subset of columns should correctly decode selected geometry
<span class="w"> </span>    columns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gdf = naturalearth_lowres</span>
<span class="gi">+    tmp_file = str(tmpdir.join(f&quot;test.{file_format}&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    if file_format == &quot;parquet&quot;:</span>
<span class="gi">+        gdf.to_parquet(tmp_file)</span>
<span class="gi">+        result = read_parquet(tmp_file, columns=[&#39;name&#39;, &#39;geometry&#39;])</span>
<span class="gi">+    elif file_format == &quot;feather&quot;:</span>
<span class="gi">+        gdf.to_feather(tmp_file)</span>
<span class="gi">+        result = read_feather(tmp_file, columns=[&#39;name&#39;, &#39;geometry&#39;])</span>
<span class="gi">+    </span>
<span class="gi">+    expected = gdf[[&#39;name&#39;, &#39;geometry&#39;]]</span>
<span class="gi">+    assert_geodataframe_equal(expected, result)</span>


<span class="w"> </span>def test_promote_secondary_geometry(tmpdir, file_format, naturalearth_lowres):
<span class="w"> </span>    &quot;&quot;&quot;Reading a subset of columns that does not include the primary geometry
<span class="w"> </span>    column should promote the first geometry column present.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gdf = naturalearth_lowres.copy()</span>
<span class="gi">+    gdf[&#39;geometry2&#39;] = gdf.geometry.centroid</span>
<span class="gi">+    tmp_file = str(tmpdir.join(f&quot;test.{file_format}&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    if file_format == &quot;parquet&quot;:</span>
<span class="gi">+        gdf.to_parquet(tmp_file)</span>
<span class="gi">+        result = read_parquet(tmp_file, columns=[&#39;name&#39;, &#39;geometry2&#39;])</span>
<span class="gi">+    elif file_format == &quot;feather&quot;:</span>
<span class="gi">+        gdf.to_feather(tmp_file)</span>
<span class="gi">+        result = read_feather(tmp_file, columns=[&#39;name&#39;, &#39;geometry2&#39;])</span>
<span class="gi">+    </span>
<span class="gi">+    assert isinstance(result, GeoDataFrame)</span>
<span class="gi">+    assert result.geometry.name == &#39;geometry2&#39;</span>
<span class="gi">+    assert_geoseries_equal(gdf[&#39;geometry2&#39;], result.geometry)</span>


<span class="w"> </span>def test_columns_no_geometry(tmpdir, file_format, naturalearth_lowres):
<span class="w"> </span>    &quot;&quot;&quot;Reading a parquet file that is missing all of the geometry columns
<span class="w"> </span>    should raise a ValueError&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gdf = naturalearth_lowres</span>
<span class="gi">+    tmp_file = str(tmpdir.join(f&quot;test.{file_format}&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    if file_format == &quot;parquet&quot;:</span>
<span class="gi">+        gdf.to_parquet(tmp_file)</span>
<span class="gi">+        with pytest.raises(ValueError, match=&quot;No geometry columns found&quot;):</span>
<span class="gi">+            read_parquet(tmp_file, columns=[&#39;name&#39;, &#39;pop_est&#39;])</span>
<span class="gi">+    elif file_format == &quot;feather&quot;:</span>
<span class="gi">+        gdf.to_feather(tmp_file)</span>
<span class="gi">+        with pytest.raises(ValueError, match=&quot;No geometry columns found&quot;):</span>
<span class="gi">+            read_feather(tmp_file, columns=[&#39;name&#39;, &#39;pop_est&#39;])</span>


<span class="w"> </span>def test_missing_crs(tmpdir, file_format, naturalearth_lowres):
<span class="w"> </span>    &quot;&quot;&quot;If CRS is `None`, it should be properly handled
<span class="w"> </span>    and remain `None` when read from parquet`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gdf = naturalearth_lowres.copy()</span>
<span class="gi">+    gdf.crs = None</span>
<span class="gi">+    tmp_file = str(tmpdir.join(f&quot;test.{file_format}&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    if file_format == &quot;parquet&quot;:</span>
<span class="gi">+        gdf.to_parquet(tmp_file)</span>
<span class="gi">+        result = read_parquet(tmp_file)</span>
<span class="gi">+    elif file_format == &quot;feather&quot;:</span>
<span class="gi">+        gdf.to_feather(tmp_file)</span>
<span class="gi">+        result = read_feather(tmp_file)</span>
<span class="gi">+    </span>
<span class="gi">+    assert result.crs is None</span>
<span class="gi">+    assert_geodataframe_equal(gdf, result)</span>


<span class="w"> </span>@pytest.mark.parametrize(&#39;version&#39;, [&#39;0.1.0&#39;, &#39;0.4.0&#39;, &#39;1.0.0-beta.1&#39;])
<span class="gu">@@ -145,7 +267,17 @@ def test_read_versioned_file(version):</span>
<span class="w"> </span>    df.to_feather(DATA_PATH / &#39;arrow&#39; / f&#39;test_data_v{METADATA_VERSION}.feather&#39;)
<span class="w"> </span>    df.to_parquet(DATA_PATH / &#39;arrow&#39; / f&#39;test_data_v{METADATA_VERSION}.parquet&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    feather_file = DATA_PATH / &#39;arrow&#39; / f&#39;test_data_v{version}.feather&#39;</span>
<span class="gi">+    parquet_file = DATA_PATH / &#39;arrow&#39; / f&#39;test_data_v{version}.parquet&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    gdf_feather = read_feather(feather_file)</span>
<span class="gi">+    gdf_parquet = read_parquet(parquet_file)</span>
<span class="gi">+    </span>
<span class="gi">+    assert isinstance(gdf_feather, GeoDataFrame)</span>
<span class="gi">+    assert isinstance(gdf_parquet, GeoDataFrame)</span>
<span class="gi">+    assert gdf_feather.crs == &quot;EPSG:4326&quot;</span>
<span class="gi">+    assert gdf_parquet.crs == &quot;EPSG:4326&quot;</span>
<span class="gi">+    assert_geodataframe_equal(gdf_feather, gdf_parquet)</span>


<span class="w"> </span>def test_read_gdal_files():
<span class="gh">diff --git a/geopandas/io/tests/test_sql.py b/geopandas/io/tests/test_sql.py</span>
<span class="gh">index 00f0209..d4eba19 100644</span>
<span class="gd">--- a/geopandas/io/tests/test_sql.py</span>
<span class="gi">+++ b/geopandas/io/tests/test_sql.py</span>
<span class="gu">@@ -27,7 +27,12 @@ def check_available_postgis_drivers() -&gt;list[str]:</span>
<span class="w"> </span>    This prevents tests running if the relevant package isn&#39;t installed
<span class="w"> </span>    (rather than being skipped, as skips are treated as failures during postgis CI)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    available_drivers = []</span>
<span class="gi">+    if find_spec(&quot;psycopg2&quot;):</span>
<span class="gi">+        available_drivers.append(&quot;psycopg2&quot;)</span>
<span class="gi">+    if find_spec(&quot;psycopg&quot;):</span>
<span class="gi">+        available_drivers.append(&quot;psycopg&quot;)</span>
<span class="gi">+    return available_drivers</span>


<span class="w"> </span>POSTGIS_DRIVERS = check_available_postgis_drivers()
<span class="gu">@@ -35,7 +40,13 @@ POSTGIS_DRIVERS = check_available_postgis_drivers()</span>

<span class="w"> </span>def prepare_database_credentials() -&gt;dict:
<span class="w"> </span>    &quot;&quot;&quot;Gather postgres connection credentials from environment variables.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return {</span>
<span class="gi">+        &quot;dbname&quot;: os.environ.get(&quot;PGDATABASE&quot;, &quot;test_geopandas&quot;),</span>
<span class="gi">+        &quot;user&quot;: os.environ.get(&quot;PGUSER&quot;, &quot;postgres&quot;),</span>
<span class="gi">+        &quot;password&quot;: os.environ.get(&quot;PGPASSWORD&quot;, &quot;&quot;),</span>
<span class="gi">+        &quot;host&quot;: os.environ.get(&quot;PGHOST&quot;, &quot;localhost&quot;),</span>
<span class="gi">+        &quot;port&quot;: os.environ.get(&quot;PGPORT&quot;, 5432),</span>
<span class="gi">+    }</span>


<span class="w"> </span>@pytest.fixture()
<span class="gu">@@ -43,7 +54,20 @@ def connection_postgis(request):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a postgres connection using either psycopg2 or psycopg.

<span class="w"> </span>    Use this as an indirect fixture, where the request parameter is POSTGIS_DRIVERS.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    driver = request.param</span>
<span class="gi">+    credentials = prepare_database_credentials()</span>
<span class="gi">+    </span>
<span class="gi">+    if driver == &quot;psycopg2&quot;:</span>
<span class="gi">+        import psycopg2</span>
<span class="gi">+        conn = psycopg2.connect(**credentials)</span>
<span class="gi">+    elif driver == &quot;psycopg&quot;:</span>
<span class="gi">+        import psycopg</span>
<span class="gi">+        conn = psycopg.connect(**credentials)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported driver: {driver}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    yield conn</span>
<span class="gi">+    conn.close()</span>


<span class="w"> </span>@pytest.fixture()
<span class="gu">@@ -53,7 +77,20 @@ def engine_postgis(request):</span>

<span class="w"> </span>    Use this as an indirect fixture, where the request parameter is POSTGIS_DRIVERS.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from sqlalchemy import create_engine</span>
<span class="gi">+    </span>
<span class="gi">+    driver = request.param</span>
<span class="gi">+    credentials = prepare_database_credentials()</span>
<span class="gi">+    </span>
<span class="gi">+    if driver == &quot;psycopg2&quot;:</span>
<span class="gi">+        engine = create_engine(f&quot;postgresql+psycopg2://{credentials[&#39;user&#39;]}:{credentials[&#39;password&#39;]}@{credentials[&#39;host&#39;]}:{credentials[&#39;port&#39;]}/{credentials[&#39;dbname&#39;]}&quot;)</span>
<span class="gi">+    elif driver == &quot;psycopg&quot;:</span>
<span class="gi">+        engine = create_engine(f&quot;postgresql+psycopg://{credentials[&#39;user&#39;]}:{credentials[&#39;password&#39;]}@{credentials[&#39;host&#39;]}:{credentials[&#39;port&#39;]}/{credentials[&#39;dbname&#39;]}&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported driver: {driver}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    yield engine</span>
<span class="gi">+    engine.dispose()</span>


<span class="w"> </span>@pytest.fixture()
<span class="gu">@@ -72,7 +109,18 @@ def connection_spatialite():</span>
<span class="w"> </span>    ``AttributeError`` on missing support for loadable SQLite extensions
<span class="w"> </span>    ``sqlite3.OperationalError`` on missing SpatiaLite
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import sqlite3</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        conn = sqlite3.connect(&quot;:memory:&quot;)</span>
<span class="gi">+        conn.enable_load_extension(True)</span>
<span class="gi">+        conn.load_extension(&quot;mod_spatialite&quot;)</span>
<span class="gi">+    except (AttributeError, sqlite3.OperationalError) as e:</span>
<span class="gi">+        pytest.skip(f&quot;Unable to load SpatiaLite extension: {str(e)}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    conn.execute(&quot;SELECT InitSpatialMetadata(1)&quot;)</span>
<span class="gi">+    yield conn</span>
<span class="gi">+    conn.close()</span>


<span class="w"> </span>class TestIO:
<span class="gh">diff --git a/geopandas/io/util.py b/geopandas/io/util.py</span>
<span class="gh">index a13ec40..041f4e7 100644</span>
<span class="gd">--- a/geopandas/io/util.py</span>
<span class="gi">+++ b/geopandas/io/util.py</span>
<span class="gu">@@ -9,7 +9,8 @@ def vsi_path(path: str) -&gt;str:</span>
<span class="w"> </span>    Ensure path is a local path or a GDAL-compatible vsi path.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parsed = _parse_uri(path)</span>
<span class="gi">+    return _construct_vsi_path(*parsed)</span>


<span class="w"> </span>SCHEMES = {&#39;file&#39;: &#39;file&#39;, &#39;zip&#39;: &#39;zip&#39;, &#39;tar&#39;: &#39;tar&#39;, &#39;gzip&#39;: &#39;gzip&#39;,
<span class="gu">@@ -33,9 +34,35 @@ def _parse_uri(path: str):</span>
<span class="w"> </span>    scheme : str
<span class="w"> </span>        URI scheme such as &quot;https&quot; or &quot;zip+s3&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parsed = urlparse(path)</span>
<span class="gi">+    scheme = parsed.scheme.lower()</span>
<span class="gi">+    archive = None</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;+&#39; in scheme:</span>
<span class="gi">+        archive_scheme, inner_scheme = scheme.split(&#39;+&#39;, 1)</span>
<span class="gi">+        if archive_scheme in SCHEMES and inner_scheme in SCHEMES:</span>
<span class="gi">+            archive = f&quot;/vsi{SCHEMES[archive_scheme]}/{parsed.netloc}{parsed.path}&quot;</span>
<span class="gi">+            scheme = inner_scheme</span>
<span class="gi">+        else:</span>
<span class="gi">+            scheme = parsed.scheme</span>
<span class="gi">+</span>
<span class="gi">+    if scheme in CURLSCHEMES:</span>
<span class="gi">+        path = f&quot;{parsed.scheme}://{parsed.netloc}{parsed.path}&quot;</span>
<span class="gi">+        if parsed.query:</span>
<span class="gi">+            path += f&quot;?{parsed.query}&quot;</span>
<span class="gi">+    elif scheme in SCHEMES:</span>
<span class="gi">+        path = f&quot;{parsed.netloc}{parsed.path}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        path = parsed.path</span>
<span class="gi">+</span>
<span class="gi">+    return path, archive, scheme</span>


<span class="w"> </span>def _construct_vsi_path(path, archive, scheme) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Convert a parsed path to a GDAL VSI path&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if archive:</span>
<span class="gi">+        return f&quot;/vsi{SCHEMES[scheme]}/{archive}/{path}&quot;</span>
<span class="gi">+    elif scheme in SCHEMES:</span>
<span class="gi">+        return f&quot;/vsi{SCHEMES[scheme]}/{path}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return path</span>
<span class="gh">diff --git a/geopandas/plotting.py b/geopandas/plotting.py</span>
<span class="gh">index 974bdc1..f8f4447 100644</span>
<span class="gd">--- a/geopandas/plotting.py</span>
<span class="gi">+++ b/geopandas/plotting.py</span>
<span class="gu">@@ -25,7 +25,21 @@ def _sanitize_geoms(geoms, prefix=&#39;Multi&#39;):</span>
<span class="w"> </span>    component_index : index array
<span class="w"> </span>        indices are repeated for all components in the same Multi geometry
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    components = []</span>
<span class="gi">+    component_index = []</span>
<span class="gi">+</span>
<span class="gi">+    for idx, geom in enumerate(geoms):</span>
<span class="gi">+        if geom is None or geom.is_empty:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if geom.type.startswith(prefix):</span>
<span class="gi">+            for part in geom.geoms:</span>
<span class="gi">+                components.append(part)</span>
<span class="gi">+                component_index.append(idx)</span>
<span class="gi">+        else:</span>
<span class="gi">+            components.append(geom)</span>
<span class="gi">+            component_index.append(idx)</span>
<span class="gi">+</span>
<span class="gi">+    return components, component_index</span>


<span class="w"> </span>def _expand_kwargs(kwargs, multiindex):
<span class="gu">@@ -35,7 +49,12 @@ def _expand_kwargs(kwargs, multiindex):</span>
<span class="w"> </span>    it (in place) to the correct length/formats with help of &#39;multiindex&#39;, unless
<span class="w"> </span>    the value appears to already be a valid (single) value for the key.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for key, value in kwargs.items():</span>
<span class="gi">+        if isinstance(value, (list, np.ndarray, pd.Series)):</span>
<span class="gi">+            if len(value) != len(multiindex):</span>
<span class="gi">+                kwargs[key] = [value[i] for i in multiindex]</span>
<span class="gi">+        elif not isinstance(value, (str, int, float, bool)):</span>
<span class="gi">+            kwargs[key] = [value for _ in multiindex]</span>


<span class="w"> </span>def _PolygonPatch(polygon, **kwargs):
<span class="gu">@@ -54,7 +73,30 @@ def _PolygonPatch(polygon, **kwargs):</span>
<span class="w"> </span>    (BSD license, https://pypi.org/project/descartes) for PolygonPatch, but
<span class="w"> </span>    this dependency was removed in favor of the below matplotlib code.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from matplotlib.patches import PathPatch</span>
<span class="gi">+    from matplotlib.path import Path</span>
<span class="gi">+</span>
<span class="gi">+    def ring_coding(ob):</span>
<span class="gi">+        # The codes will be all &quot;LINETO&quot; commands, except for &quot;MOVETO&quot;s at the</span>
<span class="gi">+        # beginning of each subpath</span>
<span class="gi">+        n = len(ob.coords)</span>
<span class="gi">+        codes = np.ones(n, dtype=Path.code_type) * Path.LINETO</span>
<span class="gi">+        codes[0] = Path.MOVETO</span>
<span class="gi">+        return codes</span>
<span class="gi">+</span>
<span class="gi">+    def pathify(polygon):</span>
<span class="gi">+        # Convert coordinates to path vertices. Objects produced by Shapely&#39;s</span>
<span class="gi">+        # analytic methods have the proper coordinate order, no need to sort.</span>
<span class="gi">+        vertices = np.concatenate(</span>
<span class="gi">+            [np.asarray(polygon.exterior.coords)[:, :2]]</span>
<span class="gi">+            + [np.asarray(r.coords)[:, :2] for r in polygon.interiors])</span>
<span class="gi">+        codes = np.concatenate(</span>
<span class="gi">+            [ring_coding(polygon.exterior)]</span>
<span class="gi">+            + [ring_coding(r) for r in polygon.interiors])</span>
<span class="gi">+        return Path(vertices, codes)</span>
<span class="gi">+</span>
<span class="gi">+    path = pathify(polygon)</span>
<span class="gi">+    return PathPatch(path, **kwargs)</span>


<span class="w"> </span>def _plot_polygon_collection(ax, geoms, values=None, color=None, cmap=None,
<span class="gu">@@ -87,7 +129,27 @@ def _plot_polygon_collection(ax, geoms, values=None, color=None, cmap=None,</span>
<span class="w"> </span>    -------
<span class="w"> </span>    collection : matplotlib.collections.Collection that was plotted
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from matplotlib.collections import PatchCollection</span>
<span class="gi">+    from matplotlib.colors import Normalize</span>
<span class="gi">+</span>
<span class="gi">+    geoms, multiindex = _sanitize_geoms(geoms)</span>
<span class="gi">+    _expand_kwargs(kwargs, multiindex)</span>
<span class="gi">+</span>
<span class="gi">+    patches = [_PolygonPatch(poly) for poly in geoms]</span>
<span class="gi">+    collection = PatchCollection(patches, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if values is not None:</span>
<span class="gi">+        values = np.take(values, multiindex)</span>
<span class="gi">+        collection.set_array(values)</span>
<span class="gi">+        collection.set_cmap(cmap)</span>
<span class="gi">+        collection.set_norm(Normalize(vmin=vmin, vmax=vmax))</span>
<span class="gi">+    elif color is not None:</span>
<span class="gi">+        collection.set_facecolor(color)</span>
<span class="gi">+        collection.set_edgecolor(color)</span>
<span class="gi">+</span>
<span class="gi">+    ax.add_collection(collection, autolim=autolim)</span>
<span class="gi">+</span>
<span class="gi">+    return collection</span>


<span class="w"> </span>def _plot_linestring_collection(ax, geoms, values=None, color=None, cmap=
<span class="gh">diff --git a/geopandas/sindex.py b/geopandas/sindex.py</span>
<span class="gh">index f72d4f2..963507a 100644</span>
<span class="gd">--- a/geopandas/sindex.py</span>
<span class="gi">+++ b/geopandas/sindex.py</span>
<span class="gu">@@ -40,7 +40,7 @@ class SpatialIndex:</span>
<span class="w"> </span>        &gt;&gt;&gt; s.sindex.valid_query_predicates  # doctest: +SKIP
<span class="w"> </span>        {None, &quot;contains&quot;, &quot;contains_properly&quot;, &quot;covered_by&quot;, &quot;covers&quot;, &quot;crosses&quot;, &quot;dwithin&quot;, &quot;intersects&quot;, &quot;overlaps&quot;, &quot;touches&quot;, &quot;within&quot;}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return PREDICATES</span>

<span class="w"> </span>    def query(self, geometry, predicate=None, sort=False, distance=None,
<span class="w"> </span>        output_format=&#39;tuple&#39;):
<span class="gu">@@ -165,7 +165,31 @@ class SpatialIndex:</span>
<span class="w"> </span>        geometries that can be joined based on overlapping bounding boxes or
<span class="w"> </span>        optional predicate are returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        geometry_array = self._as_geometry_array(geometry)</span>
<span class="gi">+        </span>
<span class="gi">+        if predicate == &#39;dwithin&#39; and distance is None:</span>
<span class="gi">+            raise ValueError(&quot;Distance is required for &#39;dwithin&#39; predicate&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if predicate not in self.valid_query_predicates:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid predicate: {predicate}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if predicate is None:</span>
<span class="gi">+            result = self._tree.query(geometry_array)</span>
<span class="gi">+        elif predicate == &#39;dwithin&#39;:</span>
<span class="gi">+            result = self._tree.query(geometry_array, predicate=predicate, distance=distance)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = self._tree.query(geometry_array, predicate=predicate)</span>
<span class="gi">+        </span>
<span class="gi">+        if sort:</span>
<span class="gi">+            result = np.sort(result, axis=1)</span>
<span class="gi">+        </span>
<span class="gi">+        if output_format == &#39;tuple&#39;:</span>
<span class="gi">+            return result</span>
<span class="gi">+        elif output_format == &#39;pandas&#39;:</span>
<span class="gi">+            import pandas as pd</span>
<span class="gi">+            return pd.DataFrame(result.T, columns=[&#39;input_index&#39;, &#39;tree_index&#39;])</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid output_format: {output_format}&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _as_geometry_array(geometry):
<span class="gu">@@ -182,7 +206,16 @@ class SpatialIndex:</span>
<span class="w"> </span>        np.ndarray
<span class="w"> </span>            A numpy array of Shapely geometries.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(geometry, BaseGeometry):</span>
<span class="gi">+            return np.array([geometry])</span>
<span class="gi">+        elif isinstance(geometry, (geoseries.GeoSeries, array.GeometryArray)):</span>
<span class="gi">+            return geometry.values</span>
<span class="gi">+        elif isinstance(geometry, np.ndarray) and isinstance(geometry[0], BaseGeometry):</span>
<span class="gi">+            return geometry</span>
<span class="gi">+        elif isinstance(geometry, list) and all(isinstance(g, BaseGeometry) for g in geometry):</span>
<span class="gi">+            return np.array(geometry)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Invalid geometry type. Expected Shapely geometry, GeoSeries, GeometryArray, or list/array of Shapely geometries.&quot;)</span>

<span class="w"> </span>    def nearest(self, geometry, return_all=True, max_distance=None,
<span class="w"> </span>        return_distance=False, exclusive=False):
<span class="gu">@@ -264,7 +297,18 @@ class SpatialIndex:</span>
<span class="w"> </span>        array([[0, 1],
<span class="w"> </span>               [8, 9]])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        geometry_array = self._as_geometry_array(geometry)</span>
<span class="gi">+        </span>
<span class="gi">+        if max_distance is not None and max_distance &lt;= 0:</span>
<span class="gi">+            raise ValueError(&quot;max_distance must be greater than 0&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        result = self._tree.nearest(geometry_array, return_all=return_all, max_distance=max_distance, exclusive=exclusive)</span>
<span class="gi">+        </span>
<span class="gi">+        if return_distance:</span>
<span class="gi">+            indices, distances = result</span>
<span class="gi">+            return indices, distances</span>
<span class="gi">+        else:</span>
<span class="gi">+            return result</span>

<span class="w"> </span>    def intersection(self, coordinates):
<span class="w"> </span>        &quot;&quot;&quot;Compatibility wrapper for rtree.index.Index.intersection,
<span class="gu">@@ -302,7 +346,14 @@ class SpatialIndex:</span>
<span class="w"> </span>        array([1, 2, 3])

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(coordinates) == 2:</span>
<span class="gi">+            # Point query</span>
<span class="gi">+            return self.query(shapely.Point(coordinates))</span>
<span class="gi">+        elif len(coordinates) == 4:</span>
<span class="gi">+            # Rectangle query</span>
<span class="gi">+            return self.query(shapely.box(*coordinates))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Invalid coordinates. Expected (x, y) for point or (min_x, min_y, max_x, max_y) for rectangle.&quot;)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def size(self):
<span class="gu">@@ -330,7 +381,7 @@ class SpatialIndex:</span>
<span class="w"> </span>        &gt;&gt;&gt; s.sindex.size
<span class="w"> </span>        10
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._tree)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_empty(self):
<span class="gu">@@ -360,7 +411,7 @@ class SpatialIndex:</span>
<span class="w"> </span>        &gt;&gt;&gt; s2.sindex.is_empty
<span class="w"> </span>        True
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._tree) == 0</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self._tree)
<span class="gh">diff --git a/geopandas/testing.py b/geopandas/testing.py</span>
<span class="gh">index 582d8a2..c5f3994 100644</span>
<span class="gd">--- a/geopandas/testing.py</span>
<span class="gi">+++ b/geopandas/testing.py</span>
<span class="gu">@@ -9,7 +9,10 @@ from geopandas.array import GeometryDtype</span>

<span class="w"> </span>def _isna(this):
<span class="w"> </span>    &quot;&quot;&quot;isna version that works for both scalars and (Geo)Series&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(this, (GeoSeries, pd.Series)):</span>
<span class="gi">+        return this.isna()</span>
<span class="gi">+    else:</span>
<span class="gi">+        return pd.isna(this)</span>


<span class="w"> </span>def _geom_equals_mask(this, that):
<span class="gu">@@ -27,7 +30,20 @@ def _geom_equals_mask(this, that):</span>
<span class="w"> </span>    Series
<span class="w"> </span>        boolean Series, True if geometries in left equal geometries in right
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(this, GeoSeries):</span>
<span class="gi">+        this = this.geometry</span>
<span class="gi">+    if isinstance(that, GeoSeries):</span>
<span class="gi">+        that = that.geometry</span>
<span class="gi">+</span>
<span class="gi">+    this_na = _isna(this)</span>
<span class="gi">+    that_na = _isna(that)</span>
<span class="gi">+    </span>
<span class="gi">+    empty_mask = this.is_empty | that.is_empty</span>
<span class="gi">+    na_mask = this_na | that_na</span>
<span class="gi">+    </span>
<span class="gi">+    equals_mask = this.equals(that)</span>
<span class="gi">+    </span>
<span class="gi">+    return (empty_mask &amp; na_mask) | equals_mask</span>


<span class="w"> </span>def geom_equals(this, that):
<span class="gu">@@ -45,7 +61,7 @@ def geom_equals(this, that):</span>
<span class="w"> </span>    bool
<span class="w"> </span>        True if all geometries in left equal geometries in right
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _geom_equals_mask(this, that).all()</span>


<span class="w"> </span>def _geom_almost_equals_mask(this, that):
<span class="gu">@@ -65,7 +81,20 @@ def _geom_almost_equals_mask(this, that):</span>
<span class="w"> </span>    Series
<span class="w"> </span>        boolean Series, True if geometries in left almost equal geometries in right
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(this, GeoSeries):</span>
<span class="gi">+        this = this.geometry</span>
<span class="gi">+    if isinstance(that, GeoSeries):</span>
<span class="gi">+        that = that.geometry</span>
<span class="gi">+</span>
<span class="gi">+    this_na = _isna(this)</span>
<span class="gi">+    that_na = _isna(that)</span>
<span class="gi">+    </span>
<span class="gi">+    empty_mask = this.is_empty | that.is_empty</span>
<span class="gi">+    na_mask = this_na | that_na</span>
<span class="gi">+    </span>
<span class="gi">+    almost_equals_mask = this.almost_equals(that)</span>
<span class="gi">+    </span>
<span class="gi">+    return (empty_mask &amp; na_mask) | almost_equals_mask</span>


<span class="w"> </span>def geom_almost_equals(this, that):
<span class="gu">@@ -86,7 +115,7 @@ def geom_almost_equals(this, that):</span>
<span class="w"> </span>    bool
<span class="w"> </span>        True if all geometries in left almost equal geometries in right
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _geom_almost_equals_mask(this, that).all()</span>


<span class="w"> </span>def assert_geoseries_equal(left, right, check_dtype=True, check_index_type=
<span class="gu">@@ -119,12 +148,45 @@ def assert_geoseries_equal(left, right, check_dtype=True, check_index_type=</span>
<span class="w"> </span>        Typically useful with ``check_less_precise=True``, which uses
<span class="w"> </span>        ``geom_equals_exact`` and requires exact coordinate order.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if check_series_type:</span>
<span class="gi">+        assert isinstance(left, GeoSeries)</span>
<span class="gi">+        assert isinstance(right, GeoSeries)</span>
<span class="gi">+</span>
<span class="gi">+    if check_dtype:</span>
<span class="gi">+        assert isinstance(left.dtype, GeometryDtype)</span>
<span class="gi">+        assert isinstance(right.dtype, GeometryDtype)</span>
<span class="gi">+</span>
<span class="gi">+    if check_index_type:</span>
<span class="gi">+        assert isinstance(left.index, type(right.index))</span>
<span class="gi">+</span>
<span class="gi">+    assert len(left) == len(right)</span>
<span class="gi">+</span>
<span class="gi">+    if check_crs and check_series_type:</span>
<span class="gi">+        assert left.crs == right.crs</span>
<span class="gi">+</span>
<span class="gi">+    if normalize:</span>
<span class="gi">+        left = left.normalize()</span>
<span class="gi">+        right = right.normalize()</span>
<span class="gi">+</span>
<span class="gi">+    if check_geom_type:</span>
<span class="gi">+        assert (left.geom_type == right.geom_type).all()</span>
<span class="gi">+</span>
<span class="gi">+    if check_less_precise:</span>
<span class="gi">+        assert geom_almost_equals(left, right)</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert geom_equals(left, right)</span>


<span class="w"> </span>def _truncated_string(geom):
<span class="w"> </span>    &quot;&quot;&quot;Truncated WKT repr of geom&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if geom is None:</span>
<span class="gi">+        return &#39;None&#39;</span>
<span class="gi">+    if geom.is_empty:</span>
<span class="gi">+        return &#39;EMPTY&#39;</span>
<span class="gi">+    wkt = geom.wkt</span>
<span class="gi">+    if len(wkt) &gt; 80:</span>
<span class="gi">+        return wkt[:77] + &#39;...&#39;</span>
<span class="gi">+    return wkt</span>


<span class="w"> </span>def assert_geodataframe_equal(left, right, check_dtype=True,
<span class="gu">@@ -158,4 +220,52 @@ def assert_geodataframe_equal(left, right, check_dtype=True,</span>
<span class="w"> </span>        Typically useful with ``check_less_precise=True``, which uses
<span class="w"> </span>        ``geom_equals_exact`` and requires exact coordinate order.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if check_frame_type:</span>
<span class="gi">+        assert isinstance(left, GeoDataFrame)</span>
<span class="gi">+        assert isinstance(right, GeoDataFrame)</span>
<span class="gi">+</span>
<span class="gi">+    assert len(left) == len(right)</span>
<span class="gi">+    assert len(left.columns) == len(right.columns)</span>
<span class="gi">+</span>
<span class="gi">+    if check_like:</span>
<span class="gi">+        left = left.sort_index().sort_index(axis=1)</span>
<span class="gi">+        right = right.sort_index().sort_index(axis=1)</span>
<span class="gi">+</span>
<span class="gi">+    assert (left.columns == right.columns).all()</span>
<span class="gi">+</span>
<span class="gi">+    if check_dtype:</span>
<span class="gi">+        assert (left.dtypes == right.dtypes).all()</span>
<span class="gi">+</span>
<span class="gi">+    if check_index_type == &#39;equiv&#39;:</span>
<span class="gi">+        assert left.index.equals(right.index)</span>
<span class="gi">+    elif check_index_type:</span>
<span class="gi">+        assert isinstance(left.index, type(right.index))</span>
<span class="gi">+</span>
<span class="gi">+    if check_column_type == &#39;equiv&#39;:</span>
<span class="gi">+        assert (left.columns == right.columns).all()</span>
<span class="gi">+    elif check_column_type:</span>
<span class="gi">+        assert isinstance(left.columns, type(right.columns))</span>
<span class="gi">+</span>
<span class="gi">+    if check_crs and check_frame_type:</span>
<span class="gi">+        assert left.crs == right.crs</span>
<span class="gi">+</span>
<span class="gi">+    if normalize:</span>
<span class="gi">+        left.geometry = left.geometry.normalize()</span>
<span class="gi">+        right.geometry = right.geometry.normalize()</span>
<span class="gi">+</span>
<span class="gi">+    if check_geom_type:</span>
<span class="gi">+        assert (left.geometry.geom_type == right.geometry.geom_type).all()</span>
<span class="gi">+</span>
<span class="gi">+    for col in left.columns:</span>
<span class="gi">+        if col == left._geometry_column_name:</span>
<span class="gi">+            if check_less_precise:</span>
<span class="gi">+                assert geom_almost_equals(left[col], right[col])</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert geom_equals(left[col], right[col])</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert_series_equal(left[col], right[col], check_dtype=check_dtype,</span>
<span class="gi">+                                check_index_type=check_index_type,</span>
<span class="gi">+                                check_series_type=False,</span>
<span class="gi">+                                check_less_precise=check_less_precise,</span>
<span class="gi">+                                check_names=True,</span>
<span class="gi">+                                obj=f&#39;DataFrame.{col}&#39;)</span>
<span class="gh">diff --git a/geopandas/tools/_random.py b/geopandas/tools/_random.py</span>
<span class="gh">index b79a37a..347b8bf 100644</span>
<span class="gd">--- a/geopandas/tools/_random.py</span>
<span class="gi">+++ b/geopandas/tools/_random.py</span>
<span class="gu">@@ -37,18 +37,61 @@ def uniform(geom, size, rng=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; square = box(0,0,1,1)
<span class="w"> </span>    &gt;&gt;&gt; uniform(square, size=102) # doctest: +SKIP
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if rng is None:</span>
<span class="gi">+        rng = numpy.random.default_rng()</span>
<span class="gi">+</span>
<span class="gi">+    if geom.geom_type == &#39;Polygon&#39;:</span>
<span class="gi">+        return _uniform_polygon(geom, size, rng)</span>
<span class="gi">+    elif geom.geom_type == &#39;LineString&#39;:</span>
<span class="gi">+        return _uniform_line(geom, size, rng)</span>
<span class="gi">+    elif geom.geom_type == &#39;MultiPolygon&#39;:</span>
<span class="gi">+        weights = [p.area for p in geom.geoms]</span>
<span class="gi">+        total_weight = sum(weights)</span>
<span class="gi">+        weights = [w / total_weight for w in weights]</span>
<span class="gi">+        counts = rng.multinomial(size, weights)</span>
<span class="gi">+        points = [_uniform_polygon(p, c, rng) for p, c in zip(geom.geoms, counts) if c &gt; 0]</span>
<span class="gi">+        return MultiPoint([p for subpoints in points for p in subpoints.geoms])</span>
<span class="gi">+    elif geom.geom_type == &#39;MultiLineString&#39;:</span>
<span class="gi">+        weights = [l.length for l in geom.geoms]</span>
<span class="gi">+        total_weight = sum(weights)</span>
<span class="gi">+        weights = [w / total_weight for w in weights]</span>
<span class="gi">+        counts = rng.multinomial(size, weights)</span>
<span class="gi">+        points = [_uniform_line(l, c, rng) for l, c in zip(geom.geoms, counts) if c &gt; 0]</span>
<span class="gi">+        return MultiPoint([p for subpoints in points for p in subpoints.geoms])</span>
<span class="gi">+    else:</span>
<span class="gi">+        warn(f&quot;Geometry type {geom.geom_type} not supported. Returning empty MultiPoint.&quot;)</span>
<span class="gi">+        return MultiPoint()</span>


<span class="w"> </span>def _uniform_line(geom, size, generator):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Sample points from an input shapely linestring
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if size == 0:</span>
<span class="gi">+        return MultiPoint()</span>
<span class="gi">+</span>
<span class="gi">+    total_length = geom.length</span>
<span class="gi">+    distances = generator.random(size) * total_length</span>
<span class="gi">+    points = [geom.interpolate(distance) for distance in distances]</span>
<span class="gi">+    return MultiPoint(points)</span>


<span class="w"> </span>def _uniform_polygon(geom, size, generator):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Sample uniformly from within a polygon using batched sampling.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if size == 0:</span>
<span class="gi">+        return MultiPoint()</span>
<span class="gi">+</span>
<span class="gi">+    minx, miny, maxx, maxy = geom.bounds</span>
<span class="gi">+    points = []</span>
<span class="gi">+    batch_size = min(1000, size * 2)  # Adjust batch size as needed</span>
<span class="gi">+</span>
<span class="gi">+    while len(points) &lt; size:</span>
<span class="gi">+        x = generator.uniform(minx, maxx, batch_size)</span>
<span class="gi">+        y = generator.uniform(miny, maxy, batch_size)</span>
<span class="gi">+        candidates = MultiPoint(list(zip(x, y)))</span>
<span class="gi">+        valid_points = [p for p in candidates.geoms if geom.contains(p)]</span>
<span class="gi">+        points.extend(valid_points[:size - len(points)])</span>
<span class="gi">+</span>
<span class="gi">+    return MultiPoint(points[:size])</span>
<span class="gh">diff --git a/geopandas/tools/_show_versions.py b/geopandas/tools/_show_versions.py</span>
<span class="gh">index 661c2c2..72725e3 100644</span>
<span class="gd">--- a/geopandas/tools/_show_versions.py</span>
<span class="gi">+++ b/geopandas/tools/_show_versions.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>import importlib
<span class="w"> </span>import platform
<span class="w"> </span>import sys
<span class="gi">+from collections import OrderedDict</span>


<span class="w"> </span>def _get_sys_info():
<span class="gu">@@ -11,7 +12,19 @@ def _get_sys_info():</span>
<span class="w"> </span>    sys_info : dict
<span class="w"> </span>        system and Python version information
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return OrderedDict(</span>
<span class="gi">+        [</span>
<span class="gi">+            (&quot;python&quot;, sys.version.split()[0]),</span>
<span class="gi">+            (&quot;python-bits&quot;, f&quot;{sys.maxsize.bit_length() + 1}&quot;),</span>
<span class="gi">+            (&quot;OS&quot;, platform.system()),</span>
<span class="gi">+            (&quot;OS-release&quot;, platform.release()),</span>
<span class="gi">+            (&quot;machine&quot;, platform.machine()),</span>
<span class="gi">+            (&quot;processor&quot;, platform.processor()),</span>
<span class="gi">+            (&quot;byteorder&quot;, sys.byteorder),</span>
<span class="gi">+            (&quot;LC_ALL&quot;, &quot;.&quot;.join(platform.localeconv().get(&quot;decimal_point&quot;, &quot;&quot;))),</span>
<span class="gi">+            (&quot;LANG&quot;, os.environ.get(&quot;LANG&quot;, &quot;None&quot;)),</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _get_C_info():
<span class="gu">@@ -21,7 +34,17 @@ def _get_C_info():</span>
<span class="w"> </span>    c_info: dict
<span class="w"> </span>        system PROJ information
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import pyproj</span>
<span class="gi">+    import fiona</span>
<span class="gi">+    from shapely import geos_version_string</span>
<span class="gi">+</span>
<span class="gi">+    return OrderedDict(</span>
<span class="gi">+        [</span>
<span class="gi">+            (&quot;PROJ&quot;, pyproj.proj_version_str),</span>
<span class="gi">+            (&quot;GDAL&quot;, fiona.__gdal_version__),</span>
<span class="gi">+            (&quot;GEOS&quot;, geos_version_string),</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _get_deps_info():
<span class="gu">@@ -32,7 +55,37 @@ def _get_deps_info():</span>
<span class="w"> </span>    deps_info: dict
<span class="w"> </span>        version information on relevant Python libraries
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    deps = [</span>
<span class="gi">+        &quot;geopandas&quot;,</span>
<span class="gi">+        &quot;pandas&quot;,</span>
<span class="gi">+        &quot;fiona&quot;,</span>
<span class="gi">+        &quot;numpy&quot;,</span>
<span class="gi">+        &quot;shapely&quot;,</span>
<span class="gi">+        &quot;pyproj&quot;,</span>
<span class="gi">+        &quot;rtree&quot;,</span>
<span class="gi">+        &quot;matplotlib&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def get_version(module):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return module.__version__</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return module.version</span>
<span class="gi">+</span>
<span class="gi">+    deps_info = {}</span>
<span class="gi">+</span>
<span class="gi">+    for modname in deps:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if modname in sys.modules:</span>
<span class="gi">+                mod = sys.modules[modname]</span>
<span class="gi">+            else:</span>
<span class="gi">+                mod = importlib.import_module(modname)</span>
<span class="gi">+            ver = get_version(mod)</span>
<span class="gi">+            deps_info[modname] = ver</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            deps_info[modname] = None</span>
<span class="gi">+</span>
<span class="gi">+    return deps_info</span>


<span class="w"> </span>def show_versions():
<span class="gu">@@ -46,4 +99,18 @@ def show_versions():</span>

<span class="w"> </span>        $ python -c &quot;import geopandas; geopandas.show_versions()&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sys_info = _get_sys_info()</span>
<span class="gi">+    c_info = _get_C_info()</span>
<span class="gi">+    deps_info = _get_deps_info()</span>
<span class="gi">+</span>
<span class="gi">+    print(&quot;\nSystem:&quot;)</span>
<span class="gi">+    for k, v in sys_info.items():</span>
<span class="gi">+        print(f&quot;{k}: {v}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    print(&quot;\nC dependencies:&quot;)</span>
<span class="gi">+    for k, v in c_info.items():</span>
<span class="gi">+        print(f&quot;{k}: {v}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    print(&quot;\nPython dependencies:&quot;)</span>
<span class="gi">+    for k, v in deps_info.items():</span>
<span class="gi">+        print(f&quot;{k}: {v}&quot;)</span>
<span class="gh">diff --git a/geopandas/tools/clip.py b/geopandas/tools/clip.py</span>
<span class="gh">index 2ec2eda..2017847 100644</span>
<span class="gd">--- a/geopandas/tools/clip.py</span>
<span class="gi">+++ b/geopandas/tools/clip.py</span>
<span class="gu">@@ -37,7 +37,18 @@ def _clip_gdf_with_mask(gdf, mask, sort=False):</span>
<span class="w"> </span>        The returned GeoDataFrame is a clipped subset of gdf
<span class="w"> </span>        that intersects with polygon/rectangle.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(mask, (Polygon, MultiPolygon)):</span>
<span class="gi">+        clipped = gdf.intersection(mask)</span>
<span class="gi">+    else:</span>
<span class="gi">+        clipped = gdf.clip_by_rect(*mask)</span>
<span class="gi">+    </span>
<span class="gi">+    # Remove empty geometries</span>
<span class="gi">+    clipped = clipped[~clipped.is_empty]</span>
<span class="gi">+    </span>
<span class="gi">+    if sort:</span>
<span class="gi">+        clipped = clipped.sort_index()</span>
<span class="gi">+    </span>
<span class="gi">+    return GeoDataFrame(clipped, crs=gdf.crs)</span>


<span class="w"> </span>def clip(gdf, mask, keep_geom_type=False, sort=False):
<span class="gu">@@ -105,4 +116,19 @@ def clip(gdf, mask, keep_geom_type=False, sort=False):</span>
<span class="w"> </span>    &gt;&gt;&gt; nws_groceries.shape
<span class="w"> </span>    (7, 8)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(gdf, GeoSeries):</span>
<span class="gi">+        return _clip_gdf_with_mask(GeoDataFrame(geometry=gdf), mask, sort=sort).geometry</span>
<span class="gi">+</span>
<span class="gi">+    _check_crs(gdf, mask)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(mask, (GeoDataFrame, GeoSeries)):</span>
<span class="gi">+        mask = mask.geometry.unary_union</span>
<span class="gi">+    elif isinstance(mask, (list, tuple)) and len(mask) == 4:</span>
<span class="gi">+        mask = box(*mask)</span>
<span class="gi">+</span>
<span class="gi">+    clipped = _clip_gdf_with_mask(gdf, mask, sort=sort)</span>
<span class="gi">+</span>
<span class="gi">+    if keep_geom_type:</span>
<span class="gi">+        clipped = clipped[clipped.geom_type == gdf.geom_type]</span>
<span class="gi">+</span>
<span class="gi">+    return clipped</span>
<span class="gh">diff --git a/geopandas/tools/geocoding.py b/geopandas/tools/geocoding.py</span>
<span class="gh">index 995d1d8..05d56ba 100644</span>
<span class="gd">--- a/geopandas/tools/geocoding.py</span>
<span class="gi">+++ b/geopandas/tools/geocoding.py</span>
<span class="gu">@@ -10,7 +10,13 @@ def _get_throttle_time(provider):</span>
<span class="w"> </span>    Amount of time to wait between requests to a geocoding API, for providers
<span class="w"> </span>    that specify rate limits in their terms of service.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    throttle_times = {</span>
<span class="gi">+        &#39;nominatim&#39;: 1.0,  # 1 request per second</span>
<span class="gi">+        &#39;googlev3&#39;: 0.2,   # 50 requests per second</span>
<span class="gi">+        &#39;bing&#39;: 0.5,       # 2 requests per second</span>
<span class="gi">+        &#39;photon&#39;: 0.1,     # 10 requests per second (default)</span>
<span class="gi">+    }</span>
<span class="gi">+    return throttle_times.get(provider, 0.1)  # Default to 0.1 if provider not listed</span>


<span class="w"> </span>def geocode(strings, provider=None, **kwargs):
<span class="gu">@@ -50,7 +56,27 @@ def geocode(strings, provider=None, **kwargs):</span>
<span class="w"> </span>    0  POINT (-71.05863 42.35899)                          Boston, MA, United States
<span class="w"> </span>    1  POINT (-77.03651 38.89766)  1600 Pennsylvania Ave NW, Washington, DC 20006...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from geopy.geocoders import get_geocoder_for_service</span>
<span class="gi">+    from geopy.exc import GeocoderTimedOut, GeocoderServiceError</span>
<span class="gi">+</span>
<span class="gi">+    if provider is None:</span>
<span class="gi">+        provider = &#39;photon&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(provider, str):</span>
<span class="gi">+        provider = get_geocoder_for_service(provider)(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    results = {}</span>
<span class="gi">+    for i, string in enumerate(strings):</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = provider.geocode(string)</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                results[i] = (string, (result.latitude, result.longitude))</span>
<span class="gi">+        except (GeocoderTimedOut, GeocoderServiceError):</span>
<span class="gi">+            results[i] = (string, (None, None))</span>
<span class="gi">+        </span>
<span class="gi">+        time.sleep(_get_throttle_time(provider.__class__.__name__.lower()))</span>
<span class="gi">+</span>
<span class="gi">+    return _prepare_geocode_result(results)</span>


<span class="w"> </span>def reverse_geocode(points, provider=None, **kwargs):
<span class="gu">@@ -96,7 +122,27 @@ def reverse_geocode(points, provider=None, **kwargs):</span>
<span class="w"> </span>    0  POINT (-71.05941 42.35837)       29 Court Sq, Boston, MA 02108, United States
<span class="w"> </span>    1  POINT (-77.03641 38.89766)  1600 Pennsylvania Ave NW, Washington, DC 20006...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from geopy.geocoders import get_geocoder_for_service</span>
<span class="gi">+    from geopy.exc import GeocoderTimedOut, GeocoderServiceError</span>
<span class="gi">+</span>
<span class="gi">+    if provider is None:</span>
<span class="gi">+        provider = &#39;photon&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(provider, str):</span>
<span class="gi">+        provider = get_geocoder_for_service(provider)(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    results = {}</span>
<span class="gi">+    for i, point in enumerate(points):</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = provider.reverse((point.y, point.x))</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                results[i] = (result.address, (point.y, point.x))</span>
<span class="gi">+        except (GeocoderTimedOut, GeocoderServiceError):</span>
<span class="gi">+            results[i] = (None, (point.y, point.x))</span>
<span class="gi">+        </span>
<span class="gi">+        time.sleep(_get_throttle_time(provider.__class__.__name__.lower()))</span>
<span class="gi">+</span>
<span class="gi">+    return _prepare_geocode_result(results)</span>


<span class="w"> </span>def _prepare_geocode_result(results):
<span class="gu">@@ -107,4 +153,12 @@ def _prepare_geocode_result(results):</span>
<span class="w"> </span>    (address, (lat, lon))

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    df = pd.DataFrame(</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;address&quot;: [r[0] for r in results.values()],</span>
<span class="gi">+            &quot;geometry&quot;: [Point(r[1][1], r[1][0]) if r[1][0] is not None else None</span>
<span class="gi">+                         for r in results.values()]</span>
<span class="gi">+        },</span>
<span class="gi">+        index=results.keys()</span>
<span class="gi">+    )</span>
<span class="gi">+    return geopandas.GeoDataFrame(df, crs=&quot;EPSG:4326&quot;)</span>
<span class="gh">diff --git a/geopandas/tools/hilbert_curve.py b/geopandas/tools/hilbert_curve.py</span>
<span class="gh">index 7315816..420322b 100644</span>
<span class="gd">--- a/geopandas/tools/hilbert_curve.py</span>
<span class="gi">+++ b/geopandas/tools/hilbert_curve.py</span>
<span class="gu">@@ -23,7 +23,18 @@ def _hilbert_distance(geoms, total_bounds=None, level=16):</span>
<span class="w"> </span>        Array containing distances along the Hilbert curve

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if total_bounds is None:</span>
<span class="gi">+        total_bounds = geoms.total_bounds</span>
<span class="gi">+</span>
<span class="gi">+    bounds = geoms.bounds</span>
<span class="gi">+    discrete_coords = _continuous_to_discrete_coords(bounds, level, total_bounds)</span>
<span class="gi">+    </span>
<span class="gi">+    # Calculate Hilbert distances using the discrete coordinates</span>
<span class="gi">+    distances = np.zeros(len(geoms), dtype=np.uint64)</span>
<span class="gi">+    for i, (x, y) in enumerate(discrete_coords):</span>
<span class="gi">+        distances[i] = _xy2d(level, x, y)</span>
<span class="gi">+    </span>
<span class="gi">+    return distances</span>


<span class="w"> </span>def _continuous_to_discrete_coords(bounds, level, total_bounds):
<span class="gu">@@ -46,7 +57,17 @@ def _continuous_to_discrete_coords(bounds, level, total_bounds):</span>
<span class="w"> </span>    Two-dimensional array Array of hilbert distances for each geom

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    minx, miny, maxx, maxy = total_bounds</span>
<span class="gi">+    </span>
<span class="gi">+    # Calculate midpoints</span>
<span class="gi">+    mid_x = (bounds[:, 0] + bounds[:, 2]) / 2</span>
<span class="gi">+    mid_y = (bounds[:, 1] + bounds[:, 3]) / 2</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert to discrete coordinates</span>
<span class="gi">+    x_discrete = _continuous_to_discrete(mid_x, (minx, maxx), 2**level)</span>
<span class="gi">+    y_discrete = _continuous_to_discrete(mid_y, (miny, maxy), 2**level)</span>
<span class="gi">+    </span>
<span class="gi">+    return np.column_stack((x_discrete, y_discrete))</span>


<span class="w"> </span>def _continuous_to_discrete(vals, val_range, n):
<span class="gu">@@ -67,7 +88,21 @@ def _continuous_to_discrete(vals, val_range, n):</span>
<span class="w"> </span>    One-dimensional array of discrete ints

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    min_val, max_val = val_range</span>
<span class="gi">+    scaled = (vals - min_val) / (max_val - min_val)</span>
<span class="gi">+    return np.clip((scaled * (n - 1)).astype(int), 0, n - 1)</span>


<span class="w"> </span>MAX_LEVEL = 16
<span class="gi">+</span>
<span class="gi">+def _xy2d(n, x, y):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Convert (x,y) to d</span>
<span class="gi">+    n: int</span>
<span class="gi">+        Number of bits for x and y</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    d = 0</span>
<span class="gi">+    for s in range(n):</span>
<span class="gi">+        d += int(((x &amp; (1 &lt;&lt; s)) != 0) &lt;&lt; (2*s))</span>
<span class="gi">+        d += int(((y &amp; (1 &lt;&lt; s)) != 0) &lt;&lt; (2*s + 1))</span>
<span class="gi">+    return d</span>
<span class="gh">diff --git a/geopandas/tools/overlay.py b/geopandas/tools/overlay.py</span>
<span class="gh">index efb6afb..0b021ea 100644</span>
<span class="gd">--- a/geopandas/tools/overlay.py</span>
<span class="gi">+++ b/geopandas/tools/overlay.py</span>
<span class="gu">@@ -12,39 +12,81 @@ def _ensure_geometry_column(df):</span>
<span class="w"> </span>    Helper function to ensure the geometry column is called &#39;geometry&#39;.
<span class="w"> </span>    If another column with that name exists, it will be dropped.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;geometry&#39; not in df.columns:</span>
<span class="gi">+        df.set_geometry(df.geometry.name, inplace=True)</span>
<span class="gi">+    elif not df.geometry.name == &#39;geometry&#39;:</span>
<span class="gi">+        df = df.rename(columns={df.geometry.name: &#39;geometry&#39;})</span>
<span class="gi">+        df.set_geometry(&#39;geometry&#39;, inplace=True)</span>
<span class="gi">+    return df</span>


<span class="w"> </span>def _overlay_intersection(df1, df2):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Overlay Intersection operation used in overlay function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    df1 = _ensure_geometry_column(df1)</span>
<span class="gi">+    df2 = _ensure_geometry_column(df2)</span>
<span class="gi">+    </span>
<span class="gi">+    intersection = df1.geometry.intersection(df2.geometry)</span>
<span class="gi">+    intersection = GeoDataFrame(geometry=intersection)</span>
<span class="gi">+    </span>
<span class="gi">+    df1 = df1.drop(columns=&#39;geometry&#39;)</span>
<span class="gi">+    df2 = df2.drop(columns=&#39;geometry&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return intersection.join(df1).join(df2, rsuffix=&#39;_2&#39;)</span>


<span class="w"> </span>def _overlay_difference(df1, df2):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Overlay Difference operation used in overlay function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    df1 = _ensure_geometry_column(df1)</span>
<span class="gi">+    df2 = _ensure_geometry_column(df2)</span>
<span class="gi">+    </span>
<span class="gi">+    difference = df1.geometry.difference(df2.geometry)</span>
<span class="gi">+    difference = GeoDataFrame(geometry=difference)</span>
<span class="gi">+    </span>
<span class="gi">+    df1 = df1.drop(columns=&#39;geometry&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return difference.join(df1)</span>


<span class="w"> </span>def _overlay_symmetric_diff(df1, df2):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Overlay Symmetric Difference operation used in overlay function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    df1 = _ensure_geometry_column(df1)</span>
<span class="gi">+    df2 = _ensure_geometry_column(df2)</span>
<span class="gi">+    </span>
<span class="gi">+    symmetric_difference = df1.geometry.symmetric_difference(df2.geometry)</span>
<span class="gi">+    symmetric_difference = GeoDataFrame(geometry=symmetric_difference)</span>
<span class="gi">+    </span>
<span class="gi">+    df1 = df1.drop(columns=&#39;geometry&#39;)</span>
<span class="gi">+    df2 = df2.drop(columns=&#39;geometry&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    left = symmetric_difference.join(df1)</span>
<span class="gi">+    right = symmetric_difference.join(df2, rsuffix=&#39;_2&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return pd.concat([left, right])</span>


<span class="w"> </span>def _overlay_union(df1, df2):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Overlay Union operation used in overlay function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def overlay(df1, df2, how=&#39;intersection&#39;, keep_geom_type=None, make_valid=True</span>
<span class="gd">-    ):</span>
<span class="gi">+    df1 = _ensure_geometry_column(df1)</span>
<span class="gi">+    df2 = _ensure_geometry_column(df2)</span>
<span class="gi">+    </span>
<span class="gi">+    union = df1.geometry.union(df2.geometry)</span>
<span class="gi">+    union = GeoDataFrame(geometry=union)</span>
<span class="gi">+    </span>
<span class="gi">+    df1 = df1.drop(columns=&#39;geometry&#39;)</span>
<span class="gi">+    df2 = df2.drop(columns=&#39;geometry&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return union.join(df1).join(df2, rsuffix=&#39;_2&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def overlay(df1, df2, how=&#39;intersection&#39;, keep_geom_type=None, make_valid=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Perform spatial overlay between two GeoDataFrames.

<span class="w"> </span>    Currently only supports data GeoDataFrames with uniform geometry types,
<span class="gu">@@ -132,4 +174,35 @@ def overlay(df1, df2, how=&#39;intersection&#39;, keep_geom_type=None, make_valid=True</span>
<span class="w"> </span>    Every operation in GeoPandas is planar, i.e. the potential third
<span class="w"> </span>    dimension is not taken into account.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if make_valid:</span>
<span class="gi">+        df1.geometry = df1.geometry.make_valid()</span>
<span class="gi">+        df2.geometry = df2.geometry.make_valid()</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not df1.geometry.is_valid.all() or not df2.geometry.is_valid.all():</span>
<span class="gi">+            raise ValueError(&quot;Invalid geometries found. Use make_valid=True to correct them.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    df1 = _ensure_geometry_column(df1)</span>
<span class="gi">+    df2 = _ensure_geometry_column(df2)</span>
<span class="gi">+</span>
<span class="gi">+    if how == &#39;intersection&#39;:</span>
<span class="gi">+        result = _overlay_intersection(df1, df2)</span>
<span class="gi">+    elif how == &#39;union&#39;:</span>
<span class="gi">+        result = _overlay_union(df1, df2)</span>
<span class="gi">+    elif how == &#39;identity&#39;:</span>
<span class="gi">+        result = _overlay_union(df1, df2)</span>
<span class="gi">+        result = result[result.geometry.intersects(df1.geometry.unary_union)]</span>
<span class="gi">+    elif how == &#39;symmetric_difference&#39;:</span>
<span class="gi">+        result = _overlay_symmetric_diff(df1, df2)</span>
<span class="gi">+    elif how == &#39;difference&#39;:</span>
<span class="gi">+        result = _overlay_difference(df1, df2)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Unknown overlay operation: {0}&quot;.format(how))</span>
<span class="gi">+</span>
<span class="gi">+    if keep_geom_type is None:</span>
<span class="gi">+        keep_geom_type = True</span>
<span class="gi">+        warnings.warn(&quot;Default behavior of keep_geom_type will change to False in a future version.&quot;, FutureWarning)</span>
<span class="gi">+</span>
<span class="gi">+    if keep_geom_type:</span>
<span class="gi">+        result = result[result.geometry.geom_type == df1.geometry.geom_type[0]]</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/geopandas/tools/sjoin.py b/geopandas/tools/sjoin.py</span>
<span class="gh">index 04fc98c..9d09a1b 100644</span>
<span class="gd">--- a/geopandas/tools/sjoin.py</span>
<span class="gi">+++ b/geopandas/tools/sjoin.py</span>
<span class="gu">@@ -117,7 +117,20 @@ def _basic_checks(left_df, right_df, how, lsuffix, rsuffix, on_attribute=None):</span>
<span class="w"> </span>    on_attribute : list, default None
<span class="w"> </span>        list of column names to merge on along with geometry
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if how not in [&#39;left&#39;, &#39;right&#39;, &#39;inner&#39;]:</span>
<span class="gi">+        raise ValueError(&quot;`how` must be one of &#39;left&#39;, &#39;right&#39;, or &#39;inner&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if f&#39;index_{lsuffix}&#39; in left_df.columns:</span>
<span class="gi">+        raise ValueError(f&quot;&#39;index_{lsuffix}&#39; column already exists in left GeoDataFrame&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if f&#39;index_{rsuffix}&#39; in right_df.columns:</span>
<span class="gi">+        raise ValueError(f&quot;&#39;index_{rsuffix}&#39; column already exists in right GeoDataFrame&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if on_attribute:</span>
<span class="gi">+        if not isinstance(on_attribute, (list, tuple)):</span>
<span class="gi">+            raise ValueError(&quot;`on_attribute` must be a list or tuple&quot;)</span>
<span class="gi">+        if not set(on_attribute).issubset(left_df.columns) or not set(on_attribute).issubset(right_df.columns):</span>
<span class="gi">+            raise ValueError(&quot;All `on_attribute` columns must exist in both GeoDataFrames&quot;)</span>


<span class="w"> </span>def _geom_predicate_query(left_df, right_df, predicate, distance,
<span class="gu">@@ -140,7 +153,22 @@ def _geom_predicate_query(left_df, right_df, predicate, distance,</span>
<span class="w"> </span>        DataFrame with matching indices in
<span class="w"> </span>        columns named `_key_left` and `_key_right`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    left_sindex = left_df.sindex</span>
<span class="gi">+    right_geom = right_df.geometry</span>
<span class="gi">+</span>
<span class="gi">+    if predicate == &#39;dwithin&#39;:</span>
<span class="gi">+        if distance is None:</span>
<span class="gi">+            raise ValueError(&quot;Distance must be provided for &#39;dwithin&#39; predicate&quot;)</span>
<span class="gi">+        matches = left_sindex.query(right_geom, predicate=predicate, distance=distance)</span>
<span class="gi">+    else:</span>
<span class="gi">+        matches = left_sindex.query(right_geom, predicate=predicate)</span>
<span class="gi">+</span>
<span class="gi">+    left_idx, right_idx = matches</span>
<span class="gi">+</span>
<span class="gi">+    if on_attribute:</span>
<span class="gi">+        left_idx, right_idx = _filter_shared_attribute(left_df, right_df, left_idx, right_idx, on_attribute)</span>
<span class="gi">+</span>
<span class="gi">+    return pd.DataFrame({&#39;_key_left&#39;: left_idx, &#39;_key_right&#39;: right_idx})</span>


<span class="w"> </span>def _reset_index_with_suffix(df, suffix, other):
<span class="gu">@@ -148,7 +176,18 @@ def _reset_index_with_suffix(df, suffix, other):</span>
<span class="w"> </span>    Equivalent of df.reset_index(), but with adding &#39;suffix&#39; to auto-generated
<span class="w"> </span>    column names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    df = df.reset_index()</span>
<span class="gi">+    if df.index.name:</span>
<span class="gi">+        df.index.name = f&quot;{df.index.name}_{suffix}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        df.index.name = f&quot;index_{suffix}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Rename columns that conflict with the other DataFrame</span>
<span class="gi">+    for col in df.columns:</span>
<span class="gi">+        if col in other.columns:</span>
<span class="gi">+            df = df.rename(columns={col: f&quot;{col}_{suffix}&quot;})</span>
<span class="gi">+</span>
<span class="gi">+    return df</span>


<span class="w"> </span>def _process_column_names_with_suffix(left: pd.Index, right: pd.Index,
<span class="gu">@@ -159,7 +198,30 @@ def _process_column_names_with_suffix(left: pd.Index, right: pd.Index,</span>
<span class="w"> </span>    This is based on pandas&#39; merge logic at https://github.com/pandas-dev/pandas/blob/
<span class="w"> </span>    a0779adb183345a8eb4be58b3ad00c223da58768/pandas/core/reshape/merge.py#L2300-L2370
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    to_rename = {</span>
<span class="gi">+        &#39;left&#39;: {},</span>
<span class="gi">+        &#39;right&#39;: {}</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    left_set = set(left) - {left_df._geometry_column_name}</span>
<span class="gi">+    right_set = set(right) - {right_df._geometry_column_name}</span>
<span class="gi">+    overlap = left_set.intersection(right_set)</span>
<span class="gi">+</span>
<span class="gi">+    if not overlap:</span>
<span class="gi">+        return to_rename</span>
<span class="gi">+</span>
<span class="gi">+    for name in overlap:</span>
<span class="gi">+        left_suffix, right_suffix = suffixes</span>
<span class="gi">+</span>
<span class="gi">+        if name in left_set:</span>
<span class="gi">+            left_name = f&quot;{name}{left_suffix}&quot;</span>
<span class="gi">+            to_rename[&#39;left&#39;][name] = left_name</span>
<span class="gi">+</span>
<span class="gi">+        if name in right_set:</span>
<span class="gi">+            right_name = f&quot;{name}{right_suffix}&quot;</span>
<span class="gi">+            to_rename[&#39;right&#39;][name] = right_name</span>
<span class="gi">+</span>
<span class="gi">+    return to_rename</span>


<span class="w"> </span>def _restore_index(joined, index_names, index_names_original):
<span class="gu">@@ -167,7 +229,11 @@ def _restore_index(joined, index_names, index_names_original):</span>
<span class="w"> </span>    Set back the the original index columns, and restoring their name as `None`
<span class="w"> </span>    if they didn&#39;t have a name originally.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    joined = joined.set_index(index_names)</span>
<span class="gi">+    for i, name in enumerate(index_names_original):</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            joined.index.names[i] = None</span>
<span class="gi">+    return joined</span>


<span class="w"> </span>def _adjust_indexers(indices, distances, original_length, how, predicate):
<span class="gu">@@ -176,7 +242,24 @@ def _adjust_indexers(indices, distances, original_length, how, predicate):</span>
<span class="w"> </span>    For a left or right join, we need to adjust them to include the rows
<span class="w"> </span>    that would not be present in an inner join.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    left_index, right_index = indices</span>
<span class="gi">+    if how == &#39;inner&#39;:</span>
<span class="gi">+        return left_index, right_index, distances</span>
<span class="gi">+</span>
<span class="gi">+    if how == &#39;left&#39;:</span>
<span class="gi">+        missing = np.setdiff1d(np.arange(original_length), left_index)</span>
<span class="gi">+        left_index = np.concatenate([left_index, missing])</span>
<span class="gi">+        right_index = np.concatenate([right_index, np.full(len(missing), -1)])</span>
<span class="gi">+        if distances is not None:</span>
<span class="gi">+            distances = np.concatenate([distances, np.full(len(missing), np.inf)])</span>
<span class="gi">+    elif how == &#39;right&#39;:</span>
<span class="gi">+        missing = np.setdiff1d(np.arange(original_length), right_index)</span>
<span class="gi">+        right_index = np.concatenate([right_index, missing])</span>
<span class="gi">+        left_index = np.concatenate([left_index, np.full(len(missing), -1)])</span>
<span class="gi">+        if distances is not None:</span>
<span class="gi">+            distances = np.concatenate([distances, np.full(len(missing), np.inf)])</span>
<span class="gi">+</span>
<span class="gi">+    return left_index, right_index, distances</span>


<span class="w"> </span>def _frame_join(left_df, right_df, indices, distances, how, lsuffix,
<span class="gu">@@ -208,7 +291,42 @@ def _frame_join(left_df, right_df, indices, distances, how, lsuffix,</span>
<span class="w"> </span>    GeoDataFrame
<span class="w"> </span>        Joined GeoDataFrame.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    left_index, right_index = indices</span>
<span class="gi">+</span>
<span class="gi">+    # Prepare DataFrames for join</span>
<span class="gi">+    left = left_df.iloc[left_index].copy()</span>
<span class="gi">+    right = right_df.iloc[right_index].copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Add distance column if provided</span>
<span class="gi">+    if distances is not None:</span>
<span class="gi">+        right[&#39;_distance&#39;] = distances</span>
<span class="gi">+</span>
<span class="gi">+    # Rename conflicting columns</span>
<span class="gi">+    rename_dict = _process_column_names_with_suffix(left.columns, right.columns, (lsuffix, rsuffix), left_df, right_df)</span>
<span class="gi">+    left = left.rename(columns=rename_dict[&#39;left&#39;])</span>
<span class="gi">+    right = right.rename(columns=rename_dict[&#39;right&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    # Perform join</span>
<span class="gi">+    if how == &#39;left&#39;:</span>
<span class="gi">+        joined = left.join(right, how=&#39;left&#39;, lsuffix=lsuffix, rsuffix=rsuffix)</span>
<span class="gi">+    elif how == &#39;right&#39;:</span>
<span class="gi">+        joined = right.join(left, how=&#39;left&#39;, lsuffix=rsuffix, rsuffix=lsuffix)</span>
<span class="gi">+    else:  # inner</span>
<span class="gi">+        joined = left.join(right, how=&#39;inner&#39;, lsuffix=lsuffix, rsuffix=rsuffix)</span>
<span class="gi">+</span>
<span class="gi">+    # Restore original index</span>
<span class="gi">+    if how in (&#39;left&#39;, &#39;inner&#39;):</span>
<span class="gi">+        joined.index = left_df.index[left_index]</span>
<span class="gi">+    else:  # right</span>
<span class="gi">+        joined.index = right_df.index[right_index]</span>
<span class="gi">+</span>
<span class="gi">+    # Set geometry column</span>
<span class="gi">+    if how in (&#39;left&#39;, &#39;inner&#39;):</span>
<span class="gi">+        joined.set_geometry(left_df._geometry_column_name, inplace=True)</span>
<span class="gi">+    else:  # right</span>
<span class="gi">+        joined.set_geometry(right_df._geometry_column_name, inplace=True)</span>
<span class="gi">+</span>
<span class="gi">+    return joined</span>


<span class="w"> </span>def _filter_shared_attribute(left_df, right_df, l_idx, r_idx, attribute):
<span class="gh">diff --git a/geopandas/tools/tests/test_clip.py b/geopandas/tools/tests/test_clip.py</span>
<span class="gh">index 6ccf6e2..11b9f20 100644</span>
<span class="gd">--- a/geopandas/tools/tests/test_clip.py</span>
<span class="gi">+++ b/geopandas/tools/tests/test_clip.py</span>
<span class="gu">@@ -20,51 +20,67 @@ mask_variants_large_rectangle = [&#39;larger_single_rectangle_gdf&#39;,</span>
<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def point_gdf():
<span class="w"> </span>    &quot;&quot;&quot;Create a point GeoDataFrame.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [Point(0, 0), Point(1, 1), Point(2, 2)]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def point_gdf2():
<span class="w"> </span>    &quot;&quot;&quot;Create a point GeoDataFrame.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [Point(0, 0), Point(1, 1), Point(2, 2)],</span>
<span class="gi">+         &#39;value&#39;: [1, 2, 3]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def pointsoutside_nooverlap_gdf():
<span class="w"> </span>    &quot;&quot;&quot;Create a point GeoDataFrame. Its points are all outside the single
<span class="w"> </span>    rectangle, and its bounds are outside the single rectangle&#39;s.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [Point(-1, -1), Point(-2, -2), Point(-3, -3)]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def pointsoutside_overlap_gdf():
<span class="w"> </span>    &quot;&quot;&quot;Create a point GeoDataFrame. Its points are all outside the single
<span class="w"> </span>    rectangle, and its bounds are overlapping the single rectangle&#39;s.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [Point(-1, -1), Point(3, 3), Point(5, 5)]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def single_rectangle_gdf():
<span class="w"> </span>    &quot;&quot;&quot;Create a single rectangle for clipping.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [box(0, 0, 2, 2)]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def single_rectangle_gdf_tuple_bounds(single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Bounds of the created single rectangle&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return tuple(single_rectangle_gdf.total_bounds)</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def single_rectangle_gdf_list_bounds(single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Bounds of the created single rectangle&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(single_rectangle_gdf.total_bounds)</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def single_rectangle_gdf_array_bounds(single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Bounds of the created single rectangle&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return single_rectangle_gdf.total_bounds</span>


<span class="w"> </span>@pytest.fixture
<span class="gu">@@ -74,184 +90,266 @@ def larger_single_rectangle_gdf():</span>
<span class="w"> </span>    are returned when you clip polygons. This fixture is larger which
<span class="w"> </span>    eliminates the slivers in the clip return.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [box(-1, -1, 3, 3)]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def larger_single_rectangle_gdf_bounds(larger_single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Bounds of the created single rectangle&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return larger_single_rectangle_gdf.total_bounds</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def buffered_locations(point_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Buffer points to create a multi-polygon.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(geometry=point_gdf.geometry.buffer(1), crs=point_gdf.crs)</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def donut_geometry(buffered_locations, single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Make a geometry with a hole in the middle (a donut).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return buffered_locations.geometry.unary_union.difference(single_rectangle_gdf.geometry.unary_union)</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def two_line_gdf():
<span class="w"> </span>    &quot;&quot;&quot;Create Line Objects For Testing&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [LineString([(0, 0), (2, 2)]), LineString([(2, 0), (0, 2)])]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def multi_poly_gdf(donut_geometry):
<span class="w"> </span>    &quot;&quot;&quot;Create a multi-polygon GeoDataFrame.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [donut_geometry]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def multi_line(two_line_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Create a multi-line GeoDataFrame.
<span class="w"> </span>    This GDF has one multiline and one regular line.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multi = two_line_gdf.geometry.unary_union</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [multi, two_line_gdf.geometry.iloc[0]]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def multi_point(point_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Create a multi-point GeoDataFrame.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multi = MultiPoint(point_gdf.geometry.tolist())</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [multi]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def mixed_gdf():
<span class="w"> </span>    &quot;&quot;&quot;Create a Mixed Polygon and LineString For Testing&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [Polygon([(0, 0), (1, 1), (0, 1)]), LineString([(0, 0), (1, 1)])]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def geomcol_gdf():
<span class="w"> </span>    &quot;&quot;&quot;Create a Mixed Polygon and LineString For Testing&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [GeometryCollection([Polygon([(0, 0), (1, 1), (0, 1)]), LineString([(0, 0), (1, 1)])])]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pytest.fixture
<span class="w"> </span>def sliver_line():
<span class="w"> </span>    &quot;&quot;&quot;Create a line that will create a point when clipped.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return GeoDataFrame(</span>
<span class="gi">+        {&#39;geometry&#39;: [LineString([(0, 0), (2, 2)])]},</span>
<span class="gi">+        crs=&quot;EPSG:4326&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>def test_not_gdf(single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Non-GeoDataFrame inputs raise attribute errors.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with pytest.raises(AttributeError):</span>
<span class="gi">+        clip(np.array([1, 2, 3]), single_rectangle_gdf)</span>


<span class="w"> </span>def test_non_overlapping_geoms():
<span class="w"> </span>    &quot;&quot;&quot;Test that a bounding box returns empty if the extents don&#39;t overlap&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    points = GeoDataFrame({&#39;geometry&#39;: [Point(0, 0), Point(1, 1)]}, crs=&quot;EPSG:4326&quot;)</span>
<span class="gi">+    clip_box = box(10, 10, 20, 20)</span>
<span class="gi">+    clipped = clip(points, clip_box)</span>
<span class="gi">+    assert clipped.empty</span>


<span class="w"> </span>@pytest.mark.parametrize(&#39;mask_fixture_name&#39;, mask_variants_single_rectangle)
<span class="w"> </span>class TestClipWithSingleRectangleGdf:

<span class="gd">-    def test_returns_gdf(self, point_gdf, mask):</span>
<span class="gi">+    def test_returns_gdf(self, point_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test that function returns a GeoDataFrame (or GDF-like) object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(point_gdf, mask)</span>
<span class="gi">+        assert isinstance(result, GeoDataFrame)</span>

<span class="gd">-    def test_returns_series(self, point_gdf, mask):</span>
<span class="gi">+    def test_returns_series(self, point_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test that function returns a GeoSeries if GeoSeries is passed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(point_gdf.geometry, mask)</span>
<span class="gi">+        assert isinstance(result, GeoSeries)</span>

<span class="gd">-    def test_clip_points(self, point_gdf, mask):</span>
<span class="gi">+    def test_clip_points(self, point_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clipping a points GDF with a generic polygon geometry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(point_gdf, mask)</span>
<span class="gi">+        assert len(result) == 3</span>
<span class="gi">+        assert all(result.geometry.geom_type == &#39;Point&#39;)</span>

<span class="gd">-    def test_clip_points_geom_col_rename(self, point_gdf, mask):</span>
<span class="gi">+    def test_clip_points_geom_col_rename(self, point_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clipping a points GDF with a generic polygon geometry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        gdf_geom_custom = point_gdf.rename(columns={&#39;geometry&#39;: &#39;geom&#39;}).set_geometry(&#39;geom&#39;)</span>
<span class="gi">+        result = clip(gdf_geom_custom, mask)</span>
<span class="gi">+        assert result.geometry.name == &#39;geom&#39;</span>

<span class="gd">-    def test_clip_poly(self, buffered_locations, mask):</span>
<span class="gi">+    def test_clip_poly(self, buffered_locations, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clipping a polygon GDF with a generic polygon geometry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(buffered_locations, mask)</span>
<span class="gi">+        assert all(result.geometry.geom_type == &#39;Polygon&#39;)</span>

<span class="gd">-    def test_clip_poly_geom_col_rename(self, buffered_locations, mask):</span>
<span class="gi">+    def test_clip_poly_geom_col_rename(self, buffered_locations, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clipping a polygon GDF with a generic polygon geometry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        gdf_geom_custom = buffered_locations.rename(columns={&#39;geometry&#39;: &#39;geom&#39;}).set_geometry(&#39;geom&#39;)</span>
<span class="gi">+        result = clip(gdf_geom_custom, mask)</span>
<span class="gi">+        assert result.geometry.name == &#39;geom&#39;</span>

<span class="gd">-    def test_clip_poly_series(self, buffered_locations, mask):</span>
<span class="gi">+    def test_clip_poly_series(self, buffered_locations, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clipping a polygon GDF with a generic polygon geometry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(buffered_locations.geometry, mask)</span>
<span class="gi">+        assert isinstance(result, GeoSeries)</span>
<span class="gi">+        assert all(result.geom_type == &#39;Polygon&#39;)</span>

<span class="gd">-    def test_clip_multipoly_keep_geom_type(self, multi_poly_gdf, mask):</span>
<span class="gi">+    def test_clip_multipoly_keep_geom_type(self, multi_poly_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test a multi poly object where the return includes a sliver.
<span class="w"> </span>        Also the bounds of the object should == the bounds of the clip object
<span class="w"> </span>        if they fully overlap (as they do in these fixtures).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(multi_poly_gdf, mask)</span>
<span class="gi">+        assert all(result.geometry.geom_type == &#39;MultiPolygon&#39;)</span>
<span class="gi">+        assert_index_equal(result.bounds, mask.bounds)</span>

<span class="gd">-    def test_clip_multiline(self, multi_line, mask):</span>
<span class="gi">+    def test_clip_multiline(self, multi_line, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test that clipping a multiline feature with a poly returns expected
<span class="w"> </span>        output.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(multi_line, mask)</span>
<span class="gi">+        assert all(result.geometry.geom_type.isin([&#39;MultiLineString&#39;, &#39;LineString&#39;]))</span>

<span class="gd">-    def test_clip_multipoint(self, multi_point, mask):</span>
<span class="gi">+    def test_clip_multipoint(self, multi_point, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Clipping a multipoint feature with a polygon works as expected.
<span class="w"> </span>        should return a geodataframe with a single multi point feature&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(multi_point, mask)</span>
<span class="gi">+        assert all(result.geometry.geom_type == &#39;MultiPoint&#39;)</span>

<span class="gd">-    def test_clip_lines(self, two_line_gdf, mask):</span>
<span class="gi">+    def test_clip_lines(self, two_line_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test what happens when you give the clip_extent a line GDF.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(two_line_gdf, mask)</span>
<span class="gi">+        assert all(result.geometry.geom_type == &#39;LineString&#39;)</span>

<span class="gd">-    def test_mixed_geom(self, mixed_gdf, mask):</span>
<span class="gi">+    def test_mixed_geom(self, mixed_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clipping a mixed GeoDataFrame&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(mixed_gdf, mask)</span>
<span class="gi">+        assert set(result.geometry.geom_type) == {&#39;Polygon&#39;, &#39;LineString&#39;}</span>

<span class="gd">-    def test_mixed_series(self, mixed_gdf, mask):</span>
<span class="gi">+    def test_mixed_series(self, mixed_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clipping a mixed GeoSeries&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(mixed_gdf.geometry, mask)</span>
<span class="gi">+        assert isinstance(result, GeoSeries)</span>
<span class="gi">+        assert set(result.geom_type) == {&#39;Polygon&#39;, &#39;LineString&#39;}</span>

<span class="gd">-    def test_clip_with_line_extra_geom(self, sliver_line, mask):</span>
<span class="gi">+    def test_clip_with_line_extra_geom(self, sliver_line, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;When the output of a clipped line returns a geom collection,
<span class="w"> </span>        and keep_geom_type is True, no geometry collections should be returned.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(sliver_line, mask, keep_geom_type=True)</span>
<span class="gi">+        assert all(result.geometry.geom_type == &#39;LineString&#39;)</span>

<span class="gd">-    def test_clip_no_box_overlap(self, pointsoutside_nooverlap_gdf, mask):</span>
<span class="gi">+    def test_clip_no_box_overlap(self, pointsoutside_nooverlap_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clip when intersection is empty and boxes do not overlap.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(pointsoutside_nooverlap_gdf, mask)</span>
<span class="gi">+        assert result.empty</span>

<span class="gd">-    def test_clip_box_overlap(self, pointsoutside_overlap_gdf, mask):</span>
<span class="gi">+    def test_clip_box_overlap(self, pointsoutside_overlap_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test clip when intersection is empty and boxes do overlap.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        result = clip(pointsoutside_overlap_gdf, mask)</span>
<span class="gi">+        assert result.empty</span>

<span class="gd">-    def test_warning_extra_geoms_mixed(self, mixed_gdf, mask):</span>
<span class="gi">+    def test_warning_extra_geoms_mixed(self, mixed_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test the correct warnings are raised if keep_geom_type is
<span class="w"> </span>        called on a mixed GDF&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        with pytest.warns(UserWarning, match=&quot;Geometry types of input geodataframe&quot;):</span>
<span class="gi">+            clip(mixed_gdf, mask, keep_geom_type=True)</span>

<span class="gd">-    def test_warning_geomcoll(self, geomcol_gdf, mask):</span>
<span class="gi">+    def test_warning_geomcoll(self, geomcol_gdf, mask, request):</span>
<span class="w"> </span>        &quot;&quot;&quot;Test the correct warnings are raised if keep_geom_type is
<span class="w"> </span>        called on a GDF with GeometryCollection&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+        with pytest.warns(UserWarning, match=&quot;Geometry types of input geodataframe&quot;):</span>
<span class="gi">+            clip(geomcol_gdf, mask, keep_geom_type=True)</span>


<span class="w"> </span>def test_clip_line_keep_slivers(sliver_line, single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Test the correct output if a point is returned
<span class="w"> </span>    from a line only geometry type.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = clip(sliver_line, single_rectangle_gdf, keep_geom_type=False)</span>
<span class="gi">+    assert set(result.geometry.geom_type) == {&#39;LineString&#39;, &#39;Point&#39;}</span>


<span class="w"> </span>def test_clip_multipoly_keep_slivers(multi_poly_gdf, single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Test a multi poly object where the return includes a sliver.
<span class="w"> </span>    Also the bounds of the object should == the bounds of the clip object
<span class="w"> </span>    if they fully overlap (as they do in these fixtures).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = clip(multi_poly_gdf, single_rectangle_gdf, keep_geom_type=False)</span>
<span class="gi">+    assert set(result.geometry.geom_type) == {&#39;Polygon&#39;, &#39;MultiPolygon&#39;}</span>
<span class="gi">+    assert_index_equal(result.bounds, single_rectangle_gdf.bounds)</span>


<span class="w"> </span>def test_clip_with_polygon(single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Test clip when using a shapely object&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    poly = Polygon([(0, 0), (1, 1), (1, 0)])</span>
<span class="gi">+    gdf = GeoDataFrame({&#39;geometry&#39;: [poly]}, crs=&quot;EPSG:4326&quot;)</span>
<span class="gi">+    result = clip(gdf, single_rectangle_gdf.geometry.iloc[0])</span>
<span class="gi">+    assert isinstance(result, GeoDataFrame)</span>
<span class="gi">+    assert len(result) == 1</span>


<span class="w"> </span>def test_clip_with_multipolygon(buffered_locations, single_rectangle_gdf):
<span class="w"> </span>    &quot;&quot;&quot;Test clipping a polygon with a multipolygon.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multi = MultiPolygon([single_rectangle_gdf.geometry.iloc[0], Polygon([(2, 2), (3, 3), (3, 2)])])</span>
<span class="gi">+    result = clip(buffered_locations, multi)</span>
<span class="gi">+    assert isinstance(result, GeoDataFrame)</span>
<span class="gi">+    assert all(result.geometry.geom_type == &#39;Polygon&#39;)</span>


<span class="w"> </span>@pytest.mark.parametrize(&#39;mask_fixture_name&#39;, mask_variants_large_rectangle)
<span class="gu">@@ -259,7 +357,9 @@ def test_clip_single_multipoly_no_extra_geoms(buffered_locations,</span>
<span class="w"> </span>    mask_fixture_name, request):
<span class="w"> </span>    &quot;&quot;&quot;When clipping a multi-polygon feature, no additional geom types
<span class="w"> </span>    should be returned.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mask = request.getfixturevalue(mask_fixture_name)</span>
<span class="gi">+    result = clip(buffered_locations, mask)</span>
<span class="gi">+    assert set(result.geometry.geom_type) == {&#39;Polygon&#39;}</span>


<span class="w"> </span>@pytest.mark.filterwarnings(&#39;ignore:All-NaN slice encountered&#39;)
<span class="gu">@@ -269,9 +369,15 @@ def test_clip_single_multipoly_no_extra_geoms(buffered_locations,</span>
<span class="w"> </span>    &#39;EPSG:3857&#39;), GeoSeries([], crs=&#39;EPSG:3857&#39;).to_frame()])
<span class="w"> </span>def test_clip_empty_mask(buffered_locations, mask):
<span class="w"> </span>    &quot;&quot;&quot;Test that clipping with empty mask returns an empty result.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = clip(buffered_locations, mask)</span>
<span class="gi">+    assert result.empty</span>


<span class="w"> </span>def test_clip_sorting(point_gdf2):
<span class="w"> </span>    &quot;&quot;&quot;Test the sorting kwarg in clip&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    box = Polygon([(0.5, 0.5), (1.5, 0.5), (1.5, 1.5), (0.5, 1.5)])</span>
<span class="gi">+    result = clip(point_gdf2, box)</span>
<span class="gi">+    assert_index_equal(result.index, point_gdf2.index[1:2])</span>
<span class="gi">+</span>
<span class="gi">+    result_unsorted = clip(point_gdf2, box, keep_geom_type=True)</span>
<span class="gi">+    assert_index_equal(result_unsorted.index, point_gdf2.index[1:2])</span>
<span class="gh">diff --git a/geopandas/tools/tests/test_sjoin.py b/geopandas/tools/tests/test_sjoin.py</span>
<span class="gh">index a4a880c..405d6d8 100644</span>
<span class="gd">--- a/geopandas/tools/tests/test_sjoin.py</span>
<span class="gi">+++ b/geopandas/tools/tests/test_sjoin.py</span>
<span class="gu">@@ -13,11 +13,50 @@ from pandas.testing import assert_frame_equal, assert_index_equal, assert_series</span>


<span class="w"> </span>class TestSpatialJoin:
<span class="gd">-    pass</span>
<span class="gi">+    def test_spatial_join(self):</span>
<span class="gi">+        # Create sample GeoDataFrames</span>
<span class="gi">+        left_gdf = GeoDataFrame({</span>
<span class="gi">+            &#39;geometry&#39;: [Point(0, 0), Point(1, 1), Point(2, 2)],</span>
<span class="gi">+            &#39;value&#39;: [1, 2, 3]</span>
<span class="gi">+        })</span>
<span class="gi">+        right_gdf = GeoDataFrame({</span>
<span class="gi">+            &#39;geometry&#39;: [Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), </span>
<span class="gi">+                         Polygon([(1, 1), (1, 2), (2, 2), (2, 1)])],</span>
<span class="gi">+            &#39;attr&#39;: [&#39;A&#39;, &#39;B&#39;]</span>
<span class="gi">+        })</span>
<span class="gi">+</span>
<span class="gi">+        # Perform spatial join</span>
<span class="gi">+        result = sjoin(left_gdf, right_gdf, how=&#39;left&#39;, predicate=&#39;intersects&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Assert the result</span>
<span class="gi">+        expected = GeoDataFrame({</span>
<span class="gi">+            &#39;geometry&#39;: [Point(0, 0), Point(1, 1), Point(2, 2)],</span>
<span class="gi">+            &#39;value&#39;: [1, 2, 3],</span>
<span class="gi">+            &#39;index_right&#39;: [0, 1, 1],</span>
<span class="gi">+            &#39;attr&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;B&#39;]</span>
<span class="gi">+        })</span>
<span class="gi">+        assert_geodataframe_equal(result, expected)</span>


<span class="w"> </span>class TestIndexNames:
<span class="gd">-    pass</span>
<span class="gi">+    def test_index_names(self):</span>
<span class="gi">+        # Create sample GeoDataFrames with named indexes</span>
<span class="gi">+        left_gdf = GeoDataFrame({</span>
<span class="gi">+            &#39;geometry&#39;: [Point(0, 0), Point(1, 1)],</span>
<span class="gi">+            &#39;value&#39;: [1, 2]</span>
<span class="gi">+        }, index=pd.Index([&#39;a&#39;, &#39;b&#39;], name=&#39;left_idx&#39;))</span>
<span class="gi">+        right_gdf = GeoDataFrame({</span>
<span class="gi">+            &#39;geometry&#39;: [Polygon([(0, 0), (0, 1), (1, 1), (1, 0)])],</span>
<span class="gi">+            &#39;attr&#39;: [&#39;A&#39;]</span>
<span class="gi">+        }, index=pd.Index([&#39;x&#39;], name=&#39;right_idx&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        # Perform spatial join</span>
<span class="gi">+        result = sjoin(left_gdf, right_gdf, how=&#39;left&#39;, predicate=&#39;intersects&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Assert the result</span>
<span class="gi">+        assert result.index.name == &#39;left_idx&#39;</span>
<span class="gi">+        assert &#39;index_right&#39; in result.columns</span>
<span class="gi">+        assert_series_equal(result[&#39;index_right&#39;], pd.Series([&#39;x&#39;, &#39;x&#39;], name=&#39;index_right&#39;, index=[&#39;a&#39;, &#39;b&#39;]))</span>


<span class="w"> </span>@pytest.mark.usefixtures(&#39;_setup_class_nybb_filename&#39;)
<span class="gu">@@ -26,8 +65,41 @@ class TestSpatialJoinNYBB:</span>
<span class="w"> </span>    @pytest.mark.parametrize(&#39;predicate&#39;, [&#39;intersects&#39;, &#39;within&#39;, &#39;contains&#39;])
<span class="w"> </span>    def test_sjoin_no_valid_geoms(self, predicate):
<span class="w"> </span>        &quot;&quot;&quot;Tests a completely empty GeoDataFrame.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        empty_df = GeoDataFrame(geometry=[])</span>
<span class="gi">+        nybb = read_file(self.nybb_filename)</span>
<span class="gi">+        </span>
<span class="gi">+        # Test empty left GeoDataFrame</span>
<span class="gi">+        result_left = sjoin(empty_df, nybb, how=&#39;left&#39;, predicate=predicate)</span>
<span class="gi">+        assert len(result_left) == 0</span>
<span class="gi">+        assert set(result_left.columns) == set(empty_df.columns).union(nybb.columns).union([&#39;index_right&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        # Test empty right GeoDataFrame</span>
<span class="gi">+        result_right = sjoin(nybb, empty_df, how=&#39;left&#39;, predicate=predicate)</span>
<span class="gi">+        assert len(result_right) == len(nybb)</span>
<span class="gi">+        assert set(result_right.columns) == set(nybb.columns).union(empty_df.columns).union([&#39;index_right&#39;])</span>
<span class="gi">+        assert result_right[&#39;index_right&#39;].isna().all()</span>


<span class="w"> </span>class TestNearest:
<span class="gd">-    pass</span>
<span class="gi">+    def test_nearest_join(self):</span>
<span class="gi">+        # Create sample GeoDataFrames</span>
<span class="gi">+        left_gdf = GeoDataFrame({</span>
<span class="gi">+            &#39;geometry&#39;: [Point(0, 0), Point(1, 1), Point(2, 2)],</span>
<span class="gi">+            &#39;value&#39;: [1, 2, 3]</span>
<span class="gi">+        })</span>
<span class="gi">+        right_gdf = GeoDataFrame({</span>
<span class="gi">+            &#39;geometry&#39;: [Point(0.1, 0.1), Point(1.1, 1.1), Point(2.1, 2.1)],</span>
<span class="gi">+            &#39;attr&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
<span class="gi">+        })</span>
<span class="gi">+</span>
<span class="gi">+        # Perform nearest join</span>
<span class="gi">+        result = sjoin_nearest(left_gdf, right_gdf, how=&#39;left&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Assert the result</span>
<span class="gi">+        expected = GeoDataFrame({</span>
<span class="gi">+            &#39;geometry&#39;: [Point(0, 0), Point(1, 1), Point(2, 2)],</span>
<span class="gi">+            &#39;value&#39;: [1, 2, 3],</span>
<span class="gi">+            &#39;index_right&#39;: [0, 1, 2],</span>
<span class="gi">+            &#39;attr&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
<span class="gi">+        })</span>
<span class="gi">+        assert_geodataframe_equal(result, expected)</span>
<span class="gh">diff --git a/geopandas/tools/tests/test_tools.py b/geopandas/tools/tests/test_tools.py</span>
<span class="gh">index a51978e..1dee985 100644</span>
<span class="gd">--- a/geopandas/tools/tests/test_tools.py</span>
<span class="gi">+++ b/geopandas/tools/tests/test_tools.py</span>
<span class="gu">@@ -1,8 +1,46 @@</span>
<span class="gd">-from shapely.geometry import LineString, MultiPoint, Point</span>
<span class="gi">+from shapely.geometry import LineString, MultiPoint, Point, Polygon</span>
<span class="w"> </span>from geopandas import GeoSeries
<span class="w"> </span>from geopandas.tools import collect
<span class="w"> </span>import pytest


<span class="w"> </span>class TestTools:
<span class="gd">-    pass</span>
<span class="gi">+    def test_collect_points(self):</span>
<span class="gi">+        points = GeoSeries([Point(0, 0), Point(1, 1), Point(2, 2)])</span>
<span class="gi">+        result = collect(points)</span>
<span class="gi">+        assert isinstance(result, MultiPoint)</span>
<span class="gi">+        assert len(result.geoms) == 3</span>
<span class="gi">+</span>
<span class="gi">+    def test_collect_lines(self):</span>
<span class="gi">+        lines = GeoSeries([LineString([(0, 0), (1, 1)]), LineString([(1, 1), (2, 2)])])</span>
<span class="gi">+        result = collect(lines)</span>
<span class="gi">+        assert isinstance(result, LineString)</span>
<span class="gi">+        assert len(result.coords) == 3</span>
<span class="gi">+</span>
<span class="gi">+    def test_collect_mixed(self):</span>
<span class="gi">+        mixed = GeoSeries([Point(0, 0), LineString([(1, 1), (2, 2)]), Polygon([(0, 0), (1, 1), (1, 0)])])</span>
<span class="gi">+        result = collect(mixed)</span>
<span class="gi">+        assert isinstance(result, MultiPoint)</span>
<span class="gi">+        assert len(result.geoms) == 3</span>
<span class="gi">+</span>
<span class="gi">+    def test_collect_single(self):</span>
<span class="gi">+        single = GeoSeries([Point(0, 0)])</span>
<span class="gi">+        result = collect(single)</span>
<span class="gi">+        assert isinstance(result, Point)</span>
<span class="gi">+</span>
<span class="gi">+    def test_collect_empty(self):</span>
<span class="gi">+        empty = GeoSeries([])</span>
<span class="gi">+        result = collect(empty)</span>
<span class="gi">+        assert result is None</span>
<span class="gi">+</span>
<span class="gi">+    def test_collect_multi(self):</span>
<span class="gi">+        points = GeoSeries([Point(0, 0), Point(1, 1), Point(2, 2)])</span>
<span class="gi">+        result = collect(points, multi=True)</span>
<span class="gi">+        assert isinstance(result, MultiPoint)</span>
<span class="gi">+        assert len(result.geoms) == 3</span>
<span class="gi">+</span>
<span class="gi">+    def test_collect_lines_multi(self):</span>
<span class="gi">+        lines = GeoSeries([LineString([(0, 0), (1, 1)]), LineString([(1, 1), (2, 2)])])</span>
<span class="gi">+        result = collect(lines, multi=True)</span>
<span class="gi">+        assert isinstance(result, MultiPoint)</span>
<span class="gi">+        assert len(result.geoms) == 4</span>
<span class="gh">diff --git a/geopandas/tools/util.py b/geopandas/tools/util.py</span>
<span class="gh">index bea1b2d..b588293 100644</span>
<span class="gd">--- a/geopandas/tools/util.py</span>
<span class="gi">+++ b/geopandas/tools/util.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>import pandas as pd
<span class="gd">-from shapely.geometry import MultiLineString, MultiPoint, MultiPolygon</span>
<span class="gi">+import numpy as np</span>
<span class="gi">+from shapely.geometry import MultiLineString, MultiPoint, MultiPolygon, GeometryCollection</span>
<span class="w"> </span>from shapely.geometry.base import BaseGeometry
<span class="gi">+from shapely.geometry.collection import MultiGeometryCollection</span>
<span class="w"> </span>_multi_type_map = {&#39;Point&#39;: MultiPoint, &#39;LineString&#39;: MultiLineString,
<span class="w"> </span>    &#39;Polygon&#39;: MultiPolygon}

<span class="gu">@@ -17,5 +19,29 @@ def collect(x, multi=False):</span>
<span class="w"> </span>        if True, force returned geometries to be Multi* even if they
<span class="w"> </span>        only have one component.

<span class="gi">+    Returns</span>
<span class="gi">+    -------</span>
<span class="gi">+    geometry : Shapely geometry</span>
<span class="gi">+        A single Shapely geometry object</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(x, BaseGeometry):</span>
<span class="gi">+        if multi and not isinstance(x, tuple(_multi_type_map.values())):</span>
<span class="gi">+            return _multi_type_map[x.geom_type]([x])</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(x, pd.Series):</span>
<span class="gi">+        x = x.values</span>
<span class="gi">+</span>
<span class="gi">+    types = list(set([geom.geom_type for geom in x]))</span>
<span class="gi">+    if len(types) &gt; 1:</span>
<span class="gi">+        return MultiGeometryCollection(list(x))</span>
<span class="gi">+</span>
<span class="gi">+    geom_type = types[0]</span>
<span class="gi">+    if geom_type in _multi_type_map:</span>
<span class="gi">+        multi_type = _multi_type_map[geom_type]</span>
<span class="gi">+        if multi or len(x) &gt; 1:</span>
<span class="gi">+            return multi_type(list(x))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return x[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return GeometryCollection(list(x))</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>