
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference flask - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-flask" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference flask
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_loggingpytest_logger" class="md-nav__link">
    <span class="md-ellipsis">
      test_logging.py::test_logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggingpytest_logger_debug" class="md-nav__link">
    <span class="md-ellipsis">
      test_logging.py::test_logger_debug
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggingpytest_wsgi_errors_stream" class="md-nav__link">
    <span class="md-ellipsis">
      test_logging.py::test_wsgi_errors_stream
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggingpytest_has_level_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_logging.py::test_has_level_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggingpytest_log_view_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_logging.py::test_log_view_exception
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-flask"><strong>Reference (Gold)</strong>: flask</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">477</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">484</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">484</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_loggingpytest_logger">test_logging.py::test_logger</h3>
<details><summary> <pre>test_logging.py::test_logger</pre></summary><pre>
app = <Flask 'flask_test'>

    def test_logger(app):
        assert app.logger.name == "flask_test"
        assert app.logger.level == logging.NOTSET
>       assert app.logger.handlers == [default_handler]
E       AssertionError: assert [] == [<StreamHandl...ue> (NOTSET)>]
E         
E         Right contains one more item: <StreamHandler <_io.FileIO name=9 mode='rb+' closefd=True> (NOTSET)>
E         Use -v to get more diff

tests/test_logging.py:39: AssertionError
</pre>
</details>
<h3 id="test_loggingpytest_logger_debug">test_logging.py::test_logger_debug</h3>
<details><summary> <pre>test_logging.py::test_logger_debug</pre></summary><pre>
app = <Flask 'flask_test'>

    def test_logger_debug(app):
        app.debug = True
        assert app.logger.level == logging.DEBUG
>       assert app.logger.handlers == [default_handler]
E       AssertionError: assert [] == [<StreamHandl...ue> (NOTSET)>]
E         
E         Right contains one more item: <StreamHandler <_io.FileIO name=9 mode='rb+' closefd=True> (NOTSET)>
E         Use -v to get more diff

tests/test_logging.py:45: AssertionError
</pre>
</details>
<h3 id="test_loggingpytest_wsgi_errors_stream">test_logging.py::test_wsgi_errors_stream</h3>
<details><summary> <pre>test_logging.py::test_wsgi_errors_stream</pre></summary><pre>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_wsgi_errors_stream(app, client):
        @app.route("/")
        def index():
            app.logger.error("test")
            return ""

        stream = StringIO()
        client.get("/", errors_stream=stream)
>       assert "ERROR in test_logging: test" in stream.getvalue()
E       AssertionError: assert 'ERROR in test_logging: test' in ''
E        +  where '' = <built-in method getvalue of _io.StringIO object at 0x7f3a6e95f340>()
E        +    where <built-in method getvalue of _io.StringIO object at 0x7f3a6e95f340> = <_io.StringIO object at 0x7f3a6e95f340>.getvalue

tests/test_logging.py:62: AssertionError
</pre>
</details>
<h3 id="test_loggingpytest_has_level_handler">test_logging.py::test_has_level_handler</h3>
<details><summary> <pre>test_logging.py::test_has_level_handler</pre></summary><pre>
def test_has_level_handler():
        logger = logging.getLogger("flask.app")
>       assert not has_level_handler(logger)
E       assert not True
E        +  where True = has_level_handler(<Logger flask.app (WARNING)>)

tests/test_logging.py:72: AssertionError
</pre>
</details>
<h3 id="test_loggingpytest_log_view_exception">test_logging.py::test_log_view_exception</h3>
<details><summary> <pre>test_logging.py::test_log_view_exception</pre></summary><pre>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_log_view_exception(app, client):
        @app.route("/")
        def index():
            raise Exception("test")

        app.testing = False
        stream = StringIO()
        rv = client.get("/", errors_stream=stream)
        assert rv.status_code == 500
        assert rv.data
        err = stream.getvalue()
>       assert "Exception on / [GET]" in err
E       AssertionError: assert 'Exception on / [GET]' in ''

tests/test_logging.py:97: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/flask/app.py b/src/flask/app.py</span>
<span class="gh">index 3e76b0ba..7622b5e8 100644</span>
<span class="gd">--- a/src/flask/app.py</span>
<span class="gi">+++ b/src/flask/app.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections.abc as cabc
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gu">@@ -9,6 +10,7 @@ from inspect import iscoroutinefunction</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from types import TracebackType
<span class="w"> </span>from urllib.parse import quote as _url_quote
<span class="gi">+</span>
<span class="w"> </span>import click
<span class="w"> </span>from werkzeug.datastructures import Headers
<span class="w"> </span>from werkzeug.datastructures import ImmutableDict
<span class="gu">@@ -22,6 +24,7 @@ from werkzeug.routing import RoutingException</span>
<span class="w"> </span>from werkzeug.routing import Rule
<span class="w"> </span>from werkzeug.serving import is_running_from_reloader
<span class="w"> </span>from werkzeug.wrappers import Response as BaseResponse
<span class="gi">+</span>
<span class="w"> </span>from . import cli
<span class="w"> </span>from . import typing as ft
<span class="w"> </span>from .ctx import AppContext
<span class="gu">@@ -49,19 +52,28 @@ from .signals import request_tearing_down</span>
<span class="w"> </span>from .templating import Environment
<span class="w"> </span>from .wrappers import Request
<span class="w"> </span>from .wrappers import Response
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from _typeshed.wsgi import StartResponse
<span class="w"> </span>    from _typeshed.wsgi import WSGIEnvironment
<span class="gi">+</span>
<span class="w"> </span>    from .testing import FlaskClient
<span class="w"> </span>    from .testing import FlaskCliRunner
<span class="gd">-T_shell_context_processor = t.TypeVar(&#39;T_shell_context_processor&#39;, bound=ft</span>
<span class="gd">-    .ShellContextProcessorCallable)</span>
<span class="gd">-T_teardown = t.TypeVar(&#39;T_teardown&#39;, bound=ft.TeardownCallable)</span>
<span class="gd">-T_template_filter = t.TypeVar(&#39;T_template_filter&#39;, bound=ft.</span>
<span class="gd">-    TemplateFilterCallable)</span>
<span class="gd">-T_template_global = t.TypeVar(&#39;T_template_global&#39;, bound=ft.</span>
<span class="gd">-    TemplateGlobalCallable)</span>
<span class="gd">-T_template_test = t.TypeVar(&#39;T_template_test&#39;, bound=ft.TemplateTestCallable)</span>
<span class="gi">+</span>
<span class="gi">+T_shell_context_processor = t.TypeVar(</span>
<span class="gi">+    &quot;T_shell_context_processor&quot;, bound=ft.ShellContextProcessorCallable</span>
<span class="gi">+)</span>
<span class="gi">+T_teardown = t.TypeVar(&quot;T_teardown&quot;, bound=ft.TeardownCallable)</span>
<span class="gi">+T_template_filter = t.TypeVar(&quot;T_template_filter&quot;, bound=ft.TemplateFilterCallable)</span>
<span class="gi">+T_template_global = t.TypeVar(&quot;T_template_global&quot;, bound=ft.TemplateGlobalCallable)</span>
<span class="gi">+T_template_test = t.TypeVar(&quot;T_template_test&quot;, bound=ft.TemplateTestCallable)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_timedelta(value: timedelta | int | None) -&gt; timedelta | None:</span>
<span class="gi">+    if value is None or isinstance(value, timedelta):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    return timedelta(seconds=value)</span>


<span class="w"> </span>class Flask(App):
<span class="gu">@@ -160,45 +172,105 @@ class Flask(App):</span>
<span class="w"> </span>        This should only be set manually when it can&#39;t be detected
<span class="w"> </span>        automatically, such as for namespace packages.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_config = ImmutableDict({&#39;DEBUG&#39;: None, &#39;TESTING&#39;: False,</span>
<span class="gd">-        &#39;PROPAGATE_EXCEPTIONS&#39;: None, &#39;SECRET_KEY&#39;: None,</span>
<span class="gd">-        &#39;PERMANENT_SESSION_LIFETIME&#39;: timedelta(days=31), &#39;USE_X_SENDFILE&#39;:</span>
<span class="gd">-        False, &#39;SERVER_NAME&#39;: None, &#39;APPLICATION_ROOT&#39;: &#39;/&#39;,</span>
<span class="gd">-        &#39;SESSION_COOKIE_NAME&#39;: &#39;session&#39;, &#39;SESSION_COOKIE_DOMAIN&#39;: None,</span>
<span class="gd">-        &#39;SESSION_COOKIE_PATH&#39;: None, &#39;SESSION_COOKIE_HTTPONLY&#39;: True,</span>
<span class="gd">-        &#39;SESSION_COOKIE_SECURE&#39;: False, &#39;SESSION_COOKIE_SAMESITE&#39;: None,</span>
<span class="gd">-        &#39;SESSION_REFRESH_EACH_REQUEST&#39;: True, &#39;MAX_CONTENT_LENGTH&#39;: None,</span>
<span class="gd">-        &#39;SEND_FILE_MAX_AGE_DEFAULT&#39;: None, &#39;TRAP_BAD_REQUEST_ERRORS&#39;: None,</span>
<span class="gd">-        &#39;TRAP_HTTP_EXCEPTIONS&#39;: False, &#39;EXPLAIN_TEMPLATE_LOADING&#39;: False,</span>
<span class="gd">-        &#39;PREFERRED_URL_SCHEME&#39;: &#39;http&#39;, &#39;TEMPLATES_AUTO_RELOAD&#39;: None,</span>
<span class="gd">-        &#39;MAX_COOKIE_SIZE&#39;: 4093})</span>
<span class="gi">+</span>
<span class="gi">+    default_config = ImmutableDict(</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;DEBUG&quot;: None,</span>
<span class="gi">+            &quot;TESTING&quot;: False,</span>
<span class="gi">+            &quot;PROPAGATE_EXCEPTIONS&quot;: None,</span>
<span class="gi">+            &quot;SECRET_KEY&quot;: None,</span>
<span class="gi">+            &quot;PERMANENT_SESSION_LIFETIME&quot;: timedelta(days=31),</span>
<span class="gi">+            &quot;USE_X_SENDFILE&quot;: False,</span>
<span class="gi">+            &quot;SERVER_NAME&quot;: None,</span>
<span class="gi">+            &quot;APPLICATION_ROOT&quot;: &quot;/&quot;,</span>
<span class="gi">+            &quot;SESSION_COOKIE_NAME&quot;: &quot;session&quot;,</span>
<span class="gi">+            &quot;SESSION_COOKIE_DOMAIN&quot;: None,</span>
<span class="gi">+            &quot;SESSION_COOKIE_PATH&quot;: None,</span>
<span class="gi">+            &quot;SESSION_COOKIE_HTTPONLY&quot;: True,</span>
<span class="gi">+            &quot;SESSION_COOKIE_SECURE&quot;: False,</span>
<span class="gi">+            &quot;SESSION_COOKIE_SAMESITE&quot;: None,</span>
<span class="gi">+            &quot;SESSION_REFRESH_EACH_REQUEST&quot;: True,</span>
<span class="gi">+            &quot;MAX_CONTENT_LENGTH&quot;: None,</span>
<span class="gi">+            &quot;SEND_FILE_MAX_AGE_DEFAULT&quot;: None,</span>
<span class="gi">+            &quot;TRAP_BAD_REQUEST_ERRORS&quot;: None,</span>
<span class="gi">+            &quot;TRAP_HTTP_EXCEPTIONS&quot;: False,</span>
<span class="gi">+            &quot;EXPLAIN_TEMPLATE_LOADING&quot;: False,</span>
<span class="gi">+            &quot;PREFERRED_URL_SCHEME&quot;: &quot;http&quot;,</span>
<span class="gi">+            &quot;TEMPLATES_AUTO_RELOAD&quot;: None,</span>
<span class="gi">+            &quot;MAX_COOKIE_SIZE&quot;: 4093,</span>
<span class="gi">+        }</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    #: The class that is used for request objects.  See :class:`~flask.Request`</span>
<span class="gi">+    #: for more information.</span>
<span class="w"> </span>    request_class: type[Request] = Request
<span class="gi">+</span>
<span class="gi">+    #: The class that is used for response objects.  See</span>
<span class="gi">+    #: :class:`~flask.Response` for more information.</span>
<span class="w"> </span>    response_class: type[Response] = Response
<span class="gi">+</span>
<span class="gi">+    #: the session interface to use.  By default an instance of</span>
<span class="gi">+    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.8</span>
<span class="w"> </span>    session_interface: SessionInterface = SecureCookieSessionInterface()

<span class="gd">-    def __init__(self, import_name: str, static_url_path: (str | None)=None,</span>
<span class="gd">-        static_folder: (str | os.PathLike[str] | None)=&#39;static&#39;,</span>
<span class="gd">-        static_host: (str | None)=None, host_matching: bool=False,</span>
<span class="gd">-        subdomain_matching: bool=False, template_folder: (str | os.PathLike</span>
<span class="gd">-        [str] | None)=&#39;templates&#39;, instance_path: (str | None)=None,</span>
<span class="gd">-        instance_relative_config: bool=False, root_path: (str | None)=None):</span>
<span class="gd">-        super().__init__(import_name=import_name, static_url_path=</span>
<span class="gd">-            static_url_path, static_folder=static_folder, static_host=</span>
<span class="gd">-            static_host, host_matching=host_matching, subdomain_matching=</span>
<span class="gd">-            subdomain_matching, template_folder=template_folder,</span>
<span class="gd">-            instance_path=instance_path, instance_relative_config=</span>
<span class="gd">-            instance_relative_config, root_path=root_path)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        import_name: str,</span>
<span class="gi">+        static_url_path: str | None = None,</span>
<span class="gi">+        static_folder: str | os.PathLike[str] | None = &quot;static&quot;,</span>
<span class="gi">+        static_host: str | None = None,</span>
<span class="gi">+        host_matching: bool = False,</span>
<span class="gi">+        subdomain_matching: bool = False,</span>
<span class="gi">+        template_folder: str | os.PathLike[str] | None = &quot;templates&quot;,</span>
<span class="gi">+        instance_path: str | None = None,</span>
<span class="gi">+        instance_relative_config: bool = False,</span>
<span class="gi">+        root_path: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            import_name=import_name,</span>
<span class="gi">+            static_url_path=static_url_path,</span>
<span class="gi">+            static_folder=static_folder,</span>
<span class="gi">+            static_host=static_host,</span>
<span class="gi">+            host_matching=host_matching,</span>
<span class="gi">+            subdomain_matching=subdomain_matching,</span>
<span class="gi">+            template_folder=template_folder,</span>
<span class="gi">+            instance_path=instance_path,</span>
<span class="gi">+            instance_relative_config=instance_relative_config,</span>
<span class="gi">+            root_path=root_path,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        #: The Click command group for registering CLI commands for this</span>
<span class="gi">+        #: object. The commands are available from the ``flask`` command</span>
<span class="gi">+        #: once the application has been discovered and blueprints have</span>
<span class="gi">+        #: been registered.</span>
<span class="w"> </span>        self.cli = cli.AppGroup()
<span class="gi">+</span>
<span class="gi">+        # Set the name of the Click group in case someone wants to add</span>
<span class="gi">+        # the app&#39;s commands to another CLI tool.</span>
<span class="w"> </span>        self.cli.name = self.name
<span class="gi">+</span>
<span class="gi">+        # Add a static route using the provided static_url_path, static_host,</span>
<span class="gi">+        # and static_folder if there is a configured static_folder.</span>
<span class="gi">+        # Note we do this without checking if static_folder exists.</span>
<span class="gi">+        # For one, it might be created while the server is running (e.g. during</span>
<span class="gi">+        # development). Also, Google App Engine stores static files somewhere</span>
<span class="w"> </span>        if self.has_static_folder:
<span class="gd">-            assert bool(static_host</span>
<span class="gd">-                ) == host_matching, &#39;Invalid static_host/host_matching combination&#39;</span>
<span class="gi">+            assert (</span>
<span class="gi">+                bool(static_host) == host_matching</span>
<span class="gi">+            ), &quot;Invalid static_host/host_matching combination&quot;</span>
<span class="gi">+            # Use a weakref to avoid creating a reference cycle between the app</span>
<span class="gi">+            # and the view function (see #3761).</span>
<span class="w"> </span>            self_ref = weakref.ref(self)
<span class="gd">-            self.add_url_rule(f&#39;{self.static_url_path}/&lt;path:filename&gt;&#39;,</span>
<span class="gd">-                endpoint=&#39;static&#39;, host=static_host, view_func=lambda **kw:</span>
<span class="gd">-                self_ref().send_static_file(**kw))</span>
<span class="gd">-</span>
<span class="gd">-    def get_send_file_max_age(self, filename: (str | None)) -&gt;(int | None):</span>
<span class="gi">+            self.add_url_rule(</span>
<span class="gi">+                f&quot;{self.static_url_path}/&lt;path:filename&gt;&quot;,</span>
<span class="gi">+                endpoint=&quot;static&quot;,</span>
<span class="gi">+                host=static_host,</span>
<span class="gi">+                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def get_send_file_max_age(self, filename: str | None) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used by :func:`send_file` to determine the ``max_age`` cache
<span class="w"> </span>        value for a given file path if it wasn&#39;t passed.

<span class="gu">@@ -215,9 +287,17 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 0.9
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = current_app.config[&quot;SEND_FILE_MAX_AGE_DEFAULT&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, timedelta):</span>
<span class="gi">+            return int(value.total_seconds())</span>

<span class="gd">-    def send_static_file(self, filename: str) -&gt;Response:</span>
<span class="gi">+        return value  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def send_static_file(self, filename: str) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;The view function used to serve files from
<span class="w"> </span>        :attr:`static_folder`. A route is automatically registered for
<span class="w"> </span>        this view at :attr:`static_url_path` if :attr:`static_folder` is
<span class="gu">@@ -229,9 +309,17 @@ class Flask(App):</span>
<span class="w"> </span>        .. versionadded:: 0.5

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.has_static_folder:</span>
<span class="gi">+            raise RuntimeError(&quot;&#39;static_folder&#39; must be set to serve static_files.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # send_file only knows to call get_send_file_max_age on the app,</span>
<span class="gi">+        # call it here so it works for blueprints too.</span>
<span class="gi">+        max_age = self.get_send_file_max_age(filename)</span>
<span class="gi">+        return send_from_directory(</span>
<span class="gi">+            t.cast(str, self.static_folder), filename, max_age=max_age</span>
<span class="gi">+        )</span>

<span class="gd">-    def open_resource(self, resource: str, mode: str=&#39;rb&#39;) -&gt;t.IO[t.AnyStr]:</span>
<span class="gi">+    def open_resource(self, resource: str, mode: str = &quot;rb&quot;) -&gt; t.IO[t.AnyStr]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Open a resource file relative to :attr:`root_path` for
<span class="w"> </span>        reading.

<span class="gu">@@ -253,10 +341,12 @@ class Flask(App):</span>
<span class="w"> </span>        class.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mode not in {&quot;r&quot;, &quot;rt&quot;, &quot;rb&quot;}:</span>
<span class="gi">+            raise ValueError(&quot;Resources can only be opened for reading.&quot;)</span>

<span class="gd">-    def open_instance_resource(self, resource: str, mode: str=&#39;rb&#39;) -&gt;t.IO[t</span>
<span class="gd">-        .AnyStr]:</span>
<span class="gi">+        return open(os.path.join(self.root_path, resource), mode)</span>
<span class="gi">+</span>
<span class="gi">+    def open_instance_resource(self, resource: str, mode: str = &quot;rb&quot;) -&gt; t.IO[t.AnyStr]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Opens a resource from the application&#39;s instance folder
<span class="w"> </span>        (:attr:`instance_path`).  Otherwise works like
<span class="w"> </span>        :meth:`open_resource`.  Instance resources can also be opened for
<span class="gu">@@ -266,9 +356,9 @@ class Flask(App):</span>
<span class="w"> </span>                         subfolders use forward slashes as separator.
<span class="w"> </span>        :param mode: resource file opening mode, default is &#39;rb&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return open(os.path.join(self.instance_path, resource), mode)</span>

<span class="gd">-    def create_jinja_environment(self) -&gt;Environment:</span>
<span class="gi">+    def create_jinja_environment(self) -&gt; Environment:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the Jinja environment based on :attr:`jinja_options`
<span class="w"> </span>        and the various Jinja-related methods of the app. Changing
<span class="w"> </span>        :attr:`jinja_options` after this will have no effect. Also adds
<span class="gu">@@ -280,10 +370,35 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 0.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def create_url_adapter(self, request: (Request | None)) -&gt;(MapAdapter |</span>
<span class="gd">-        None):</span>
<span class="gi">+        options = dict(self.jinja_options)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;autoescape&quot; not in options:</span>
<span class="gi">+            options[&quot;autoescape&quot;] = self.select_jinja_autoescape</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;auto_reload&quot; not in options:</span>
<span class="gi">+            auto_reload = self.config[&quot;TEMPLATES_AUTO_RELOAD&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            if auto_reload is None:</span>
<span class="gi">+                auto_reload = self.debug</span>
<span class="gi">+</span>
<span class="gi">+            options[&quot;auto_reload&quot;] = auto_reload</span>
<span class="gi">+</span>
<span class="gi">+        rv = self.jinja_environment(self, **options)</span>
<span class="gi">+        rv.globals.update(</span>
<span class="gi">+            url_for=self.url_for,</span>
<span class="gi">+            get_flashed_messages=get_flashed_messages,</span>
<span class="gi">+            config=self.config,</span>
<span class="gi">+            # request, session and g are normally added with the</span>
<span class="gi">+            # context processor for efficiency reasons but for imported</span>
<span class="gi">+            # templates we also want the proxies in there.</span>
<span class="gi">+            request=request,</span>
<span class="gi">+            session=session,</span>
<span class="gi">+            g=g,</span>
<span class="gi">+        )</span>
<span class="gi">+        rv.policies[&quot;json.dumps_function&quot;] = self.json.dumps</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def create_url_adapter(self, request: Request | None) -&gt; MapAdapter | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a URL adapter for the given request. The URL adapter
<span class="w"> </span>        is created at a point where the request context is not yet set
<span class="w"> </span>        up so the request is passed explicitly.
<span class="gu">@@ -298,9 +413,32 @@ class Flask(App):</span>
<span class="w"> </span>            :data:`SERVER_NAME` no longer implicitly enables subdomain
<span class="w"> </span>            matching. Use :attr:`subdomain_matching` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def raise_routing_exception(self, request: Request) -&gt;t.NoReturn:</span>
<span class="gi">+        if request is not None:</span>
<span class="gi">+            # If subdomain matching is disabled (the default), use the</span>
<span class="gi">+            # default subdomain in all cases. This should be the default</span>
<span class="gi">+            # in Werkzeug but it currently does not have that feature.</span>
<span class="gi">+            if not self.subdomain_matching:</span>
<span class="gi">+                subdomain = self.url_map.default_subdomain or None</span>
<span class="gi">+            else:</span>
<span class="gi">+                subdomain = None</span>
<span class="gi">+</span>
<span class="gi">+            return self.url_map.bind_to_environ(</span>
<span class="gi">+                request.environ,</span>
<span class="gi">+                server_name=self.config[&quot;SERVER_NAME&quot;],</span>
<span class="gi">+                subdomain=subdomain,</span>
<span class="gi">+            )</span>
<span class="gi">+        # We need at the very least the server name to be set for this</span>
<span class="gi">+        # to work.</span>
<span class="gi">+        if self.config[&quot;SERVER_NAME&quot;] is not None:</span>
<span class="gi">+            return self.url_map.bind(</span>
<span class="gi">+                self.config[&quot;SERVER_NAME&quot;],</span>
<span class="gi">+                script_name=self.config[&quot;APPLICATION_ROOT&quot;],</span>
<span class="gi">+                url_scheme=self.config[&quot;PREFERRED_URL_SCHEME&quot;],</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def raise_routing_exception(self, request: Request) -&gt; t.NoReturn:</span>
<span class="w"> </span>        &quot;&quot;&quot;Intercept routing exceptions and possibly do something else.

<span class="w"> </span>        In debug mode, intercept a routing redirect and replace it with
<span class="gu">@@ -316,9 +454,19 @@ class Flask(App):</span>
<span class="w"> </span>        :meta private:
<span class="w"> </span>        :internal:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            not self.debug</span>
<span class="gi">+            or not isinstance(request.routing_exception, RequestRedirect)</span>
<span class="gi">+            or request.routing_exception.code in {307, 308}</span>
<span class="gi">+            or request.method in {&quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;}</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise request.routing_exception  # type: ignore[misc]</span>
<span class="gi">+</span>
<span class="gi">+        from .debughelpers import FormDataRoutingRedirect</span>

<span class="gd">-    def update_template_context(self, context: dict[str, t.Any]) -&gt;None:</span>
<span class="gi">+        raise FormDataRoutingRedirect(request)</span>
<span class="gi">+</span>
<span class="gi">+    def update_template_context(self, context: dict[str, t.Any]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update the template context with some commonly used variables.
<span class="w"> </span>        This injects request, session, config and g into the template
<span class="w"> </span>        context as well as everything template context processors want
<span class="gu">@@ -329,19 +477,43 @@ class Flask(App):</span>
<span class="w"> </span>        :param context: the context as a dictionary that is updated in place
<span class="w"> </span>                        to add extra variables.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        names: t.Iterable[str | None] = (None,)</span>
<span class="gi">+</span>
<span class="gi">+        # A template may be rendered outside a request context.</span>
<span class="gi">+        if request:</span>
<span class="gi">+            names = chain(names, reversed(request.blueprints))</span>

<span class="gd">-    def make_shell_context(self) -&gt;dict[str, t.Any]:</span>
<span class="gi">+        # The values passed to render_template take precedence. Keep a</span>
<span class="gi">+        # copy to re-apply after all context functions.</span>
<span class="gi">+        orig_ctx = context.copy()</span>
<span class="gi">+</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            if name in self.template_context_processors:</span>
<span class="gi">+                for func in self.template_context_processors[name]:</span>
<span class="gi">+                    context.update(self.ensure_sync(func)())</span>
<span class="gi">+</span>
<span class="gi">+        context.update(orig_ctx)</span>
<span class="gi">+</span>
<span class="gi">+    def make_shell_context(self) -&gt; dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the shell context for an interactive shell for this
<span class="w"> </span>        application.  This runs all the registered shell context
<span class="w"> </span>        processors.

<span class="w"> </span>        .. versionadded:: 0.11
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def run(self, host: (str | None)=None, port: (int | None)=None, debug:</span>
<span class="gd">-        (bool | None)=None, load_dotenv: bool=True, **options: t.Any) -&gt;None:</span>
<span class="gi">+        rv = {&quot;app&quot;: self, &quot;g&quot;: g}</span>
<span class="gi">+        for processor in self.shell_context_processors:</span>
<span class="gi">+            rv.update(processor())</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def run(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host: str | None = None,</span>
<span class="gi">+        port: int | None = None,</span>
<span class="gi">+        debug: bool | None = None,</span>
<span class="gi">+        load_dotenv: bool = True,</span>
<span class="gi">+        **options: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Runs the application on a local development server.

<span class="w"> </span>        Do not use ``run()`` in a production setting. It is not intended to
<span class="gu">@@ -397,10 +569,67 @@ class Flask(App):</span>
<span class="w"> </span>            The default port is now picked from the ``SERVER_NAME``
<span class="w"> </span>            variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def test_client(self, use_cookies: bool=True, **kwargs: t.Any</span>
<span class="gd">-        ) -&gt;FlaskClient:</span>
<span class="gi">+        # Ignore this call so that it doesn&#39;t start another server if</span>
<span class="gi">+        # the &#39;flask run&#39; command is used.</span>
<span class="gi">+        if os.environ.get(&quot;FLASK_RUN_FROM_CLI&quot;) == &quot;true&quot;:</span>
<span class="gi">+            if not is_running_from_reloader():</span>
<span class="gi">+                click.secho(</span>
<span class="gi">+                    &quot; * Ignoring a call to &#39;app.run()&#39; that would block&quot;</span>
<span class="gi">+                    &quot; the current &#39;flask&#39; CLI command.\n&quot;</span>
<span class="gi">+                    &quot;   Only call &#39;app.run()&#39; in an &#39;if __name__ ==&quot;</span>
<span class="gi">+                    &#39; &quot;__main__&quot;\&#39; guard.&#39;,</span>
<span class="gi">+                    fg=&quot;red&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if get_load_dotenv(load_dotenv):</span>
<span class="gi">+            cli.load_dotenv()</span>
<span class="gi">+</span>
<span class="gi">+            # if set, env var overrides existing value</span>
<span class="gi">+            if &quot;FLASK_DEBUG&quot; in os.environ:</span>
<span class="gi">+                self.debug = get_debug_flag()</span>
<span class="gi">+</span>
<span class="gi">+        # debug passed to method overrides all other sources</span>
<span class="gi">+        if debug is not None:</span>
<span class="gi">+            self.debug = bool(debug)</span>
<span class="gi">+</span>
<span class="gi">+        server_name = self.config.get(&quot;SERVER_NAME&quot;)</span>
<span class="gi">+        sn_host = sn_port = None</span>
<span class="gi">+</span>
<span class="gi">+        if server_name:</span>
<span class="gi">+            sn_host, _, sn_port = server_name.partition(&quot;:&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not host:</span>
<span class="gi">+            if sn_host:</span>
<span class="gi">+                host = sn_host</span>
<span class="gi">+            else:</span>
<span class="gi">+                host = &quot;127.0.0.1&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if port or port == 0:</span>
<span class="gi">+            port = int(port)</span>
<span class="gi">+        elif sn_port:</span>
<span class="gi">+            port = int(sn_port)</span>
<span class="gi">+        else:</span>
<span class="gi">+            port = 5000</span>
<span class="gi">+</span>
<span class="gi">+        options.setdefault(&quot;use_reloader&quot;, self.debug)</span>
<span class="gi">+        options.setdefault(&quot;use_debugger&quot;, self.debug)</span>
<span class="gi">+        options.setdefault(&quot;threaded&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+        cli.show_server_banner(self.debug, self.name)</span>
<span class="gi">+</span>
<span class="gi">+        from werkzeug.serving import run_simple</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            run_simple(t.cast(str, host), port, self, **options)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # reset the first request information if the development server</span>
<span class="gi">+            # reset normally.  This makes it possible to restart the server</span>
<span class="gi">+            # without reloader and that stuff from an interactive shell.</span>
<span class="gi">+            self._got_first_request = False</span>
<span class="gi">+</span>
<span class="gi">+    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -&gt; FlaskClient:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a test client for this application.  For information
<span class="w"> </span>        about unit testing head over to :doc:`/testing`.

<span class="gu">@@ -451,9 +680,14 @@ class Flask(App):</span>
<span class="w"> </span>           Added `**kwargs` to support passing additional keyword arguments to
<span class="w"> </span>           the constructor of :attr:`test_client_class`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def test_cli_runner(self, **kwargs: t.Any) -&gt;FlaskCliRunner:</span>
<span class="gi">+        cls = self.test_client_class</span>
<span class="gi">+        if cls is None:</span>
<span class="gi">+            from .testing import FlaskClient as cls</span>
<span class="gi">+        return cls(  # type: ignore</span>
<span class="gi">+            self, self.response_class, use_cookies=use_cookies, **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def test_cli_runner(self, **kwargs: t.Any) -&gt; FlaskCliRunner:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a CLI runner for testing CLI commands.
<span class="w"> </span>        See :ref:`testing-cli`.

<span class="gu">@@ -463,10 +697,16 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 1.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls = self.test_cli_runner_class</span>
<span class="gi">+</span>
<span class="gi">+        if cls is None:</span>
<span class="gi">+            from .testing import FlaskCliRunner as cls</span>
<span class="gi">+</span>
<span class="gi">+        return cls(self, **kwargs)  # type: ignore</span>

<span class="gd">-    def handle_http_exception(self, e: HTTPException) -&gt;(HTTPException | ft</span>
<span class="gd">-        .ResponseReturnValue):</span>
<span class="gi">+    def handle_http_exception(</span>
<span class="gi">+        self, e: HTTPException</span>
<span class="gi">+    ) -&gt; HTTPException | ft.ResponseReturnValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles an HTTP exception.  By default this will invoke the
<span class="w"> </span>        registered error handlers and fall back to returning the
<span class="w"> </span>        exception as response.
<span class="gu">@@ -483,10 +723,25 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 0.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def handle_user_exception(self, e: Exception) -&gt;(HTTPException | ft.</span>
<span class="gd">-        ResponseReturnValue):</span>
<span class="gi">+        # Proxy exceptions don&#39;t have error codes.  We want to always return</span>
<span class="gi">+        # those unchanged as errors</span>
<span class="gi">+        if e.code is None:</span>
<span class="gi">+            return e</span>
<span class="gi">+</span>
<span class="gi">+        # RoutingExceptions are used internally to trigger routing</span>
<span class="gi">+        # actions, such as slash redirects raising RequestRedirect. They</span>
<span class="gi">+        # are not raised or handled in user code.</span>
<span class="gi">+        if isinstance(e, RoutingException):</span>
<span class="gi">+            return e</span>
<span class="gi">+</span>
<span class="gi">+        handler = self._find_error_handler(e, request.blueprints)</span>
<span class="gi">+        if handler is None:</span>
<span class="gi">+            return e</span>
<span class="gi">+        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def handle_user_exception(</span>
<span class="gi">+        self, e: Exception</span>
<span class="gi">+    ) -&gt; HTTPException | ft.ResponseReturnValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method is called whenever an exception occurs that
<span class="w"> </span>        should be handled. A special case is :class:`~werkzeug
<span class="w"> </span>        .exceptions.HTTPException` which is forwarded to the
<span class="gu">@@ -501,9 +756,22 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 0.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(e, BadRequestKeyError) and (</span>
<span class="gi">+            self.debug or self.config[&quot;TRAP_BAD_REQUEST_ERRORS&quot;]</span>
<span class="gi">+        ):</span>
<span class="gi">+            e.show_exception = True</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(e, HTTPException) and not self.trap_http_exception(e):</span>
<span class="gi">+            return self.handle_http_exception(e)</span>
<span class="gi">+</span>
<span class="gi">+        handler = self._find_error_handler(e, request.blueprints)</span>
<span class="gi">+</span>
<span class="gi">+        if handler is None:</span>
<span class="gi">+            raise</span>

<span class="gd">-    def handle_exception(self, e: Exception) -&gt;Response:</span>
<span class="gi">+        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def handle_exception(self, e: Exception) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle an exception that did not have an error handler
<span class="w"> </span>        associated with it, or that was raised from an error handler.
<span class="w"> </span>        This always causes a 500 ``InternalServerError``.
<span class="gu">@@ -531,10 +799,35 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 0.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        exc_info = sys.exc_info()</span>
<span class="gi">+        got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)</span>
<span class="gi">+        propagate = self.config[&quot;PROPAGATE_EXCEPTIONS&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if propagate is None:</span>
<span class="gi">+            propagate = self.testing or self.debug</span>
<span class="gi">+</span>
<span class="gi">+        if propagate:</span>
<span class="gi">+            # Re-raise if called with an active exception, otherwise</span>
<span class="gi">+            # raise the passed in exception.</span>
<span class="gi">+            if exc_info[1] is e:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            raise e</span>

<span class="gd">-    def log_exception(self, exc_info: (tuple[type, BaseException,</span>
<span class="gd">-        TracebackType] | tuple[None, None, None])) -&gt;None:</span>
<span class="gi">+        self.log_exception(exc_info)</span>
<span class="gi">+        server_error: InternalServerError | ft.ResponseReturnValue</span>
<span class="gi">+        server_error = InternalServerError(original_exception=e)</span>
<span class="gi">+        handler = self._find_error_handler(server_error, request.blueprints)</span>
<span class="gi">+</span>
<span class="gi">+        if handler is not None:</span>
<span class="gi">+            server_error = self.ensure_sync(handler)(server_error)</span>
<span class="gi">+</span>
<span class="gi">+        return self.finalize_request(server_error, from_error_handler=True)</span>
<span class="gi">+</span>
<span class="gi">+    def log_exception(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Logs an exception.  This is called by :meth:`handle_exception`
<span class="w"> </span>        if debugging is disabled and right before the handler is called.
<span class="w"> </span>        The default implementation logs the exception as error on the
<span class="gu">@@ -542,9 +835,11 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 0.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.logger.error(</span>
<span class="gi">+            f&quot;Exception on {request.path} [{request.method}]&quot;, exc_info=exc_info</span>
<span class="gi">+        )</span>

<span class="gd">-    def dispatch_request(self) -&gt;ft.ResponseReturnValue:</span>
<span class="gi">+    def dispatch_request(self) -&gt; ft.ResponseReturnValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;Does the request dispatching.  Matches the URL and returns the
<span class="w"> </span>        return value of the view or error handler.  This does not have to
<span class="w"> </span>        be a response object.  In order to convert the return value to a
<span class="gu">@@ -554,19 +849,44 @@ class Flask(App):</span>
<span class="w"> </span>           This no longer does the exception handling, this code was
<span class="w"> </span>           moved to the new :meth:`full_dispatch_request`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def full_dispatch_request(self) -&gt;Response:</span>
<span class="gi">+        req = request_ctx.request</span>
<span class="gi">+        if req.routing_exception is not None:</span>
<span class="gi">+            self.raise_routing_exception(req)</span>
<span class="gi">+        rule: Rule = req.url_rule  # type: ignore[assignment]</span>
<span class="gi">+        # if we provide automatic options for this URL and the</span>
<span class="gi">+        # request came with the OPTIONS method, reply automatically</span>
<span class="gi">+        if (</span>
<span class="gi">+            getattr(rule, &quot;provide_automatic_options&quot;, False)</span>
<span class="gi">+            and req.method == &quot;OPTIONS&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return self.make_default_options_response()</span>
<span class="gi">+        # otherwise dispatch to the handler for that endpoint</span>
<span class="gi">+        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]</span>
<span class="gi">+        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def full_dispatch_request(self) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;Dispatches the request and on top of that performs request
<span class="w"> </span>        pre and postprocessing as well as HTTP exception catching and
<span class="w"> </span>        error handling.

<span class="w"> </span>        .. versionadded:: 0.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def finalize_request(self, rv: (ft.ResponseReturnValue | HTTPException),</span>
<span class="gd">-        from_error_handler: bool=False) -&gt;Response:</span>
<span class="gi">+        self._got_first_request = True</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            request_started.send(self, _async_wrapper=self.ensure_sync)</span>
<span class="gi">+            rv = self.preprocess_request()</span>
<span class="gi">+            if rv is None:</span>
<span class="gi">+                rv = self.dispatch_request()</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            rv = self.handle_user_exception(e)</span>
<span class="gi">+        return self.finalize_request(rv)</span>
<span class="gi">+</span>
<span class="gi">+    def finalize_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rv: ft.ResponseReturnValue | HTTPException,</span>
<span class="gi">+        from_error_handler: bool = False,</span>
<span class="gi">+    ) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given the return value from a view function this finalizes
<span class="w"> </span>        the request by converting it into a response and invoking the
<span class="w"> </span>        postprocessing functions.  This is invoked for both normal
<span class="gu">@@ -579,19 +899,34 @@ class Flask(App):</span>

<span class="w"> </span>        :internal:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def make_default_options_response(self) -&gt;Response:</span>
<span class="gi">+        response = self.make_response(rv)</span>
<span class="gi">+        try:</span>
<span class="gi">+            response = self.process_response(response)</span>
<span class="gi">+            request_finished.send(</span>
<span class="gi">+                self, _async_wrapper=self.ensure_sync, response=response</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if not from_error_handler:</span>
<span class="gi">+                raise</span>
<span class="gi">+            self.logger.exception(</span>
<span class="gi">+                &quot;Request finalizing failed with an error while handling an error&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return response</span>
<span class="gi">+</span>
<span class="gi">+    def make_default_options_response(self) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method is called to create the default ``OPTIONS`` response.
<span class="w"> </span>        This can be changed through subclassing to change the default
<span class="w"> </span>        behavior of ``OPTIONS`` responses.

<span class="w"> </span>        .. versionadded:: 0.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        adapter = request_ctx.url_adapter</span>
<span class="gi">+        methods = adapter.allowed_methods()  # type: ignore[union-attr]</span>
<span class="gi">+        rv = self.response_class()</span>
<span class="gi">+        rv.allow.update(methods)</span>
<span class="gi">+        return rv</span>

<span class="gd">-    def ensure_sync(self, func: t.Callable[..., t.Any]) -&gt;t.Callable[..., t.Any</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def ensure_sync(self, func: t.Callable[..., t.Any]) -&gt; t.Callable[..., t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Ensure that the function is synchronous for WSGI workers.
<span class="w"> </span>        Plain ``def`` functions are returned as-is. ``async def``
<span class="w"> </span>        functions are wrapped to run and wait for the response.
<span class="gu">@@ -600,10 +935,14 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if iscoroutinefunction(func):</span>
<span class="gi">+            return self.async_to_sync(func)</span>

<span class="gd">-    def async_to_sync(self, func: t.Callable[..., t.Coroutine[t.Any, t.Any,</span>
<span class="gd">-        t.Any]]) -&gt;t.Callable[..., t.Any]:</span>
<span class="gi">+        return func</span>
<span class="gi">+</span>
<span class="gi">+    def async_to_sync(</span>
<span class="gi">+        self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]]</span>
<span class="gi">+    ) -&gt; t.Callable[..., t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a sync function that will run the coroutine function.

<span class="w"> </span>        .. code-block:: python
<span class="gu">@@ -615,11 +954,26 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def url_for(self, /, endpoint: str, *, _anchor: (str | None)=None,</span>
<span class="gd">-        _method: (str | None)=None, _scheme: (str | None)=None, _external:</span>
<span class="gd">-        (bool | None)=None, **values: t.Any) -&gt;str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            from asgiref.sync import async_to_sync as asgiref_async_to_sync</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;Install Flask with the &#39;async&#39; extra in order to use async views.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="gi">+</span>
<span class="gi">+        return asgiref_async_to_sync(func)</span>
<span class="gi">+</span>
<span class="gi">+    def url_for(</span>
<span class="gi">+        self,</span>
<span class="gi">+        /,</span>
<span class="gi">+        endpoint: str,</span>
<span class="gi">+        *,</span>
<span class="gi">+        _anchor: str | None = None,</span>
<span class="gi">+        _method: str | None = None,</span>
<span class="gi">+        _scheme: str | None = None,</span>
<span class="gi">+        _external: bool | None = None,</span>
<span class="gi">+        **values: t.Any,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a URL to the given endpoint with the given values.

<span class="w"> </span>        This is called by :func:`flask.url_for`, and can be called
<span class="gu">@@ -666,9 +1020,76 @@ class Flask(App):</span>
<span class="w"> </span>        .. versionadded:: 2.2
<span class="w"> </span>            Moved from ``flask.url_for``, which calls this method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def make_response(self, rv: ft.ResponseReturnValue) -&gt;Response:</span>
<span class="gi">+        req_ctx = _cv_request.get(None)</span>
<span class="gi">+</span>
<span class="gi">+        if req_ctx is not None:</span>
<span class="gi">+            url_adapter = req_ctx.url_adapter</span>
<span class="gi">+            blueprint_name = req_ctx.request.blueprint</span>
<span class="gi">+</span>
<span class="gi">+            # If the endpoint starts with &quot;.&quot; and the request matches a</span>
<span class="gi">+            # blueprint, the endpoint is relative to the blueprint.</span>
<span class="gi">+            if endpoint[:1] == &quot;.&quot;:</span>
<span class="gi">+                if blueprint_name is not None:</span>
<span class="gi">+                    endpoint = f&quot;{blueprint_name}{endpoint}&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    endpoint = endpoint[1:]</span>
<span class="gi">+</span>
<span class="gi">+            # When in a request, generate a URL without scheme and</span>
<span class="gi">+            # domain by default, unless a scheme is given.</span>
<span class="gi">+            if _external is None:</span>
<span class="gi">+                _external = _scheme is not None</span>
<span class="gi">+        else:</span>
<span class="gi">+            app_ctx = _cv_app.get(None)</span>
<span class="gi">+</span>
<span class="gi">+            # If called by helpers.url_for, an app context is active,</span>
<span class="gi">+            # use its url_adapter. Otherwise, app.url_for was called</span>
<span class="gi">+            # directly, build an adapter.</span>
<span class="gi">+            if app_ctx is not None:</span>
<span class="gi">+                url_adapter = app_ctx.url_adapter</span>
<span class="gi">+            else:</span>
<span class="gi">+                url_adapter = self.create_url_adapter(None)</span>
<span class="gi">+</span>
<span class="gi">+            if url_adapter is None:</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    &quot;Unable to build URLs outside an active request&quot;</span>
<span class="gi">+                    &quot; without &#39;SERVER_NAME&#39; configured. Also configure&quot;</span>
<span class="gi">+                    &quot; &#39;APPLICATION_ROOT&#39; and &#39;PREFERRED_URL_SCHEME&#39; as&quot;</span>
<span class="gi">+                    &quot; needed.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # When outside a request, generate a URL with scheme and</span>
<span class="gi">+            # domain by default.</span>
<span class="gi">+            if _external is None:</span>
<span class="gi">+                _external = True</span>
<span class="gi">+</span>
<span class="gi">+        # It is an error to set _scheme when _external=False, in order</span>
<span class="gi">+        # to avoid accidental insecure URLs.</span>
<span class="gi">+        if _scheme is not None and not _external:</span>
<span class="gi">+            raise ValueError(&quot;When specifying &#39;_scheme&#39;, &#39;_external&#39; must be True.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.inject_url_defaults(endpoint, values)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            rv = url_adapter.build(  # type: ignore[union-attr]</span>
<span class="gi">+                endpoint,</span>
<span class="gi">+                values,</span>
<span class="gi">+                method=_method,</span>
<span class="gi">+                url_scheme=_scheme,</span>
<span class="gi">+                force_external=_external,</span>
<span class="gi">+            )</span>
<span class="gi">+        except BuildError as error:</span>
<span class="gi">+            values.update(</span>
<span class="gi">+                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external</span>
<span class="gi">+            )</span>
<span class="gi">+            return self.handle_url_build_error(error, endpoint, values)</span>
<span class="gi">+</span>
<span class="gi">+        if _anchor is not None:</span>
<span class="gi">+            _anchor = _url_quote(_anchor, safe=&quot;%!#$&amp;&#39;()*+,/:;=?@&quot;)</span>
<span class="gi">+            rv = f&quot;{rv}#{_anchor}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def make_response(self, rv: ft.ResponseReturnValue) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the return value from a view function to an instance of
<span class="w"> </span>        :attr:`response_class`.

<span class="gu">@@ -724,9 +1145,92 @@ class Flask(App):</span>
<span class="w"> </span>           Previously a tuple was interpreted as the arguments for the
<span class="w"> </span>           response object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def preprocess_request(self) -&gt;(ft.ResponseReturnValue | None):</span>
<span class="gi">+        status = headers = None</span>
<span class="gi">+</span>
<span class="gi">+        # unpack tuple returns</span>
<span class="gi">+        if isinstance(rv, tuple):</span>
<span class="gi">+            len_rv = len(rv)</span>
<span class="gi">+</span>
<span class="gi">+            # a 3-tuple is unpacked directly</span>
<span class="gi">+            if len_rv == 3:</span>
<span class="gi">+                rv, status, headers = rv  # type: ignore[misc]</span>
<span class="gi">+            # decide if a 2-tuple has status or headers</span>
<span class="gi">+            elif len_rv == 2:</span>
<span class="gi">+                if isinstance(rv[1], (Headers, dict, tuple, list)):</span>
<span class="gi">+                    rv, headers = rv</span>
<span class="gi">+                else:</span>
<span class="gi">+                    rv, status = rv  # type: ignore[assignment,misc]</span>
<span class="gi">+            # other sized tuples are not allowed</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &quot;The view function did not return a valid response tuple.&quot;</span>
<span class="gi">+                    &quot; The tuple must have the form (body, status, headers),&quot;</span>
<span class="gi">+                    &quot; (body, status), or (body, headers).&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # the body must not be None</span>
<span class="gi">+        if rv is None:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;The view function for {request.endpoint!r} did not&quot;</span>
<span class="gi">+                &quot; return a valid response. The function either returned&quot;</span>
<span class="gi">+                &quot; None or ended without a return statement.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # make sure the body is an instance of the response class</span>
<span class="gi">+        if not isinstance(rv, self.response_class):</span>
<span class="gi">+            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):</span>
<span class="gi">+                # let the response class set the status and headers instead of</span>
<span class="gi">+                # waiting to do it manually, so that the class can handle any</span>
<span class="gi">+                # special logic</span>
<span class="gi">+                rv = self.response_class(</span>
<span class="gi">+                    rv,</span>
<span class="gi">+                    status=status,</span>
<span class="gi">+                    headers=headers,  # type: ignore[arg-type]</span>
<span class="gi">+                )</span>
<span class="gi">+                status = headers = None</span>
<span class="gi">+            elif isinstance(rv, (dict, list)):</span>
<span class="gi">+                rv = self.json.response(rv)</span>
<span class="gi">+            elif isinstance(rv, BaseResponse) or callable(rv):</span>
<span class="gi">+                # evaluate a WSGI callable, or coerce a different response</span>
<span class="gi">+                # class to the correct type</span>
<span class="gi">+                try:</span>
<span class="gi">+                    rv = self.response_class.force_type(</span>
<span class="gi">+                        rv,  # type: ignore[arg-type]</span>
<span class="gi">+                        request.environ,</span>
<span class="gi">+                    )</span>
<span class="gi">+                except TypeError as e:</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        f&quot;{e}\nThe view function did not return a valid&quot;</span>
<span class="gi">+                        &quot; response. The return type must be a string,&quot;</span>
<span class="gi">+                        &quot; dict, list, tuple with headers or status,&quot;</span>
<span class="gi">+                        &quot; Response instance, or WSGI callable, but it&quot;</span>
<span class="gi">+                        f&quot; was a {type(rv).__name__}.&quot;</span>
<span class="gi">+                    ).with_traceback(sys.exc_info()[2]) from None</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &quot;The view function did not return a valid&quot;</span>
<span class="gi">+                    &quot; response. The return type must be a string,&quot;</span>
<span class="gi">+                    &quot; dict, list, tuple with headers or status,&quot;</span>
<span class="gi">+                    &quot; Response instance, or WSGI callable, but it was a&quot;</span>
<span class="gi">+                    f&quot; {type(rv).__name__}.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        rv = t.cast(Response, rv)</span>
<span class="gi">+        # prefer the status if it was provided</span>
<span class="gi">+        if status is not None:</span>
<span class="gi">+            if isinstance(status, (str, bytes, bytearray)):</span>
<span class="gi">+                rv.status = status</span>
<span class="gi">+            else:</span>
<span class="gi">+                rv.status_code = status</span>
<span class="gi">+</span>
<span class="gi">+        # extend existing headers with provided headers</span>
<span class="gi">+        if headers:</span>
<span class="gi">+            rv.headers.update(headers)  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def preprocess_request(self) -&gt; ft.ResponseReturnValue | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called before the request is dispatched. Calls
<span class="w"> </span>        :attr:`url_value_preprocessors` registered with the app and the
<span class="w"> </span>        current blueprint (if any). Then calls :attr:`before_request_funcs`
<span class="gu">@@ -736,9 +1240,24 @@ class Flask(App):</span>
<span class="w"> </span>        value is handled as if it was the return value from the view, and
<span class="w"> </span>        further request handling is stopped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        names = (None, *reversed(request.blueprints))</span>
<span class="gi">+</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            if name in self.url_value_preprocessors:</span>
<span class="gi">+                for url_func in self.url_value_preprocessors[name]:</span>
<span class="gi">+                    url_func(request.endpoint, request.view_args)</span>
<span class="gi">+</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            if name in self.before_request_funcs:</span>
<span class="gi">+                for before_func in self.before_request_funcs[name]:</span>
<span class="gi">+                    rv = self.ensure_sync(before_func)()</span>
<span class="gi">+</span>
<span class="gi">+                    if rv is not None:</span>
<span class="gi">+                        return rv  # type: ignore[no-any-return]</span>

<span class="gd">-    def process_response(self, response: Response) -&gt;Response:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def process_response(self, response: Response) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;Can be overridden in order to modify the response object
<span class="w"> </span>        before it&#39;s sent to the WSGI server.  By default this will
<span class="w"> </span>        call all the :meth:`after_request` decorated functions.
<span class="gu">@@ -751,10 +1270,25 @@ class Flask(App):</span>
<span class="w"> </span>        :return: a new response object or the same, has to be an
<span class="w"> </span>                 instance of :attr:`response_class`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+        for func in ctx._after_request_functions:</span>
<span class="gi">+            response = self.ensure_sync(func)(response)</span>
<span class="gi">+</span>
<span class="gi">+        for name in chain(request.blueprints, (None,)):</span>
<span class="gi">+            if name in self.after_request_funcs:</span>
<span class="gi">+                for func in reversed(self.after_request_funcs[name]):</span>
<span class="gi">+                    response = self.ensure_sync(func)(response)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.session_interface.is_null_session(ctx.session):</span>
<span class="gi">+            self.session_interface.save_session(self, ctx.session, response)</span>

<span class="gd">-    def do_teardown_request(self, exc: (BaseException | None)=_sentinel</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        return response</span>
<span class="gi">+</span>
<span class="gi">+    def do_teardown_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc: BaseException | None = _sentinel,  # type: ignore[assignment]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called after the request is dispatched and the response is
<span class="w"> </span>        returned, right before the request context is popped.

<span class="gu">@@ -775,10 +1309,20 @@ class Flask(App):</span>
<span class="w"> </span>        .. versionchanged:: 0.9
<span class="w"> </span>            Added the ``exc`` argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if exc is _sentinel:</span>
<span class="gi">+            exc = sys.exc_info()[1]</span>
<span class="gi">+</span>
<span class="gi">+        for name in chain(request.blueprints, (None,)):</span>
<span class="gi">+            if name in self.teardown_request_funcs:</span>
<span class="gi">+                for func in reversed(self.teardown_request_funcs[name]):</span>
<span class="gi">+                    self.ensure_sync(func)(exc)</span>

<span class="gd">-    def do_teardown_appcontext(self, exc: (BaseException | None)=_sentinel</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)</span>
<span class="gi">+</span>
<span class="gi">+    def do_teardown_appcontext(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc: BaseException | None = _sentinel,  # type: ignore[assignment]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called right before the application context is popped.

<span class="w"> </span>        When handling a request, the application context is popped
<span class="gu">@@ -793,9 +1337,15 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 0.9
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if exc is _sentinel:</span>
<span class="gi">+            exc = sys.exc_info()[1]</span>
<span class="gi">+</span>
<span class="gi">+        for func in reversed(self.teardown_appcontext_funcs):</span>
<span class="gi">+            self.ensure_sync(func)(exc)</span>

<span class="gd">-    def app_context(self) -&gt;AppContext:</span>
<span class="gi">+        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)</span>
<span class="gi">+</span>
<span class="gi">+    def app_context(self) -&gt; AppContext:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
<span class="w"> </span>        block to push the context, which will make :data:`current_app`
<span class="w"> </span>        point at this application.
<span class="gu">@@ -814,9 +1364,9 @@ class Flask(App):</span>

<span class="w"> </span>        .. versionadded:: 0.9
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AppContext(self)</span>

<span class="gd">-    def request_context(self, environ: WSGIEnvironment) -&gt;RequestContext:</span>
<span class="gi">+    def request_context(self, environ: WSGIEnvironment) -&gt; RequestContext:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a :class:`~flask.ctx.RequestContext` representing a
<span class="w"> </span>        WSGI environment. Use a ``with`` block to push the context,
<span class="w"> </span>        which will make :data:`request` point at this request.
<span class="gu">@@ -830,10 +1380,9 @@ class Flask(App):</span>

<span class="w"> </span>        :param environ: a WSGI environment
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return RequestContext(self, environ)</span>

<span class="gd">-    def test_request_context(self, *args: t.Any, **kwargs: t.Any</span>
<span class="gd">-        ) -&gt;RequestContext:</span>
<span class="gi">+    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -&gt; RequestContext:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a :class:`~flask.ctx.RequestContext` for a WSGI
<span class="w"> </span>        environment created from the given values. This is mostly useful
<span class="w"> </span>        during testing, where you may want to run a function that uses
<span class="gu">@@ -880,10 +1429,18 @@ class Flask(App):</span>
<span class="w"> </span>        :param kwargs: other keyword arguments passed to
<span class="w"> </span>            :class:`~werkzeug.test.EnvironBuilder`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .testing import EnvironBuilder</span>
<span class="gi">+</span>
<span class="gi">+        builder = EnvironBuilder(self, *args, **kwargs)</span>

<span class="gd">-    def wsgi_app(self, environ: WSGIEnvironment, start_response: StartResponse</span>
<span class="gd">-        ) -&gt;cabc.Iterable[bytes]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.request_context(builder.get_environ())</span>
<span class="gi">+        finally:</span>
<span class="gi">+            builder.close()</span>
<span class="gi">+</span>
<span class="gi">+    def wsgi_app(</span>
<span class="gi">+        self, environ: WSGIEnvironment, start_response: StartResponse</span>
<span class="gi">+    ) -&gt; cabc.Iterable[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The actual WSGI application. This is not implemented in
<span class="w"> </span>        :meth:`__call__` so that middlewares can be applied without
<span class="w"> </span>        losing a reference to the app object. Instead of doing this::
<span class="gu">@@ -908,10 +1465,32 @@ class Flask(App):</span>
<span class="w"> </span>            a list of headers, and an optional exception context to
<span class="w"> </span>            start the response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __call__(self, environ: WSGIEnvironment, start_response: StartResponse</span>
<span class="gd">-        ) -&gt;cabc.Iterable[bytes]:</span>
<span class="gi">+        ctx = self.request_context(environ)</span>
<span class="gi">+        error: BaseException | None = None</span>
<span class="gi">+        try:</span>
<span class="gi">+            try:</span>
<span class="gi">+                ctx.push()</span>
<span class="gi">+                response = self.full_dispatch_request()</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                error = e</span>
<span class="gi">+                response = self.handle_exception(e)</span>
<span class="gi">+            except:  # noqa: B001</span>
<span class="gi">+                error = sys.exc_info()[1]</span>
<span class="gi">+                raise</span>
<span class="gi">+            return response(environ, start_response)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if &quot;werkzeug.debug.preserve_context&quot; in environ:</span>
<span class="gi">+                environ[&quot;werkzeug.debug.preserve_context&quot;](_cv_app.get())</span>
<span class="gi">+                environ[&quot;werkzeug.debug.preserve_context&quot;](_cv_request.get())</span>
<span class="gi">+</span>
<span class="gi">+            if error is not None and self.should_ignore_error(error):</span>
<span class="gi">+                error = None</span>
<span class="gi">+</span>
<span class="gi">+            ctx.pop(error)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, environ: WSGIEnvironment, start_response: StartResponse</span>
<span class="gi">+    ) -&gt; cabc.Iterable[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The WSGI server calls the Flask application object as the
<span class="w"> </span>        WSGI application. This calls :meth:`wsgi_app`, which can be
<span class="w"> </span>        wrapped to apply middleware.
<span class="gh">diff --git a/src/flask/blueprints.py b/src/flask/blueprints.py</span>
<span class="gh">index 446e7185..aa9eacf2 100644</span>
<span class="gd">--- a/src/flask/blueprints.py</span>
<span class="gi">+++ b/src/flask/blueprints.py</span>
<span class="gu">@@ -1,32 +1,58 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import typing as t
<span class="w"> </span>from datetime import timedelta
<span class="gi">+</span>
<span class="w"> </span>from .cli import AppGroup
<span class="w"> </span>from .globals import current_app
<span class="w"> </span>from .helpers import send_from_directory
<span class="w"> </span>from .sansio.blueprints import Blueprint as SansioBlueprint
<span class="gd">-from .sansio.blueprints import BlueprintSetupState as BlueprintSetupState</span>
<span class="gi">+from .sansio.blueprints import BlueprintSetupState as BlueprintSetupState  # noqa</span>
<span class="w"> </span>from .sansio.scaffold import _sentinel
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from .wrappers import Response


<span class="w"> </span>class Blueprint(SansioBlueprint):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, name: str, import_name: str, static_folder: (str |</span>
<span class="gd">-        os.PathLike[str] | None)=None, static_url_path: (str | None)=None,</span>
<span class="gd">-        template_folder: (str | os.PathLike[str] | None)=None, url_prefix:</span>
<span class="gd">-        (str | None)=None, subdomain: (str | None)=None, url_defaults: (</span>
<span class="gd">-        dict[str, t.Any] | None)=None, root_path: (str | None)=None,</span>
<span class="gd">-        cli_group: (str | None)=_sentinel) -&gt;None:</span>
<span class="gd">-        super().__init__(name, import_name, static_folder, static_url_path,</span>
<span class="gd">-            template_folder, url_prefix, subdomain, url_defaults, root_path,</span>
<span class="gd">-            cli_group)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        import_name: str,</span>
<span class="gi">+        static_folder: str | os.PathLike[str] | None = None,</span>
<span class="gi">+        static_url_path: str | None = None,</span>
<span class="gi">+        template_folder: str | os.PathLike[str] | None = None,</span>
<span class="gi">+        url_prefix: str | None = None,</span>
<span class="gi">+        subdomain: str | None = None,</span>
<span class="gi">+        url_defaults: dict[str, t.Any] | None = None,</span>
<span class="gi">+        root_path: str | None = None,</span>
<span class="gi">+        cli_group: str | None = _sentinel,  # type: ignore</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            name,</span>
<span class="gi">+            import_name,</span>
<span class="gi">+            static_folder,</span>
<span class="gi">+            static_url_path,</span>
<span class="gi">+            template_folder,</span>
<span class="gi">+            url_prefix,</span>
<span class="gi">+            subdomain,</span>
<span class="gi">+            url_defaults,</span>
<span class="gi">+            root_path,</span>
<span class="gi">+            cli_group,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        #: The Click command group for registering CLI commands for this</span>
<span class="gi">+        #: object. The commands are available from the ``flask`` command</span>
<span class="gi">+        #: once the application has been discovered and blueprints have</span>
<span class="gi">+        #: been registered.</span>
<span class="w"> </span>        self.cli = AppGroup()
<span class="gi">+</span>
<span class="gi">+        # Set the name of the Click group in case someone wants to add</span>
<span class="gi">+        # the app&#39;s commands to another CLI tool.</span>
<span class="w"> </span>        self.cli.name = self.name

<span class="gd">-    def get_send_file_max_age(self, filename: (str | None)) -&gt;(int | None):</span>
<span class="gi">+    def get_send_file_max_age(self, filename: str | None) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used by :func:`send_file` to determine the ``max_age`` cache
<span class="w"> </span>        value for a given file path if it wasn&#39;t passed.

<span class="gu">@@ -43,9 +69,17 @@ class Blueprint(SansioBlueprint):</span>

<span class="w"> </span>        .. versionadded:: 0.9
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = current_app.config[&quot;SEND_FILE_MAX_AGE_DEFAULT&quot;]</span>

<span class="gd">-    def send_static_file(self, filename: str) -&gt;Response:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, timedelta):</span>
<span class="gi">+            return int(value.total_seconds())</span>
<span class="gi">+</span>
<span class="gi">+        return value  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def send_static_file(self, filename: str) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;The view function used to serve files from
<span class="w"> </span>        :attr:`static_folder`. A route is automatically registered for
<span class="w"> </span>        this view at :attr:`static_url_path` if :attr:`static_folder` is
<span class="gu">@@ -57,9 +91,17 @@ class Blueprint(SansioBlueprint):</span>
<span class="w"> </span>        .. versionadded:: 0.5

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.has_static_folder:</span>
<span class="gi">+            raise RuntimeError(&quot;&#39;static_folder&#39; must be set to serve static_files.&quot;)</span>

<span class="gd">-    def open_resource(self, resource: str, mode: str=&#39;rb&#39;) -&gt;t.IO[t.AnyStr]:</span>
<span class="gi">+        # send_file only knows to call get_send_file_max_age on the app,</span>
<span class="gi">+        # call it here so it works for blueprints too.</span>
<span class="gi">+        max_age = self.get_send_file_max_age(filename)</span>
<span class="gi">+        return send_from_directory(</span>
<span class="gi">+            t.cast(str, self.static_folder), filename, max_age=max_age</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def open_resource(self, resource: str, mode: str = &quot;rb&quot;) -&gt; t.IO[t.AnyStr]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Open a resource file relative to :attr:`root_path` for
<span class="w"> </span>        reading.

<span class="gu">@@ -81,4 +123,7 @@ class Blueprint(SansioBlueprint):</span>
<span class="w"> </span>        class.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mode not in {&quot;r&quot;, &quot;rt&quot;, &quot;rb&quot;}:</span>
<span class="gi">+            raise ValueError(&quot;Resources can only be opened for reading.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return open(os.path.join(self.root_path, resource), mode)</span>
<span class="gh">diff --git a/src/flask/cli.py b/src/flask/cli.py</span>
<span class="gh">index f98c3984..ecb292a0 100644</span>
<span class="gd">--- a/src/flask/cli.py</span>
<span class="gi">+++ b/src/flask/cli.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>import collections.abc as cabc
<span class="w"> </span>import importlib.metadata
<span class="gu">@@ -12,19 +13,24 @@ import typing as t</span>
<span class="w"> </span>from functools import update_wrapper
<span class="w"> </span>from operator import itemgetter
<span class="w"> </span>from types import ModuleType
<span class="gi">+</span>
<span class="w"> </span>import click
<span class="w"> </span>from click.core import ParameterSource
<span class="w"> </span>from werkzeug import run_simple
<span class="w"> </span>from werkzeug.serving import is_running_from_reloader
<span class="w"> </span>from werkzeug.utils import import_string
<span class="gi">+</span>
<span class="w"> </span>from .globals import current_app
<span class="w"> </span>from .helpers import get_debug_flag
<span class="w"> </span>from .helpers import get_load_dotenv
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import ssl
<span class="gi">+</span>
<span class="w"> </span>    from _typeshed.wsgi import StartResponse
<span class="w"> </span>    from _typeshed.wsgi import WSGIApplication
<span class="w"> </span>    from _typeshed.wsgi import WSGIEnvironment
<span class="gi">+</span>
<span class="w"> </span>    from .app import Flask


<span class="gu">@@ -32,14 +38,60 @@ class NoAppException(click.UsageError):</span>
<span class="w"> </span>    &quot;&quot;&quot;Raised if an application cannot be found or loaded.&quot;&quot;&quot;


<span class="gd">-def find_best_app(module: ModuleType) -&gt;Flask:</span>
<span class="gi">+def find_best_app(module: ModuleType) -&gt; Flask:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a module instance this tries to find the best possible
<span class="w"> </span>    application in the module or raises an exception.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from . import Flask</span>
<span class="gi">+</span>
<span class="gi">+    # Search for the most common names first.</span>
<span class="gi">+    for attr_name in (&quot;app&quot;, &quot;application&quot;):</span>
<span class="gi">+        app = getattr(module, attr_name, None)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(app, Flask):</span>
<span class="gi">+            return app</span>
<span class="gi">+</span>
<span class="gi">+    # Otherwise find the only object that is a Flask instance.</span>
<span class="gi">+    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]</span>
<span class="gi">+</span>
<span class="gi">+    if len(matches) == 1:</span>
<span class="gi">+        return matches[0]</span>
<span class="gi">+    elif len(matches) &gt; 1:</span>
<span class="gi">+        raise NoAppException(</span>
<span class="gi">+            &quot;Detected multiple Flask applications in module&quot;</span>
<span class="gi">+            f&quot; &#39;{module.__name__}&#39;. Use &#39;{module.__name__}:name&#39;&quot;</span>
<span class="gi">+            &quot; to specify the correct one.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Search for app factory functions.</span>
<span class="gi">+    for attr_name in (&quot;create_app&quot;, &quot;make_app&quot;):</span>
<span class="gi">+        app_factory = getattr(module, attr_name, None)</span>
<span class="gi">+</span>
<span class="gi">+        if inspect.isfunction(app_factory):</span>
<span class="gi">+            try:</span>
<span class="gi">+                app = app_factory()</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(app, Flask):</span>
<span class="gi">+                    return app</span>
<span class="gi">+            except TypeError as e:</span>
<span class="gi">+                if not _called_with_wrong_args(app_factory):</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+                raise NoAppException(</span>
<span class="gi">+                    f&quot;Detected factory &#39;{attr_name}&#39; in module &#39;{module.__name__}&#39;,&quot;</span>
<span class="gi">+                    &quot; but could not call it without arguments. Use&quot;</span>
<span class="gi">+                    f&quot; &#39;{module.__name__}:{attr_name}(args)&#39;&quot;</span>
<span class="gi">+                    &quot; to specify arguments.&quot;</span>
<span class="gi">+                ) from e</span>
<span class="gi">+</span>
<span class="gi">+    raise NoAppException(</span>
<span class="gi">+        &quot;Failed to find Flask application or factory in module&quot;</span>
<span class="gi">+        f&quot; &#39;{module.__name__}&#39;. Use &#39;{module.__name__}:name&#39;&quot;</span>
<span class="gi">+        &quot; to specify one.&quot;</span>
<span class="gi">+    )</span>


<span class="gd">-def _called_with_wrong_args(f: t.Callable[..., Flask]) -&gt;bool:</span>
<span class="gi">+def _called_with_wrong_args(f: t.Callable[..., Flask]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check whether calling a function raised a ``TypeError`` because
<span class="w"> </span>    the call failed or because something in the factory raised the
<span class="w"> </span>    error.
<span class="gu">@@ -47,25 +99,195 @@ def _called_with_wrong_args(f: t.Callable[..., Flask]) -&gt;bool:</span>
<span class="w"> </span>    :param f: The function that was called.
<span class="w"> </span>    :return: ``True`` if the call failed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tb = sys.exc_info()[2]</span>

<span class="gi">+    try:</span>
<span class="gi">+        while tb is not None:</span>
<span class="gi">+            if tb.tb_frame.f_code is f.__code__:</span>
<span class="gi">+                # In the function, it was called successfully.</span>
<span class="gi">+                return False</span>

<span class="gd">-def find_app_by_string(module: ModuleType, app_name: str) -&gt;Flask:</span>
<span class="gi">+            tb = tb.tb_next</span>
<span class="gi">+</span>
<span class="gi">+        # Didn&#39;t reach the function.</span>
<span class="gi">+        return True</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # Delete tb to break a circular reference.</span>
<span class="gi">+        # https://docs.python.org/2/library/sys.html#sys.exc_info</span>
<span class="gi">+        del tb</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_app_by_string(module: ModuleType, app_name: str) -&gt; Flask:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given string is a variable name or a function. Call
<span class="w"> </span>    a function to get the app instance, or return the variable directly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from . import Flask</span>
<span class="gi">+</span>
<span class="gi">+    # Parse app_name as a single expression to determine if it&#39;s a valid</span>
<span class="gi">+    # attribute name or function call.</span>
<span class="gi">+    try:</span>
<span class="gi">+        expr = ast.parse(app_name.strip(), mode=&quot;eval&quot;).body</span>
<span class="gi">+    except SyntaxError:</span>
<span class="gi">+        raise NoAppException(</span>
<span class="gi">+            f&quot;Failed to parse {app_name!r} as an attribute name or function call.&quot;</span>
<span class="gi">+        ) from None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(expr, ast.Name):</span>
<span class="gi">+        name = expr.id</span>
<span class="gi">+        args = []</span>
<span class="gi">+        kwargs = {}</span>
<span class="gi">+    elif isinstance(expr, ast.Call):</span>
<span class="gi">+        # Ensure the function name is an attribute name only.</span>
<span class="gi">+        if not isinstance(expr.func, ast.Name):</span>
<span class="gi">+            raise NoAppException(</span>
<span class="gi">+                f&quot;Function reference must be a simple name: {app_name!r}.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        name = expr.func.id</span>
<span class="gi">+</span>
<span class="gi">+        # Parse the positional and keyword arguments as literals.</span>
<span class="gi">+        try:</span>
<span class="gi">+            args = [ast.literal_eval(arg) for arg in expr.args]</span>
<span class="gi">+            kwargs = {</span>
<span class="gi">+                kw.arg: ast.literal_eval(kw.value)</span>
<span class="gi">+                for kw in expr.keywords</span>
<span class="gi">+                if kw.arg is not None</span>
<span class="gi">+            }</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            # literal_eval gives cryptic error messages, show a generic</span>
<span class="gi">+            # message with the full expression instead.</span>
<span class="gi">+            raise NoAppException(</span>
<span class="gi">+                f&quot;Failed to parse arguments as literal values: {app_name!r}.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NoAppException(</span>
<span class="gi">+            f&quot;Failed to parse {app_name!r} as an attribute name or function call.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        attr = getattr(module, name)</span>
<span class="gi">+    except AttributeError as e:</span>
<span class="gi">+        raise NoAppException(</span>
<span class="gi">+            f&quot;Failed to find attribute {name!r} in {module.__name__!r}.&quot;</span>
<span class="gi">+        ) from e</span>
<span class="gi">+</span>
<span class="gi">+    # If the attribute is a function, call it with any args and kwargs</span>
<span class="gi">+    # to get the real application.</span>
<span class="gi">+    if inspect.isfunction(attr):</span>
<span class="gi">+        try:</span>
<span class="gi">+            app = attr(*args, **kwargs)</span>
<span class="gi">+        except TypeError as e:</span>
<span class="gi">+            if not _called_with_wrong_args(attr):</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            raise NoAppException(</span>
<span class="gi">+                f&quot;The factory {app_name!r} in module&quot;</span>
<span class="gi">+                f&quot; {module.__name__!r} could not be called with the&quot;</span>
<span class="gi">+                &quot; specified arguments.&quot;</span>
<span class="gi">+            ) from e</span>
<span class="gi">+    else:</span>
<span class="gi">+        app = attr</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(app, Flask):</span>
<span class="gi">+        return app</span>
<span class="gi">+</span>
<span class="gi">+    raise NoAppException(</span>
<span class="gi">+        &quot;A valid Flask application was not obtained from&quot;</span>
<span class="gi">+        f&quot; &#39;{module.__name__}:{app_name}&#39;.&quot;</span>
<span class="gi">+    )</span>


<span class="gd">-def prepare_import(path: str) -&gt;str:</span>
<span class="gi">+def prepare_import(path: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a filename this will try to calculate the python path, add it
<span class="w"> </span>    to the search path and return the actual module name that is expected.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = os.path.realpath(path)</span>
<span class="gi">+</span>
<span class="gi">+    fname, ext = os.path.splitext(path)</span>
<span class="gi">+    if ext == &quot;.py&quot;:</span>
<span class="gi">+        path = fname</span>
<span class="gi">+</span>
<span class="gi">+    if os.path.basename(path) == &quot;__init__&quot;:</span>
<span class="gi">+        path = os.path.dirname(path)</span>
<span class="gi">+</span>
<span class="gi">+    module_name = []</span>
<span class="gi">+</span>
<span class="gi">+    # move up until outside package structure (no __init__.py)</span>
<span class="gi">+    while True:</span>
<span class="gi">+        path, name = os.path.split(path)</span>
<span class="gi">+        module_name.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        if not os.path.exists(os.path.join(path, &quot;__init__.py&quot;)):</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    if sys.path[0] != path:</span>
<span class="gi">+        sys.path.insert(0, path)</span>
<span class="gi">+</span>
<span class="gi">+    return &quot;.&quot;.join(module_name[::-1])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def locate_app(</span>
<span class="gi">+    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True</span>
<span class="gi">+) -&gt; Flask: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@t.overload</span>
<span class="gi">+def locate_app(</span>
<span class="gi">+    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[False] = ...</span>
<span class="gi">+) -&gt; Flask | None: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def locate_app(</span>
<span class="gi">+    module_name: str, app_name: str | None, raise_if_not_found: bool = True</span>
<span class="gi">+) -&gt; Flask | None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        __import__(module_name)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        # Reraise the ImportError if it occurred within the imported module.</span>
<span class="gi">+        # Determine this by checking whether the trace has a depth &gt; 1.</span>
<span class="gi">+        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]</span>
<span class="gi">+            raise NoAppException(</span>
<span class="gi">+                f&quot;While importing {module_name!r}, an ImportError was&quot;</span>
<span class="gi">+                f&quot; raised:\n\n{traceback.format_exc()}&quot;</span>
<span class="gi">+            ) from None</span>
<span class="gi">+        elif raise_if_not_found:</span>
<span class="gi">+            raise NoAppException(f&quot;Could not import {module_name!r}.&quot;) from None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    module = sys.modules[module_name]</span>

<span class="gi">+    if app_name is None:</span>
<span class="gi">+        return find_best_app(module)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return find_app_by_string(module, app_name)</span>

<span class="gd">-version_option = click.Option([&#39;--version&#39;], help=&#39;Show the Flask version.&#39;,</span>
<span class="gd">-    expose_value=False, callback=get_version, is_flag=True, is_eager=True)</span>
<span class="gi">+</span>
<span class="gi">+def get_version(ctx: click.Context, param: click.Parameter, value: t.Any) -&gt; None:</span>
<span class="gi">+    if not value or ctx.resilient_parsing:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    flask_version = importlib.metadata.version(&quot;flask&quot;)</span>
<span class="gi">+    werkzeug_version = importlib.metadata.version(&quot;werkzeug&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    click.echo(</span>
<span class="gi">+        f&quot;Python {platform.python_version()}\n&quot;</span>
<span class="gi">+        f&quot;Flask {flask_version}\n&quot;</span>
<span class="gi">+        f&quot;Werkzeug {werkzeug_version}&quot;,</span>
<span class="gi">+        color=ctx.color,</span>
<span class="gi">+    )</span>
<span class="gi">+    ctx.exit()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+version_option = click.Option(</span>
<span class="gi">+    [&quot;--version&quot;],</span>
<span class="gi">+    help=&quot;Show the Flask version.&quot;,</span>
<span class="gi">+    expose_value=False,</span>
<span class="gi">+    callback=get_version,</span>
<span class="gi">+    is_flag=True,</span>
<span class="gi">+    is_eager=True,</span>
<span class="gi">+)</span>


<span class="w"> </span>class ScriptInfo:
<span class="gu">@@ -77,27 +299,71 @@ class ScriptInfo:</span>
<span class="w"> </span>    onwards as click object.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app_import_path: (str | None)=None, create_app: (t.</span>
<span class="gd">-        Callable[..., Flask] | None)=None, set_debug_flag: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        app_import_path: str | None = None,</span>
<span class="gi">+        create_app: t.Callable[..., Flask] | None = None,</span>
<span class="gi">+        set_debug_flag: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        #: Optionally the import path for the Flask application.</span>
<span class="w"> </span>        self.app_import_path = app_import_path
<span class="gi">+        #: Optionally a function that is passed the script info to create</span>
<span class="gi">+        #: the instance of the application.</span>
<span class="w"> </span>        self.create_app = create_app
<span class="gi">+        #: A dictionary with arbitrary data that can be associated with</span>
<span class="gi">+        #: this script info.</span>
<span class="w"> </span>        self.data: dict[t.Any, t.Any] = {}
<span class="w"> </span>        self.set_debug_flag = set_debug_flag
<span class="w"> </span>        self._loaded_app: Flask | None = None

<span class="gd">-    def load_app(self) -&gt;Flask:</span>
<span class="gi">+    def load_app(self) -&gt; Flask:</span>
<span class="w"> </span>        &quot;&quot;&quot;Loads the Flask app (if not yet loaded) and returns it.  Calling
<span class="w"> </span>        this multiple times will just result in the already loaded app to
<span class="w"> </span>        be returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._loaded_app is not None:</span>
<span class="gi">+            return self._loaded_app</span>
<span class="gi">+</span>
<span class="gi">+        if self.create_app is not None:</span>
<span class="gi">+            app: Flask | None = self.create_app()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.app_import_path:</span>
<span class="gi">+                path, name = (</span>
<span class="gi">+                    re.split(r&quot;:(?![\\/])&quot;, self.app_import_path, maxsplit=1) + [None]</span>
<span class="gi">+                )[:2]</span>
<span class="gi">+                import_name = prepare_import(path)</span>
<span class="gi">+                app = locate_app(import_name, name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for path in (&quot;wsgi.py&quot;, &quot;app.py&quot;):</span>
<span class="gi">+                    import_name = prepare_import(path)</span>
<span class="gi">+                    app = locate_app(import_name, None, raise_if_not_found=False)</span>
<span class="gi">+</span>
<span class="gi">+                    if app is not None:</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+        if app is None:</span>
<span class="gi">+            raise NoAppException(</span>
<span class="gi">+                &quot;Could not locate a Flask application. Use the&quot;</span>
<span class="gi">+                &quot; &#39;flask --app&#39; option, &#39;FLASK_APP&#39; environment&quot;</span>
<span class="gi">+                &quot; variable, or a &#39;wsgi.py&#39; or &#39;app.py&#39; file in the&quot;</span>
<span class="gi">+                &quot; current directory.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self.set_debug_flag:</span>
<span class="gi">+            # Update the app&#39;s debug flag through the descriptor so that</span>
<span class="gi">+            # other values repopulate as well.</span>
<span class="gi">+            app.debug = get_debug_flag()</span>
<span class="gi">+</span>
<span class="gi">+        self._loaded_app = app</span>
<span class="gi">+        return app</span>


<span class="w"> </span>pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>

<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>

<span class="gd">-def with_appcontext(f: F) -&gt;F:</span>
<span class="gi">+</span>
<span class="gi">+def with_appcontext(f: F) -&gt; F:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wraps a callback so that it&#39;s guaranteed to be executed with the
<span class="w"> </span>    script&#39;s application context.

<span class="gu">@@ -110,7 +376,16 @@ def with_appcontext(f: F) -&gt;F:</span>
<span class="w"> </span>        decorated callback. The app context is always available to
<span class="w"> </span>        ``app.cli`` command and parameter callbacks.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    @click.pass_context</span>
<span class="gi">+    def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="gi">+        if not current_app:</span>
<span class="gi">+            app = ctx.ensure_object(ScriptInfo).load_app()</span>
<span class="gi">+            ctx.with_resource(app.app_context())</span>
<span class="gi">+</span>
<span class="gi">+        return ctx.invoke(f, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return update_wrapper(decorator, f)  # type: ignore[return-value]</span>


<span class="w"> </span>class AppGroup(click.Group):
<span class="gu">@@ -121,32 +396,119 @@ class AppGroup(click.Group):</span>
<span class="w"> </span>    Not to be confused with :class:`FlaskGroup`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def command(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Callable[[t.</span>
<span class="gd">-        Callable[..., t.Any]], click.Command]:</span>
<span class="gi">+    def command(  # type: ignore[override]</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Callable[[t.Callable[..., t.Any]], click.Command]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This works exactly like the method of the same name on a regular
<span class="w"> </span>        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
<span class="w"> </span>        unless it&#39;s disabled by passing ``with_appcontext=False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        wrap_for_ctx = kwargs.pop(&quot;with_appcontext&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: t.Callable[..., t.Any]) -&gt; click.Command:</span>
<span class="gi">+            if wrap_for_ctx:</span>
<span class="gi">+                f = with_appcontext(f)</span>
<span class="gi">+            return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]</span>

<span class="gd">-    def group(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Callable[[t.Callable</span>
<span class="gd">-        [..., t.Any]], click.Group]:</span>
<span class="gi">+        return decorator</span>
<span class="gi">+</span>
<span class="gi">+    def group(  # type: ignore[override]</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Callable[[t.Callable[..., t.Any]], click.Group]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This works exactly like the method of the same name on a regular
<span class="w"> </span>        :class:`click.Group` but it defaults the group class to
<span class="w"> </span>        :class:`AppGroup`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_app_option = click.Option([&#39;-A&#39;, &#39;--app&#39;], metavar=&#39;IMPORT&#39;, help=</span>
<span class="gd">-    &quot;The Flask application or factory function to load, in the form &#39;module:name&#39;. Module can be a dotted import or file path. Name is not required if it is &#39;app&#39;, &#39;application&#39;, &#39;create_app&#39;, or &#39;make_app&#39;, and can be &#39;name(args)&#39; to pass arguments.&quot;</span>
<span class="gd">-    , is_eager=True, expose_value=False, callback=_set_app)</span>
<span class="gd">-_debug_option = click.Option([&#39;--debug/--no-debug&#39;], help=&#39;Set debug mode.&#39;,</span>
<span class="gd">-    expose_value=False, callback=_set_debug)</span>
<span class="gd">-_env_file_option = click.Option([&#39;-e&#39;, &#39;--env-file&#39;], type=click.Path(</span>
<span class="gd">-    exists=True, dir_okay=False), help=</span>
<span class="gd">-    &#39;Load environment variables from this file. python-dotenv must be installed.&#39;</span>
<span class="gd">-    , is_eager=True, expose_value=False, callback=_env_file_callback)</span>
<span class="gi">+        kwargs.setdefault(&quot;cls&quot;, AppGroup)</span>
<span class="gi">+        return super().group(*args, **kwargs)  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _set_app(ctx: click.Context, param: click.Option, value: str | None) -&gt; str | None:</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    info = ctx.ensure_object(ScriptInfo)</span>
<span class="gi">+    info.app_import_path = value</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This option is eager so the app will be available if --help is given.</span>
<span class="gi">+# --help is also eager, so --app must be before it in the param list.</span>
<span class="gi">+# no_args_is_help bypasses eager processing, so this option must be</span>
<span class="gi">+# processed manually in that case to ensure FLASK_APP gets picked up.</span>
<span class="gi">+_app_option = click.Option(</span>
<span class="gi">+    [&quot;-A&quot;, &quot;--app&quot;],</span>
<span class="gi">+    metavar=&quot;IMPORT&quot;,</span>
<span class="gi">+    help=(</span>
<span class="gi">+        &quot;The Flask application or factory function to load, in the form &#39;module:name&#39;.&quot;</span>
<span class="gi">+        &quot; Module can be a dotted import or file path. Name is not required if it is&quot;</span>
<span class="gi">+        &quot; &#39;app&#39;, &#39;application&#39;, &#39;create_app&#39;, or &#39;make_app&#39;, and can be &#39;name(args)&#39; to&quot;</span>
<span class="gi">+        &quot; pass arguments.&quot;</span>
<span class="gi">+    ),</span>
<span class="gi">+    is_eager=True,</span>
<span class="gi">+    expose_value=False,</span>
<span class="gi">+    callback=_set_app,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _set_debug(ctx: click.Context, param: click.Option, value: bool) -&gt; bool | None:</span>
<span class="gi">+    # If the flag isn&#39;t provided, it will default to False. Don&#39;t use</span>
<span class="gi">+    # that, let debug be set by env in that case.</span>
<span class="gi">+    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+    if source is not None and source in (</span>
<span class="gi">+        ParameterSource.DEFAULT,</span>
<span class="gi">+        ParameterSource.DEFAULT_MAP,</span>
<span class="gi">+    ):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # Set with env var instead of ScriptInfo.load so that it can be</span>
<span class="gi">+    # accessed early during a factory function.</span>
<span class="gi">+    os.environ[&quot;FLASK_DEBUG&quot;] = &quot;1&quot; if value else &quot;0&quot;</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_debug_option = click.Option(</span>
<span class="gi">+    [&quot;--debug/--no-debug&quot;],</span>
<span class="gi">+    help=&quot;Set debug mode.&quot;,</span>
<span class="gi">+    expose_value=False,</span>
<span class="gi">+    callback=_set_debug,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _env_file_callback(</span>
<span class="gi">+    ctx: click.Context, param: click.Option, value: str | None</span>
<span class="gi">+) -&gt; str | None:</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    import importlib</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        importlib.import_module(&quot;dotenv&quot;)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        raise click.BadParameter(</span>
<span class="gi">+            &quot;python-dotenv must be installed to load an env file.&quot;,</span>
<span class="gi">+            ctx=ctx,</span>
<span class="gi">+            param=param,</span>
<span class="gi">+        ) from None</span>
<span class="gi">+</span>
<span class="gi">+    # Don&#39;t check FLASK_SKIP_DOTENV, that only disables automatically</span>
<span class="gi">+    # loading .env and .flaskenv files.</span>
<span class="gi">+    load_dotenv(value)</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This option is eager so env vars are loaded as early as possible to be</span>
<span class="gi">+# used by other options.</span>
<span class="gi">+_env_file_option = click.Option(</span>
<span class="gi">+    [&quot;-e&quot;, &quot;--env-file&quot;],</span>
<span class="gi">+    type=click.Path(exists=True, dir_okay=False),</span>
<span class="gi">+    help=&quot;Load environment variables from this file. python-dotenv must be installed.&quot;,</span>
<span class="gi">+    is_eager=True,</span>
<span class="gi">+    expose_value=False,</span>
<span class="gi">+    callback=_env_file_callback,</span>
<span class="gi">+)</span>


<span class="w"> </span>class FlaskGroup(AppGroup):
<span class="gu">@@ -178,36 +540,151 @@ class FlaskGroup(AppGroup):</span>
<span class="w"> </span>        from :file:`.env` and :file:`.flaskenv` files.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, add_default_commands: bool=True, create_app: (t.</span>
<span class="gd">-        Callable[..., Flask] | None)=None, add_version_option: bool=True,</span>
<span class="gd">-        load_dotenv: bool=True, set_debug_flag: bool=True, **extra: t.Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gd">-        params = list(extra.pop(&#39;params&#39;, None) or ())</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        add_default_commands: bool = True,</span>
<span class="gi">+        create_app: t.Callable[..., Flask] | None = None,</span>
<span class="gi">+        add_version_option: bool = True,</span>
<span class="gi">+        load_dotenv: bool = True,</span>
<span class="gi">+        set_debug_flag: bool = True,</span>
<span class="gi">+        **extra: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        params = list(extra.pop(&quot;params&quot;, None) or ())</span>
<span class="gi">+        # Processing is done with option callbacks instead of a group</span>
<span class="gi">+        # callback. This allows users to make a custom group callback</span>
<span class="gi">+        # without losing the behavior. --env-file must come first so</span>
<span class="gi">+        # that it is eagerly evaluated before --app.</span>
<span class="w"> </span>        params.extend((_env_file_option, _app_option, _debug_option))
<span class="gi">+</span>
<span class="w"> </span>        if add_version_option:
<span class="w"> </span>            params.append(version_option)
<span class="gd">-        if &#39;context_settings&#39; not in extra:</span>
<span class="gd">-            extra[&#39;context_settings&#39;] = {}</span>
<span class="gd">-        extra[&#39;context_settings&#39;].setdefault(&#39;auto_envvar_prefix&#39;, &#39;FLASK&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;context_settings&quot; not in extra:</span>
<span class="gi">+            extra[&quot;context_settings&quot;] = {}</span>
<span class="gi">+</span>
<span class="gi">+        extra[&quot;context_settings&quot;].setdefault(&quot;auto_envvar_prefix&quot;, &quot;FLASK&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(params=params, **extra)
<span class="gi">+</span>
<span class="w"> </span>        self.create_app = create_app
<span class="w"> </span>        self.load_dotenv = load_dotenv
<span class="w"> </span>        self.set_debug_flag = set_debug_flag
<span class="gi">+</span>
<span class="w"> </span>        if add_default_commands:
<span class="w"> </span>            self.add_command(run_command)
<span class="w"> </span>            self.add_command(shell_command)
<span class="w"> </span>            self.add_command(routes_command)
<span class="gd">-        self._loaded_plugin_commands = False</span>

<span class="gi">+        self._loaded_plugin_commands = False</span>

<span class="gd">-def _path_is_ancestor(path: str, other: str) -&gt;bool:</span>
<span class="gi">+    def _load_plugin_commands(self) -&gt; None:</span>
<span class="gi">+        if self._loaded_plugin_commands:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if sys.version_info &gt;= (3, 10):</span>
<span class="gi">+            from importlib import metadata</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Use a backport on Python &lt; 3.10. We technically have</span>
<span class="gi">+            # importlib.metadata on 3.8+, but the API changed in 3.10,</span>
<span class="gi">+            # so use the backport for consistency.</span>
<span class="gi">+            import importlib_metadata as metadata</span>
<span class="gi">+</span>
<span class="gi">+        for ep in metadata.entry_points(group=&quot;flask.commands&quot;):</span>
<span class="gi">+            self.add_command(ep.load(), ep.name)</span>
<span class="gi">+</span>
<span class="gi">+        self._loaded_plugin_commands = True</span>
<span class="gi">+</span>
<span class="gi">+    def get_command(self, ctx: click.Context, name: str) -&gt; click.Command | None:</span>
<span class="gi">+        self._load_plugin_commands()</span>
<span class="gi">+        # Look up built-in and plugin commands, which should be</span>
<span class="gi">+        # available even if the app fails to load.</span>
<span class="gi">+        rv = super().get_command(ctx, name)</span>
<span class="gi">+</span>
<span class="gi">+        if rv is not None:</span>
<span class="gi">+            return rv</span>
<span class="gi">+</span>
<span class="gi">+        info = ctx.ensure_object(ScriptInfo)</span>
<span class="gi">+</span>
<span class="gi">+        # Look up commands provided by the app, showing an error and</span>
<span class="gi">+        # continuing if the app couldn&#39;t be loaded.</span>
<span class="gi">+        try:</span>
<span class="gi">+            app = info.load_app()</span>
<span class="gi">+        except NoAppException as e:</span>
<span class="gi">+            click.secho(f&quot;Error: {e.format_message()}\n&quot;, err=True, fg=&quot;red&quot;)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # Push an app context for the loaded app unless it is already</span>
<span class="gi">+        # active somehow. This makes the context available to parameter</span>
<span class="gi">+        # and command callbacks without needing @with_appcontext.</span>
<span class="gi">+        if not current_app or current_app._get_current_object() is not app:  # type: ignore[attr-defined]</span>
<span class="gi">+            ctx.with_resource(app.app_context())</span>
<span class="gi">+</span>
<span class="gi">+        return app.cli.get_command(ctx, name)</span>
<span class="gi">+</span>
<span class="gi">+    def list_commands(self, ctx: click.Context) -&gt; list[str]:</span>
<span class="gi">+        self._load_plugin_commands()</span>
<span class="gi">+        # Start with the built-in and plugin commands.</span>
<span class="gi">+        rv = set(super().list_commands(ctx))</span>
<span class="gi">+        info = ctx.ensure_object(ScriptInfo)</span>
<span class="gi">+</span>
<span class="gi">+        # Add commands provided by the app, showing an error and</span>
<span class="gi">+        # continuing if the app couldn&#39;t be loaded.</span>
<span class="gi">+        try:</span>
<span class="gi">+            rv.update(info.load_app().cli.list_commands(ctx))</span>
<span class="gi">+        except NoAppException as e:</span>
<span class="gi">+            # When an app couldn&#39;t be loaded, show the error message</span>
<span class="gi">+            # without the traceback.</span>
<span class="gi">+            click.secho(f&quot;Error: {e.format_message()}\n&quot;, err=True, fg=&quot;red&quot;)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # When any other errors occurred during loading, show the</span>
<span class="gi">+            # full traceback.</span>
<span class="gi">+            click.secho(f&quot;{traceback.format_exc()}\n&quot;, err=True, fg=&quot;red&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return sorted(rv)</span>
<span class="gi">+</span>
<span class="gi">+    def make_context(</span>
<span class="gi">+        self,</span>
<span class="gi">+        info_name: str | None,</span>
<span class="gi">+        args: list[str],</span>
<span class="gi">+        parent: click.Context | None = None,</span>
<span class="gi">+        **extra: t.Any,</span>
<span class="gi">+    ) -&gt; click.Context:</span>
<span class="gi">+        # Set a flag to tell app.run to become a no-op. If app.run was</span>
<span class="gi">+        # not in a __name__ == __main__ guard, it would start the server</span>
<span class="gi">+        # when importing, blocking whatever command is being called.</span>
<span class="gi">+        os.environ[&quot;FLASK_RUN_FROM_CLI&quot;] = &quot;true&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Attempt to load .env and .flask env files. The --env-file</span>
<span class="gi">+        # option can cause another file to be loaded.</span>
<span class="gi">+        if get_load_dotenv(self.load_dotenv):</span>
<span class="gi">+            load_dotenv()</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;obj&quot; not in extra and &quot;obj&quot; not in self.context_settings:</span>
<span class="gi">+            extra[&quot;obj&quot;] = ScriptInfo(</span>
<span class="gi">+                create_app=self.create_app, set_debug_flag=self.set_debug_flag</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return super().make_context(info_name, args, parent=parent, **extra)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_args(self, ctx: click.Context, args: list[str]) -&gt; list[str]:</span>
<span class="gi">+        if not args and self.no_args_is_help:</span>
<span class="gi">+            # Attempt to load --env-file and --app early in case they</span>
<span class="gi">+            # were given as env vars. Otherwise no_args_is_help will not</span>
<span class="gi">+            # see commands from app.cli.</span>
<span class="gi">+            _env_file_option.handle_parse_result(ctx, {}, [])</span>
<span class="gi">+            _app_option.handle_parse_result(ctx, {}, [])</span>
<span class="gi">+</span>
<span class="gi">+        return super().parse_args(ctx, args)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _path_is_ancestor(path: str, other: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Take ``other`` and remove the length of ``path`` from it. Then join it
<span class="w"> </span>    to ``path``. If it is the original value, ``path`` is an ancestor of
<span class="w"> </span>    ``other``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other</span>


<span class="gd">-def load_dotenv(path: (str | os.PathLike[str] | None)=None) -&gt;bool:</span>
<span class="gi">+def load_dotenv(path: str | os.PathLike[str] | None = None) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Load &quot;dotenv&quot; files in order of precedence to set environment variables.

<span class="w"> </span>    If an env var is already set it is not overwritten, so earlier files in the
<span class="gu">@@ -233,14 +710,53 @@ def load_dotenv(path: (str | os.PathLike[str] | None)=None) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        import dotenv</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        if path or os.path.isfile(&quot;.env&quot;) or os.path.isfile(&quot;.flaskenv&quot;):</span>
<span class="gi">+            click.secho(</span>
<span class="gi">+                &quot; * Tip: There are .env or .flaskenv files present.&quot;</span>
<span class="gi">+                &#39; Do &quot;pip install python-dotenv&quot; to use them.&#39;,</span>
<span class="gi">+                fg=&quot;yellow&quot;,</span>
<span class="gi">+                err=True,</span>
<span class="gi">+            )</span>

<span class="gi">+        return False</span>

<span class="gd">-def show_server_banner(debug: bool, app_import_path: (str | None)) -&gt;None:</span>
<span class="gi">+    # Always return after attempting to load a given path, don&#39;t load</span>
<span class="gi">+    # the default files.</span>
<span class="gi">+    if path is not None:</span>
<span class="gi">+        if os.path.isfile(path):</span>
<span class="gi">+            return dotenv.load_dotenv(path, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    loaded = False</span>
<span class="gi">+</span>
<span class="gi">+    for name in (&quot;.env&quot;, &quot;.flaskenv&quot;):</span>
<span class="gi">+        path = dotenv.find_dotenv(name, usecwd=True)</span>
<span class="gi">+</span>
<span class="gi">+        if not path:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        dotenv.load_dotenv(path, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        loaded = True</span>
<span class="gi">+</span>
<span class="gi">+    return loaded  # True if at least one file was located and loaded.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def show_server_banner(debug: bool, app_import_path: str | None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Show extra startup messages the first time the server is run,
<span class="w"> </span>    ignoring the reloader.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_running_from_reloader():</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if app_import_path is not None:</span>
<span class="gi">+        click.echo(f&quot; * Serving Flask app &#39;{app_import_path}&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if debug is not None:</span>
<span class="gi">+        click.echo(f&quot; * Debug mode: {&#39;on&#39; if debug else &#39;off&#39;}&quot;)</span>


<span class="w"> </span>class CertParamType(click.ParamType):
<span class="gu">@@ -248,19 +764,86 @@ class CertParamType(click.ParamType):</span>
<span class="w"> </span>    existing file, the string ``&#39;adhoc&#39;``, or an import for a
<span class="w"> </span>    :class:`~ssl.SSLContext` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;path&#39;</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.path_type = click.Path(exists=True, dir_okay=False,</span>
<span class="gd">-            resolve_path=True)</span>
<span class="gi">+    name = &quot;path&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)</span>
<span class="gi">+</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        try:</span>
<span class="gi">+            import ssl</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            raise click.BadParameter(</span>
<span class="gi">+                &#39;Using &quot;--cert&quot; requires Python to be compiled with SSL support.&#39;,</span>
<span class="gi">+                ctx,</span>
<span class="gi">+                param,</span>
<span class="gi">+            ) from None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.path_type(value, param, ctx)</span>
<span class="gi">+        except click.BadParameter:</span>
<span class="gi">+            value = click.STRING(value, param, ctx).lower()</span>

<span class="gi">+            if value == &quot;adhoc&quot;:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    import cryptography  # noqa: F401</span>
<span class="gi">+                except ImportError:</span>
<span class="gi">+                    raise click.BadParameter(</span>
<span class="gi">+                        &quot;Using ad-hoc certificates requires the cryptography library.&quot;,</span>
<span class="gi">+                        ctx,</span>
<span class="gi">+                        param,</span>
<span class="gi">+                    ) from None</span>

<span class="gd">-def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any</span>
<span class="gd">-    ) -&gt;t.Any:</span>
<span class="gi">+                return value</span>
<span class="gi">+</span>
<span class="gi">+            obj = import_string(value, silent=True)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(obj, ssl.SSLContext):</span>
<span class="gi">+                return obj</span>
<span class="gi">+</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;The ``--key`` option must be specified when ``--cert`` is a file.
<span class="w"> </span>    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cert = ctx.params.get(&quot;cert&quot;)</span>
<span class="gi">+    is_adhoc = cert == &quot;adhoc&quot;</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import ssl</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        is_context = False</span>
<span class="gi">+    else:</span>
<span class="gi">+        is_context = isinstance(cert, ssl.SSLContext)</span>
<span class="gi">+</span>
<span class="gi">+    if value is not None:</span>
<span class="gi">+        if is_adhoc:</span>
<span class="gi">+            raise click.BadParameter(</span>
<span class="gi">+                &#39;When &quot;--cert&quot; is &quot;adhoc&quot;, &quot;--key&quot; is not used.&#39;, ctx, param</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if is_context:</span>
<span class="gi">+            raise click.BadParameter(</span>
<span class="gi">+                &#39;When &quot;--cert&quot; is an SSLContext object, &quot;--key&quot; is not used.&#39;,</span>
<span class="gi">+                ctx,</span>
<span class="gi">+                param,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not cert:</span>
<span class="gi">+            raise click.BadParameter(&#39;&quot;--cert&quot; must also be specified.&#39;, ctx, param)</span>
<span class="gi">+</span>
<span class="gi">+        ctx.params[&quot;cert&quot;] = cert, value</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        if cert and not (is_adhoc or is_context):</span>
<span class="gi">+            raise click.BadParameter(&#39;Required when using &quot;--cert&quot;.&#39;, ctx, param)</span>
<span class="gi">+</span>
<span class="gi">+    return value</span>


<span class="w"> </span>class SeparatedPathType(click.Path):
<span class="gu">@@ -269,37 +852,79 @@ class SeparatedPathType(click.Path):</span>
<span class="w"> </span>    validated as a :class:`click.Path` type.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="gd">-@click.command(&#39;run&#39;, short_help=&#39;Run a development server.&#39;)</span>
<span class="gd">-@click.option(&#39;--host&#39;, &#39;-h&#39;, default=&#39;127.0.0.1&#39;, help=</span>
<span class="gd">-    &#39;The interface to bind to.&#39;)</span>
<span class="gd">-@click.option(&#39;--port&#39;, &#39;-p&#39;, default=5000, help=&#39;The port to bind to.&#39;)</span>
<span class="gd">-@click.option(&#39;--cert&#39;, type=CertParamType(), help=</span>
<span class="gd">-    &#39;Specify a certificate file to use HTTPS.&#39;, is_eager=True)</span>
<span class="gd">-@click.option(&#39;--key&#39;, type=click.Path(exists=True, dir_okay=False,</span>
<span class="gd">-    resolve_path=True), callback=_validate_key, expose_value=False, help=</span>
<span class="gd">-    &#39;The key file to use when specifying a certificate.&#39;)</span>
<span class="gd">-@click.option(&#39;--reload/--no-reload&#39;, default=None, help=</span>
<span class="gd">-    &#39;Enable or disable the reloader. By default the reloader is active if debug is enabled.&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-@click.option(&#39;--debugger/--no-debugger&#39;, default=None, help=</span>
<span class="gd">-    &#39;Enable or disable the debugger. By default the debugger is active if debug is enabled.&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-@click.option(&#39;--with-threads/--without-threads&#39;, default=True, help=</span>
<span class="gd">-    &#39;Enable or disable multithreading.&#39;)</span>
<span class="gd">-@click.option(&#39;--extra-files&#39;, default=None, type=SeparatedPathType(), help</span>
<span class="gd">-    =</span>
<span class="gd">-    f&#39;Extra files that trigger a reload on change. Multiple paths are separated by {os.path.pathsep!r}.&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-@click.option(&#39;--exclude-patterns&#39;, default=None, type=SeparatedPathType(),</span>
<span class="gd">-    help=</span>
<span class="gd">-    f&#39;Files matching these fnmatch patterns will not trigger a reload on change. Multiple patterns are separated by {os.path.pathsep!r}.&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    def convert(</span>
<span class="gi">+        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        items = self.split_envvar_value(value)</span>
<span class="gi">+        # can&#39;t call no-arg super() inside list comprehension until Python 3.12</span>
<span class="gi">+        super_convert = super().convert</span>
<span class="gi">+        return [super_convert(item, param, ctx) for item in items]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@click.command(&quot;run&quot;, short_help=&quot;Run a development server.&quot;)</span>
<span class="gi">+@click.option(&quot;--host&quot;, &quot;-h&quot;, default=&quot;127.0.0.1&quot;, help=&quot;The interface to bind to.&quot;)</span>
<span class="gi">+@click.option(&quot;--port&quot;, &quot;-p&quot;, default=5000, help=&quot;The port to bind to.&quot;)</span>
<span class="gi">+@click.option(</span>
<span class="gi">+    &quot;--cert&quot;,</span>
<span class="gi">+    type=CertParamType(),</span>
<span class="gi">+    help=&quot;Specify a certificate file to use HTTPS.&quot;,</span>
<span class="gi">+    is_eager=True,</span>
<span class="gi">+)</span>
<span class="gi">+@click.option(</span>
<span class="gi">+    &quot;--key&quot;,</span>
<span class="gi">+    type=click.Path(exists=True, dir_okay=False, resolve_path=True),</span>
<span class="gi">+    callback=_validate_key,</span>
<span class="gi">+    expose_value=False,</span>
<span class="gi">+    help=&quot;The key file to use when specifying a certificate.&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+@click.option(</span>
<span class="gi">+    &quot;--reload/--no-reload&quot;,</span>
<span class="gi">+    default=None,</span>
<span class="gi">+    help=&quot;Enable or disable the reloader. By default the reloader &quot;</span>
<span class="gi">+    &quot;is active if debug is enabled.&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+@click.option(</span>
<span class="gi">+    &quot;--debugger/--no-debugger&quot;,</span>
<span class="gi">+    default=None,</span>
<span class="gi">+    help=&quot;Enable or disable the debugger. By default the debugger &quot;</span>
<span class="gi">+    &quot;is active if debug is enabled.&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+@click.option(</span>
<span class="gi">+    &quot;--with-threads/--without-threads&quot;,</span>
<span class="gi">+    default=True,</span>
<span class="gi">+    help=&quot;Enable or disable multithreading.&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+@click.option(</span>
<span class="gi">+    &quot;--extra-files&quot;,</span>
<span class="gi">+    default=None,</span>
<span class="gi">+    type=SeparatedPathType(),</span>
<span class="gi">+    help=(</span>
<span class="gi">+        &quot;Extra files that trigger a reload on change. Multiple paths&quot;</span>
<span class="gi">+        f&quot; are separated by {os.path.pathsep!r}.&quot;</span>
<span class="gi">+    ),</span>
<span class="gi">+)</span>
<span class="gi">+@click.option(</span>
<span class="gi">+    &quot;--exclude-patterns&quot;,</span>
<span class="gi">+    default=None,</span>
<span class="gi">+    type=SeparatedPathType(),</span>
<span class="gi">+    help=(</span>
<span class="gi">+        &quot;Files matching these fnmatch patterns will not trigger a reload&quot;</span>
<span class="gi">+        &quot; on change. Multiple patterns are separated by&quot;</span>
<span class="gi">+        f&quot; {os.path.pathsep!r}.&quot;</span>
<span class="gi">+    ),</span>
<span class="gi">+)</span>
<span class="w"> </span>@pass_script_info
<span class="gd">-def run_command(info: ScriptInfo, host: str, port: int, reload: bool,</span>
<span class="gd">-    debugger: bool, with_threads: bool, cert: (ssl.SSLContext | tuple[str, </span>
<span class="gd">-    str | None] | t.Literal[&#39;adhoc&#39;] | None), extra_files: (list[str] |</span>
<span class="gd">-    None), exclude_patterns: (list[str] | None)) -&gt;None:</span>
<span class="gi">+def run_command(</span>
<span class="gi">+    info: ScriptInfo,</span>
<span class="gi">+    host: str,</span>
<span class="gi">+    port: int,</span>
<span class="gi">+    reload: bool,</span>
<span class="gi">+    debugger: bool,</span>
<span class="gi">+    with_threads: bool,</span>
<span class="gi">+    cert: ssl.SSLContext | tuple[str, str | None] | t.Literal[&quot;adhoc&quot;] | None,</span>
<span class="gi">+    extra_files: list[str] | None,</span>
<span class="gi">+    exclude_patterns: list[str] | None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Run a local development server.

<span class="w"> </span>    This server is for development purposes only. It does not provide
<span class="gu">@@ -308,15 +933,54 @@ def run_command(info: ScriptInfo, host: str, port: int, reload: bool,</span>
<span class="w"> </span>    The reloader and debugger are enabled by default with the &#39;--debug&#39;
<span class="w"> </span>    option.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        app: WSGIApplication = info.load_app()</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        if is_running_from_reloader():</span>
<span class="gi">+            # When reloading, print out the error immediately, but raise</span>
<span class="gi">+            # it later so the debugger or server can handle it.</span>
<span class="gi">+            traceback.print_exc()</span>
<span class="gi">+            err = e</span>
<span class="gi">+</span>
<span class="gi">+            def app(</span>
<span class="gi">+                environ: WSGIEnvironment, start_response: StartResponse</span>
<span class="gi">+            ) -&gt; cabc.Iterable[bytes]:</span>
<span class="gi">+                raise err from None</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # When not reloading, raise the error immediately so the</span>
<span class="gi">+            # command fails.</span>
<span class="gi">+            raise e from None</span>
<span class="gi">+</span>
<span class="gi">+    debug = get_debug_flag()</span>
<span class="gi">+</span>
<span class="gi">+    if reload is None:</span>
<span class="gi">+        reload = debug</span>
<span class="gi">+</span>
<span class="gi">+    if debugger is None:</span>
<span class="gi">+        debugger = debug</span>
<span class="gi">+</span>
<span class="gi">+    show_server_banner(debug, info.app_import_path)</span>
<span class="gi">+</span>
<span class="gi">+    run_simple(</span>
<span class="gi">+        host,</span>
<span class="gi">+        port,</span>
<span class="gi">+        app,</span>
<span class="gi">+        use_reloader=reload,</span>
<span class="gi">+        use_debugger=debugger,</span>
<span class="gi">+        threaded=with_threads,</span>
<span class="gi">+        ssl_context=cert,</span>
<span class="gi">+        extra_files=extra_files,</span>
<span class="gi">+        exclude_patterns=exclude_patterns,</span>
<span class="gi">+    )</span>


<span class="w"> </span>run_command.params.insert(0, _debug_option)


<span class="gd">-@click.command(&#39;shell&#39;, short_help=&#39;Run a shell in the app context.&#39;)</span>
<span class="gi">+@click.command(&quot;shell&quot;, short_help=&quot;Run a shell in the app context.&quot;)</span>
<span class="w"> </span>@with_appcontext
<span class="gd">-def shell_command() -&gt;None:</span>
<span class="gi">+def shell_command() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Run an interactive Python shell in the context of a given
<span class="w"> </span>    Flask application.  The application will populate the default
<span class="w"> </span>    namespace of this shell according to its configuration.
<span class="gu">@@ -324,29 +988,122 @@ def shell_command() -&gt;None:</span>
<span class="w"> </span>    This is useful for executing small snippets of management code
<span class="w"> </span>    without having to manually configure the application.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import code</span>

<span class="gd">-</span>
<span class="gd">-@click.command(&#39;routes&#39;, short_help=&#39;Show the routes for the app.&#39;)</span>
<span class="gd">-@click.option(&#39;--sort&#39;, &#39;-s&#39;, type=click.Choice((&#39;endpoint&#39;, &#39;methods&#39;,</span>
<span class="gd">-    &#39;domain&#39;, &#39;rule&#39;, &#39;match&#39;)), default=&#39;endpoint&#39;, help=</span>
<span class="gd">-    &quot;Method to sort routes by. &#39;match&#39; is the order that Flask will match routes when dispatching a request.&quot;</span>
<span class="gi">+    banner = (</span>
<span class="gi">+        f&quot;Python {sys.version} on {sys.platform}\n&quot;</span>
<span class="gi">+        f&quot;App: {current_app.import_name}\n&quot;</span>
<span class="gi">+        f&quot;Instance: {current_app.instance_path}&quot;</span>
<span class="w"> </span>    )
<span class="gd">-@click.option(&#39;--all-methods&#39;, is_flag=True, help=</span>
<span class="gd">-    &#39;Show HEAD and OPTIONS methods.&#39;)</span>
<span class="gi">+    ctx: dict[str, t.Any] = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Support the regular Python interpreter startup script if someone</span>
<span class="gi">+    # is using it.</span>
<span class="gi">+    startup = os.environ.get(&quot;PYTHONSTARTUP&quot;)</span>
<span class="gi">+    if startup and os.path.isfile(startup):</span>
<span class="gi">+        with open(startup) as f:</span>
<span class="gi">+            eval(compile(f.read(), startup, &quot;exec&quot;), ctx)</span>
<span class="gi">+</span>
<span class="gi">+    ctx.update(current_app.make_shell_context())</span>
<span class="gi">+</span>
<span class="gi">+    # Site, customize, or startup script can set a hook to call when</span>
<span class="gi">+    # entering interactive mode. The default one sets up readline with</span>
<span class="gi">+    # tab and history completion.</span>
<span class="gi">+    interactive_hook = getattr(sys, &quot;__interactivehook__&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    if interactive_hook is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            import readline</span>
<span class="gi">+            from rlcompleter import Completer</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            # rlcompleter uses __main__.__dict__ by default, which is</span>
<span class="gi">+            # flask.__main__. Use the shell context instead.</span>
<span class="gi">+            readline.set_completer(Completer(ctx).complete)</span>
<span class="gi">+</span>
<span class="gi">+        interactive_hook()</span>
<span class="gi">+</span>
<span class="gi">+    code.interact(banner=banner, local=ctx)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@click.command(&quot;routes&quot;, short_help=&quot;Show the routes for the app.&quot;)</span>
<span class="gi">+@click.option(</span>
<span class="gi">+    &quot;--sort&quot;,</span>
<span class="gi">+    &quot;-s&quot;,</span>
<span class="gi">+    type=click.Choice((&quot;endpoint&quot;, &quot;methods&quot;, &quot;domain&quot;, &quot;rule&quot;, &quot;match&quot;)),</span>
<span class="gi">+    default=&quot;endpoint&quot;,</span>
<span class="gi">+    help=(</span>
<span class="gi">+        &quot;Method to sort routes by. &#39;match&#39; is the order that Flask will match routes&quot;</span>
<span class="gi">+        &quot; when dispatching a request.&quot;</span>
<span class="gi">+    ),</span>
<span class="gi">+)</span>
<span class="gi">+@click.option(&quot;--all-methods&quot;, is_flag=True, help=&quot;Show HEAD and OPTIONS methods.&quot;)</span>
<span class="w"> </span>@with_appcontext
<span class="gd">-def routes_command(sort: str, all_methods: bool) -&gt;None:</span>
<span class="gi">+def routes_command(sort: str, all_methods: bool) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Show all registered routes with endpoints and methods.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rules = list(current_app.url_map.iter_rules())</span>
<span class="gi">+</span>
<span class="gi">+    if not rules:</span>
<span class="gi">+        click.echo(&quot;No routes were registered.&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    ignored_methods = set() if all_methods else {&quot;HEAD&quot;, &quot;OPTIONS&quot;}</span>
<span class="gi">+    host_matching = current_app.url_map.host_matching</span>
<span class="gi">+    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)</span>
<span class="gi">+    rows = []</span>
<span class="gi">+</span>
<span class="gi">+    for rule in rules:</span>
<span class="gi">+        row = [</span>
<span class="gi">+            rule.endpoint,</span>
<span class="gi">+            &quot;, &quot;.join(sorted((rule.methods or set()) - ignored_methods)),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        if has_domain:</span>
<span class="gi">+            row.append((rule.host if host_matching else rule.subdomain) or &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        row.append(rule.rule)</span>
<span class="gi">+        rows.append(row)</span>

<span class="gi">+    headers = [&quot;Endpoint&quot;, &quot;Methods&quot;]</span>
<span class="gi">+    sorts = [&quot;endpoint&quot;, &quot;methods&quot;]</span>

<span class="gd">-cli = FlaskGroup(name=&#39;flask&#39;, help=</span>
<span class="gd">-    &quot;&quot;&quot;A general utility script for Flask applications.</span>
<span class="gi">+    if has_domain:</span>
<span class="gi">+        headers.append(&quot;Host&quot; if host_matching else &quot;Subdomain&quot;)</span>
<span class="gi">+        sorts.append(&quot;domain&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    headers.append(&quot;Rule&quot;)</span>
<span class="gi">+    sorts.append(&quot;rule&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        rows.sort(key=itemgetter(sorts.index(sort)))</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    rows.insert(0, headers)</span>
<span class="gi">+    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]</span>
<span class="gi">+    rows.insert(1, [&quot;-&quot; * w for w in widths])</span>
<span class="gi">+    template = &quot;  &quot;.join(f&quot;{{{i}:&lt;{w}}}&quot; for i, w in enumerate(widths))</span>
<span class="gi">+</span>
<span class="gi">+    for row in rows:</span>
<span class="gi">+        click.echo(template.format(*row))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+cli = FlaskGroup(</span>
<span class="gi">+    name=&quot;flask&quot;,</span>
<span class="gi">+    help=&quot;&quot;&quot;\</span>
<span class="gi">+A general utility script for Flask applications.</span>

<span class="w"> </span>An application to load must be given with the &#39;--app&#39; option,
<span class="w"> </span>&#39;FLASK_APP&#39; environment variable, or with a &#39;wsgi.py&#39; or &#39;app.py&#39; file
<span class="w"> </span>in the current directory.
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+&quot;&quot;&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main() -&gt; None:</span>
<span class="gi">+    cli.main()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    main()
<span class="gh">diff --git a/src/flask/config.py b/src/flask/config.py</span>
<span class="gh">index 917b25e6..7e3ba179 100644</span>
<span class="gd">--- a/src/flask/config.py</span>
<span class="gi">+++ b/src/flask/config.py</span>
<span class="gu">@@ -1,46 +1,53 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import errno
<span class="w"> </span>import json
<span class="w"> </span>import os
<span class="w"> </span>import types
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from werkzeug.utils import import_string
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .sansio.app import App
<span class="gd">-T = t.TypeVar(&#39;T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+T = t.TypeVar(&quot;T&quot;)</span>


<span class="w"> </span>class ConfigAttribute(t.Generic[T]):
<span class="w"> </span>    &quot;&quot;&quot;Makes an attribute forward to the config&quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str, get_converter: (t.Callable[[t.Any], T] |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.__name__ = name
<span class="w"> </span>        self.get_converter = get_converter

<span class="w"> </span>    @t.overload
<span class="gd">-    def __get__(self, obj: None, owner: None) -&gt;te.Self:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __get__(self, obj: None, owner: None) -&gt; te.Self: ...</span>

<span class="w"> </span>    @t.overload
<span class="gd">-    def __get__(self, obj: App, owner: type[App]) -&gt;T:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __get__(self, obj: App, owner: type[App]) -&gt; T: ...</span>

<span class="gd">-    def __get__(self, obj: (App | None), owner: (type[App] | None)=None) -&gt;(T |</span>
<span class="gd">-        te.Self):</span>
<span class="gi">+    def __get__(self, obj: App | None, owner: type[App] | None = None) -&gt; T | te.Self:</span>
<span class="w"> </span>        if obj is None:
<span class="w"> </span>            return self
<span class="gi">+</span>
<span class="w"> </span>        rv = obj.config[self.__name__]
<span class="gi">+</span>
<span class="w"> </span>        if self.get_converter is not None:
<span class="w"> </span>            rv = self.get_converter(rv)
<span class="gd">-        return rv</span>

<span class="gd">-    def __set__(self, obj: App, value: t.Any) -&gt;None:</span>
<span class="gi">+        return rv  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def __set__(self, obj: App, value: t.Any) -&gt; None:</span>
<span class="w"> </span>        obj.config[self.__name__] = value


<span class="gd">-class Config(dict):</span>
<span class="gi">+class Config(dict):  # type: ignore[type-arg]</span>
<span class="w"> </span>    &quot;&quot;&quot;Works exactly like a dict but provides ways to fill it from files
<span class="w"> </span>    or special dictionaries.  There are two common patterns to populate the
<span class="w"> </span>    config.
<span class="gu">@@ -84,12 +91,15 @@ class Config(dict):</span>
<span class="w"> </span>    :param defaults: an optional dictionary of default values
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, root_path: (str | os.PathLike[str]), defaults: (dict</span>
<span class="gd">-        [str, t.Any] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        root_path: str | os.PathLike[str],</span>
<span class="gi">+        defaults: dict[str, t.Any] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(defaults or {})
<span class="w"> </span>        self.root_path = root_path

<span class="gd">-    def from_envvar(self, variable_name: str, silent: bool=False) -&gt;bool:</span>
<span class="gi">+    def from_envvar(self, variable_name: str, silent: bool = False) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Loads a configuration from an environment variable pointing to
<span class="w"> </span>        a configuration file.  This is basically just a shortcut with nicer
<span class="w"> </span>        error messages for this line of code::
<span class="gu">@@ -101,10 +111,21 @@ class Config(dict):</span>
<span class="w"> </span>                       files.
<span class="w"> </span>        :return: ``True`` if the file was loaded successfully.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def from_prefixed_env(self, prefix: str=&#39;FLASK&#39;, *, loads: t.Callable[[</span>
<span class="gd">-        str], t.Any]=json.loads) -&gt;bool:</span>
<span class="gi">+        rv = os.environ.get(variable_name)</span>
<span class="gi">+        if not rv:</span>
<span class="gi">+            if silent:</span>
<span class="gi">+                return False</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                f&quot;The environment variable {variable_name!r} is not set&quot;</span>
<span class="gi">+                &quot; and as such configuration could not be loaded. Set&quot;</span>
<span class="gi">+                &quot; this variable and make it point to a configuration&quot;</span>
<span class="gi">+                &quot; file&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return self.from_pyfile(rv, silent=silent)</span>
<span class="gi">+</span>
<span class="gi">+    def from_prefixed_env(</span>
<span class="gi">+        self, prefix: str = &quot;FLASK&quot;, *, loads: t.Callable[[str], t.Any] = json.loads</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load any environment variables that start with ``FLASK_``,
<span class="w"> </span>        dropping the prefix from the env key for the config key. Values
<span class="w"> </span>        are passed through a loading function to attempt to convert them
<span class="gu">@@ -128,10 +149,47 @@ class Config(dict):</span>

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prefix = f&quot;{prefix}_&quot;</span>
<span class="gi">+        len_prefix = len(prefix)</span>
<span class="gi">+</span>
<span class="gi">+        for key in sorted(os.environ):</span>
<span class="gi">+            if not key.startswith(prefix):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            value = os.environ[key]</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = loads(value)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                # Keep the value as a string if loading failed.</span>
<span class="gi">+                pass</span>

<span class="gd">-    def from_pyfile(self, filename: (str | os.PathLike[str]), silent: bool=</span>
<span class="gd">-        False) -&gt;bool:</span>
<span class="gi">+            # Change to key.removeprefix(prefix) on Python &gt;= 3.9.</span>
<span class="gi">+            key = key[len_prefix:]</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;__&quot; not in key:</span>
<span class="gi">+                # A non-nested key, set directly.</span>
<span class="gi">+                self[key] = value</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Traverse nested dictionaries with keys separated by &quot;__&quot;.</span>
<span class="gi">+            current = self</span>
<span class="gi">+            *parts, tail = key.split(&quot;__&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            for part in parts:</span>
<span class="gi">+                # If an intermediate dict does not exist, create it.</span>
<span class="gi">+                if part not in current:</span>
<span class="gi">+                    current[part] = {}</span>
<span class="gi">+</span>
<span class="gi">+                current = current[part]</span>
<span class="gi">+</span>
<span class="gi">+            current[tail] = value</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def from_pyfile(</span>
<span class="gi">+        self, filename: str | os.PathLike[str], silent: bool = False</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Updates the values in the config from a Python file.  This function
<span class="w"> </span>        behaves as if the file was imported as module with the
<span class="w"> </span>        :meth:`from_object` function.
<span class="gu">@@ -146,9 +204,21 @@ class Config(dict):</span>
<span class="w"> </span>        .. versionadded:: 0.7
<span class="w"> </span>           `silent` parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def from_object(self, obj: (object | str)) -&gt;None:</span>
<span class="gi">+        filename = os.path.join(self.root_path, filename)</span>
<span class="gi">+        d = types.ModuleType(&quot;config&quot;)</span>
<span class="gi">+        d.__file__ = filename</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(filename, mode=&quot;rb&quot;) as config_file:</span>
<span class="gi">+                exec(compile(config_file.read(), filename, &quot;exec&quot;), d.__dict__)</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):</span>
<span class="gi">+                return False</span>
<span class="gi">+            e.strerror = f&quot;Unable to load configuration file ({e.strerror})&quot;</span>
<span class="gi">+            raise</span>
<span class="gi">+        self.from_object(d)</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def from_object(self, obj: object | str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Updates the values from the given object.  An object can be of one
<span class="w"> </span>        of the following two types:

<span class="gu">@@ -180,11 +250,19 @@ class Config(dict):</span>

<span class="w"> </span>        :param obj: an import name or object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def from_file(self, filename: (str | os.PathLike[str]), load: t.</span>
<span class="gd">-        Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]], silent: bool=False,</span>
<span class="gd">-        text: bool=True) -&gt;bool:</span>
<span class="gi">+        if isinstance(obj, str):</span>
<span class="gi">+            obj = import_string(obj)</span>
<span class="gi">+        for key in dir(obj):</span>
<span class="gi">+            if key.isupper():</span>
<span class="gi">+                self[key] = getattr(obj, key)</span>
<span class="gi">+</span>
<span class="gi">+    def from_file(</span>
<span class="gi">+        self,</span>
<span class="gi">+        filename: str | os.PathLike[str],</span>
<span class="gi">+        load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],</span>
<span class="gi">+        silent: bool = False,</span>
<span class="gi">+        text: bool = True,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update the values in the config from a file that is loaded
<span class="w"> </span>        using the ``load`` parameter. The loaded data is passed to the
<span class="w"> </span>        :meth:`from_mapping` method.
<span class="gu">@@ -212,10 +290,23 @@ class Config(dict):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        filename = os.path.join(self.root_path, filename)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(filename, &quot;r&quot; if text else &quot;rb&quot;) as f:</span>
<span class="gi">+                obj = load(f)</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if silent and e.errno in (errno.ENOENT, errno.EISDIR):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            e.strerror = f&quot;Unable to load configuration file ({e.strerror})&quot;</span>
<span class="gi">+            raise</span>

<span class="gd">-    def from_mapping(self, mapping: (t.Mapping[str, t.Any] | None)=None, **</span>
<span class="gd">-        kwargs: t.Any) -&gt;bool:</span>
<span class="gi">+        return self.from_mapping(obj)</span>
<span class="gi">+</span>
<span class="gi">+    def from_mapping(</span>
<span class="gi">+        self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Updates the config like :meth:`update` ignoring items with
<span class="w"> </span>        non-upper keys.

<span class="gu">@@ -223,10 +314,18 @@ class Config(dict):</span>

<span class="w"> </span>        .. versionadded:: 0.11
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_namespace(self, namespace: str, lowercase: bool=True,</span>
<span class="gd">-        trim_namespace: bool=True) -&gt;dict[str, t.Any]:</span>
<span class="gi">+        mappings: dict[str, t.Any] = {}</span>
<span class="gi">+        if mapping is not None:</span>
<span class="gi">+            mappings.update(mapping)</span>
<span class="gi">+        mappings.update(kwargs)</span>
<span class="gi">+        for key, value in mappings.items():</span>
<span class="gi">+            if key.isupper():</span>
<span class="gi">+                self[key] = value</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def get_namespace(</span>
<span class="gi">+        self, namespace: str, lowercase: bool = True, trim_namespace: bool = True</span>
<span class="gi">+    ) -&gt; dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a dictionary containing a subset of configuration options
<span class="w"> </span>        that match the specified namespace/prefix. Example usage::

<span class="gu">@@ -254,7 +353,18 @@ class Config(dict):</span>

<span class="w"> </span>        .. versionadded:: 0.11
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = {}</span>
<span class="gi">+        for k, v in self.items():</span>
<span class="gi">+            if not k.startswith(namespace):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if trim_namespace:</span>
<span class="gi">+                key = k[len(namespace) :]</span>
<span class="gi">+            else:</span>
<span class="gi">+                key = k</span>
<span class="gi">+            if lowercase:</span>
<span class="gi">+                key = key.lower()</span>
<span class="gi">+            rv[key] = v</span>
<span class="gi">+        return rv</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {dict.__repr__(self)}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {dict.__repr__(self)}&gt;&quot;</span>
<span class="gh">diff --git a/src/flask/ctx.py b/src/flask/ctx.py</span>
<span class="gh">index ce2683ae..9b164d39 100644</span>
<span class="gd">--- a/src/flask/ctx.py</span>
<span class="gi">+++ b/src/flask/ctx.py</span>
<span class="gu">@@ -1,20 +1,28 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextvars
<span class="w"> </span>import sys
<span class="w"> </span>import typing as t
<span class="w"> </span>from functools import update_wrapper
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>from werkzeug.exceptions import HTTPException
<span class="gi">+</span>
<span class="w"> </span>from . import typing as ft
<span class="w"> </span>from .globals import _cv_app
<span class="w"> </span>from .globals import _cv_request
<span class="w"> </span>from .signals import appcontext_popped
<span class="w"> </span>from .signals import appcontext_pushed
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from _typeshed.wsgi import WSGIEnvironment
<span class="gi">+</span>
<span class="w"> </span>    from .app import Flask
<span class="w"> </span>    from .sessions import SessionMixin
<span class="w"> </span>    from .wrappers import Request
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# a singleton sentinel value for parameter defaults</span>
<span class="w"> </span>_sentinel = object()


<span class="gu">@@ -38,22 +46,25 @@ class _AppCtxGlobals:</span>
<span class="w"> </span>        .. versionadded:: 0.10
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __getattr__(self, name: str) -&gt;t.Any:</span>
<span class="gi">+    # Define attr methods to let mypy know this is a namespace object</span>
<span class="gi">+    # that has arbitrary attributes.</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; t.Any:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return self.__dict__[name]
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            raise AttributeError(name) from None

<span class="gd">-    def __setattr__(self, name: str, value: t.Any) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, name: str, value: t.Any) -&gt; None:</span>
<span class="w"> </span>        self.__dict__[name] = value

<span class="gd">-    def __delattr__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __delattr__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            del self.__dict__[name]
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            raise AttributeError(name) from None

<span class="gd">-    def get(self, name: str, default: (t.Any | None)=None) -&gt;t.Any:</span>
<span class="gi">+    def get(self, name: str, default: t.Any | None = None) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get an attribute by name, or a default value. Like
<span class="w"> </span>        :meth:`dict.get`.

<span class="gu">@@ -62,9 +73,9 @@ class _AppCtxGlobals:</span>

<span class="w"> </span>        .. versionadded:: 0.10
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__dict__.get(name, default)</span>

<span class="gd">-    def pop(self, name: str, default: t.Any=_sentinel) -&gt;t.Any:</span>
<span class="gi">+    def pop(self, name: str, default: t.Any = _sentinel) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get and remove an attribute by name. Like :meth:`dict.pop`.

<span class="w"> </span>        :param name: Name of attribute to pop.
<span class="gu">@@ -73,9 +84,12 @@ class _AppCtxGlobals:</span>

<span class="w"> </span>        .. versionadded:: 0.11
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if default is _sentinel:</span>
<span class="gi">+            return self.__dict__.pop(name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.__dict__.pop(name, default)</span>

<span class="gd">-    def setdefault(self, name: str, default: t.Any=None) -&gt;t.Any:</span>
<span class="gi">+    def setdefault(self, name: str, default: t.Any = None) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the value of an attribute if it is present, otherwise
<span class="w"> </span>        set and return a default value. Like :meth:`dict.setdefault`.

<span class="gu">@@ -85,23 +99,24 @@ class _AppCtxGlobals:</span>

<span class="w"> </span>        .. versionadded:: 0.11
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__dict__.setdefault(name, default)</span>

<span class="gd">-    def __contains__(self, item: str) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, item: str) -&gt; bool:</span>
<span class="w"> </span>        return item in self.__dict__

<span class="gd">-    def __iter__(self) -&gt;t.Iterator[str]:</span>
<span class="gi">+    def __iter__(self) -&gt; t.Iterator[str]:</span>
<span class="w"> </span>        return iter(self.__dict__)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        ctx = _cv_app.get(None)
<span class="w"> </span>        if ctx is not None:
<span class="w"> </span>            return f&quot;&lt;flask.g of &#39;{ctx.app.name}&#39;&gt;&quot;
<span class="w"> </span>        return object.__repr__(self)


<span class="gd">-def after_this_request(f: ft.AfterRequestCallable[t.Any]</span>
<span class="gd">-    ) -&gt;ft.AfterRequestCallable[t.Any]:</span>
<span class="gi">+def after_this_request(</span>
<span class="gi">+    f: ft.AfterRequestCallable[t.Any],</span>
<span class="gi">+) -&gt; ft.AfterRequestCallable[t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Executes a function after this request.  This is useful to modify
<span class="w"> </span>    response objects.  The function is passed the response object and has
<span class="w"> </span>    to return the same or a new one.
<span class="gu">@@ -122,13 +137,22 @@ def after_this_request(f: ft.AfterRequestCallable[t.Any]</span>

<span class="w"> </span>    .. versionadded:: 0.9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ctx = _cv_request.get(None)</span>

<span class="gi">+    if ctx is None:</span>
<span class="gi">+        raise RuntimeError(</span>
<span class="gi">+            &quot;&#39;after_this_request&#39; can only be used when a request&quot;</span>
<span class="gi">+            &quot; context is active, such as in a view function.&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+    ctx._after_request_functions.append(f)</span>
<span class="gi">+    return f</span>


<span class="gd">-def copy_current_request_context(f: F) -&gt;F:</span>
<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def copy_current_request_context(f: F) -&gt; F:</span>
<span class="w"> </span>    &quot;&quot;&quot;A helper function that decorates a function to retain the current
<span class="w"> </span>    request context.  This is useful when working with greenlets.  The moment
<span class="w"> </span>    the function is decorated a copy of the request context is created and
<span class="gu">@@ -152,10 +176,24 @@ def copy_current_request_context(f: F) -&gt;F:</span>

<span class="w"> </span>    .. versionadded:: 0.10
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ctx = _cv_request.get(None)</span>
<span class="gi">+</span>
<span class="gi">+    if ctx is None:</span>
<span class="gi">+        raise RuntimeError(</span>
<span class="gi">+            &quot;&#39;copy_current_request_context&#39; can only be used when a&quot;</span>
<span class="gi">+            &quot; request context is active, such as in a view function.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    ctx = ctx.copy()</span>

<span class="gi">+    def wrapper(*args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="gi">+        with ctx:  # type: ignore[union-attr]</span>
<span class="gi">+            return ctx.app.ensure_sync(f)(*args, **kwargs)  # type: ignore[union-attr]</span>

<span class="gd">-def has_request_context() -&gt;bool:</span>
<span class="gi">+    return update_wrapper(wrapper, f)  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def has_request_context() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;If you have code that wants to test if a request context is there or
<span class="w"> </span>    not this function can be used.  For instance, you may want to take advantage
<span class="w"> </span>    of request information if the request object is available, but fail
<span class="gu">@@ -184,17 +222,17 @@ def has_request_context() -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 0.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _cv_request.get(None) is not None</span>


<span class="gd">-def has_app_context() -&gt;bool:</span>
<span class="gi">+def has_app_context() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Works like :func:`has_request_context` but for the application
<span class="w"> </span>    context.  You can also just do a boolean check on the
<span class="w"> </span>    :data:`current_app` object instead.

<span class="w"> </span>    .. versionadded:: 0.9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _cv_app.get(None) is not None</span>


<span class="w"> </span>class AppContext:
<span class="gu">@@ -204,26 +242,45 @@ class AppContext:</span>
<span class="w"> </span>    running CLI commands.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Flask) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Flask) -&gt; None:</span>
<span class="w"> </span>        self.app = app
<span class="w"> </span>        self.url_adapter = app.create_url_adapter(None)
<span class="w"> </span>        self.g: _AppCtxGlobals = app.app_ctx_globals_class()
<span class="w"> </span>        self._cv_tokens: list[contextvars.Token[AppContext]] = []

<span class="gd">-    def push(self) -&gt;None:</span>
<span class="gi">+    def push(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Binds the app context to the current context.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cv_tokens.append(_cv_app.set(self))</span>
<span class="gi">+        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)</span>

<span class="gd">-    def pop(self, exc: (BaseException | None)=_sentinel) -&gt;None:</span>
<span class="gi">+    def pop(self, exc: BaseException | None = _sentinel) -&gt; None:  # type: ignore</span>
<span class="w"> </span>        &quot;&quot;&quot;Pops the app context.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            if len(self._cv_tokens) == 1:</span>
<span class="gi">+                if exc is _sentinel:</span>
<span class="gi">+                    exc = sys.exc_info()[1]</span>
<span class="gi">+                self.app.do_teardown_appcontext(exc)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            ctx = _cv_app.get()</span>
<span class="gi">+            _cv_app.reset(self._cv_tokens.pop())</span>
<span class="gi">+</span>
<span class="gi">+        if ctx is not self:</span>
<span class="gi">+            raise AssertionError(</span>
<span class="gi">+                f&quot;Popped wrong app context. ({ctx!r} instead of {self!r})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)</span>

<span class="gd">-    def __enter__(self) -&gt;AppContext:</span>
<span class="gi">+    def __enter__(self) -&gt; AppContext:</span>
<span class="w"> </span>        self.push()
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: (type | None), exc_value: (BaseException |</span>
<span class="gd">-        None), tb: (TracebackType | None)) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: type | None,</span>
<span class="gi">+        exc_value: BaseException | None,</span>
<span class="gi">+        tb: TracebackType | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.pop(exc_value)


<span class="gu">@@ -249,8 +306,13 @@ class RequestContext:</span>
<span class="w"> </span>    database connections.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Flask, environ: WSGIEnvironment, request: (</span>
<span class="gd">-        Request | None)=None, session: (SessionMixin | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        app: Flask,</span>
<span class="gi">+        environ: WSGIEnvironment,</span>
<span class="gi">+        request: Request | None = None,</span>
<span class="gi">+        session: SessionMixin | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.app = app
<span class="w"> </span>        if request is None:
<span class="w"> </span>            request = app.request_class(environ)
<span class="gu">@@ -263,12 +325,16 @@ class RequestContext:</span>
<span class="w"> </span>            self.request.routing_exception = e
<span class="w"> </span>        self.flashes: list[tuple[str, str]] | None = None
<span class="w"> </span>        self.session: SessionMixin | None = session
<span class="gd">-        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = [</span>
<span class="gd">-            ]</span>
<span class="gd">-        self._cv_tokens: list[tuple[contextvars.Token[RequestContext], </span>
<span class="gd">-            AppContext | None]] = []</span>
<span class="gi">+        # Functions that should be executed after the request on the response</span>
<span class="gi">+        # object.  These will be called before the regular &quot;after_request&quot;</span>
<span class="gi">+        # functions.</span>
<span class="gi">+        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []</span>

<span class="gd">-    def copy(self) -&gt;RequestContext:</span>
<span class="gi">+        self._cv_tokens: list[</span>
<span class="gi">+            tuple[contextvars.Token[RequestContext], AppContext | None]</span>
<span class="gi">+        ] = []</span>
<span class="gi">+</span>
<span class="gi">+    def copy(self) -&gt; RequestContext:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a copy of this request context with the same request object.
<span class="w"> </span>        This can be used to move a request context to a different greenlet.
<span class="w"> </span>        Because the actual request object is the same this cannot be used to
<span class="gu">@@ -281,15 +347,53 @@ class RequestContext:</span>
<span class="w"> </span>           The current session object is used instead of reloading the original
<span class="w"> </span>           data. This prevents `flask.session` pointing to an out-of-date object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def match_request(self) -&gt;None:</span>
<span class="gi">+        return self.__class__(</span>
<span class="gi">+            self.app,</span>
<span class="gi">+            environ=self.request.environ,</span>
<span class="gi">+            request=self.request,</span>
<span class="gi">+            session=self.session,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def match_request(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Can be overridden by a subclass to hook into the matching
<span class="w"> </span>        of the request.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = self.url_adapter.match(return_rule=True)  # type: ignore</span>
<span class="gi">+            self.request.url_rule, self.request.view_args = result  # type: ignore</span>
<span class="gi">+        except HTTPException as e:</span>
<span class="gi">+            self.request.routing_exception = e</span>
<span class="gi">+</span>
<span class="gi">+    def push(self) -&gt; None:</span>
<span class="gi">+        # Before we push the request context we have to ensure that there</span>
<span class="gi">+        # is an application context.</span>
<span class="gi">+        app_ctx = _cv_app.get(None)</span>

<span class="gd">-    def pop(self, exc: (BaseException | None)=_sentinel) -&gt;None:</span>
<span class="gi">+        if app_ctx is None or app_ctx.app is not self.app:</span>
<span class="gi">+            app_ctx = self.app.app_context()</span>
<span class="gi">+            app_ctx.push()</span>
<span class="gi">+        else:</span>
<span class="gi">+            app_ctx = None</span>
<span class="gi">+</span>
<span class="gi">+        self._cv_tokens.append((_cv_request.set(self), app_ctx))</span>
<span class="gi">+</span>
<span class="gi">+        # Open the session at the moment that the request context is available.</span>
<span class="gi">+        # This allows a custom open_session method to use the request context.</span>
<span class="gi">+        # Only open a new session if this is the first time the request was</span>
<span class="gi">+        # pushed, otherwise stream_with_context loses the session.</span>
<span class="gi">+        if self.session is None:</span>
<span class="gi">+            session_interface = self.app.session_interface</span>
<span class="gi">+            self.session = session_interface.open_session(self.app, self.request)</span>
<span class="gi">+</span>
<span class="gi">+            if self.session is None:</span>
<span class="gi">+                self.session = session_interface.make_null_session(self.app)</span>
<span class="gi">+</span>
<span class="gi">+        # Match the request URL after loading the session, so that the</span>
<span class="gi">+        # session is available in custom URL converters.</span>
<span class="gi">+        if self.url_adapter is not None:</span>
<span class="gi">+            self.match_request()</span>
<span class="gi">+</span>
<span class="gi">+    def pop(self, exc: BaseException | None = _sentinel) -&gt; None:  # type: ignore</span>
<span class="w"> </span>        &quot;&quot;&quot;Pops the request context and unbinds it by doing that.  This will
<span class="w"> </span>        also trigger the execution of functions registered by the
<span class="w"> </span>        :meth:`~flask.Flask.teardown_request` decorator.
<span class="gu">@@ -297,17 +401,49 @@ class RequestContext:</span>
<span class="w"> </span>        .. versionchanged:: 0.9
<span class="w"> </span>           Added the `exc` argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        clear_request = len(self._cv_tokens) == 1</span>

<span class="gd">-    def __enter__(self) -&gt;RequestContext:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if clear_request:</span>
<span class="gi">+                if exc is _sentinel:</span>
<span class="gi">+                    exc = sys.exc_info()[1]</span>
<span class="gi">+                self.app.do_teardown_request(exc)</span>
<span class="gi">+</span>
<span class="gi">+                request_close = getattr(self.request, &quot;close&quot;, None)</span>
<span class="gi">+                if request_close is not None:</span>
<span class="gi">+                    request_close()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            ctx = _cv_request.get()</span>
<span class="gi">+            token, app_ctx = self._cv_tokens.pop()</span>
<span class="gi">+            _cv_request.reset(token)</span>
<span class="gi">+</span>
<span class="gi">+            # get rid of circular dependencies at the end of the request</span>
<span class="gi">+            # so that we don&#39;t require the GC to be active.</span>
<span class="gi">+            if clear_request:</span>
<span class="gi">+                ctx.request.environ[&quot;werkzeug.request&quot;] = None</span>
<span class="gi">+</span>
<span class="gi">+            if app_ctx is not None:</span>
<span class="gi">+                app_ctx.pop(exc)</span>
<span class="gi">+</span>
<span class="gi">+            if ctx is not self:</span>
<span class="gi">+                raise AssertionError(</span>
<span class="gi">+                    f&quot;Popped wrong request context. ({ctx!r} instead of {self!r})&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; RequestContext:</span>
<span class="w"> </span>        self.push()
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: (type | None), exc_value: (BaseException |</span>
<span class="gd">-        None), tb: (TracebackType | None)) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: type | None,</span>
<span class="gi">+        exc_value: BaseException | None,</span>
<span class="gi">+        tb: TracebackType | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.pop(exc_value)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;&lt;{type(self).__name__} {self.request.url!r} [{self.request.method}] of {self.app.name}&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;&lt;{type(self).__name__} {self.request.url!r}&quot;</span>
<span class="gi">+            f&quot; [{self.request.method}] of {self.app.name}&gt;&quot;</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/flask/debughelpers.py b/src/flask/debughelpers.py</span>
<span class="gh">index ac217f75..2c8c4c48 100644</span>
<span class="gd">--- a/src/flask/debughelpers.py</span>
<span class="gi">+++ b/src/flask/debughelpers.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from jinja2.loaders import BaseLoader
<span class="w"> </span>from werkzeug.routing import RequestRedirect
<span class="gi">+</span>
<span class="w"> </span>from .blueprints import Blueprint
<span class="w"> </span>from .globals import request_ctx
<span class="w"> </span>from .sansio.app import App
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .sansio.scaffold import Scaffold
<span class="w"> </span>    from .wrappers import Request
<span class="gu">@@ -21,21 +25,25 @@ class DebugFilesKeyError(KeyError, AssertionError):</span>
<span class="w"> </span>    provide a better error message than just a generic KeyError/BadRequest.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, request: Request, key: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, request: Request, key: str) -&gt; None:</span>
<span class="w"> </span>        form_matches = request.form.getlist(key)
<span class="w"> </span>        buf = [
<span class="gd">-            f&#39;You tried to access the file {key!r} in the request.files dictionary but it does not exist. The mimetype for the request is {request.mimetype!r} instead of \&#39;multipart/form-data\&#39; which means that no file contents were transmitted. To fix this error you should provide enctype=&quot;multipart/form-data&quot; in your form.&#39;</span>
<span class="gd">-            ]</span>
<span class="gi">+            f&quot;You tried to access the file {key!r} in the request.files&quot;</span>
<span class="gi">+            &quot; dictionary but it does not exist. The mimetype for the&quot;</span>
<span class="gi">+            f&quot; request is {request.mimetype!r} instead of&quot;</span>
<span class="gi">+            &quot; &#39;multipart/form-data&#39; which means that no file contents&quot;</span>
<span class="gi">+            &quot; were transmitted. To fix this error you should provide&quot;</span>
<span class="gi">+            &#39; enctype=&quot;multipart/form-data&quot; in your form.&#39;</span>
<span class="gi">+        ]</span>
<span class="w"> </span>        if form_matches:
<span class="gd">-            names = &#39;, &#39;.join(repr(x) for x in form_matches)</span>
<span class="gi">+            names = &quot;, &quot;.join(repr(x) for x in form_matches)</span>
<span class="w"> </span>            buf.append(
<span class="gd">-                f&quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-The browser instead transmitted some file names. This was submitted: {names}&quot;&quot;&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-        self.msg = &#39;&#39;.join(buf)</span>
<span class="gi">+                &quot;\n\nThe browser instead transmitted some file names. &quot;</span>
<span class="gi">+                f&quot;This was submitted: {names}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        self.msg = &quot;&quot;.join(buf)</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.msg


<span class="gu">@@ -46,36 +54,125 @@ class FormDataRoutingRedirect(AssertionError):</span>
<span class="w"> </span>    307 or 308.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, request: Request) -&gt;None:</span>
<span class="gi">+    def __init__(self, request: Request) -&gt; None:</span>
<span class="w"> </span>        exc = request.routing_exception
<span class="w"> </span>        assert isinstance(exc, RequestRedirect)
<span class="w"> </span>        buf = [
<span class="gd">-            f&quot;A request was sent to &#39;{request.url}&#39;, but routing issued a redirect to the canonical URL &#39;{exc.new_url}&#39;.&quot;</span>
<span class="gd">-            ]</span>
<span class="gd">-        if f&#39;{request.base_url}/&#39; == exc.new_url.partition(&#39;?&#39;)[0]:</span>
<span class="gd">-            buf.append(</span>
<span class="gd">-                &#39; The URL was defined with a trailing slash. Flask will redirect to the URL with a trailing slash if it was accessed without one.&#39;</span>
<span class="gd">-                )</span>
<span class="gd">-        buf.append(</span>
<span class="gd">-            &quot;&quot;&quot; Send requests to the canonical URL, or use 307 or 308 for routing redirects. Otherwise, browsers will drop form data.</span>
<span class="gi">+            f&quot;A request was sent to &#39;{request.url}&#39;, but routing issued&quot;</span>
<span class="gi">+            f&quot; a redirect to the canonical URL &#39;{exc.new_url}&#39;.&quot;</span>
<span class="gi">+        ]</span>

<span class="gd">-This exception is only raised in debug mode.&quot;&quot;&quot;</span>
<span class="gi">+        if f&quot;{request.base_url}/&quot; == exc.new_url.partition(&quot;?&quot;)[0]:</span>
<span class="gi">+            buf.append(</span>
<span class="gi">+                &quot; The URL was defined with a trailing slash. Flask&quot;</span>
<span class="gi">+                &quot; will redirect to the URL with a trailing slash if it&quot;</span>
<span class="gi">+                &quot; was accessed without one.&quot;</span>
<span class="w"> </span>            )
<span class="gd">-        super().__init__(&#39;&#39;.join(buf))</span>
<span class="gi">+</span>
<span class="gi">+        buf.append(</span>
<span class="gi">+            &quot; Send requests to the canonical URL, or use 307 or 308 for&quot;</span>
<span class="gi">+            &quot; routing redirects. Otherwise, browsers will drop form&quot;</span>
<span class="gi">+            &quot; data.\n\n&quot;</span>
<span class="gi">+            &quot;This exception is only raised in debug mode.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        super().__init__(&quot;&quot;.join(buf))</span>


<span class="gd">-def attach_enctype_error_multidict(request: Request) -&gt;None:</span>
<span class="gi">+def attach_enctype_error_multidict(request: Request) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Patch ``request.files.__getitem__`` to raise a descriptive error
<span class="w"> </span>    about ``enctype=multipart/form-data``.

<span class="w"> </span>    :param request: The request to patch.
<span class="w"> </span>    :meta private:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def explain_template_loading_attempts(app: App, template: str, attempts:</span>
<span class="gd">-    list[tuple[BaseLoader, Scaffold, tuple[str, str | None, t.Callable[[],</span>
<span class="gd">-    bool] | None] | None]]) -&gt;None:</span>
<span class="gi">+    oldcls = request.files.__class__</span>
<span class="gi">+</span>
<span class="gi">+    class newcls(oldcls):  # type: ignore[valid-type, misc]</span>
<span class="gi">+        def __getitem__(self, key: str) -&gt; t.Any:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return super().__getitem__(key)</span>
<span class="gi">+            except KeyError as e:</span>
<span class="gi">+                if key not in request.form:</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+                raise DebugFilesKeyError(request, key).with_traceback(</span>
<span class="gi">+                    e.__traceback__</span>
<span class="gi">+                ) from None</span>
<span class="gi">+</span>
<span class="gi">+    newcls.__name__ = oldcls.__name__</span>
<span class="gi">+    newcls.__module__ = oldcls.__module__</span>
<span class="gi">+    request.files.__class__ = newcls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dump_loader_info(loader: BaseLoader) -&gt; t.Iterator[str]:</span>
<span class="gi">+    yield f&quot;class: {type(loader).__module__}.{type(loader).__name__}&quot;</span>
<span class="gi">+    for key, value in sorted(loader.__dict__.items()):</span>
<span class="gi">+        if key.startswith(&quot;_&quot;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(value, (tuple, list)):</span>
<span class="gi">+            if not all(isinstance(x, str) for x in value):</span>
<span class="gi">+                continue</span>
<span class="gi">+            yield f&quot;{key}:&quot;</span>
<span class="gi">+            for item in value:</span>
<span class="gi">+                yield f&quot;  - {item}&quot;</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif not isinstance(value, (str, int, float, bool)):</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield f&quot;{key}: {value!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def explain_template_loading_attempts(</span>
<span class="gi">+    app: App,</span>
<span class="gi">+    template: str,</span>
<span class="gi">+    attempts: list[</span>
<span class="gi">+        tuple[</span>
<span class="gi">+            BaseLoader,</span>
<span class="gi">+            Scaffold,</span>
<span class="gi">+            tuple[str, str | None, t.Callable[[], bool] | None] | None,</span>
<span class="gi">+        ]</span>
<span class="gi">+    ],</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;This should help developers understand what failed&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    info = [f&quot;Locating template {template!r}:&quot;]</span>
<span class="gi">+    total_found = 0</span>
<span class="gi">+    blueprint = None</span>
<span class="gi">+    if request_ctx and request_ctx.request.blueprint is not None:</span>
<span class="gi">+        blueprint = request_ctx.request.blueprint</span>
<span class="gi">+</span>
<span class="gi">+    for idx, (loader, srcobj, triple) in enumerate(attempts):</span>
<span class="gi">+        if isinstance(srcobj, App):</span>
<span class="gi">+            src_info = f&quot;application {srcobj.import_name!r}&quot;</span>
<span class="gi">+        elif isinstance(srcobj, Blueprint):</span>
<span class="gi">+            src_info = f&quot;blueprint {srcobj.name!r} ({srcobj.import_name})&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            src_info = repr(srcobj)</span>
<span class="gi">+</span>
<span class="gi">+        info.append(f&quot;{idx + 1:5}: trying loader of {src_info}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for line in _dump_loader_info(loader):</span>
<span class="gi">+            info.append(f&quot;       {line}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if triple is None:</span>
<span class="gi">+            detail = &quot;no match&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            detail = f&quot;found ({triple[1] or &#39;&lt;string&gt;&#39;!r})&quot;</span>
<span class="gi">+            total_found += 1</span>
<span class="gi">+        info.append(f&quot;       -&gt; {detail}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    seems_fishy = False</span>
<span class="gi">+    if total_found == 0:</span>
<span class="gi">+        info.append(&quot;Error: the template could not be found.&quot;)</span>
<span class="gi">+        seems_fishy = True</span>
<span class="gi">+    elif total_found &gt; 1:</span>
<span class="gi">+        info.append(&quot;Warning: multiple loaders returned a match for the template.&quot;)</span>
<span class="gi">+        seems_fishy = True</span>
<span class="gi">+</span>
<span class="gi">+    if blueprint is not None and seems_fishy:</span>
<span class="gi">+        info.append(</span>
<span class="gi">+            &quot;  The template was looked up from an endpoint that belongs&quot;</span>
<span class="gi">+            f&quot; to the blueprint {blueprint!r}.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        info.append(&quot;  Maybe you did not place a template in the right folder?&quot;)</span>
<span class="gi">+        info.append(&quot;  See https://flask.palletsprojects.com/blueprints/#templates&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    app.logger.info(&quot;\n&quot;.join(info))</span>
<span class="gh">diff --git a/src/flask/globals.py b/src/flask/globals.py</span>
<span class="gh">index 4a5f4a78..e2c410cc 100644</span>
<span class="gd">--- a/src/flask/globals.py</span>
<span class="gi">+++ b/src/flask/globals.py</span>
<span class="gu">@@ -1,32 +1,51 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from contextvars import ContextVar
<span class="gi">+</span>
<span class="w"> </span>from werkzeug.local import LocalProxy
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from .app import Flask
<span class="w"> </span>    from .ctx import _AppCtxGlobals
<span class="w"> </span>    from .ctx import AppContext
<span class="w"> </span>    from .ctx import RequestContext
<span class="w"> </span>    from .sessions import SessionMixin
<span class="w"> </span>    from .wrappers import Request
<span class="gd">-_no_app_msg = &quot;&quot;&quot;Working outside of application context.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_no_app_msg = &quot;&quot;&quot;\</span>
<span class="gi">+Working outside of application context.</span>

<span class="w"> </span>This typically means that you attempted to use functionality that needed
<span class="w"> </span>the current application. To solve this, set up an application context
<span class="gd">-with app.app_context(). See the documentation for more information.&quot;&quot;&quot;</span>
<span class="gd">-_cv_app: ContextVar[AppContext] = ContextVar(&#39;flask.app_ctx&#39;)</span>
<span class="gd">-app_ctx: AppContext = LocalProxy(_cv_app, unbound_message=_no_app_msg)</span>
<span class="gd">-current_app: Flask = LocalProxy(_cv_app, &#39;app&#39;, unbound_message=_no_app_msg)</span>
<span class="gd">-g: _AppCtxGlobals = LocalProxy(_cv_app, &#39;g&#39;, unbound_message=_no_app_msg)</span>
<span class="gd">-_no_req_msg = &quot;&quot;&quot;Working outside of request context.</span>
<span class="gi">+with app.app_context(). See the documentation for more information.\</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+_cv_app: ContextVar[AppContext] = ContextVar(&quot;flask.app_ctx&quot;)</span>
<span class="gi">+app_ctx: AppContext = LocalProxy(  # type: ignore[assignment]</span>
<span class="gi">+    _cv_app, unbound_message=_no_app_msg</span>
<span class="gi">+)</span>
<span class="gi">+current_app: Flask = LocalProxy(  # type: ignore[assignment]</span>
<span class="gi">+    _cv_app, &quot;app&quot;, unbound_message=_no_app_msg</span>
<span class="gi">+)</span>
<span class="gi">+g: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]</span>
<span class="gi">+    _cv_app, &quot;g&quot;, unbound_message=_no_app_msg</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+_no_req_msg = &quot;&quot;&quot;\</span>
<span class="gi">+Working outside of request context.</span>

<span class="w"> </span>This typically means that you attempted to use functionality that needed
<span class="w"> </span>an active HTTP request. Consult the documentation on testing for
<span class="gd">-information about how to avoid this problem.&quot;&quot;&quot;</span>
<span class="gd">-_cv_request: ContextVar[RequestContext] = ContextVar(&#39;flask.request_ctx&#39;)</span>
<span class="gd">-request_ctx: RequestContext = LocalProxy(_cv_request, unbound_message=</span>
<span class="gd">-    _no_req_msg)</span>
<span class="gd">-request: Request = LocalProxy(_cv_request, &#39;request&#39;, unbound_message=</span>
<span class="gd">-    _no_req_msg)</span>
<span class="gd">-session: SessionMixin = LocalProxy(_cv_request, &#39;session&#39;, unbound_message=</span>
<span class="gd">-    _no_req_msg)</span>
<span class="gi">+information about how to avoid this problem.\</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+_cv_request: ContextVar[RequestContext] = ContextVar(&quot;flask.request_ctx&quot;)</span>
<span class="gi">+request_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]</span>
<span class="gi">+    _cv_request, unbound_message=_no_req_msg</span>
<span class="gi">+)</span>
<span class="gi">+request: Request = LocalProxy(  # type: ignore[assignment]</span>
<span class="gi">+    _cv_request, &quot;request&quot;, unbound_message=_no_req_msg</span>
<span class="gi">+)</span>
<span class="gi">+session: SessionMixin = LocalProxy(  # type: ignore[assignment]</span>
<span class="gi">+    _cv_request, &quot;session&quot;, unbound_message=_no_req_msg</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/src/flask/helpers.py b/src/flask/helpers.py</span>
<span class="gh">index 2061dbf3..359a842a 100644</span>
<span class="gd">--- a/src/flask/helpers.py</span>
<span class="gi">+++ b/src/flask/helpers.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import importlib.util
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gu">@@ -6,39 +7,49 @@ import typing as t</span>
<span class="w"> </span>from datetime import datetime
<span class="w"> </span>from functools import lru_cache
<span class="w"> </span>from functools import update_wrapper
<span class="gi">+</span>
<span class="w"> </span>import werkzeug.utils
<span class="w"> </span>from werkzeug.exceptions import abort as _wz_abort
<span class="w"> </span>from werkzeug.utils import redirect as _wz_redirect
<span class="w"> </span>from werkzeug.wrappers import Response as BaseResponse
<span class="gi">+</span>
<span class="w"> </span>from .globals import _cv_request
<span class="w"> </span>from .globals import current_app
<span class="w"> </span>from .globals import request
<span class="w"> </span>from .globals import request_ctx
<span class="w"> </span>from .globals import session
<span class="w"> </span>from .signals import message_flashed
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from .wrappers import Response


<span class="gd">-def get_debug_flag() -&gt;bool:</span>
<span class="gi">+def get_debug_flag() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get whether debug mode should be enabled for the app, indicated by the
<span class="w"> </span>    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    val = os.environ.get(&quot;FLASK_DEBUG&quot;)</span>
<span class="gi">+    return bool(val and val.lower() not in {&quot;0&quot;, &quot;false&quot;, &quot;no&quot;})</span>


<span class="gd">-def get_load_dotenv(default: bool=True) -&gt;bool:</span>
<span class="gi">+def get_load_dotenv(default: bool = True) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get whether the user has disabled loading default dotenv files by
<span class="w"> </span>    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load
<span class="w"> </span>    the files.

<span class="w"> </span>    :param default: What to return if the env var isn&#39;t set.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    val = os.environ.get(&quot;FLASK_SKIP_DOTENV&quot;)</span>

<span class="gi">+    if not val:</span>
<span class="gi">+        return default</span>

<span class="gd">-def stream_with_context(generator_or_function: (t.Iterator[t.AnyStr] | t.</span>
<span class="gd">-    Callable[..., t.Iterator[t.AnyStr]])) -&gt;t.Iterator[t.AnyStr]:</span>
<span class="gi">+    return val.lower() in (&quot;0&quot;, &quot;false&quot;, &quot;no&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def stream_with_context(</span>
<span class="gi">+    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],</span>
<span class="gi">+) -&gt; t.Iterator[t.AnyStr]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Request contexts disappear when the response is started on the server.
<span class="w"> </span>    This is done for efficiency reasons and to make it less likely to encounter
<span class="w"> </span>    memory leaks with badly written WSGI middlewares.  The downside is that if
<span class="gu">@@ -72,10 +83,48 @@ def stream_with_context(generator_or_function: (t.Iterator[t.AnyStr] | t.</span>

<span class="w"> </span>    .. versionadded:: 0.9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def make_response(*args: t.Any) -&gt;Response:</span>
<span class="gi">+    try:</span>
<span class="gi">+        gen = iter(generator_or_function)  # type: ignore[arg-type]</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(*args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="gi">+            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]</span>
<span class="gi">+            return stream_with_context(gen)</span>
<span class="gi">+</span>
<span class="gi">+        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+    def generator() -&gt; t.Iterator[t.AnyStr | None]:</span>
<span class="gi">+        ctx = _cv_request.get(None)</span>
<span class="gi">+        if ctx is None:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;&#39;stream_with_context&#39; can only be used when a request&quot;</span>
<span class="gi">+                &quot; context is active, such as in a view function.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        with ctx:</span>
<span class="gi">+            # Dummy sentinel.  Has to be inside the context block or we&#39;re</span>
<span class="gi">+            # not actually keeping the context around.</span>
<span class="gi">+            yield None</span>
<span class="gi">+</span>
<span class="gi">+            # The try/finally is here so that if someone passes a WSGI level</span>
<span class="gi">+            # iterator in we&#39;re still running the cleanup logic.  Generators</span>
<span class="gi">+            # don&#39;t need that because they are closed on their destruction</span>
<span class="gi">+            # automatically.</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield from gen</span>
<span class="gi">+            finally:</span>
<span class="gi">+                if hasattr(gen, &quot;close&quot;):</span>
<span class="gi">+                    gen.close()</span>
<span class="gi">+</span>
<span class="gi">+    # The trick is to start the generator.  Then the code execution runs until</span>
<span class="gi">+    # the first dummy None is yielded at which point the context was already</span>
<span class="gi">+    # pushed.  This item is discarded.  Then when the iteration continues the</span>
<span class="gi">+    # real generator is executed.</span>
<span class="gi">+    wrapped_g = generator()</span>
<span class="gi">+    next(wrapped_g)</span>
<span class="gi">+    return wrapped_g  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_response(*args: t.Any) -&gt; Response:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sometimes it is necessary to set additional headers in a view.  Because
<span class="w"> </span>    views do not have to return response objects but can return a value that
<span class="w"> </span>    is converted into a response object by Flask itself, it becomes tricky to
<span class="gu">@@ -117,12 +166,22 @@ def make_response(*args: t.Any) -&gt;Response:</span>

<span class="w"> </span>    .. versionadded:: 0.6
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def url_for(endpoint: str, *, _anchor: (str | None)=None, _method: (str |</span>
<span class="gd">-    None)=None, _scheme: (str | None)=None, _external: (bool | None)=None,</span>
<span class="gd">-    **values: t.Any) -&gt;str:</span>
<span class="gi">+    if not args:</span>
<span class="gi">+        return current_app.response_class()</span>
<span class="gi">+    if len(args) == 1:</span>
<span class="gi">+        args = args[0]</span>
<span class="gi">+    return current_app.make_response(args)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def url_for(</span>
<span class="gi">+    endpoint: str,</span>
<span class="gi">+    *,</span>
<span class="gi">+    _anchor: str | None = None,</span>
<span class="gi">+    _method: str | None = None,</span>
<span class="gi">+    _scheme: str | None = None,</span>
<span class="gi">+    _external: bool | None = None,</span>
<span class="gi">+    **values: t.Any,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a URL to the given endpoint with the given values.

<span class="w"> </span>    This requires an active request or application context, and calls
<span class="gu">@@ -158,11 +217,19 @@ def url_for(endpoint: str, *, _anchor: (str | None)=None, _method: (str |</span>
<span class="w"> </span>    .. versionchanged:: 0.9
<span class="w"> </span>       Calls ``app.handle_url_build_error`` on build errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def redirect(location: str, code: int=302, Response: (type[BaseResponse] |</span>
<span class="gd">-    None)=None) -&gt;BaseResponse:</span>
<span class="gi">+    return current_app.url_for(</span>
<span class="gi">+        endpoint,</span>
<span class="gi">+        _anchor=_anchor,</span>
<span class="gi">+        _method=_method,</span>
<span class="gi">+        _scheme=_scheme,</span>
<span class="gi">+        _external=_external,</span>
<span class="gi">+        **values,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def redirect(</span>
<span class="gi">+    location: str, code: int = 302, Response: type[BaseResponse] | None = None</span>
<span class="gi">+) -&gt; BaseResponse:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a redirect response object.

<span class="w"> </span>    If :data:`~flask.current_app` is available, it will use its
<span class="gu">@@ -178,11 +245,13 @@ def redirect(location: str, code: int=302, Response: (type[BaseResponse] |</span>
<span class="w"> </span>        Calls ``current_app.redirect`` if available instead of always
<span class="w"> </span>        using Werkzeug&#39;s default ``redirect``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if current_app:</span>
<span class="gi">+        return current_app.redirect(location, code=code)</span>
<span class="gi">+</span>
<span class="gi">+    return _wz_redirect(location, code=code, Response=Response)</span>


<span class="gd">-def abort(code: (int | BaseResponse), *args: t.Any, **kwargs: t.Any</span>
<span class="gd">-    ) -&gt;t.NoReturn:</span>
<span class="gi">+def abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any) -&gt; t.NoReturn:</span>
<span class="w"> </span>    &quot;&quot;&quot;Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given
<span class="w"> </span>    status code.

<span class="gu">@@ -199,10 +268,13 @@ def abort(code: (int | BaseResponse), *args: t.Any, **kwargs: t.Any</span>
<span class="w"> </span>        Calls ``current_app.aborter`` if available instead of always
<span class="w"> </span>        using Werkzeug&#39;s default ``abort``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if current_app:</span>
<span class="gi">+        current_app.aborter(code, *args, **kwargs)</span>

<span class="gi">+    _wz_abort(code, *args, **kwargs)</span>

<span class="gd">-def get_template_attribute(template_name: str, attribute: str) -&gt;t.Any:</span>
<span class="gi">+</span>
<span class="gi">+def get_template_attribute(template_name: str, attribute: str) -&gt; t.Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Loads a macro (or variable) a template exports.  This can be used to
<span class="w"> </span>    invoke a macro from within Python code.  If you for example have a
<span class="w"> </span>    template named :file:`_cider.html` with the following contents:
<span class="gu">@@ -221,10 +293,10 @@ def get_template_attribute(template_name: str, attribute: str) -&gt;t.Any:</span>
<span class="w"> </span>    :param template_name: the name of the template
<span class="w"> </span>    :param attribute: the name of the variable of macro to access
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return getattr(current_app.jinja_env.get_template(template_name).module, attribute)</span>


<span class="gd">-def flash(message: str, category: str=&#39;message&#39;) -&gt;None:</span>
<span class="gi">+def flash(message: str, category: str = &quot;message&quot;) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Flashes a message to the next request.  In order to remove the
<span class="w"> </span>    flashed message from the session and to display it to the user,
<span class="w"> </span>    the template has to call :func:`get_flashed_messages`.
<span class="gu">@@ -239,11 +311,28 @@ def flash(message: str, category: str=&#39;message&#39;) -&gt;None:</span>
<span class="w"> </span>                     messages and ``&#39;warning&#39;`` for warnings.  However any
<span class="w"> </span>                     kind of string can be used as category.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_flashed_messages(with_categories: bool=False, category_filter: t.</span>
<span class="gd">-    Iterable[str]=()) -&gt;(list[str] | list[tuple[str, str]]):</span>
<span class="gi">+    # Original implementation:</span>
<span class="gi">+    #</span>
<span class="gi">+    #     session.setdefault(&#39;_flashes&#39;, []).append((category, message))</span>
<span class="gi">+    #</span>
<span class="gi">+    # This assumed that changes made to mutable structures in the session are</span>
<span class="gi">+    # always in sync with the session object, which is not true for session</span>
<span class="gi">+    # implementations that use external storage for keeping their keys/values.</span>
<span class="gi">+    flashes = session.get(&quot;_flashes&quot;, [])</span>
<span class="gi">+    flashes.append((category, message))</span>
<span class="gi">+    session[&quot;_flashes&quot;] = flashes</span>
<span class="gi">+    app = current_app._get_current_object()  # type: ignore</span>
<span class="gi">+    message_flashed.send(</span>
<span class="gi">+        app,</span>
<span class="gi">+        _async_wrapper=app.ensure_sync,</span>
<span class="gi">+        message=message,</span>
<span class="gi">+        category=category,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_flashed_messages(</span>
<span class="gi">+    with_categories: bool = False, category_filter: t.Iterable[str] = ()</span>
<span class="gi">+) -&gt; list[str] | list[tuple[str, str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pulls all flashed messages from the session and returns them.
<span class="w"> </span>    Further calls in the same request to the function will return
<span class="w"> </span>    the same messages.  By default just the messages are returned,
<span class="gu">@@ -272,14 +361,40 @@ def get_flashed_messages(with_categories: bool=False, category_filter: t.</span>
<span class="w"> </span>    :param category_filter: filter of categories to limit return values.  Only
<span class="w"> </span>                            categories in the list will be returned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def send_file(path_or_file: (os.PathLike[t.AnyStr] | str | t.BinaryIO),</span>
<span class="gd">-    mimetype: (str | None)=None, as_attachment: bool=False, download_name:</span>
<span class="gd">-    (str | None)=None, conditional: bool=True, etag: (bool | str)=True,</span>
<span class="gd">-    last_modified: (datetime | int | float | None)=None, max_age: (None | (</span>
<span class="gd">-    int | t.Callable[[str | None], int | None]))=None) -&gt;Response:</span>
<span class="gi">+    flashes = request_ctx.flashes</span>
<span class="gi">+    if flashes is None:</span>
<span class="gi">+        flashes = session.pop(&quot;_flashes&quot;) if &quot;_flashes&quot; in session else []</span>
<span class="gi">+        request_ctx.flashes = flashes</span>
<span class="gi">+    if category_filter:</span>
<span class="gi">+        flashes = list(filter(lambda f: f[0] in category_filter, flashes))</span>
<span class="gi">+    if not with_categories:</span>
<span class="gi">+        return [x[1] for x in flashes]</span>
<span class="gi">+    return flashes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _prepare_send_file_kwargs(**kwargs: t.Any) -&gt; dict[str, t.Any]:</span>
<span class="gi">+    if kwargs.get(&quot;max_age&quot;) is None:</span>
<span class="gi">+        kwargs[&quot;max_age&quot;] = current_app.get_send_file_max_age</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.update(</span>
<span class="gi">+        environ=request.environ,</span>
<span class="gi">+        use_x_sendfile=current_app.config[&quot;USE_X_SENDFILE&quot;],</span>
<span class="gi">+        response_class=current_app.response_class,</span>
<span class="gi">+        _root_path=current_app.root_path,  # type: ignore</span>
<span class="gi">+    )</span>
<span class="gi">+    return kwargs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def send_file(</span>
<span class="gi">+    path_or_file: os.PathLike[t.AnyStr] | str | t.BinaryIO,</span>
<span class="gi">+    mimetype: str | None = None,</span>
<span class="gi">+    as_attachment: bool = False,</span>
<span class="gi">+    download_name: str | None = None,</span>
<span class="gi">+    conditional: bool = True,</span>
<span class="gi">+    etag: bool | str = True,</span>
<span class="gi">+    last_modified: datetime | int | float | None = None,</span>
<span class="gi">+    max_age: None | (int | t.Callable[[str | None], int | None]) = None,</span>
<span class="gi">+) -&gt; Response:</span>
<span class="w"> </span>    &quot;&quot;&quot;Send the contents of a file to the client.

<span class="w"> </span>    The first argument can be a file path or a file-like object. Paths
<span class="gu">@@ -381,11 +496,26 @@ def send_file(path_or_file: (os.PathLike[t.AnyStr] | str | t.BinaryIO),</span>

<span class="w"> </span>    .. versionadded:: 0.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def send_from_directory(directory: (os.PathLike[str] | str), path: (os.</span>
<span class="gd">-    PathLike[str] | str), **kwargs: t.Any) -&gt;Response:</span>
<span class="gi">+    return werkzeug.utils.send_file(  # type: ignore[return-value]</span>
<span class="gi">+        **_prepare_send_file_kwargs(</span>
<span class="gi">+            path_or_file=path_or_file,</span>
<span class="gi">+            environ=request.environ,</span>
<span class="gi">+            mimetype=mimetype,</span>
<span class="gi">+            as_attachment=as_attachment,</span>
<span class="gi">+            download_name=download_name,</span>
<span class="gi">+            conditional=conditional,</span>
<span class="gi">+            etag=etag,</span>
<span class="gi">+            last_modified=last_modified,</span>
<span class="gi">+            max_age=max_age,</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def send_from_directory(</span>
<span class="gi">+    directory: os.PathLike[str] | str,</span>
<span class="gi">+    path: os.PathLike[str] | str,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; Response:</span>
<span class="w"> </span>    &quot;&quot;&quot;Send a file from within a directory using :func:`send_file`.

<span class="w"> </span>    .. code-block:: python
<span class="gu">@@ -419,10 +549,12 @@ def send_from_directory(directory: (os.PathLike[str] | str), path: (os.</span>

<span class="w"> </span>    .. versionadded:: 0.5
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]</span>
<span class="gi">+        directory, path, **_prepare_send_file_kwargs(**kwargs)</span>
<span class="gi">+    )</span>


<span class="gd">-def get_root_path(import_name: str) -&gt;str:</span>
<span class="gi">+def get_root_path(import_name: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the root path of a package, or the path that contains a
<span class="w"> </span>    module. If it cannot be found, returns the current working
<span class="w"> </span>    directory.
<span class="gu">@@ -431,4 +563,59 @@ def get_root_path(import_name: str) -&gt;str:</span>

<span class="w"> </span>    :meta private:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Module already imported and has a file attribute. Use that first.</span>
<span class="gi">+    mod = sys.modules.get(import_name)</span>
<span class="gi">+</span>
<span class="gi">+    if mod is not None and hasattr(mod, &quot;__file__&quot;) and mod.__file__ is not None:</span>
<span class="gi">+        return os.path.dirname(os.path.abspath(mod.__file__))</span>
<span class="gi">+</span>
<span class="gi">+    # Next attempt: check the loader.</span>
<span class="gi">+    try:</span>
<span class="gi">+        spec = importlib.util.find_spec(import_name)</span>
<span class="gi">+</span>
<span class="gi">+        if spec is None:</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+    except (ImportError, ValueError):</span>
<span class="gi">+        loader = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        loader = spec.loader</span>
<span class="gi">+</span>
<span class="gi">+    # Loader does not exist or we&#39;re referring to an unloaded main</span>
<span class="gi">+    # module or a main module without path (interactive sessions), go</span>
<span class="gi">+    # with the current working directory.</span>
<span class="gi">+    if loader is None:</span>
<span class="gi">+        return os.getcwd()</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(loader, &quot;get_filename&quot;):</span>
<span class="gi">+        filepath = loader.get_filename(import_name)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Fall back to imports.</span>
<span class="gi">+        __import__(import_name)</span>
<span class="gi">+        mod = sys.modules[import_name]</span>
<span class="gi">+        filepath = getattr(mod, &quot;__file__&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # If we don&#39;t have a file path it might be because it is a</span>
<span class="gi">+        # namespace package. In this case pick the root path from the</span>
<span class="gi">+        # first module that is contained in the package.</span>
<span class="gi">+        if filepath is None:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;No root path can be found for the provided module&quot;</span>
<span class="gi">+                f&quot; {import_name!r}. This can happen because the module&quot;</span>
<span class="gi">+                &quot; came from an import hook that does not provide file&quot;</span>
<span class="gi">+                &quot; name information or because it&#39;s a namespace package.&quot;</span>
<span class="gi">+                &quot; In this case the root path needs to be explicitly&quot;</span>
<span class="gi">+                &quot; provided.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # filepath is import_name.py for a module, or __init__.py for a package.</span>
<span class="gi">+    return os.path.dirname(os.path.abspath(filepath))  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@lru_cache(maxsize=None)</span>
<span class="gi">+def _split_blueprint_path(name: str) -&gt; list[str]:</span>
<span class="gi">+    out: list[str] = [name]</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;.&quot; in name:</span>
<span class="gi">+        out.extend(_split_blueprint_path(name.rpartition(&quot;.&quot;)[0]))</span>
<span class="gi">+</span>
<span class="gi">+    return out</span>
<span class="gh">diff --git a/src/flask/json/provider.py b/src/flask/json/provider.py</span>
<span class="gh">index e9123cb0..f9b2e8ff 100644</span>
<span class="gd">--- a/src/flask/json/provider.py</span>
<span class="gi">+++ b/src/flask/json/provider.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import decimal
<span class="w"> </span>import json
<span class="gu">@@ -6,9 +7,12 @@ import typing as t</span>
<span class="w"> </span>import uuid
<span class="w"> </span>import weakref
<span class="w"> </span>from datetime import date
<span class="gi">+</span>
<span class="w"> </span>from werkzeug.http import http_date
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from werkzeug.sansio.response import Response
<span class="gi">+</span>
<span class="w"> </span>    from ..sansio.app import App


<span class="gu">@@ -31,18 +35,18 @@ class JSONProvider:</span>
<span class="w"> </span>    .. versionadded:: 2.2
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: App) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: App) -&gt; None:</span>
<span class="w"> </span>        self._app: App = weakref.proxy(app)

<span class="gd">-    def dumps(self, obj: t.Any, **kwargs: t.Any) -&gt;str:</span>
<span class="gi">+    def dumps(self, obj: t.Any, **kwargs: t.Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize data as JSON.

<span class="w"> </span>        :param obj: The data to serialize.
<span class="w"> </span>        :param kwargs: May be passed to the underlying JSON library.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize data as JSON and write to a file.

<span class="w"> </span>        :param obj: The data to serialize.
<span class="gu">@@ -50,25 +54,39 @@ class JSONProvider:</span>
<span class="w"> </span>            encoding to be valid JSON.
<span class="w"> </span>        :param kwargs: May be passed to the underlying JSON library.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fp.write(self.dumps(obj, **kwargs))</span>

<span class="gd">-    def loads(self, s: (str | bytes), **kwargs: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def loads(self, s: str | bytes, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Deserialize data as JSON.

<span class="w"> </span>        :param s: Text or UTF-8 bytes.
<span class="w"> </span>        :param kwargs: May be passed to the underlying JSON library.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Deserialize data as JSON read from a file.

<span class="w"> </span>        :param fp: A file opened for reading text or UTF-8 bytes.
<span class="w"> </span>        :param kwargs: May be passed to the underlying JSON library.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.loads(fp.read(), **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def _prepare_response_obj(</span>
<span class="gi">+        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        if args and kwargs:</span>
<span class="gi">+            raise TypeError(&quot;app.json.response() takes either args or kwargs, not both&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not args and not kwargs:</span>
<span class="gi">+            return None</span>

<span class="gd">-    def response(self, *args: t.Any, **kwargs: t.Any) -&gt;Response:</span>
<span class="gi">+        if len(args) == 1:</span>
<span class="gi">+            return args[0]</span>
<span class="gi">+</span>
<span class="gi">+        return args or kwargs</span>
<span class="gi">+</span>
<span class="gi">+    def response(self, *args: t.Any, **kwargs: t.Any) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize the given arguments as JSON, and return a
<span class="w"> </span>        :class:`~flask.Response` object with the ``application/json``
<span class="w"> </span>        mimetype.
<span class="gu">@@ -83,7 +101,24 @@ class JSONProvider:</span>
<span class="w"> </span>            treat as a list to serialize.
<span class="w"> </span>        :param kwargs: Treat as a dict to serialize.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        obj = self._prepare_response_obj(args, kwargs)</span>
<span class="gi">+        return self._app.response_class(self.dumps(obj), mimetype=&quot;application/json&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _default(o: t.Any) -&gt; t.Any:</span>
<span class="gi">+    if isinstance(o, date):</span>
<span class="gi">+        return http_date(o)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(o, (decimal.Decimal, uuid.UUID)):</span>
<span class="gi">+        return str(o)</span>
<span class="gi">+</span>
<span class="gi">+    if dataclasses and dataclasses.is_dataclass(o):</span>
<span class="gi">+        return dataclasses.asdict(o)</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(o, &quot;__html__&quot;):</span>
<span class="gi">+        return str(o.__html__())</span>
<span class="gi">+</span>
<span class="gi">+    raise TypeError(f&quot;Object of type {type(o).__name__} is not JSON serializable&quot;)</span>


<span class="w"> </span>class DefaultJSONProvider(JSONProvider):
<span class="gu">@@ -99,31 +134,36 @@ class DefaultJSONProvider(JSONProvider):</span>
<span class="w"> </span>    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``
<span class="w"> </span>        method) will call the ``__html__`` method to get a string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default: t.Callable[[t.Any], t.Any] = staticmethod(_default)</span>
<span class="gi">+</span>
<span class="gi">+    default: t.Callable[[t.Any], t.Any] = staticmethod(_default)  # type: ignore[assignment]</span>
<span class="w"> </span>    &quot;&quot;&quot;Apply this function to any object that :meth:`json.dumps` does
<span class="w"> </span>    not know how to serialize. It should return a valid JSON type or
<span class="w"> </span>    raise a ``TypeError``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ensure_ascii = True
<span class="w"> </span>    &quot;&quot;&quot;Replace non-ASCII characters with escape sequences. This may be
<span class="w"> </span>    more compatible with some clients, but can be disabled for better
<span class="w"> </span>    performance and size.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    sort_keys = True
<span class="w"> </span>    &quot;&quot;&quot;Sort the keys in any serialized dicts. This may be useful for
<span class="w"> </span>    some caching situations, but can be disabled for better performance.
<span class="w"> </span>    When enabled, keys must all be strings, they are not converted
<span class="w"> </span>    before sorting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    compact: bool | None = None
<span class="w"> </span>    &quot;&quot;&quot;If ``True``, or ``None`` out of debug mode, the :meth:`response`
<span class="w"> </span>    output will not add indentation, newlines, or spaces. If ``False``,
<span class="w"> </span>    or ``None`` in debug mode, it will use a non-compact representation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    mimetype = &#39;application/json&#39;</span>
<span class="gi">+</span>
<span class="gi">+    mimetype = &quot;application/json&quot;</span>
<span class="w"> </span>    &quot;&quot;&quot;The mimetype set in :meth:`response`.&quot;&quot;&quot;

<span class="gd">-    def dumps(self, obj: t.Any, **kwargs: t.Any) -&gt;str:</span>
<span class="gi">+    def dumps(self, obj: t.Any, **kwargs: t.Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize data as JSON to a string.

<span class="w"> </span>        Keyword arguments are passed to :func:`json.dumps`. Sets some
<span class="gu">@@ -133,17 +173,20 @@ class DefaultJSONProvider(JSONProvider):</span>
<span class="w"> </span>        :param obj: The data to serialize.
<span class="w"> </span>        :param kwargs: Passed to :func:`json.dumps`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs.setdefault(&quot;default&quot;, self.default)</span>
<span class="gi">+        kwargs.setdefault(&quot;ensure_ascii&quot;, self.ensure_ascii)</span>
<span class="gi">+        kwargs.setdefault(&quot;sort_keys&quot;, self.sort_keys)</span>
<span class="gi">+        return json.dumps(obj, **kwargs)</span>

<span class="gd">-    def loads(self, s: (str | bytes), **kwargs: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def loads(self, s: str | bytes, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Deserialize data as JSON from a string or bytes.

<span class="w"> </span>        :param s: Text or UTF-8 bytes.
<span class="w"> </span>        :param kwargs: Passed to :func:`json.loads`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return json.loads(s, **kwargs)</span>

<span class="gd">-    def response(self, *args: t.Any, **kwargs: t.Any) -&gt;Response:</span>
<span class="gi">+    def response(self, *args: t.Any, **kwargs: t.Any) -&gt; Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize the given arguments as JSON, and return a
<span class="w"> </span>        :class:`~flask.Response` object with it. The response mimetype
<span class="w"> </span>        will be &quot;application/json&quot; and can be changed with
<span class="gu">@@ -159,4 +202,14 @@ class DefaultJSONProvider(JSONProvider):</span>
<span class="w"> </span>            treat as a list to serialize.
<span class="w"> </span>        :param kwargs: Treat as a dict to serialize.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        obj = self._prepare_response_obj(args, kwargs)</span>
<span class="gi">+        dump_args: dict[str, t.Any] = {}</span>
<span class="gi">+</span>
<span class="gi">+        if (self.compact is None and self._app.debug) or self.compact is False:</span>
<span class="gi">+            dump_args.setdefault(&quot;indent&quot;, 2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            dump_args.setdefault(&quot;separators&quot;, (&quot;,&quot;, &quot;:&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        return self._app.response_class(</span>
<span class="gi">+            f&quot;{self.dumps(obj, **dump_args)}\n&quot;, mimetype=self.mimetype</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/flask/json/tag.py b/src/flask/json/tag.py</span>
<span class="gh">index ded094b2..8dc3629b 100644</span>
<span class="gd">--- a/src/flask/json/tag.py</span>
<span class="gi">+++ b/src/flask/json/tag.py</span>
<span class="gu">@@ -40,46 +40,54 @@ be processed before ``dict``.</span>

<span class="w"> </span>    app.session_interface.serializer.register(TagOrderedDict, index=0)
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from base64 import b64decode
<span class="w"> </span>from base64 import b64encode
<span class="w"> </span>from datetime import datetime
<span class="w"> </span>from uuid import UUID
<span class="gi">+</span>
<span class="w"> </span>from markupsafe import Markup
<span class="w"> </span>from werkzeug.http import http_date
<span class="w"> </span>from werkzeug.http import parse_date
<span class="gi">+</span>
<span class="w"> </span>from ..json import dumps
<span class="w"> </span>from ..json import loads


<span class="w"> </span>class JSONTag:
<span class="w"> </span>    &quot;&quot;&quot;Base class for defining type tags for :class:`TaggedJSONSerializer`.&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;serializer&#39;,</span>
<span class="gd">-    key: str = &#39;&#39;</span>

<span class="gd">-    def __init__(self, serializer: TaggedJSONSerializer) -&gt;None:</span>
<span class="gi">+    __slots__ = (&quot;serializer&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+    #: The tag to mark the serialized object with. If empty, this tag is</span>
<span class="gi">+    #: only used as an intermediate step during tagging.</span>
<span class="gi">+    key: str = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, serializer: TaggedJSONSerializer) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a tagger for the given serializer.&quot;&quot;&quot;
<span class="w"> </span>        self.serializer = serializer

<span class="gd">-    def check(self, value: t.Any) -&gt;bool:</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the given value should be tagged by this tag.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def to_json(self, value: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the Python object to an object that is a valid JSON type.
<span class="w"> </span>        The tag will be added later.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def to_python(self, value: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def to_python(self, value: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the JSON representation back to the correct type. The tag
<span class="w"> </span>        will already be removed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def tag(self, value: t.Any) -&gt;dict[str, t.Any]:</span>
<span class="gi">+    def tag(self, value: t.Any) -&gt; dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the value to a valid JSON type and add the tag structure
<span class="w"> </span>        around it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {self.key: self.to_json(value)}</span>


<span class="w"> </span>class TagDict(JSONTag):
<span class="gu">@@ -88,46 +96,124 @@ class TagDict(JSONTag):</span>
<span class="w"> </span>    Internally, the dict key is suffixed with `__`, and the suffix is removed
<span class="w"> </span>    when deserializing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="gd">-    key = &#39; di&#39;</span>
<span class="gi">+    key = &quot; di&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(value, dict)</span>
<span class="gi">+            and len(value) == 1</span>
<span class="gi">+            and next(iter(value)) in self.serializer.tags</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        key = next(iter(value))</span>
<span class="gi">+        return {f&quot;{key}__&quot;: self.serializer.tag(value[key])}</span>
<span class="gi">+</span>
<span class="gi">+    def to_python(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        key = next(iter(value))</span>
<span class="gi">+        return {key[:-2]: value[key]}</span>


<span class="w"> </span>class PassDict(JSONTag):
<span class="w"> </span>    __slots__ = ()
<span class="gi">+</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(value, dict)</span>
<span class="gi">+</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        # JSON objects may only have string keys, so don&#39;t bother tagging the</span>
<span class="gi">+        # key here.</span>
<span class="gi">+        return {k: self.serializer.tag(v) for k, v in value.items()}</span>
<span class="gi">+</span>
<span class="w"> </span>    tag = to_json


<span class="w"> </span>class TagTuple(JSONTag):
<span class="w"> </span>    __slots__ = ()
<span class="gd">-    key = &#39; t&#39;</span>
<span class="gi">+    key = &quot; t&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(value, tuple)</span>
<span class="gi">+</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return [self.serializer.tag(item) for item in value]</span>
<span class="gi">+</span>
<span class="gi">+    def to_python(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return tuple(value)</span>


<span class="w"> </span>class PassList(JSONTag):
<span class="w"> </span>    __slots__ = ()
<span class="gi">+</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(value, list)</span>
<span class="gi">+</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return [self.serializer.tag(item) for item in value]</span>
<span class="gi">+</span>
<span class="w"> </span>    tag = to_json


<span class="w"> </span>class TagBytes(JSONTag):
<span class="w"> </span>    __slots__ = ()
<span class="gd">-    key = &#39; b&#39;</span>
<span class="gi">+    key = &quot; b&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(value, bytes)</span>
<span class="gi">+</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return b64encode(value).decode(&quot;ascii&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def to_python(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return b64decode(value)</span>


<span class="w"> </span>class TagMarkup(JSONTag):
<span class="w"> </span>    &quot;&quot;&quot;Serialize anything matching the :class:`~markupsafe.Markup` API by
<span class="w"> </span>    having a ``__html__`` method to the result of that method. Always
<span class="w"> </span>    deserializes to an instance of :class:`~markupsafe.Markup`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="gd">-    key = &#39; m&#39;</span>
<span class="gi">+    key = &quot; m&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        return callable(getattr(value, &quot;__html__&quot;, None))</span>
<span class="gi">+</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return str(value.__html__())</span>
<span class="gi">+</span>
<span class="gi">+    def to_python(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return Markup(value)</span>


<span class="w"> </span>class TagUUID(JSONTag):
<span class="w"> </span>    __slots__ = ()
<span class="gd">-    key = &#39; u&#39;</span>
<span class="gi">+    key = &quot; u&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(value, UUID)</span>
<span class="gi">+</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return value.hex</span>
<span class="gi">+</span>
<span class="gi">+    def to_python(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return UUID(value)</span>


<span class="w"> </span>class TagDateTime(JSONTag):
<span class="w"> </span>    __slots__ = ()
<span class="gd">-    key = &#39; d&#39;</span>
<span class="gi">+    key = &quot; d&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def check(self, value: t.Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(value, datetime)</span>
<span class="gi">+</span>
<span class="gi">+    def to_json(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return http_date(value)</span>
<span class="gi">+</span>
<span class="gi">+    def to_python(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return parse_date(value)</span>


<span class="w"> </span>class TaggedJSONSerializer:
<span class="gu">@@ -144,18 +230,35 @@ class TaggedJSONSerializer:</span>
<span class="w"> </span>    * :class:`~uuid.UUID`
<span class="w"> </span>    * :class:`~datetime.datetime`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;tags&#39;, &#39;order&#39;</span>
<span class="gd">-    default_tags = [TagDict, PassDict, TagTuple, PassList, TagBytes,</span>
<span class="gd">-        TagMarkup, TagUUID, TagDateTime]</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    __slots__ = (&quot;tags&quot;, &quot;order&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    #: Tag classes to bind when creating the serializer. Other tags can be</span>
<span class="gi">+    #: added later using :meth:`~register`.</span>
<span class="gi">+    default_tags = [</span>
<span class="gi">+        TagDict,</span>
<span class="gi">+        PassDict,</span>
<span class="gi">+        TagTuple,</span>
<span class="gi">+        PassList,</span>
<span class="gi">+        TagBytes,</span>
<span class="gi">+        TagMarkup,</span>
<span class="gi">+        TagUUID,</span>
<span class="gi">+        TagDateTime,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.tags: dict[str, JSONTag] = {}
<span class="w"> </span>        self.order: list[JSONTag] = []
<span class="gi">+</span>
<span class="w"> </span>        for cls in self.default_tags:
<span class="w"> </span>            self.register(cls)

<span class="gd">-    def register(self, tag_class: type[JSONTag], force: bool=False, index:</span>
<span class="gd">-        (int | None)=None) -&gt;None:</span>
<span class="gi">+    def register(</span>
<span class="gi">+        self,</span>
<span class="gi">+        tag_class: type[JSONTag],</span>
<span class="gi">+        force: bool = False,</span>
<span class="gi">+        index: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a new tag with this serializer.

<span class="w"> </span>        :param tag_class: tag class to register. Will be instantiated with this
<span class="gu">@@ -169,20 +272,56 @@ class TaggedJSONSerializer:</span>
<span class="w"> </span>        :raise KeyError: if the tag key is already registered and ``force`` is
<span class="w"> </span>            not true.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tag = tag_class(self)</span>
<span class="gi">+        key = tag.key</span>
<span class="gi">+</span>
<span class="gi">+        if key:</span>
<span class="gi">+            if not force and key in self.tags:</span>
<span class="gi">+                raise KeyError(f&quot;Tag &#39;{key}&#39; is already registered.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            self.tags[key] = tag</span>

<span class="gd">-    def tag(self, value: t.Any) -&gt;t.Any:</span>
<span class="gi">+        if index is None:</span>
<span class="gi">+            self.order.append(tag)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.order.insert(index, tag)</span>
<span class="gi">+</span>
<span class="gi">+    def tag(self, value: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert a value to a tagged representation if necessary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for tag in self.order:</span>
<span class="gi">+            if tag.check(value):</span>
<span class="gi">+                return tag.tag(value)</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>

<span class="gd">-    def untag(self, value: dict[str, t.Any]) -&gt;t.Any:</span>
<span class="gi">+    def untag(self, value: dict[str, t.Any]) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert a tagged representation back to the original type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(value) != 1:</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        key = next(iter(value))</span>
<span class="gi">+</span>
<span class="gi">+        if key not in self.tags:</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        return self.tags[key].to_python(value[key])</span>
<span class="gi">+</span>
<span class="gi">+    def _untag_scan(self, value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        if isinstance(value, dict):</span>
<span class="gi">+            # untag each item recursively</span>
<span class="gi">+            value = {k: self._untag_scan(v) for k, v in value.items()}</span>
<span class="gi">+            # untag the dict itself</span>
<span class="gi">+            value = self.untag(value)</span>
<span class="gi">+        elif isinstance(value, list):</span>
<span class="gi">+            # untag each item recursively</span>
<span class="gi">+            value = [self._untag_scan(item) for item in value]</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>

<span class="gd">-    def dumps(self, value: t.Any) -&gt;str:</span>
<span class="gi">+    def dumps(self, value: t.Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Tag the value and dump it to a compact JSON string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dumps(self.tag(value), separators=(&quot;,&quot;, &quot;:&quot;))</span>

<span class="gd">-    def loads(self, value: str) -&gt;t.Any:</span>
<span class="gi">+    def loads(self, value: str) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load data from a JSON string and deserialized any tagged objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._untag_scan(loads(value))</span>
<span class="gh">diff --git a/src/flask/logging.py b/src/flask/logging.py</span>
<span class="gh">index 6fe6f650..0cb8f437 100644</span>
<span class="gd">--- a/src/flask/logging.py</span>
<span class="gi">+++ b/src/flask/logging.py</span>
<span class="gu">@@ -1,15 +1,19 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import sys
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from werkzeug.local import LocalProxy
<span class="gi">+</span>
<span class="w"> </span>from .globals import request
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from .sansio.app import App


<span class="w"> </span>@LocalProxy
<span class="gd">-def wsgi_errors_stream() -&gt;t.TextIO:</span>
<span class="gi">+def wsgi_errors_stream() -&gt; t.TextIO:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the most appropriate error stream for the application. If a request
<span class="w"> </span>    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.

<span class="gu">@@ -18,22 +22,40 @@ def wsgi_errors_stream() -&gt;t.TextIO:</span>
<span class="w"> </span>    can&#39;t import this directly, you can refer to it as
<span class="w"> </span>    ``ext://flask.logging.wsgi_errors_stream``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if request:</span>
<span class="gi">+        return request.environ[&quot;wsgi.errors&quot;]  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    return sys.stderr</span>


<span class="gd">-def has_level_handler(logger: logging.Logger) -&gt;bool:</span>
<span class="gi">+def has_level_handler(logger: logging.Logger) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if there is a handler in the logging chain that will handle the
<span class="w"> </span>    given logger&#39;s :meth:`effective level &lt;~logging.Logger.getEffectiveLevel&gt;`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    level = logger.getEffectiveLevel()</span>
<span class="gi">+    current = logger</span>
<span class="gi">+</span>
<span class="gi">+    while current:</span>
<span class="gi">+        if any(handler.level &lt;= level for handler in current.handlers):</span>
<span class="gi">+            return True</span>

<span class="gi">+        if not current.propagate:</span>
<span class="gi">+            break</span>

<span class="gd">-default_handler = logging.StreamHandler(wsgi_errors_stream)</span>
<span class="gd">-default_handler.setFormatter(logging.Formatter(</span>
<span class="gd">-    &#39;[%(asctime)s] %(levelname)s in %(module)s: %(message)s&#39;))</span>
<span class="gi">+        current = current.parent  # type: ignore</span>

<span class="gi">+    return False</span>

<span class="gd">-def create_logger(app: App) -&gt;logging.Logger:</span>
<span class="gi">+</span>
<span class="gi">+#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format</span>
<span class="gi">+#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.</span>
<span class="gi">+default_handler = logging.StreamHandler(wsgi_errors_stream)  # type: ignore</span>
<span class="gi">+default_handler.setFormatter(</span>
<span class="gi">+    logging.Formatter(&quot;[%(asctime)s] %(levelname)s in %(module)s: %(message)s&quot;)</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_logger(app: App) -&gt; logging.Logger:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the Flask app&#39;s logger and configure it if needed.

<span class="w"> </span>    The logger name will be the same as
<span class="gu">@@ -46,4 +68,12 @@ def create_logger(app: App) -&gt;logging.Logger:</span>
<span class="w"> </span>    :class:`~logging.StreamHandler` for
<span class="w"> </span>    :func:`~flask.logging.wsgi_errors_stream` with a basic format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(app.name)</span>
<span class="gi">+</span>
<span class="gi">+    if app.debug and not logger.level:</span>
<span class="gi">+        logger.setLevel(logging.DEBUG)</span>
<span class="gi">+</span>
<span class="gi">+    if not has_level_handler(logger):</span>
<span class="gi">+        logger.addHandler(default_handler)</span>
<span class="gi">+</span>
<span class="gi">+    return logger</span>
<span class="gh">diff --git a/src/flask/sansio/app.py b/src/flask/sansio/app.py</span>
<span class="gh">index 2424fb7f..01fd5dbf 100644</span>
<span class="gd">--- a/src/flask/sansio/app.py</span>
<span class="gi">+++ b/src/flask/sansio/app.py</span>
<span class="gu">@@ -1,10 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>import typing as t
<span class="w"> </span>from datetime import timedelta
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>from werkzeug.exceptions import Aborter
<span class="w"> </span>from werkzeug.exceptions import BadRequest
<span class="w"> </span>from werkzeug.exceptions import BadRequestKeyError
<span class="gu">@@ -14,6 +16,7 @@ from werkzeug.routing import Rule</span>
<span class="w"> </span>from werkzeug.sansio.response import Response
<span class="w"> </span>from werkzeug.utils import cached_property
<span class="w"> </span>from werkzeug.utils import redirect as _wz_redirect
<span class="gi">+</span>
<span class="w"> </span>from .. import typing as ft
<span class="w"> </span>from ..config import Config
<span class="w"> </span>from ..config import ConfigAttribute
<span class="gu">@@ -29,19 +32,28 @@ from .scaffold import _endpoint_from_view_func</span>
<span class="w"> </span>from .scaffold import find_package
<span class="w"> </span>from .scaffold import Scaffold
<span class="w"> </span>from .scaffold import setupmethod
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from werkzeug.wrappers import Response as BaseResponse
<span class="gi">+</span>
<span class="w"> </span>    from ..testing import FlaskClient
<span class="w"> </span>    from ..testing import FlaskCliRunner
<span class="w"> </span>    from .blueprints import Blueprint
<span class="gd">-T_shell_context_processor = t.TypeVar(&#39;T_shell_context_processor&#39;, bound=ft</span>
<span class="gd">-    .ShellContextProcessorCallable)</span>
<span class="gd">-T_teardown = t.TypeVar(&#39;T_teardown&#39;, bound=ft.TeardownCallable)</span>
<span class="gd">-T_template_filter = t.TypeVar(&#39;T_template_filter&#39;, bound=ft.</span>
<span class="gd">-    TemplateFilterCallable)</span>
<span class="gd">-T_template_global = t.TypeVar(&#39;T_template_global&#39;, bound=ft.</span>
<span class="gd">-    TemplateGlobalCallable)</span>
<span class="gd">-T_template_test = t.TypeVar(&#39;T_template_test&#39;, bound=ft.TemplateTestCallable)</span>
<span class="gi">+</span>
<span class="gi">+T_shell_context_processor = t.TypeVar(</span>
<span class="gi">+    &quot;T_shell_context_processor&quot;, bound=ft.ShellContextProcessorCallable</span>
<span class="gi">+)</span>
<span class="gi">+T_teardown = t.TypeVar(&quot;T_teardown&quot;, bound=ft.TeardownCallable)</span>
<span class="gi">+T_template_filter = t.TypeVar(&quot;T_template_filter&quot;, bound=ft.TemplateFilterCallable)</span>
<span class="gi">+T_template_global = t.TypeVar(&quot;T_template_global&quot;, bound=ft.TemplateGlobalCallable)</span>
<span class="gi">+T_template_test = t.TypeVar(&quot;T_template_test&quot;, bound=ft.TemplateTestCallable)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_timedelta(value: timedelta | int | None) -&gt; timedelta | None:</span>
<span class="gi">+    if value is None or isinstance(value, timedelta):</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    return timedelta(seconds=value)</span>


<span class="w"> </span>class App(Scaffold):
<span class="gu">@@ -140,14 +152,81 @@ class App(Scaffold):</span>
<span class="w"> </span>        This should only be set manually when it can&#39;t be detected
<span class="w"> </span>        automatically, such as for namespace packages.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: The class of the object assigned to :attr:`aborter`, created by</span>
<span class="gi">+    #: :meth:`create_aborter`. That object is called by</span>
<span class="gi">+    #: :func:`flask.abort` to raise HTTP errors, and can be</span>
<span class="gi">+    #: called directly as well.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: Defaults to :class:`werkzeug.exceptions.Aborter`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 2.2</span>
<span class="w"> </span>    aborter_class = Aborter
<span class="gi">+</span>
<span class="gi">+    #: The class that is used for the Jinja environment.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.11</span>
<span class="w"> </span>    jinja_environment = Environment
<span class="gi">+</span>
<span class="gi">+    #: The class that is used for the :data:`~flask.g` instance.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: Example use cases for a custom class:</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: 1. Store arbitrary attributes on flask.g.</span>
<span class="gi">+    #: 2. Add a property for lazy per-request database connectors.</span>
<span class="gi">+    #: 3. Return None instead of AttributeError on unexpected attributes.</span>
<span class="gi">+    #: 4. Raise exception if an unexpected attr is set, a &quot;controlled&quot; flask.g.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: In Flask 0.9 this property was called `request_globals_class` but it</span>
<span class="gi">+    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the</span>
<span class="gi">+    #: flask.g object is now application context scoped.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.10</span>
<span class="w"> </span>    app_ctx_globals_class = _AppCtxGlobals
<span class="gi">+</span>
<span class="gi">+    #: The class that is used for the ``config`` attribute of this app.</span>
<span class="gi">+    #: Defaults to :class:`~flask.Config`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: Example use cases for a custom class:</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: 1. Default values for certain config options.</span>
<span class="gi">+    #: 2. Access to config values through attributes in addition to keys.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.11</span>
<span class="w"> </span>    config_class = Config
<span class="gd">-    testing = ConfigAttribute[bool](&#39;TESTING&#39;)</span>
<span class="gd">-    secret_key = ConfigAttribute[t.Union[str, bytes, None]](&#39;SECRET_KEY&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    #: The testing flag.  Set this to ``True`` to enable the test mode of</span>
<span class="gi">+    #: Flask extensions (and in the future probably also Flask itself).</span>
<span class="gi">+    #: For example this might activate test helpers that have an</span>
<span class="gi">+    #: additional runtime cost which should not be enabled by default.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the</span>
<span class="gi">+    #: default it&#39;s implicitly enabled.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: This attribute can also be configured from the config with the</span>
<span class="gi">+    #: ``TESTING`` configuration key.  Defaults to ``False``.</span>
<span class="gi">+    testing = ConfigAttribute[bool](&quot;TESTING&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    #: If a secret key is set, cryptographic components can use this to</span>
<span class="gi">+    #: sign cookies and other things. Set this to a complex random value</span>
<span class="gi">+    #: when you want to use the secure cookie for instance.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: This attribute can also be configured from the config with the</span>
<span class="gi">+    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.</span>
<span class="gi">+    secret_key = ConfigAttribute[t.Union[str, bytes, None]](&quot;SECRET_KEY&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    #: A :class:`~datetime.timedelta` which is used to set the expiration</span>
<span class="gi">+    #: date of a permanent session.  The default is 31 days which makes a</span>
<span class="gi">+    #: permanent session survive for roughly one month.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: This attribute can also be configured from the config with the</span>
<span class="gi">+    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to</span>
<span class="gi">+    #: ``timedelta(days=31)``</span>
<span class="w"> </span>    permanent_session_lifetime = ConfigAttribute[timedelta](
<span class="gd">-        &#39;PERMANENT_SESSION_LIFETIME&#39;, get_converter=_make_timedelta)</span>
<span class="gi">+        &quot;PERMANENT_SESSION_LIFETIME&quot;,</span>
<span class="gi">+        get_converter=_make_timedelta,  # type: ignore[arg-type]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    json_provider_class: type[JSONProvider] = DefaultJSONProvider
<span class="w"> </span>    &quot;&quot;&quot;A subclass of :class:`~flask.json.provider.JSONProvider`. An
<span class="w"> </span>    instance is created and assigned to :attr:`app.json` when creating
<span class="gu">@@ -159,32 +238,94 @@ class App(Scaffold):</span>

<span class="w"> </span>    .. versionadded:: 2.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: Options that are passed to the Jinja environment in</span>
<span class="gi">+    #: :meth:`create_jinja_environment`. Changing these options after</span>
<span class="gi">+    #: the environment is created (accessing :attr:`jinja_env`) will</span>
<span class="gi">+    #: have no effect.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionchanged:: 1.1.0</span>
<span class="gi">+    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow</span>
<span class="gi">+    #:     easier configuration.</span>
<span class="gi">+    #:</span>
<span class="w"> </span>    jinja_options: dict[str, t.Any] = {}
<span class="gi">+</span>
<span class="gi">+    #: The rule object to use for URL rules created.  This is used by</span>
<span class="gi">+    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.7</span>
<span class="w"> </span>    url_rule_class = Rule
<span class="gi">+</span>
<span class="gi">+    #: The map object to use for storing the URL rules and routing</span>
<span class="gi">+    #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 1.1.0</span>
<span class="w"> </span>    url_map_class = Map
<span class="gi">+</span>
<span class="gi">+    #: The :meth:`test_client` method creates an instance of this test</span>
<span class="gi">+    #: client class. Defaults to :class:`~flask.testing.FlaskClient`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.7</span>
<span class="w"> </span>    test_client_class: type[FlaskClient] | None = None
<span class="gi">+</span>
<span class="gi">+    #: The :class:`~click.testing.CliRunner` subclass, by default</span>
<span class="gi">+    #: :class:`~flask.testing.FlaskCliRunner` that is used by</span>
<span class="gi">+    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a</span>
<span class="gi">+    #: Flask app object as the first argument.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 1.0</span>
<span class="w"> </span>    test_cli_runner_class: type[FlaskCliRunner] | None = None
<span class="gi">+</span>
<span class="w"> </span>    default_config: dict[str, t.Any]
<span class="w"> </span>    response_class: type[Response]

<span class="gd">-    def __init__(self, import_name: str, static_url_path: (str | None)=None,</span>
<span class="gd">-        static_folder: (str | os.PathLike[str] | None)=&#39;static&#39;,</span>
<span class="gd">-        static_host: (str | None)=None, host_matching: bool=False,</span>
<span class="gd">-        subdomain_matching: bool=False, template_folder: (str | os.PathLike</span>
<span class="gd">-        [str] | None)=&#39;templates&#39;, instance_path: (str | None)=None,</span>
<span class="gd">-        instance_relative_config: bool=False, root_path: (str | None)=None):</span>
<span class="gd">-        super().__init__(import_name=import_name, static_folder=</span>
<span class="gd">-            static_folder, static_url_path=static_url_path, template_folder</span>
<span class="gd">-            =template_folder, root_path=root_path)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        import_name: str,</span>
<span class="gi">+        static_url_path: str | None = None,</span>
<span class="gi">+        static_folder: str | os.PathLike[str] | None = &quot;static&quot;,</span>
<span class="gi">+        static_host: str | None = None,</span>
<span class="gi">+        host_matching: bool = False,</span>
<span class="gi">+        subdomain_matching: bool = False,</span>
<span class="gi">+        template_folder: str | os.PathLike[str] | None = &quot;templates&quot;,</span>
<span class="gi">+        instance_path: str | None = None,</span>
<span class="gi">+        instance_relative_config: bool = False,</span>
<span class="gi">+        root_path: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            import_name=import_name,</span>
<span class="gi">+            static_folder=static_folder,</span>
<span class="gi">+            static_url_path=static_url_path,</span>
<span class="gi">+            template_folder=template_folder,</span>
<span class="gi">+            root_path=root_path,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        if instance_path is None:
<span class="w"> </span>            instance_path = self.auto_find_instance_path()
<span class="w"> </span>        elif not os.path.isabs(instance_path):
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &#39;If an instance path is provided it must be absolute. A relative path was given instead.&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                &quot;If an instance path is provided it must be absolute.&quot;</span>
<span class="gi">+                &quot; A relative path was given instead.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        #: Holds the path to the instance folder.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 0.8</span>
<span class="w"> </span>        self.instance_path = instance_path
<span class="gi">+</span>
<span class="gi">+        #: The configuration dictionary as :class:`Config`.  This behaves</span>
<span class="gi">+        #: exactly like a regular dictionary but supports additional methods</span>
<span class="gi">+        #: to load a config from files.</span>
<span class="w"> </span>        self.config = self.make_config(instance_relative_config)
<span class="gi">+</span>
<span class="gi">+        #: An instance of :attr:`aborter_class` created by</span>
<span class="gi">+        #: :meth:`make_aborter`. This is called by :func:`flask.abort`</span>
<span class="gi">+        #: to raise HTTP errors, and can be called directly as well.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 2.2</span>
<span class="gi">+        #:     Moved from ``flask.abort``, which calls this object.</span>
<span class="w"> </span>        self.aborter = self.make_aborter()
<span class="gi">+</span>
<span class="w"> </span>        self.json: JSONProvider = self.json_provider_class(self)
<span class="w"> </span>        &quot;&quot;&quot;Provides access to JSON methods. Functions in ``flask.json``
<span class="w"> </span>        will call methods on this provider when the application context
<span class="gu">@@ -200,19 +341,89 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 2.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self.url_build_error_handlers: list[t.Callable[[Exception, str,</span>
<span class="gd">-            dict[str, t.Any]], str]] = []</span>
<span class="gi">+</span>
<span class="gi">+        #: A list of functions that are called by</span>
<span class="gi">+        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a</span>
<span class="gi">+        #: :exc:`~werkzeug.routing.BuildError`. Each function is called</span>
<span class="gi">+        #: with ``error``, ``endpoint`` and ``values``. If a function</span>
<span class="gi">+        #: returns ``None`` or raises a ``BuildError``, it is skipped.</span>
<span class="gi">+        #: Otherwise, its return value is returned by ``url_for``.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 0.9</span>
<span class="gi">+        self.url_build_error_handlers: list[</span>
<span class="gi">+            t.Callable[[Exception, str, dict[str, t.Any]], str]</span>
<span class="gi">+        ] = []</span>
<span class="gi">+</span>
<span class="gi">+        #: A list of functions that are called when the application context</span>
<span class="gi">+        #: is destroyed.  Since the application context is also torn down</span>
<span class="gi">+        #: if the request ends this is the place to store code that disconnects</span>
<span class="gi">+        #: from databases.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 0.9</span>
<span class="w"> </span>        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []
<span class="gd">-        self.shell_context_processors: list[ft.ShellContextProcessorCallable</span>
<span class="gd">-            ] = []</span>
<span class="gi">+</span>
<span class="gi">+        #: A list of shell context processor functions that should be run</span>
<span class="gi">+        #: when a shell context is created.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 0.11</span>
<span class="gi">+        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []</span>
<span class="gi">+</span>
<span class="gi">+        #: Maps registered blueprint names to blueprint objects. The</span>
<span class="gi">+        #: dict retains the order the blueprints were registered in.</span>
<span class="gi">+        #: Blueprints can be registered multiple times, this dict does</span>
<span class="gi">+        #: not track how often they were attached.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 0.7</span>
<span class="w"> </span>        self.blueprints: dict[str, Blueprint] = {}
<span class="gi">+</span>
<span class="gi">+        #: a place where extensions can store application specific state.  For</span>
<span class="gi">+        #: example this is where an extension could store database engines and</span>
<span class="gi">+        #: similar things.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: The key must match the name of the extension module. For example in</span>
<span class="gi">+        #: case of a &quot;Flask-Foo&quot; extension in `flask_foo`, the key would be</span>
<span class="gi">+        #: ``&#39;foo&#39;``.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: .. versionadded:: 0.7</span>
<span class="w"> </span>        self.extensions: dict[str, t.Any] = {}
<span class="gi">+</span>
<span class="gi">+        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use</span>
<span class="gi">+        #: this to change the routing converters after the class was created</span>
<span class="gi">+        #: but before any routes are connected.  Example::</span>
<span class="gi">+        #:</span>
<span class="gi">+        #:    from werkzeug.routing import BaseConverter</span>
<span class="gi">+        #:</span>
<span class="gi">+        #:    class ListConverter(BaseConverter):</span>
<span class="gi">+        #:        def to_python(self, value):</span>
<span class="gi">+        #:            return value.split(&#39;,&#39;)</span>
<span class="gi">+        #:        def to_url(self, values):</span>
<span class="gi">+        #:            return &#39;,&#39;.join(super(ListConverter, self).to_url(value)</span>
<span class="gi">+        #:                            for value in values)</span>
<span class="gi">+        #:</span>
<span class="gi">+        #:    app = Flask(__name__)</span>
<span class="gi">+        #:    app.url_map.converters[&#39;list&#39;] = ListConverter</span>
<span class="w"> </span>        self.url_map = self.url_map_class(host_matching=host_matching)
<span class="gi">+</span>
<span class="w"> </span>        self.subdomain_matching = subdomain_matching
<span class="gi">+</span>
<span class="gi">+        # tracks internally if the application already handled at least one</span>
<span class="gi">+        # request.</span>
<span class="w"> </span>        self._got_first_request = False

<span class="gi">+    def _check_setup_finished(self, f_name: str) -&gt; None:</span>
<span class="gi">+        if self._got_first_request:</span>
<span class="gi">+            raise AssertionError(</span>
<span class="gi">+                f&quot;The setup method &#39;{f_name}&#39; can no longer be called&quot;</span>
<span class="gi">+                &quot; on the application. It has already handled its first&quot;</span>
<span class="gi">+                &quot; request, any changes will not be applied&quot;</span>
<span class="gi">+                &quot; consistently.\n&quot;</span>
<span class="gi">+                &quot;Make sure all imports, decorators, functions, etc.&quot;</span>
<span class="gi">+                &quot; needed to set up the application are done before&quot;</span>
<span class="gi">+                &quot; running it.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>    @cached_property
<span class="gd">-    def name(self) -&gt;str:</span>
<span class="gi">+    def name(self) -&gt; str:  # type: ignore</span>
<span class="w"> </span>        &quot;&quot;&quot;The name of the application.  This is usually the import name
<span class="w"> </span>        with the difference that it&#39;s guessed from the run file if the
<span class="w"> </span>        import name is main.  This name is used as a display name when
<span class="gu">@@ -221,10 +432,15 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.import_name == &quot;__main__&quot;:</span>
<span class="gi">+            fn: str | None = getattr(sys.modules[&quot;__main__&quot;], &quot;__file__&quot;, None)</span>
<span class="gi">+            if fn is None:</span>
<span class="gi">+                return &quot;__main__&quot;</span>
<span class="gi">+            return os.path.splitext(os.path.basename(fn))[0]</span>
<span class="gi">+        return self.import_name</span>

<span class="w"> </span>    @cached_property
<span class="gd">-    def logger(self) -&gt;logging.Logger:</span>
<span class="gi">+    def logger(self) -&gt; logging.Logger:</span>
<span class="w"> </span>        &quot;&quot;&quot;A standard Python :class:`~logging.Logger` for the app, with
<span class="w"> </span>        the same name as :attr:`name`.

<span class="gu">@@ -248,19 +464,22 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return create_logger(self)</span>

<span class="w"> </span>    @cached_property
<span class="gd">-    def jinja_env(self) -&gt;Environment:</span>
<span class="gi">+    def jinja_env(self) -&gt; Environment:</span>
<span class="w"> </span>        &quot;&quot;&quot;The Jinja environment used to load templates.

<span class="w"> </span>        The environment is created the first time this property is
<span class="w"> </span>        accessed. Changing :attr:`jinja_options` after that will have no
<span class="w"> </span>        effect.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.create_jinja_environment()</span>
<span class="gi">+</span>
<span class="gi">+    def create_jinja_environment(self) -&gt; Environment:</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def make_config(self, instance_relative: bool=False) -&gt;Config:</span>
<span class="gi">+    def make_config(self, instance_relative: bool = False) -&gt; Config:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used to create the config attribute by the Flask constructor.
<span class="w"> </span>        The `instance_relative` parameter is passed in from the constructor
<span class="w"> </span>        of Flask (there named `instance_relative_config`) and indicates if
<span class="gu">@@ -269,9 +488,14 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def make_aborter(self) -&gt;Aborter:</span>
<span class="gi">+        root_path = self.root_path</span>
<span class="gi">+        if instance_relative:</span>
<span class="gi">+            root_path = self.instance_path</span>
<span class="gi">+        defaults = dict(self.default_config)</span>
<span class="gi">+        defaults[&quot;DEBUG&quot;] = get_debug_flag()</span>
<span class="gi">+        return self.config_class(root_path, defaults)</span>
<span class="gi">+</span>
<span class="gi">+    def make_aborter(self) -&gt; Aborter:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the object to assign to :attr:`aborter`. That object
<span class="w"> </span>        is called by :func:`flask.abort` to raise HTTP errors, and can
<span class="w"> </span>        be called directly as well.
<span class="gu">@@ -281,9 +505,9 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 2.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.aborter_class()</span>

<span class="gd">-    def auto_find_instance_path(self) -&gt;str:</span>
<span class="gi">+    def auto_find_instance_path(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Tries to locate the instance path if it was not provided to the
<span class="w"> </span>        constructor of the application class.  It will basically calculate
<span class="w"> </span>        the path to a folder named ``instance`` next to your main file or
<span class="gu">@@ -291,9 +515,12 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prefix, package_path = find_package(self.import_name)</span>
<span class="gi">+        if prefix is None:</span>
<span class="gi">+            return os.path.join(package_path, &quot;instance&quot;)</span>
<span class="gi">+        return os.path.join(prefix, &quot;var&quot;, f&quot;{self.name}-instance&quot;)</span>

<span class="gd">-    def create_global_jinja_loader(self) -&gt;DispatchingJinjaLoader:</span>
<span class="gi">+    def create_global_jinja_loader(self) -&gt; DispatchingJinjaLoader:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates the loader for the Jinja2 environment.  Can be used to
<span class="w"> </span>        override just the loader and keeping the rest unchanged.  It&#39;s
<span class="w"> </span>        discouraged to override this function.  Instead one should override
<span class="gu">@@ -304,9 +531,9 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return DispatchingJinjaLoader(self)</span>

<span class="gd">-    def select_jinja_autoescape(self, filename: str) -&gt;bool:</span>
<span class="gi">+    def select_jinja_autoescape(self, filename: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if autoescaping should be active for the given
<span class="w"> </span>        template name. If no template name is given, returns `True`.

<span class="gu">@@ -315,10 +542,12 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if filename is None:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return filename.endswith((&quot;.html&quot;, &quot;.htm&quot;, &quot;.xml&quot;, &quot;.xhtml&quot;, &quot;.svg&quot;))</span>

<span class="w"> </span>    @property
<span class="gd">-    def debug(self) -&gt;bool:</span>
<span class="gi">+    def debug(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether debug mode is enabled. When using ``flask run`` to start the
<span class="w"> </span>        development server, an interactive debugger will be shown for unhandled
<span class="w"> </span>        exceptions, and the server will be reloaded when code changes. This maps to the
<span class="gu">@@ -328,11 +557,17 @@ class App(Scaffold):</span>

<span class="w"> </span>        Default: ``False``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.config[&quot;DEBUG&quot;]  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    @debug.setter</span>
<span class="gi">+    def debug(self, value: bool) -&gt; None:</span>
<span class="gi">+        self.config[&quot;DEBUG&quot;] = value</span>
<span class="gi">+</span>
<span class="gi">+        if self.config[&quot;TEMPLATES_AUTO_RELOAD&quot;] is None:</span>
<span class="gi">+            self.jinja_env.auto_reload = value</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def register_blueprint(self, blueprint: Blueprint, **options: t.Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a :class:`~flask.Blueprint` on the application. Keyword
<span class="w"> </span>        arguments passed to this method will override the defaults set on the
<span class="w"> </span>        blueprint.
<span class="gu">@@ -357,18 +592,78 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        blueprint.register(self, options)</span>

<span class="gd">-    def iter_blueprints(self) -&gt;t.ValuesView[Blueprint]:</span>
<span class="gi">+    def iter_blueprints(self) -&gt; t.ValuesView[Blueprint]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterates over all blueprints by the order they were registered.

<span class="w"> </span>        .. versionadded:: 0.11
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.blueprints.values()</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def template_filter(self, name: (str | None)=None) -&gt;t.Callable[[</span>
<span class="gd">-        T_template_filter], T_template_filter]:</span>
<span class="gi">+    def add_url_rule(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rule: str,</span>
<span class="gi">+        endpoint: str | None = None,</span>
<span class="gi">+        view_func: ft.RouteCallable | None = None,</span>
<span class="gi">+        provide_automatic_options: bool | None = None,</span>
<span class="gi">+        **options: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if endpoint is None:</span>
<span class="gi">+            endpoint = _endpoint_from_view_func(view_func)  # type: ignore</span>
<span class="gi">+        options[&quot;endpoint&quot;] = endpoint</span>
<span class="gi">+        methods = options.pop(&quot;methods&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # if the methods are not given and the view_func object knows its</span>
<span class="gi">+        # methods we can use that instead.  If neither exists, we go with</span>
<span class="gi">+        # a tuple of only ``GET`` as default.</span>
<span class="gi">+        if methods is None:</span>
<span class="gi">+            methods = getattr(view_func, &quot;methods&quot;, None) or (&quot;GET&quot;,)</span>
<span class="gi">+        if isinstance(methods, str):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Allowed methods must be a list of strings, for&quot;</span>
<span class="gi">+                &#39; example: @app.route(..., methods=[&quot;POST&quot;])&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        methods = {item.upper() for item in methods}</span>
<span class="gi">+</span>
<span class="gi">+        # Methods that should always be added</span>
<span class="gi">+        required_methods = set(getattr(view_func, &quot;required_methods&quot;, ()))</span>
<span class="gi">+</span>
<span class="gi">+        # starting with Flask 0.8 the view_func object can disable and</span>
<span class="gi">+        # force-enable the automatic options handling.</span>
<span class="gi">+        if provide_automatic_options is None:</span>
<span class="gi">+            provide_automatic_options = getattr(</span>
<span class="gi">+                view_func, &quot;provide_automatic_options&quot;, None</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if provide_automatic_options is None:</span>
<span class="gi">+            if &quot;OPTIONS&quot; not in methods:</span>
<span class="gi">+                provide_automatic_options = True</span>
<span class="gi">+                required_methods.add(&quot;OPTIONS&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                provide_automatic_options = False</span>
<span class="gi">+</span>
<span class="gi">+        # Add the required methods now.</span>
<span class="gi">+        methods |= required_methods</span>
<span class="gi">+</span>
<span class="gi">+        rule_obj = self.url_rule_class(rule, methods=methods, **options)</span>
<span class="gi">+        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+        self.url_map.add(rule_obj)</span>
<span class="gi">+        if view_func is not None:</span>
<span class="gi">+            old_func = self.view_functions.get(endpoint)</span>
<span class="gi">+            if old_func is not None and old_func != view_func:</span>
<span class="gi">+                raise AssertionError(</span>
<span class="gi">+                    &quot;View function mapping is overwriting an existing&quot;</span>
<span class="gi">+                    f&quot; endpoint function: {endpoint}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            self.view_functions[endpoint] = view_func</span>
<span class="gi">+</span>
<span class="gi">+    @setupmethod</span>
<span class="gi">+    def template_filter(</span>
<span class="gi">+        self, name: str | None = None</span>
<span class="gi">+    ) -&gt; t.Callable[[T_template_filter], T_template_filter]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A decorator that is used to register custom template filter.
<span class="w"> </span>        You can specify a name for the filter, otherwise the function
<span class="w"> </span>        name will be used. Example::
<span class="gu">@@ -380,22 +675,29 @@ class App(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the filter, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_template_filter) -&gt; T_template_filter:</span>
<span class="gi">+            self.add_template_filter(f, name=name)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def add_template_filter(self, f: ft.TemplateFilterCallable, name: (str |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def add_template_filter(</span>
<span class="gi">+        self, f: ft.TemplateFilterCallable, name: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a custom template filter.  Works exactly like the
<span class="w"> </span>        :meth:`template_filter` decorator.

<span class="w"> </span>        :param name: the optional name of the filter, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.jinja_env.filters[name or f.__name__] = f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def template_test(self, name: (str | None)=None) -&gt;t.Callable[[</span>
<span class="gd">-        T_template_test], T_template_test]:</span>
<span class="gi">+    def template_test(</span>
<span class="gi">+        self, name: str | None = None</span>
<span class="gi">+    ) -&gt; t.Callable[[T_template_test], T_template_test]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A decorator that is used to register custom template test.
<span class="w"> </span>        You can specify a name for the test, otherwise the function
<span class="w"> </span>        name will be used. Example::
<span class="gu">@@ -414,11 +716,17 @@ class App(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the test, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_template_test) -&gt; T_template_test:</span>
<span class="gi">+            self.add_template_test(f, name=name)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def add_template_test(self, f: ft.TemplateTestCallable, name: (str |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def add_template_test(</span>
<span class="gi">+        self, f: ft.TemplateTestCallable, name: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a custom template test.  Works exactly like the
<span class="w"> </span>        :meth:`template_test` decorator.

<span class="gu">@@ -427,11 +735,12 @@ class App(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the test, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.jinja_env.tests[name or f.__name__] = f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def template_global(self, name: (str | None)=None) -&gt;t.Callable[[</span>
<span class="gd">-        T_template_global], T_template_global]:</span>
<span class="gi">+    def template_global(</span>
<span class="gi">+        self, name: str | None = None</span>
<span class="gi">+    ) -&gt; t.Callable[[T_template_global], T_template_global]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A decorator that is used to register a custom template global function.
<span class="w"> </span>        You can specify a name for the global function, otherwise the function
<span class="w"> </span>        name will be used. Example::
<span class="gu">@@ -445,11 +754,17 @@ class App(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the global function, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_template_global) -&gt; T_template_global:</span>
<span class="gi">+            self.add_template_global(f, name=name)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def add_template_global(self, f: ft.TemplateGlobalCallable, name: (str |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def add_template_global(</span>
<span class="gi">+        self, f: ft.TemplateGlobalCallable, name: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a custom template global function. Works exactly like the
<span class="w"> </span>        :meth:`template_global` decorator.

<span class="gu">@@ -458,10 +773,10 @@ class App(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the global function, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.jinja_env.globals[name or f.__name__] = f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def teardown_appcontext(self, f: T_teardown) -&gt;T_teardown:</span>
<span class="gi">+    def teardown_appcontext(self, f: T_teardown) -&gt; T_teardown:</span>
<span class="w"> </span>        &quot;&quot;&quot;Registers a function to be called when the application
<span class="w"> </span>        context is popped. The application context is typically popped
<span class="w"> </span>        after the request context for each request, at the end of CLI
<span class="gu">@@ -491,27 +806,46 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.9
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.teardown_appcontext_funcs.append(f)</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def shell_context_processor(self, f: T_shell_context_processor</span>
<span class="gd">-        ) -&gt;T_shell_context_processor:</span>
<span class="gi">+    def shell_context_processor(</span>
<span class="gi">+        self, f: T_shell_context_processor</span>
<span class="gi">+    ) -&gt; T_shell_context_processor:</span>
<span class="w"> </span>        &quot;&quot;&quot;Registers a shell context processor function.

<span class="w"> </span>        .. versionadded:: 0.11
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.shell_context_processors.append(f)</span>
<span class="gi">+        return f</span>

<span class="gd">-    def _find_error_handler(self, e: Exception, blueprints: list[str]) -&gt;(ft</span>
<span class="gd">-        .ErrorHandlerCallable | None):</span>
<span class="gi">+    def _find_error_handler(</span>
<span class="gi">+        self, e: Exception, blueprints: list[str]</span>
<span class="gi">+    ) -&gt; ft.ErrorHandlerCallable | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a registered error handler for an exception in this order:
<span class="w"> </span>        blueprint handler for a specific code, app handler for a specific code,
<span class="w"> </span>        blueprint handler for an exception class, app handler for an exception
<span class="w"> </span>        class, or ``None`` if a suitable handler is not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        exc_class, code = self._get_exc_class_and_code(type(e))</span>
<span class="gi">+        names = (*blueprints, None)</span>
<span class="gi">+</span>
<span class="gi">+        for c in (code, None) if code is not None else (None,):</span>
<span class="gi">+            for name in names:</span>
<span class="gi">+                handler_map = self.error_handler_spec[name][c]</span>
<span class="gi">+</span>
<span class="gi">+                if not handler_map:</span>
<span class="gi">+                    continue</span>

<span class="gd">-    def trap_http_exception(self, e: Exception) -&gt;bool:</span>
<span class="gi">+                for cls in exc_class.__mro__:</span>
<span class="gi">+                    handler = handler_map.get(cls)</span>
<span class="gi">+</span>
<span class="gi">+                    if handler is not None:</span>
<span class="gi">+                        return handler</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def trap_http_exception(self, e: Exception) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if an HTTP exception should be trapped or not.  By default
<span class="w"> </span>        this will return ``False`` for all exceptions except for a bad request
<span class="w"> </span>        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
<span class="gu">@@ -528,9 +862,25 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.config[&quot;TRAP_HTTP_EXCEPTIONS&quot;]:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        trap_bad_request = self.config[&quot;TRAP_BAD_REQUEST_ERRORS&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        # if unset, trap key errors in debug mode</span>
<span class="gi">+        if (</span>
<span class="gi">+            trap_bad_request is None</span>
<span class="gi">+            and self.debug</span>
<span class="gi">+            and isinstance(e, BadRequestKeyError)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>

<span class="gd">-    def should_ignore_error(self, error: (BaseException | None)) -&gt;bool:</span>
<span class="gi">+        if trap_bad_request:</span>
<span class="gi">+            return isinstance(e, BadRequest)</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def should_ignore_error(self, error: BaseException | None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is called to figure out if an error should be ignored
<span class="w"> </span>        or not as far as the teardown system is concerned.  If this
<span class="w"> </span>        function returns ``True`` then the teardown handlers will not be
<span class="gu">@@ -538,9 +888,9 @@ class App(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 0.10
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="gd">-    def redirect(self, location: str, code: int=302) -&gt;BaseResponse:</span>
<span class="gi">+    def redirect(self, location: str, code: int = 302) -&gt; BaseResponse:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a redirect response object.

<span class="w"> </span>        This is called by :func:`flask.redirect`, and can be called
<span class="gu">@@ -552,20 +902,36 @@ class App(Scaffold):</span>
<span class="w"> </span>        .. versionadded:: 2.2
<span class="w"> </span>            Moved from ``flask.redirect``, which calls this method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _wz_redirect(</span>
<span class="gi">+            location,</span>
<span class="gi">+            code=code,</span>
<span class="gi">+            Response=self.response_class,  # type: ignore[arg-type]</span>
<span class="gi">+        )</span>

<span class="gd">-    def inject_url_defaults(self, endpoint: str, values: dict[str, t.Any]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def inject_url_defaults(self, endpoint: str, values: dict[str, t.Any]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Injects the URL defaults for the given endpoint directly into
<span class="w"> </span>        the values dictionary passed.  This is used internally and
<span class="w"> </span>        automatically called on URL building.

<span class="w"> </span>        .. versionadded:: 0.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def handle_url_build_error(self, error: BuildError, endpoint: str,</span>
<span class="gd">-        values: dict[str, t.Any]) -&gt;str:</span>
<span class="gi">+        names: t.Iterable[str | None] = (None,)</span>
<span class="gi">+</span>
<span class="gi">+        # url_for may be called outside a request context, parse the</span>
<span class="gi">+        # passed endpoint instead of using request.blueprints.</span>
<span class="gi">+        if &quot;.&quot; in endpoint:</span>
<span class="gi">+            names = chain(</span>
<span class="gi">+                names, reversed(_split_blueprint_path(endpoint.rpartition(&quot;.&quot;)[0]))</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            if name in self.url_default_functions:</span>
<span class="gi">+                for func in self.url_default_functions[name]:</span>
<span class="gi">+                    func(endpoint, values)</span>
<span class="gi">+</span>
<span class="gi">+    def handle_url_build_error(</span>
<span class="gi">+        self, error: BuildError, endpoint: str, values: dict[str, t.Any]</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by :meth:`.url_for` if a
<span class="w"> </span>        :exc:`~werkzeug.routing.BuildError` was raised. If this returns
<span class="w"> </span>        a value, it will be returned by ``url_for``, otherwise the error
<span class="gu">@@ -580,4 +946,19 @@ class App(Scaffold):</span>
<span class="w"> </span>        :param endpoint: The endpoint being built.
<span class="w"> </span>        :param values: The keyword arguments passed to ``url_for``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for handler in self.url_build_error_handlers:</span>
<span class="gi">+            try:</span>
<span class="gi">+                rv = handler(error, endpoint, values)</span>
<span class="gi">+            except BuildError as e:</span>
<span class="gi">+                # make error available outside except block</span>
<span class="gi">+                error = e</span>
<span class="gi">+            else:</span>
<span class="gi">+                if rv is not None:</span>
<span class="gi">+                    return rv</span>
<span class="gi">+</span>
<span class="gi">+        # Re-raise if called with an active exception, otherwise raise</span>
<span class="gi">+        # the passed in exception.</span>
<span class="gi">+        if error is sys.exc_info()[1]:</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+        raise error</span>
<span class="gh">diff --git a/src/flask/sansio/blueprints.py b/src/flask/sansio/blueprints.py</span>
<span class="gh">index bd3b9de9..4f912cca 100644</span>
<span class="gd">--- a/src/flask/sansio/blueprints.py</span>
<span class="gi">+++ b/src/flask/sansio/blueprints.py</span>
<span class="gu">@@ -1,32 +1,34 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from functools import update_wrapper
<span class="gi">+</span>
<span class="w"> </span>from .. import typing as ft
<span class="w"> </span>from .scaffold import _endpoint_from_view_func
<span class="w"> </span>from .scaffold import _sentinel
<span class="w"> </span>from .scaffold import Scaffold
<span class="w"> </span>from .scaffold import setupmethod
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from .app import App
<span class="gd">-DeferredSetupFunction = t.Callable[[&#39;BlueprintSetupState&#39;], None]</span>
<span class="gd">-T_after_request = t.TypeVar(&#39;T_after_request&#39;, bound=ft.</span>
<span class="gd">-    AfterRequestCallable[t.Any])</span>
<span class="gd">-T_before_request = t.TypeVar(&#39;T_before_request&#39;, bound=ft.BeforeRequestCallable</span>
<span class="gd">-    )</span>
<span class="gd">-T_error_handler = t.TypeVar(&#39;T_error_handler&#39;, bound=ft.ErrorHandlerCallable)</span>
<span class="gd">-T_teardown = t.TypeVar(&#39;T_teardown&#39;, bound=ft.TeardownCallable)</span>
<span class="gd">-T_template_context_processor = t.TypeVar(&#39;T_template_context_processor&#39;,</span>
<span class="gd">-    bound=ft.TemplateContextProcessorCallable)</span>
<span class="gd">-T_template_filter = t.TypeVar(&#39;T_template_filter&#39;, bound=ft.</span>
<span class="gd">-    TemplateFilterCallable)</span>
<span class="gd">-T_template_global = t.TypeVar(&#39;T_template_global&#39;, bound=ft.</span>
<span class="gd">-    TemplateGlobalCallable)</span>
<span class="gd">-T_template_test = t.TypeVar(&#39;T_template_test&#39;, bound=ft.TemplateTestCallable)</span>
<span class="gd">-T_url_defaults = t.TypeVar(&#39;T_url_defaults&#39;, bound=ft.URLDefaultCallable)</span>
<span class="gd">-T_url_value_preprocessor = t.TypeVar(&#39;T_url_value_preprocessor&#39;, bound=ft.</span>
<span class="gd">-    URLValuePreprocessorCallable)</span>
<span class="gi">+</span>
<span class="gi">+DeferredSetupFunction = t.Callable[[&quot;BlueprintSetupState&quot;], None]</span>
<span class="gi">+T_after_request = t.TypeVar(&quot;T_after_request&quot;, bound=ft.AfterRequestCallable[t.Any])</span>
<span class="gi">+T_before_request = t.TypeVar(&quot;T_before_request&quot;, bound=ft.BeforeRequestCallable)</span>
<span class="gi">+T_error_handler = t.TypeVar(&quot;T_error_handler&quot;, bound=ft.ErrorHandlerCallable)</span>
<span class="gi">+T_teardown = t.TypeVar(&quot;T_teardown&quot;, bound=ft.TeardownCallable)</span>
<span class="gi">+T_template_context_processor = t.TypeVar(</span>
<span class="gi">+    &quot;T_template_context_processor&quot;, bound=ft.TemplateContextProcessorCallable</span>
<span class="gi">+)</span>
<span class="gi">+T_template_filter = t.TypeVar(&quot;T_template_filter&quot;, bound=ft.TemplateFilterCallable)</span>
<span class="gi">+T_template_global = t.TypeVar(&quot;T_template_global&quot;, bound=ft.TemplateGlobalCallable)</span>
<span class="gi">+T_template_test = t.TypeVar(&quot;T_template_test&quot;, bound=ft.TemplateTestCallable)</span>
<span class="gi">+T_url_defaults = t.TypeVar(&quot;T_url_defaults&quot;, bound=ft.URLDefaultCallable)</span>
<span class="gi">+T_url_value_preprocessor = t.TypeVar(</span>
<span class="gi">+    &quot;T_url_value_preprocessor&quot;, bound=ft.URLValuePreprocessorCallable</span>
<span class="gi">+)</span>


<span class="w"> </span>class BlueprintSetupState:
<span class="gu">@@ -36,32 +38,82 @@ class BlueprintSetupState:</span>
<span class="w"> </span>    to all register callback functions.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, blueprint: Blueprint, app: App, options: t.Any,</span>
<span class="gd">-        first_registration: bool) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        blueprint: Blueprint,</span>
<span class="gi">+        app: App,</span>
<span class="gi">+        options: t.Any,</span>
<span class="gi">+        first_registration: bool,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        #: a reference to the current application</span>
<span class="w"> </span>        self.app = app
<span class="gi">+</span>
<span class="gi">+        #: a reference to the blueprint that created this setup state.</span>
<span class="w"> </span>        self.blueprint = blueprint
<span class="gi">+</span>
<span class="gi">+        #: a dictionary with all options that were passed to the</span>
<span class="gi">+        #: :meth:`~flask.Flask.register_blueprint` method.</span>
<span class="w"> </span>        self.options = options
<span class="gi">+</span>
<span class="gi">+        #: as blueprints can be registered multiple times with the</span>
<span class="gi">+        #: application and not everything wants to be registered</span>
<span class="gi">+        #: multiple times on it, this attribute can be used to figure</span>
<span class="gi">+        #: out if the blueprint was registered in the past already.</span>
<span class="w"> </span>        self.first_registration = first_registration
<span class="gd">-        subdomain = self.options.get(&#39;subdomain&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        subdomain = self.options.get(&quot;subdomain&quot;)</span>
<span class="w"> </span>        if subdomain is None:
<span class="w"> </span>            subdomain = self.blueprint.subdomain
<span class="gi">+</span>
<span class="gi">+        #: The subdomain that the blueprint should be active for, ``None``</span>
<span class="gi">+        #: otherwise.</span>
<span class="w"> </span>        self.subdomain = subdomain
<span class="gd">-        url_prefix = self.options.get(&#39;url_prefix&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        url_prefix = self.options.get(&quot;url_prefix&quot;)</span>
<span class="w"> </span>        if url_prefix is None:
<span class="w"> </span>            url_prefix = self.blueprint.url_prefix
<span class="gi">+        #: The prefix that should be used for all URLs defined on the</span>
<span class="gi">+        #: blueprint.</span>
<span class="w"> </span>        self.url_prefix = url_prefix
<span class="gd">-        self.name = self.options.get(&#39;name&#39;, blueprint.name)</span>
<span class="gd">-        self.name_prefix = self.options.get(&#39;name_prefix&#39;, &#39;&#39;)</span>
<span class="gd">-        self.url_defaults = dict(self.blueprint.url_values_defaults)</span>
<span class="gd">-        self.url_defaults.update(self.options.get(&#39;url_defaults&#39;, ()))</span>

<span class="gd">-    def add_url_rule(self, rule: str, endpoint: (str | None)=None,</span>
<span class="gd">-        view_func: (ft.RouteCallable | None)=None, **options: t.Any) -&gt;None:</span>
<span class="gi">+        self.name = self.options.get(&quot;name&quot;, blueprint.name)</span>
<span class="gi">+        self.name_prefix = self.options.get(&quot;name_prefix&quot;, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        #: A dictionary with URL defaults that is added to each and every</span>
<span class="gi">+        #: URL that was defined with the blueprint.</span>
<span class="gi">+        self.url_defaults = dict(self.blueprint.url_values_defaults)</span>
<span class="gi">+        self.url_defaults.update(self.options.get(&quot;url_defaults&quot;, ()))</span>
<span class="gi">+</span>
<span class="gi">+    def add_url_rule(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rule: str,</span>
<span class="gi">+        endpoint: str | None = None,</span>
<span class="gi">+        view_func: ft.RouteCallable | None = None,</span>
<span class="gi">+        **options: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;A helper method to register a rule (and optionally a view function)
<span class="w"> </span>        to the application.  The endpoint is automatically prefixed with the
<span class="w"> </span>        blueprint&#39;s name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.url_prefix is not None:</span>
<span class="gi">+            if rule:</span>
<span class="gi">+                rule = &quot;/&quot;.join((self.url_prefix.rstrip(&quot;/&quot;), rule.lstrip(&quot;/&quot;)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                rule = self.url_prefix</span>
<span class="gi">+        options.setdefault(&quot;subdomain&quot;, self.subdomain)</span>
<span class="gi">+        if endpoint is None:</span>
<span class="gi">+            endpoint = _endpoint_from_view_func(view_func)  # type: ignore</span>
<span class="gi">+        defaults = self.url_defaults</span>
<span class="gi">+        if &quot;defaults&quot; in options:</span>
<span class="gi">+            defaults = dict(defaults, **options.pop(&quot;defaults&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        self.app.add_url_rule(</span>
<span class="gi">+            rule,</span>
<span class="gi">+            f&quot;{self.name_prefix}.{self.name}.{endpoint}&quot;.lstrip(&quot;.&quot;),</span>
<span class="gi">+            view_func,</span>
<span class="gi">+            defaults=defaults,</span>
<span class="gi">+            **options,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class Blueprint(Scaffold):
<span class="gu">@@ -116,60 +168,92 @@ class Blueprint(Scaffold):</span>

<span class="w"> </span>    .. versionadded:: 0.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _got_registered_once = False

<span class="gd">-    def __init__(self, name: str, import_name: str, static_folder: (str |</span>
<span class="gd">-        os.PathLike[str] | None)=None, static_url_path: (str | None)=None,</span>
<span class="gd">-        template_folder: (str | os.PathLike[str] | None)=None, url_prefix:</span>
<span class="gd">-        (str | None)=None, subdomain: (str | None)=None, url_defaults: (</span>
<span class="gd">-        dict[str, t.Any] | None)=None, root_path: (str | None)=None,</span>
<span class="gd">-        cli_group: (str | None)=_sentinel):</span>
<span class="gd">-        super().__init__(import_name=import_name, static_folder=</span>
<span class="gd">-            static_folder, static_url_path=static_url_path, template_folder</span>
<span class="gd">-            =template_folder, root_path=root_path)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        import_name: str,</span>
<span class="gi">+        static_folder: str | os.PathLike[str] | None = None,</span>
<span class="gi">+        static_url_path: str | None = None,</span>
<span class="gi">+        template_folder: str | os.PathLike[str] | None = None,</span>
<span class="gi">+        url_prefix: str | None = None,</span>
<span class="gi">+        subdomain: str | None = None,</span>
<span class="gi">+        url_defaults: dict[str, t.Any] | None = None,</span>
<span class="gi">+        root_path: str | None = None,</span>
<span class="gi">+        cli_group: str | None = _sentinel,  # type: ignore[assignment]</span>
<span class="gi">+    ):</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            import_name=import_name,</span>
<span class="gi">+            static_folder=static_folder,</span>
<span class="gi">+            static_url_path=static_url_path,</span>
<span class="gi">+            template_folder=template_folder,</span>
<span class="gi">+            root_path=root_path,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        if not name:
<span class="w"> </span>            raise ValueError(&quot;&#39;name&#39; may not be empty.&quot;)
<span class="gd">-        if &#39;.&#39; in name:</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;.&quot; in name:</span>
<span class="w"> </span>            raise ValueError(&quot;&#39;name&#39; may not contain a dot &#39;.&#39; character.&quot;)
<span class="gi">+</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.url_prefix = url_prefix
<span class="w"> </span>        self.subdomain = subdomain
<span class="w"> </span>        self.deferred_functions: list[DeferredSetupFunction] = []
<span class="gi">+</span>
<span class="w"> </span>        if url_defaults is None:
<span class="w"> </span>            url_defaults = {}
<span class="gi">+</span>
<span class="w"> </span>        self.url_values_defaults = url_defaults
<span class="w"> </span>        self.cli_group = cli_group
<span class="w"> </span>        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []

<span class="gi">+    def _check_setup_finished(self, f_name: str) -&gt; None:</span>
<span class="gi">+        if self._got_registered_once:</span>
<span class="gi">+            raise AssertionError(</span>
<span class="gi">+                f&quot;The setup method &#39;{f_name}&#39; can no longer be called on the blueprint&quot;</span>
<span class="gi">+                f&quot; &#39;{self.name}&#39;. It has already been registered at least once, any&quot;</span>
<span class="gi">+                &quot; changes will not be applied consistently.\n&quot;</span>
<span class="gi">+                &quot;Make sure all imports, decorators, functions, etc. needed to set up&quot;</span>
<span class="gi">+                &quot; the blueprint are done before registering it.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>    @setupmethod
<span class="gd">-    def record(self, func: DeferredSetupFunction) -&gt;None:</span>
<span class="gi">+    def record(self, func: DeferredSetupFunction) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Registers a function that is called when the blueprint is
<span class="w"> </span>        registered on the application.  This function is called with the
<span class="w"> </span>        state as argument as returned by the :meth:`make_setup_state`
<span class="w"> </span>        method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.deferred_functions.append(func)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def record_once(self, func: DeferredSetupFunction) -&gt;None:</span>
<span class="gi">+    def record_once(self, func: DeferredSetupFunction) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Works like :meth:`record` but wraps the function in another
<span class="w"> </span>        function that will ensure the function is only called once.  If the
<span class="w"> </span>        blueprint is registered a second time on the application, the
<span class="w"> </span>        function passed is not called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def make_setup_state(self, app: App, options: dict[str, t.Any],</span>
<span class="gd">-        first_registration: bool=False) -&gt;BlueprintSetupState:</span>
<span class="gi">+        def wrapper(state: BlueprintSetupState) -&gt; None:</span>
<span class="gi">+            if state.first_registration:</span>
<span class="gi">+                func(state)</span>
<span class="gi">+</span>
<span class="gi">+        self.record(update_wrapper(wrapper, func))</span>
<span class="gi">+</span>
<span class="gi">+    def make_setup_state(</span>
<span class="gi">+        self, app: App, options: dict[str, t.Any], first_registration: bool = False</span>
<span class="gi">+    ) -&gt; BlueprintSetupState:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
<span class="w"> </span>        object that is later passed to the register callback functions.
<span class="w"> </span>        Subclasses can override this to return a subclass of the setup state.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return BlueprintSetupState(self, app, options, first_registration)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def register_blueprint(self, blueprint: Blueprint, **options: t.Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a :class:`~flask.Blueprint` on this blueprint. Keyword
<span class="w"> </span>        arguments passed to this method will override the defaults set
<span class="w"> </span>        on the blueprint.
<span class="gu">@@ -182,9 +266,11 @@ class Blueprint(Scaffold):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if blueprint is self:</span>
<span class="gi">+            raise ValueError(&quot;Cannot register a blueprint on itself&quot;)</span>
<span class="gi">+        self._blueprints.append((blueprint, options))</span>

<span class="gd">-    def register(self, app: App, options: dict[str, t.Any]) -&gt;None:</span>
<span class="gi">+    def register(self, app: App, options: dict[str, t.Any]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by :meth:`Flask.register_blueprint` to register all
<span class="w"> </span>        views and callbacks registered on the blueprint with the
<span class="w"> </span>        application. Creates a :class:`.BlueprintSetupState` and calls
<span class="gu">@@ -213,35 +299,168 @@ class Blueprint(Scaffold):</span>
<span class="w"> </span>            blueprint to be registered multiple times with unique names
<span class="w"> </span>            for ``url_for``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name_prefix = options.get(&quot;name_prefix&quot;, &quot;&quot;)</span>
<span class="gi">+        self_name = options.get(&quot;name&quot;, self.name)</span>
<span class="gi">+        name = f&quot;{name_prefix}.{self_name}&quot;.lstrip(&quot;.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if name in app.blueprints:</span>
<span class="gi">+            bp_desc = &quot;this&quot; if app.blueprints[name] is self else &quot;a different&quot;</span>
<span class="gi">+            existing_at = f&quot; &#39;{name}&#39;&quot; if self_name != name else &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&quot;The name &#39;{self_name}&#39; is already registered for&quot;</span>
<span class="gi">+                f&quot; {bp_desc} blueprint{existing_at}. Use &#39;name=&#39; to&quot;</span>
<span class="gi">+                f&quot; provide a unique name.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        first_bp_registration = not any(bp is self for bp in app.blueprints.values())</span>
<span class="gi">+        first_name_registration = name not in app.blueprints</span>
<span class="gi">+</span>
<span class="gi">+        app.blueprints[name] = self</span>
<span class="gi">+        self._got_registered_once = True</span>
<span class="gi">+        state = self.make_setup_state(app, options, first_bp_registration)</span>
<span class="gi">+</span>
<span class="gi">+        if self.has_static_folder:</span>
<span class="gi">+            state.add_url_rule(</span>
<span class="gi">+                f&quot;{self.static_url_path}/&lt;path:filename&gt;&quot;,</span>
<span class="gi">+                view_func=self.send_static_file,  # type: ignore[attr-defined]</span>
<span class="gi">+                endpoint=&quot;static&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Merge blueprint data into parent.</span>
<span class="gi">+        if first_bp_registration or first_name_registration:</span>
<span class="gi">+            self._merge_blueprint_funcs(app, name)</span>
<span class="gi">+</span>
<span class="gi">+        for deferred in self.deferred_functions:</span>
<span class="gi">+            deferred(state)</span>
<span class="gi">+</span>
<span class="gi">+        cli_resolved_group = options.get(&quot;cli_group&quot;, self.cli_group)</span>
<span class="gi">+</span>
<span class="gi">+        if self.cli.commands:</span>
<span class="gi">+            if cli_resolved_group is None:</span>
<span class="gi">+                app.cli.commands.update(self.cli.commands)</span>
<span class="gi">+            elif cli_resolved_group is _sentinel:</span>
<span class="gi">+                self.cli.name = name</span>
<span class="gi">+                app.cli.add_command(self.cli)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.cli.name = cli_resolved_group</span>
<span class="gi">+                app.cli.add_command(self.cli)</span>
<span class="gi">+</span>
<span class="gi">+        for blueprint, bp_options in self._blueprints:</span>
<span class="gi">+            bp_options = bp_options.copy()</span>
<span class="gi">+            bp_url_prefix = bp_options.get(&quot;url_prefix&quot;)</span>
<span class="gi">+            bp_subdomain = bp_options.get(&quot;subdomain&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if bp_subdomain is None:</span>
<span class="gi">+                bp_subdomain = blueprint.subdomain</span>
<span class="gi">+</span>
<span class="gi">+            if state.subdomain is not None and bp_subdomain is not None:</span>
<span class="gi">+                bp_options[&quot;subdomain&quot;] = bp_subdomain + &quot;.&quot; + state.subdomain</span>
<span class="gi">+            elif bp_subdomain is not None:</span>
<span class="gi">+                bp_options[&quot;subdomain&quot;] = bp_subdomain</span>
<span class="gi">+            elif state.subdomain is not None:</span>
<span class="gi">+                bp_options[&quot;subdomain&quot;] = state.subdomain</span>
<span class="gi">+</span>
<span class="gi">+            if bp_url_prefix is None:</span>
<span class="gi">+                bp_url_prefix = blueprint.url_prefix</span>
<span class="gi">+</span>
<span class="gi">+            if state.url_prefix is not None and bp_url_prefix is not None:</span>
<span class="gi">+                bp_options[&quot;url_prefix&quot;] = (</span>
<span class="gi">+                    state.url_prefix.rstrip(&quot;/&quot;) + &quot;/&quot; + bp_url_prefix.lstrip(&quot;/&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+            elif bp_url_prefix is not None:</span>
<span class="gi">+                bp_options[&quot;url_prefix&quot;] = bp_url_prefix</span>
<span class="gi">+            elif state.url_prefix is not None:</span>
<span class="gi">+                bp_options[&quot;url_prefix&quot;] = state.url_prefix</span>
<span class="gi">+</span>
<span class="gi">+            bp_options[&quot;name_prefix&quot;] = name</span>
<span class="gi">+            blueprint.register(app, bp_options)</span>
<span class="gi">+</span>
<span class="gi">+    def _merge_blueprint_funcs(self, app: App, name: str) -&gt; None:</span>
<span class="gi">+        def extend(</span>
<span class="gi">+            bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],</span>
<span class="gi">+            parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],</span>
<span class="gi">+        ) -&gt; None:</span>
<span class="gi">+            for key, values in bp_dict.items():</span>
<span class="gi">+                key = name if key is None else f&quot;{name}.{key}&quot;</span>
<span class="gi">+                parent_dict[key].extend(values)</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in self.error_handler_spec.items():</span>
<span class="gi">+            key = name if key is None else f&quot;{name}.{key}&quot;</span>
<span class="gi">+            value = defaultdict(</span>
<span class="gi">+                dict,</span>
<span class="gi">+                {</span>
<span class="gi">+                    code: {exc_class: func for exc_class, func in code_values.items()}</span>
<span class="gi">+                    for code, code_values in value.items()</span>
<span class="gi">+                },</span>
<span class="gi">+            )</span>
<span class="gi">+            app.error_handler_spec[key] = value</span>
<span class="gi">+</span>
<span class="gi">+        for endpoint, func in self.view_functions.items():</span>
<span class="gi">+            app.view_functions[endpoint] = func</span>
<span class="gi">+</span>
<span class="gi">+        extend(self.before_request_funcs, app.before_request_funcs)</span>
<span class="gi">+        extend(self.after_request_funcs, app.after_request_funcs)</span>
<span class="gi">+        extend(</span>
<span class="gi">+            self.teardown_request_funcs,</span>
<span class="gi">+            app.teardown_request_funcs,</span>
<span class="gi">+        )</span>
<span class="gi">+        extend(self.url_default_functions, app.url_default_functions)</span>
<span class="gi">+        extend(self.url_value_preprocessors, app.url_value_preprocessors)</span>
<span class="gi">+        extend(self.template_context_processors, app.template_context_processors)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def add_url_rule(self, rule: str, endpoint: (str | None)=None,</span>
<span class="gd">-        view_func: (ft.RouteCallable | None)=None,</span>
<span class="gd">-        provide_automatic_options: (bool | None)=None, **options: t.Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def add_url_rule(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rule: str,</span>
<span class="gi">+        endpoint: str | None = None,</span>
<span class="gi">+        view_func: ft.RouteCallable | None = None,</span>
<span class="gi">+        provide_automatic_options: bool | None = None,</span>
<span class="gi">+        **options: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for
<span class="w"> </span>        full documentation.

<span class="w"> </span>        The URL rule is prefixed with the blueprint&#39;s URL prefix. The endpoint name,
<span class="w"> </span>        used with :func:`url_for`, is prefixed with the blueprint&#39;s name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if endpoint and &quot;.&quot; in endpoint:</span>
<span class="gi">+            raise ValueError(&quot;&#39;endpoint&#39; may not contain a dot &#39;.&#39; character.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if view_func and hasattr(view_func, &quot;__name__&quot;) and &quot;.&quot; in view_func.__name__:</span>
<span class="gi">+            raise ValueError(&quot;&#39;view_func&#39; name may not contain a dot &#39;.&#39; character.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.record(</span>
<span class="gi">+            lambda s: s.add_url_rule(</span>
<span class="gi">+                rule,</span>
<span class="gi">+                endpoint,</span>
<span class="gi">+                view_func,</span>
<span class="gi">+                provide_automatic_options=provide_automatic_options,</span>
<span class="gi">+                **options,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def app_template_filter(self, name: (str | None)=None) -&gt;t.Callable[[</span>
<span class="gd">-        T_template_filter], T_template_filter]:</span>
<span class="gi">+    def app_template_filter(</span>
<span class="gi">+        self, name: str | None = None</span>
<span class="gi">+    ) -&gt; t.Callable[[T_template_filter], T_template_filter]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a template filter, available in any template rendered by the
<span class="w"> </span>        application. Equivalent to :meth:`.Flask.template_filter`.

<span class="w"> </span>        :param name: the optional name of the filter, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_template_filter) -&gt; T_template_filter:</span>
<span class="gi">+            self.add_app_template_filter(f, name=name)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def add_app_template_filter(self, f: ft.TemplateFilterCallable, name: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gi">+    def add_app_template_filter(</span>
<span class="gi">+        self, f: ft.TemplateFilterCallable, name: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a template filter, available in any template rendered by the
<span class="w"> </span>        application. Works like the :meth:`app_template_filter` decorator. Equivalent to
<span class="w"> </span>        :meth:`.Flask.add_template_filter`.
<span class="gu">@@ -249,11 +468,16 @@ class Blueprint(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the filter, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def register_template(state: BlueprintSetupState) -&gt; None:</span>
<span class="gi">+            state.app.jinja_env.filters[name or f.__name__] = f</span>
<span class="gi">+</span>
<span class="gi">+        self.record_once(register_template)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def app_template_test(self, name: (str | None)=None) -&gt;t.Callable[[</span>
<span class="gd">-        T_template_test], T_template_test]:</span>
<span class="gi">+    def app_template_test(</span>
<span class="gi">+        self, name: str | None = None</span>
<span class="gi">+    ) -&gt; t.Callable[[T_template_test], T_template_test]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a template test, available in any template rendered by the
<span class="w"> </span>        application. Equivalent to :meth:`.Flask.template_test`.

<span class="gu">@@ -262,11 +486,17 @@ class Blueprint(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the test, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_template_test) -&gt; T_template_test:</span>
<span class="gi">+            self.add_app_template_test(f, name=name)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def add_app_template_test(self, f: ft.TemplateTestCallable, name: (str |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def add_app_template_test(</span>
<span class="gi">+        self, f: ft.TemplateTestCallable, name: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a template test, available in any template rendered by the
<span class="w"> </span>        application. Works like the :meth:`app_template_test` decorator. Equivalent to
<span class="w"> </span>        :meth:`.Flask.add_template_test`.
<span class="gu">@@ -276,11 +506,16 @@ class Blueprint(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the test, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def register_template(state: BlueprintSetupState) -&gt; None:</span>
<span class="gi">+            state.app.jinja_env.tests[name or f.__name__] = f</span>
<span class="gi">+</span>
<span class="gi">+        self.record_once(register_template)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def app_template_global(self, name: (str | None)=None) -&gt;t.Callable[[</span>
<span class="gd">-        T_template_global], T_template_global]:</span>
<span class="gi">+    def app_template_global(</span>
<span class="gi">+        self, name: str | None = None</span>
<span class="gi">+    ) -&gt; t.Callable[[T_template_global], T_template_global]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a template global, available in any template rendered by the
<span class="w"> </span>        application. Equivalent to :meth:`.Flask.template_global`.

<span class="gu">@@ -289,11 +524,17 @@ class Blueprint(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the global, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_template_global) -&gt; T_template_global:</span>
<span class="gi">+            self.add_app_template_global(f, name=name)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def add_app_template_global(self, f: ft.TemplateGlobalCallable, name: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gi">+    def add_app_template_global(</span>
<span class="gi">+        self, f: ft.TemplateGlobalCallable, name: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a template global, available in any template rendered by the
<span class="w"> </span>        application. Works like the :meth:`app_template_global` decorator. Equivalent to
<span class="w"> </span>        :meth:`.Flask.add_template_global`.
<span class="gu">@@ -303,56 +544,89 @@ class Blueprint(Scaffold):</span>
<span class="w"> </span>        :param name: the optional name of the global, otherwise the
<span class="w"> </span>                     function name will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def register_template(state: BlueprintSetupState) -&gt; None:</span>
<span class="gi">+            state.app.jinja_env.globals[name or f.__name__] = f</span>
<span class="gi">+</span>
<span class="gi">+        self.record_once(register_template)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def before_app_request(self, f: T_before_request) -&gt;T_before_request:</span>
<span class="gi">+    def before_app_request(self, f: T_before_request) -&gt; T_before_request:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`before_request`, but before every request, not only those handled
<span class="w"> </span>        by the blueprint. Equivalent to :meth:`.Flask.before_request`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.record_once(</span>
<span class="gi">+            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)</span>
<span class="gi">+        )</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def after_app_request(self, f: T_after_request) -&gt;T_after_request:</span>
<span class="gi">+    def after_app_request(self, f: T_after_request) -&gt; T_after_request:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`after_request`, but after every request, not only those handled
<span class="w"> </span>        by the blueprint. Equivalent to :meth:`.Flask.after_request`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.record_once(</span>
<span class="gi">+            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)</span>
<span class="gi">+        )</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def teardown_app_request(self, f: T_teardown) -&gt;T_teardown:</span>
<span class="gi">+    def teardown_app_request(self, f: T_teardown) -&gt; T_teardown:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`teardown_request`, but after every request, not only those
<span class="w"> </span>        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.record_once(</span>
<span class="gi">+            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)</span>
<span class="gi">+        )</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def app_context_processor(self, f: T_template_context_processor</span>
<span class="gd">-        ) -&gt;T_template_context_processor:</span>
<span class="gi">+    def app_context_processor(</span>
<span class="gi">+        self, f: T_template_context_processor</span>
<span class="gi">+    ) -&gt; T_template_context_processor:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`context_processor`, but for templates rendered by every view, not
<span class="w"> </span>        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.record_once(</span>
<span class="gi">+            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)</span>
<span class="gi">+        )</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def app_errorhandler(self, code: (type[Exception] | int)) -&gt;t.Callable[</span>
<span class="gd">-        [T_error_handler], T_error_handler]:</span>
<span class="gi">+    def app_errorhandler(</span>
<span class="gi">+        self, code: type[Exception] | int</span>
<span class="gi">+    ) -&gt; t.Callable[[T_error_handler], T_error_handler]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`errorhandler`, but for every request, not only those handled by
<span class="w"> </span>        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_error_handler) -&gt; T_error_handler:</span>
<span class="gi">+            def from_blueprint(state: BlueprintSetupState) -&gt; None:</span>
<span class="gi">+                state.app.errorhandler(code)(f)</span>
<span class="gi">+</span>
<span class="gi">+            self.record_once(from_blueprint)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def app_url_value_preprocessor(self, f: T_url_value_preprocessor</span>
<span class="gd">-        ) -&gt;T_url_value_preprocessor:</span>
<span class="gi">+    def app_url_value_preprocessor(</span>
<span class="gi">+        self, f: T_url_value_preprocessor</span>
<span class="gi">+    ) -&gt; T_url_value_preprocessor:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`url_value_preprocessor`, but for every request, not only those
<span class="w"> </span>        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.record_once(</span>
<span class="gi">+            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)</span>
<span class="gi">+        )</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def app_url_defaults(self, f: T_url_defaults) -&gt;T_url_defaults:</span>
<span class="gi">+    def app_url_defaults(self, f: T_url_defaults) -&gt; T_url_defaults:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`url_defaults`, but for every request, not only those handled by
<span class="w"> </span>        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.record_once(</span>
<span class="gi">+            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)</span>
<span class="gi">+        )</span>
<span class="gi">+        return f</span>
<span class="gh">diff --git a/src/flask/sansio/scaffold.py b/src/flask/sansio/scaffold.py</span>
<span class="gh">index e35f461d..69e33a09 100644</span>
<span class="gd">--- a/src/flask/sansio/scaffold.py</span>
<span class="gi">+++ b/src/flask/sansio/scaffold.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import importlib.util
<span class="w"> </span>import os
<span class="w"> </span>import pathlib
<span class="gu">@@ -6,30 +7,46 @@ import sys</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from functools import update_wrapper
<span class="gi">+</span>
<span class="w"> </span>from jinja2 import BaseLoader
<span class="w"> </span>from jinja2 import FileSystemLoader
<span class="w"> </span>from werkzeug.exceptions import default_exceptions
<span class="w"> </span>from werkzeug.exceptions import HTTPException
<span class="w"> </span>from werkzeug.utils import cached_property
<span class="gi">+</span>
<span class="w"> </span>from .. import typing as ft
<span class="w"> </span>from ..helpers import get_root_path
<span class="w"> </span>from ..templating import _default_template_ctx_processor
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from click import Group
<span class="gi">+</span>
<span class="gi">+# a singleton sentinel value for parameter defaults</span>
<span class="w"> </span>_sentinel = object()
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gd">-T_after_request = t.TypeVar(&#39;T_after_request&#39;, bound=ft.</span>
<span class="gd">-    AfterRequestCallable[t.Any])</span>
<span class="gd">-T_before_request = t.TypeVar(&#39;T_before_request&#39;, bound=ft.BeforeRequestCallable</span>
<span class="gd">-    )</span>
<span class="gd">-T_error_handler = t.TypeVar(&#39;T_error_handler&#39;, bound=ft.ErrorHandlerCallable)</span>
<span class="gd">-T_teardown = t.TypeVar(&#39;T_teardown&#39;, bound=ft.TeardownCallable)</span>
<span class="gd">-T_template_context_processor = t.TypeVar(&#39;T_template_context_processor&#39;,</span>
<span class="gd">-    bound=ft.TemplateContextProcessorCallable)</span>
<span class="gd">-T_url_defaults = t.TypeVar(&#39;T_url_defaults&#39;, bound=ft.URLDefaultCallable)</span>
<span class="gd">-T_url_value_preprocessor = t.TypeVar(&#39;T_url_value_preprocessor&#39;, bound=ft.</span>
<span class="gd">-    URLValuePreprocessorCallable)</span>
<span class="gd">-T_route = t.TypeVar(&#39;T_route&#39;, bound=ft.RouteCallable)</span>
<span class="gi">+</span>
<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+T_after_request = t.TypeVar(&quot;T_after_request&quot;, bound=ft.AfterRequestCallable[t.Any])</span>
<span class="gi">+T_before_request = t.TypeVar(&quot;T_before_request&quot;, bound=ft.BeforeRequestCallable)</span>
<span class="gi">+T_error_handler = t.TypeVar(&quot;T_error_handler&quot;, bound=ft.ErrorHandlerCallable)</span>
<span class="gi">+T_teardown = t.TypeVar(&quot;T_teardown&quot;, bound=ft.TeardownCallable)</span>
<span class="gi">+T_template_context_processor = t.TypeVar(</span>
<span class="gi">+    &quot;T_template_context_processor&quot;, bound=ft.TemplateContextProcessorCallable</span>
<span class="gi">+)</span>
<span class="gi">+T_url_defaults = t.TypeVar(&quot;T_url_defaults&quot;, bound=ft.URLDefaultCallable)</span>
<span class="gi">+T_url_value_preprocessor = t.TypeVar(</span>
<span class="gi">+    &quot;T_url_value_preprocessor&quot;, bound=ft.URLValuePreprocessorCallable</span>
<span class="gi">+)</span>
<span class="gi">+T_route = t.TypeVar(&quot;T_route&quot;, bound=ft.RouteCallable)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setupmethod(f: F) -&gt; F:</span>
<span class="gi">+    f_name = f.__name__</span>
<span class="gi">+</span>
<span class="gi">+    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="gi">+        self._check_setup_finished(f_name)</span>
<span class="gi">+        return f(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return t.cast(F, update_wrapper(wrapper_func, f))</span>


<span class="w"> </span>class Scaffold:
<span class="gu">@@ -49,125 +66,274 @@ class Scaffold:</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    cli: Group
<span class="w"> </span>    name: str
<span class="w"> </span>    _static_folder: str | None = None
<span class="w"> </span>    _static_url_path: str | None = None

<span class="gd">-    def __init__(self, import_name: str, static_folder: (str | os.PathLike[</span>
<span class="gd">-        str] | None)=None, static_url_path: (str | None)=None,</span>
<span class="gd">-        template_folder: (str | os.PathLike[str] | None)=None, root_path: (</span>
<span class="gd">-        str | None)=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        import_name: str,</span>
<span class="gi">+        static_folder: str | os.PathLike[str] | None = None,</span>
<span class="gi">+        static_url_path: str | None = None,</span>
<span class="gi">+        template_folder: str | os.PathLike[str] | None = None,</span>
<span class="gi">+        root_path: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        #: The name of the package or module that this object belongs</span>
<span class="gi">+        #: to. Do not change this once it is set by the constructor.</span>
<span class="w"> </span>        self.import_name = import_name
<span class="gd">-        self.static_folder = static_folder</span>
<span class="gi">+</span>
<span class="gi">+        self.static_folder = static_folder  # type: ignore</span>
<span class="w"> </span>        self.static_url_path = static_url_path
<span class="gi">+</span>
<span class="gi">+        #: The path to the templates folder, relative to</span>
<span class="gi">+        #: :attr:`root_path`, to add to the template loader. ``None`` if</span>
<span class="gi">+        #: templates should not be added.</span>
<span class="w"> </span>        self.template_folder = template_folder
<span class="gi">+</span>
<span class="w"> </span>        if root_path is None:
<span class="w"> </span>            root_path = get_root_path(self.import_name)
<span class="gi">+</span>
<span class="gi">+        #: Absolute path to the package on the filesystem. Used to look</span>
<span class="gi">+        #: up resources contained in the package.</span>
<span class="w"> </span>        self.root_path = root_path
<span class="gi">+</span>
<span class="gi">+        #: A dictionary mapping endpoint names to view functions.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: To register a view function, use the :meth:`route` decorator.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: This data structure is internal. It should not be modified</span>
<span class="gi">+        #: directly and its format may change at any time.</span>
<span class="w"> </span>        self.view_functions: dict[str, ft.RouteCallable] = {}
<span class="gd">-        self.error_handler_spec: dict[ft.AppOrBlueprintKey, dict[int | None,</span>
<span class="gd">-            dict[type[Exception], ft.ErrorHandlerCallable]]] = defaultdict(</span>
<span class="gd">-            lambda : defaultdict(dict))</span>
<span class="gd">-        self.before_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.</span>
<span class="gd">-            BeforeRequestCallable]] = defaultdict(list)</span>
<span class="gd">-        self.after_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.</span>
<span class="gd">-            AfterRequestCallable[t.Any]]] = defaultdict(list)</span>
<span class="gd">-        self.teardown_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.</span>
<span class="gd">-            TeardownCallable]] = defaultdict(list)</span>
<span class="gd">-        self.template_context_processors: dict[ft.AppOrBlueprintKey, list[</span>
<span class="gd">-            ft.TemplateContextProcessorCallable]] = defaultdict(list, {None:</span>
<span class="gd">-            [_default_template_ctx_processor]})</span>
<span class="gd">-        self.url_value_preprocessors: dict[ft.AppOrBlueprintKey, list[ft.</span>
<span class="gd">-            URLValuePreprocessorCallable]] = defaultdict(list)</span>
<span class="gd">-        self.url_default_functions: dict[ft.AppOrBlueprintKey, list[ft.</span>
<span class="gd">-            URLDefaultCallable]] = defaultdict(list)</span>
<span class="gd">-</span>
<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self.name!r}&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        #: A data structure of registered error handlers, in the format</span>
<span class="gi">+        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is</span>
<span class="gi">+        #: the name of a blueprint the handlers are active for, or</span>
<span class="gi">+        #: ``None`` for all requests. The ``code`` key is the HTTP</span>
<span class="gi">+        #: status code for ``HTTPException``, or ``None`` for</span>
<span class="gi">+        #: other exceptions. The innermost dictionary maps exception</span>
<span class="gi">+        #: classes to handler functions.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: To register an error handler, use the :meth:`errorhandler`</span>
<span class="gi">+        #: decorator.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: This data structure is internal. It should not be modified</span>
<span class="gi">+        #: directly and its format may change at any time.</span>
<span class="gi">+        self.error_handler_spec: dict[</span>
<span class="gi">+            ft.AppOrBlueprintKey,</span>
<span class="gi">+            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],</span>
<span class="gi">+        ] = defaultdict(lambda: defaultdict(dict))</span>
<span class="gi">+</span>
<span class="gi">+        #: A data structure of functions to call at the beginning of</span>
<span class="gi">+        #: each request, in the format ``{scope: [functions]}``. The</span>
<span class="gi">+        #: ``scope`` key is the name of a blueprint the functions are</span>
<span class="gi">+        #: active for, or ``None`` for all requests.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: To register a function, use the :meth:`before_request`</span>
<span class="gi">+        #: decorator.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: This data structure is internal. It should not be modified</span>
<span class="gi">+        #: directly and its format may change at any time.</span>
<span class="gi">+        self.before_request_funcs: dict[</span>
<span class="gi">+            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]</span>
<span class="gi">+        ] = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        #: A data structure of functions to call at the end of each</span>
<span class="gi">+        #: request, in the format ``{scope: [functions]}``. The</span>
<span class="gi">+        #: ``scope`` key is the name of a blueprint the functions are</span>
<span class="gi">+        #: active for, or ``None`` for all requests.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: To register a function, use the :meth:`after_request`</span>
<span class="gi">+        #: decorator.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: This data structure is internal. It should not be modified</span>
<span class="gi">+        #: directly and its format may change at any time.</span>
<span class="gi">+        self.after_request_funcs: dict[</span>
<span class="gi">+            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]</span>
<span class="gi">+        ] = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        #: A data structure of functions to call at the end of each</span>
<span class="gi">+        #: request even if an exception is raised, in the format</span>
<span class="gi">+        #: ``{scope: [functions]}``. The ``scope`` key is the name of a</span>
<span class="gi">+        #: blueprint the functions are active for, or ``None`` for all</span>
<span class="gi">+        #: requests.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: To register a function, use the :meth:`teardown_request`</span>
<span class="gi">+        #: decorator.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: This data structure is internal. It should not be modified</span>
<span class="gi">+        #: directly and its format may change at any time.</span>
<span class="gi">+        self.teardown_request_funcs: dict[</span>
<span class="gi">+            ft.AppOrBlueprintKey, list[ft.TeardownCallable]</span>
<span class="gi">+        ] = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        #: A data structure of functions to call to pass extra context</span>
<span class="gi">+        #: values when rendering templates, in the format</span>
<span class="gi">+        #: ``{scope: [functions]}``. The ``scope`` key is the name of a</span>
<span class="gi">+        #: blueprint the functions are active for, or ``None`` for all</span>
<span class="gi">+        #: requests.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: To register a function, use the :meth:`context_processor`</span>
<span class="gi">+        #: decorator.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: This data structure is internal. It should not be modified</span>
<span class="gi">+        #: directly and its format may change at any time.</span>
<span class="gi">+        self.template_context_processors: dict[</span>
<span class="gi">+            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]</span>
<span class="gi">+        ] = defaultdict(list, {None: [_default_template_ctx_processor]})</span>
<span class="gi">+</span>
<span class="gi">+        #: A data structure of functions to call to modify the keyword</span>
<span class="gi">+        #: arguments passed to the view function, in the format</span>
<span class="gi">+        #: ``{scope: [functions]}``. The ``scope`` key is the name of a</span>
<span class="gi">+        #: blueprint the functions are active for, or ``None`` for all</span>
<span class="gi">+        #: requests.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: To register a function, use the</span>
<span class="gi">+        #: :meth:`url_value_preprocessor` decorator.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: This data structure is internal. It should not be modified</span>
<span class="gi">+        #: directly and its format may change at any time.</span>
<span class="gi">+        self.url_value_preprocessors: dict[</span>
<span class="gi">+            ft.AppOrBlueprintKey,</span>
<span class="gi">+            list[ft.URLValuePreprocessorCallable],</span>
<span class="gi">+        ] = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        #: A data structure of functions to call to modify the keyword</span>
<span class="gi">+        #: arguments when generating URLs, in the format</span>
<span class="gi">+        #: ``{scope: [functions]}``. The ``scope`` key is the name of a</span>
<span class="gi">+        #: blueprint the functions are active for, or ``None`` for all</span>
<span class="gi">+        #: requests.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: To register a function, use the :meth:`url_defaults`</span>
<span class="gi">+        #: decorator.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: This data structure is internal. It should not be modified</span>
<span class="gi">+        #: directly and its format may change at any time.</span>
<span class="gi">+        self.url_default_functions: dict[</span>
<span class="gi">+            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]</span>
<span class="gi">+        ] = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.name!r}&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _check_setup_finished(self, f_name: str) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @property
<span class="gd">-    def static_folder(self) -&gt;(str | None):</span>
<span class="gi">+    def static_folder(self) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The absolute path to the configured static folder. ``None``
<span class="w"> </span>        if no static folder is set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._static_folder is not None:</span>
<span class="gi">+            return os.path.join(self.root_path, self._static_folder)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    @static_folder.setter</span>
<span class="gi">+    def static_folder(self, value: str | os.PathLike[str] | None) -&gt; None:</span>
<span class="gi">+        if value is not None:</span>
<span class="gi">+            value = os.fspath(value).rstrip(r&quot;\/&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._static_folder = value</span>

<span class="w"> </span>    @property
<span class="gd">-    def has_static_folder(self) -&gt;bool:</span>
<span class="gi">+    def has_static_folder(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;``True`` if :attr:`static_folder` is set.

<span class="w"> </span>        .. versionadded:: 0.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.static_folder is not None</span>

<span class="w"> </span>    @property
<span class="gd">-    def static_url_path(self) -&gt;(str | None):</span>
<span class="gi">+    def static_url_path(self) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The URL prefix that the static route will be accessible from.

<span class="w"> </span>        If it was not configured during init, it is derived from
<span class="w"> </span>        :attr:`static_folder`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._static_url_path is not None:</span>
<span class="gi">+            return self._static_url_path</span>
<span class="gi">+</span>
<span class="gi">+        if self.static_folder is not None:</span>
<span class="gi">+            basename = os.path.basename(self.static_folder)</span>
<span class="gi">+            return f&quot;/{basename}&quot;.rstrip(&quot;/&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @static_url_path.setter</span>
<span class="gi">+    def static_url_path(self, value: str | None) -&gt; None:</span>
<span class="gi">+        if value is not None:</span>
<span class="gi">+            value = value.rstrip(&quot;/&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._static_url_path = value</span>

<span class="w"> </span>    @cached_property
<span class="gd">-    def jinja_loader(self) -&gt;(BaseLoader | None):</span>
<span class="gi">+    def jinja_loader(self) -&gt; BaseLoader | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The Jinja loader for this object&#39;s templates. By default this
<span class="w"> </span>        is a class :class:`jinja2.loaders.FileSystemLoader` to
<span class="w"> </span>        :attr:`template_folder` if it is set.

<span class="w"> </span>        .. versionadded:: 0.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.template_folder is not None:</span>
<span class="gi">+            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def _method_route(</span>
<span class="gi">+        self,</span>
<span class="gi">+        method: str,</span>
<span class="gi">+        rule: str,</span>
<span class="gi">+        options: dict[str, t.Any],</span>
<span class="gi">+    ) -&gt; t.Callable[[T_route], T_route]:</span>
<span class="gi">+        if &quot;methods&quot; in options:</span>
<span class="gi">+            raise TypeError(&quot;Use the &#39;route&#39; decorator to use the &#39;methods&#39; argument.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self.route(rule, methods=[method], **options)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def get(self, rule: str, **options: t.Any) -&gt;t.Callable[[T_route], T_route</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def get(self, rule: str, **options: t.Any) -&gt; t.Callable[[T_route], T_route]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shortcut for :meth:`route` with ``methods=[&quot;GET&quot;]``.

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._method_route(&quot;GET&quot;, rule, options)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def post(self, rule: str, **options: t.Any) -&gt;t.Callable[[T_route], T_route</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def post(self, rule: str, **options: t.Any) -&gt; t.Callable[[T_route], T_route]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shortcut for :meth:`route` with ``methods=[&quot;POST&quot;]``.

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._method_route(&quot;POST&quot;, rule, options)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def put(self, rule: str, **options: t.Any) -&gt;t.Callable[[T_route], T_route</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def put(self, rule: str, **options: t.Any) -&gt; t.Callable[[T_route], T_route]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shortcut for :meth:`route` with ``methods=[&quot;PUT&quot;]``.

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._method_route(&quot;PUT&quot;, rule, options)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def delete(self, rule: str, **options: t.Any) -&gt;t.Callable[[T_route],</span>
<span class="gd">-        T_route]:</span>
<span class="gi">+    def delete(self, rule: str, **options: t.Any) -&gt; t.Callable[[T_route], T_route]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shortcut for :meth:`route` with ``methods=[&quot;DELETE&quot;]``.

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._method_route(&quot;DELETE&quot;, rule, options)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def patch(self, rule: str, **options: t.Any) -&gt;t.Callable[[T_route],</span>
<span class="gd">-        T_route]:</span>
<span class="gi">+    def patch(self, rule: str, **options: t.Any) -&gt; t.Callable[[T_route], T_route]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shortcut for :meth:`route` with ``methods=[&quot;PATCH&quot;]``.

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._method_route(&quot;PATCH&quot;, rule, options)</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def route(self, rule: str, **options: t.Any) -&gt;t.Callable[[T_route],</span>
<span class="gd">-        T_route]:</span>
<span class="gi">+    def route(self, rule: str, **options: t.Any) -&gt; t.Callable[[T_route], T_route]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decorate a view function to register it with the given URL
<span class="w"> </span>        rule and options. Calls :meth:`add_url_rule`, which has more
<span class="w"> </span>        details about the implementation.
<span class="gu">@@ -190,13 +356,23 @@ class Scaffold:</span>
<span class="w"> </span>        :param options: Extra options passed to the
<span class="w"> </span>            :class:`~werkzeug.routing.Rule` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_route) -&gt; T_route:</span>
<span class="gi">+            endpoint = options.pop(&quot;endpoint&quot;, None)</span>
<span class="gi">+            self.add_url_rule(rule, endpoint, f, **options)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def add_url_rule(self, rule: str, endpoint: (str | None)=None,</span>
<span class="gd">-        view_func: (ft.RouteCallable | None)=None,</span>
<span class="gd">-        provide_automatic_options: (bool | None)=None, **options: t.Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def add_url_rule(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rule: str,</span>
<span class="gi">+        endpoint: str | None = None,</span>
<span class="gi">+        view_func: ft.RouteCallable | None = None,</span>
<span class="gi">+        provide_automatic_options: bool | None = None,</span>
<span class="gi">+        **options: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a rule for routing incoming requests and building
<span class="w"> </span>        URLs. The :meth:`route` decorator is a shortcut to call this
<span class="w"> </span>        with the ``view_func`` argument. These are equivalent:
<span class="gu">@@ -254,10 +430,10 @@ class Scaffold:</span>
<span class="w"> </span>        :param options: Extra options passed to the
<span class="w"> </span>            :class:`~werkzeug.routing.Rule` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def endpoint(self, endpoint: str) -&gt;t.Callable[[F], F]:</span>
<span class="gi">+    def endpoint(self, endpoint: str) -&gt; t.Callable[[F], F]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decorate a view function to register it for the given
<span class="w"> </span>        endpoint. Used if a rule is added without a ``view_func`` with
<span class="w"> </span>        :meth:`add_url_rule`.
<span class="gu">@@ -273,10 +449,15 @@ class Scaffold:</span>
<span class="w"> </span>        :param endpoint: The endpoint name to associate with the view
<span class="w"> </span>            function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: F) -&gt; F:</span>
<span class="gi">+            self.view_functions[endpoint] = f</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def before_request(self, f: T_before_request) -&gt;T_before_request:</span>
<span class="gi">+    def before_request(self, f: T_before_request) -&gt; T_before_request:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a function to run before each request.

<span class="w"> </span>        For example, this can be used to open a database connection, or
<span class="gu">@@ -299,10 +480,11 @@ class Scaffold:</span>
<span class="w"> </span>        every request that the blueprint handles. To register with a blueprint and
<span class="w"> </span>        execute before every request, use :meth:`.Blueprint.before_app_request`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.before_request_funcs.setdefault(None, []).append(f)</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def after_request(self, f: T_after_request) -&gt;T_after_request:</span>
<span class="gi">+    def after_request(self, f: T_after_request) -&gt; T_after_request:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a function to run after each request to this object.

<span class="w"> </span>        The function is called with the response object, and must return
<span class="gu">@@ -319,10 +501,11 @@ class Scaffold:</span>
<span class="w"> </span>        every request that the blueprint handles. To register with a blueprint and
<span class="w"> </span>        execute after every request, use :meth:`.Blueprint.after_app_request`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.after_request_funcs.setdefault(None, []).append(f)</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def teardown_request(self, f: T_teardown) -&gt;T_teardown:</span>
<span class="gi">+    def teardown_request(self, f: T_teardown) -&gt; T_teardown:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a function to be called when the request context is
<span class="w"> </span>        popped. Typically this happens at the end of each request, but
<span class="w"> </span>        contexts may be pushed manually as well during testing.
<span class="gu">@@ -352,11 +535,14 @@ class Scaffold:</span>
<span class="w"> </span>        every request that the blueprint handles. To register with a blueprint and
<span class="w"> </span>        execute after every request, use :meth:`.Blueprint.teardown_app_request`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.teardown_request_funcs.setdefault(None, []).append(f)</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def context_processor(self, f: T_template_context_processor</span>
<span class="gd">-        ) -&gt;T_template_context_processor:</span>
<span class="gi">+    def context_processor(</span>
<span class="gi">+        self,</span>
<span class="gi">+        f: T_template_context_processor,</span>
<span class="gi">+    ) -&gt; T_template_context_processor:</span>
<span class="w"> </span>        &quot;&quot;&quot;Registers a template context processor function. These functions run before
<span class="w"> </span>        rendering a template. The keys of the returned dict are added as variables
<span class="w"> </span>        available in the template.
<span class="gu">@@ -366,11 +552,14 @@ class Scaffold:</span>
<span class="w"> </span>        for templates rendered from the blueprint&#39;s views. To register with a blueprint
<span class="w"> </span>        and affect every template, use :meth:`.Blueprint.app_context_processor`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.template_context_processors[None].append(f)</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def url_value_preprocessor(self, f: T_url_value_preprocessor</span>
<span class="gd">-        ) -&gt;T_url_value_preprocessor:</span>
<span class="gi">+    def url_value_preprocessor(</span>
<span class="gi">+        self,</span>
<span class="gi">+        f: T_url_value_preprocessor,</span>
<span class="gi">+    ) -&gt; T_url_value_preprocessor:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a URL value preprocessor function for all view
<span class="w"> </span>        functions in the application. These functions will be called before the
<span class="w"> </span>        :meth:`before_request` functions.
<span class="gu">@@ -388,10 +577,11 @@ class Scaffold:</span>
<span class="w"> </span>        requests that the blueprint handles. To register with a blueprint and affect
<span class="w"> </span>        every request, use :meth:`.Blueprint.app_url_value_preprocessor`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.url_value_preprocessors[None].append(f)</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def url_defaults(self, f: T_url_defaults) -&gt;T_url_defaults:</span>
<span class="gi">+    def url_defaults(self, f: T_url_defaults) -&gt; T_url_defaults:</span>
<span class="w"> </span>        &quot;&quot;&quot;Callback function for URL defaults for all view functions of the
<span class="w"> </span>        application.  It&#39;s called with the endpoint and values and should
<span class="w"> </span>        update the values passed in place.
<span class="gu">@@ -401,11 +591,13 @@ class Scaffold:</span>
<span class="w"> </span>        requests that the blueprint handles. To register with a blueprint and affect
<span class="w"> </span>        every request, use :meth:`.Blueprint.app_url_defaults`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.url_default_functions[None].append(f)</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def errorhandler(self, code_or_exception: (type[Exception] | int)</span>
<span class="gd">-        ) -&gt;t.Callable[[T_error_handler], T_error_handler]:</span>
<span class="gi">+    def errorhandler(</span>
<span class="gi">+        self, code_or_exception: type[Exception] | int</span>
<span class="gi">+    ) -&gt; t.Callable[[T_error_handler], T_error_handler]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a function to handle errors by code or exception class.

<span class="w"> </span>        A decorator that is used to register a function given an
<span class="gu">@@ -439,22 +631,32 @@ class Scaffold:</span>
<span class="w"> </span>        :param code_or_exception: the code as integer for the handler, or
<span class="w"> </span>                                  an arbitrary exception
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def decorator(f: T_error_handler) -&gt; T_error_handler:</span>
<span class="gi">+            self.register_error_handler(code_or_exception, f)</span>
<span class="gi">+            return f</span>
<span class="gi">+</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    @setupmethod
<span class="gd">-    def register_error_handler(self, code_or_exception: (type[Exception] |</span>
<span class="gd">-        int), f: ft.ErrorHandlerCallable) -&gt;None:</span>
<span class="gi">+    def register_error_handler(</span>
<span class="gi">+        self,</span>
<span class="gi">+        code_or_exception: type[Exception] | int,</span>
<span class="gi">+        f: ft.ErrorHandlerCallable,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Alternative error attach function to the :meth:`errorhandler`
<span class="w"> </span>        decorator that is more straightforward to use for non decorator
<span class="w"> </span>        usage.

<span class="w"> </span>        .. versionadded:: 0.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        exc_class, code = self._get_exc_class_and_code(code_or_exception)</span>
<span class="gi">+        self.error_handler_spec[None][code][exc_class] = f</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _get_exc_class_and_code(exc_class_or_code: (type[Exception] | int)</span>
<span class="gd">-        ) -&gt;tuple[type[Exception], int | None]:</span>
<span class="gi">+    def _get_exc_class_and_code(</span>
<span class="gi">+        exc_class_or_code: type[Exception] | int,</span>
<span class="gi">+    ) -&gt; tuple[type[Exception], int | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the exception class being handled. For HTTP status codes
<span class="w"> </span>        or ``HTTPException`` subclasses, return both the exception and
<span class="w"> </span>        status code.
<span class="gu">@@ -462,22 +664,103 @@ class Scaffold:</span>
<span class="w"> </span>        :param exc_class_or_code: Any exception class, or an HTTP status
<span class="w"> </span>            code as an integer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _endpoint_from_view_func(view_func: ft.RouteCallable) -&gt;str:</span>
<span class="gi">+        exc_class: type[Exception]</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(exc_class_or_code, int):</span>
<span class="gi">+            try:</span>
<span class="gi">+                exc_class = default_exceptions[exc_class_or_code]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;&#39;{exc_class_or_code}&#39; is not a recognized HTTP&quot;</span>
<span class="gi">+                    &quot; error code. Use a subclass of HTTPException with&quot;</span>
<span class="gi">+                    &quot; that code instead.&quot;</span>
<span class="gi">+                ) from None</span>
<span class="gi">+        else:</span>
<span class="gi">+            exc_class = exc_class_or_code</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(exc_class, Exception):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;{exc_class!r} is an instance, not a class. Handlers&quot;</span>
<span class="gi">+                &quot; can only be registered for Exception classes or HTTP&quot;</span>
<span class="gi">+                &quot; error codes.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not issubclass(exc_class, Exception):</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&quot;&#39;{exc_class.__name__}&#39; is not a subclass of Exception.&quot;</span>
<span class="gi">+                &quot; Handlers can only be registered for Exception classes&quot;</span>
<span class="gi">+                &quot; or HTTP error codes.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if issubclass(exc_class, HTTPException):</span>
<span class="gi">+            return exc_class, exc_class.code</span>
<span class="gi">+        else:</span>
<span class="gi">+            return exc_class, None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _endpoint_from_view_func(view_func: ft.RouteCallable) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Internal helper that returns the default endpoint for a given
<span class="w"> </span>    function.  This always is the function name.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert view_func is not None, &quot;expected view func if endpoint is not provided.&quot;</span>
<span class="gi">+    return view_func.__name__</span>


<span class="gd">-def _find_package_path(import_name: str) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Find the path that contains the package or module.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def _path_is_relative_to(path: pathlib.PurePath, base: str) -&gt; bool:</span>
<span class="gi">+    # Path.is_relative_to doesn&#39;t exist until Python 3.9</span>
<span class="gi">+    try:</span>
<span class="gi">+        path.relative_to(base)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return False</span>


<span class="gd">-def find_package(import_name: str) -&gt;tuple[str | None, str]:</span>
<span class="gi">+def _find_package_path(import_name: str) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Find the path that contains the package or module.&quot;&quot;&quot;</span>
<span class="gi">+    root_mod_name, _, _ = import_name.partition(&quot;.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        root_spec = importlib.util.find_spec(root_mod_name)</span>
<span class="gi">+</span>
<span class="gi">+        if root_spec is None:</span>
<span class="gi">+            raise ValueError(&quot;not found&quot;)</span>
<span class="gi">+    except (ImportError, ValueError):</span>
<span class="gi">+        # ImportError: the machinery told us it does not exist</span>
<span class="gi">+        # ValueError:</span>
<span class="gi">+        #    - the module name was invalid</span>
<span class="gi">+        #    - the module name is __main__</span>
<span class="gi">+        #    - we raised `ValueError` due to `root_spec` being `None`</span>
<span class="gi">+        return os.getcwd()</span>
<span class="gi">+</span>
<span class="gi">+    if root_spec.submodule_search_locations:</span>
<span class="gi">+        if root_spec.origin is None or root_spec.origin == &quot;namespace&quot;:</span>
<span class="gi">+            # namespace package</span>
<span class="gi">+            package_spec = importlib.util.find_spec(import_name)</span>
<span class="gi">+</span>
<span class="gi">+            if package_spec is not None and package_spec.submodule_search_locations:</span>
<span class="gi">+                # Pick the path in the namespace that contains the submodule.</span>
<span class="gi">+                package_path = pathlib.Path(</span>
<span class="gi">+                    os.path.commonpath(package_spec.submodule_search_locations)</span>
<span class="gi">+                )</span>
<span class="gi">+                search_location = next(</span>
<span class="gi">+                    location</span>
<span class="gi">+                    for location in root_spec.submodule_search_locations</span>
<span class="gi">+                    if _path_is_relative_to(package_path, location)</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Pick the first path.</span>
<span class="gi">+                search_location = root_spec.submodule_search_locations[0]</span>
<span class="gi">+</span>
<span class="gi">+            return os.path.dirname(search_location)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # package with __init__.py</span>
<span class="gi">+            return os.path.dirname(os.path.dirname(root_spec.origin))</span>
<span class="gi">+    else:</span>
<span class="gi">+        # module</span>
<span class="gi">+        return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_package(import_name: str) -&gt; tuple[str | None, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the prefix that a package is installed under, and the path
<span class="w"> </span>    that it would be imported from.

<span class="gu">@@ -490,4 +773,29 @@ def find_package(import_name: str) -&gt;tuple[str | None, str]:</span>
<span class="w"> </span>    for import. If the package is not installed, it&#39;s assumed that the
<span class="w"> </span>    package was imported from the current working directory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    package_path = _find_package_path(import_name)</span>
<span class="gi">+    py_prefix = os.path.abspath(sys.prefix)</span>
<span class="gi">+</span>
<span class="gi">+    # installed to the system</span>
<span class="gi">+    if _path_is_relative_to(pathlib.PurePath(package_path), py_prefix):</span>
<span class="gi">+        return py_prefix, package_path</span>
<span class="gi">+</span>
<span class="gi">+    site_parent, site_folder = os.path.split(package_path)</span>
<span class="gi">+</span>
<span class="gi">+    # installed to a virtualenv</span>
<span class="gi">+    if site_folder.lower() == &quot;site-packages&quot;:</span>
<span class="gi">+        parent, folder = os.path.split(site_parent)</span>
<span class="gi">+</span>
<span class="gi">+        # Windows (prefix/lib/site-packages)</span>
<span class="gi">+        if folder.lower() == &quot;lib&quot;:</span>
<span class="gi">+            return parent, package_path</span>
<span class="gi">+</span>
<span class="gi">+        # Unix (prefix/lib/pythonX.Y/site-packages)</span>
<span class="gi">+        if os.path.basename(parent).lower() == &quot;lib&quot;:</span>
<span class="gi">+            return os.path.dirname(parent), package_path</span>
<span class="gi">+</span>
<span class="gi">+        # something else (prefix/site-packages)</span>
<span class="gi">+        return site_parent, package_path</span>
<span class="gi">+</span>
<span class="gi">+    # not installed</span>
<span class="gi">+    return None, package_path</span>
<span class="gh">diff --git a/src/flask/sessions.py b/src/flask/sessions.py</span>
<span class="gh">index 5ed091cb..ee19ad63 100644</span>
<span class="gd">--- a/src/flask/sessions.py</span>
<span class="gi">+++ b/src/flask/sessions.py</span>
<span class="gu">@@ -1,33 +1,56 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import hashlib
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections.abc import MutableMapping
<span class="w"> </span>from datetime import datetime
<span class="w"> </span>from datetime import timezone
<span class="gi">+</span>
<span class="w"> </span>from itsdangerous import BadSignature
<span class="w"> </span>from itsdangerous import URLSafeTimedSerializer
<span class="w"> </span>from werkzeug.datastructures import CallbackDict
<span class="gi">+</span>
<span class="w"> </span>from .json.tag import TaggedJSONSerializer
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .app import Flask
<span class="w"> </span>    from .wrappers import Request
<span class="w"> </span>    from .wrappers import Response


<span class="gd">-class SessionMixin(MutableMapping):</span>
<span class="gi">+# TODO generic when Python &gt; 3.8</span>
<span class="gi">+class SessionMixin(MutableMapping):  # type: ignore[type-arg]</span>
<span class="w"> </span>    &quot;&quot;&quot;Expands a basic dictionary with session attributes.&quot;&quot;&quot;

<span class="w"> </span>    @property
<span class="gd">-    def permanent(self) -&gt;bool:</span>
<span class="gi">+    def permanent(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;This reflects the ``&#39;_permanent&#39;`` key in the dict.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get(&quot;_permanent&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+    @permanent.setter</span>
<span class="gi">+    def permanent(self, value: bool) -&gt; None:</span>
<span class="gi">+        self[&quot;_permanent&quot;] = bool(value)</span>
<span class="gi">+</span>
<span class="gi">+    #: Some implementations can detect whether a session is newly</span>
<span class="gi">+    #: created, but that is not guaranteed. Use with caution. The mixin</span>
<span class="gi">+    # default is hard-coded ``False``.</span>
<span class="w"> </span>    new = False
<span class="gi">+</span>
<span class="gi">+    #: Some implementations can detect changes to the session and set</span>
<span class="gi">+    #: this when that happens. The mixin default is hard coded to</span>
<span class="gi">+    #: ``True``.</span>
<span class="w"> </span>    modified = True
<span class="gi">+</span>
<span class="gi">+    #: Some implementations can detect when session data is read or</span>
<span class="gi">+    #: written and set this when that happens. The mixin default is hard</span>
<span class="gi">+    #: coded to ``True``.</span>
<span class="w"> </span>    accessed = True


<span class="gd">-class SecureCookieSession(CallbackDict, SessionMixin):</span>
<span class="gi">+# TODO generic when Python &gt; 3.8</span>
<span class="gi">+class SecureCookieSession(CallbackDict, SessionMixin):  # type: ignore[type-arg]</span>
<span class="w"> </span>    &quot;&quot;&quot;Base class for sessions based on signed cookies.

<span class="w"> </span>    This session backend will set the :attr:`modified` and
<span class="gu">@@ -35,28 +58,54 @@ class SecureCookieSession(CallbackDict, SessionMixin):</span>
<span class="w"> </span>    session is new (vs. empty), so :attr:`new` remains hard coded to
<span class="w"> </span>    ``False``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: When data is changed, this is set to ``True``. Only the session</span>
<span class="gi">+    #: dictionary itself is tracked; if the session contains mutable</span>
<span class="gi">+    #: data (for example a nested dict) then this must be set to</span>
<span class="gi">+    #: ``True`` manually when modifying that data. The session cookie</span>
<span class="gi">+    #: will only be written to the response if this is ``True``.</span>
<span class="w"> </span>    modified = False
<span class="gd">-    accessed = False</span>

<span class="gd">-    def __init__(self, initial: t.Any=None) -&gt;None:</span>
<span class="gi">+    #: When data is read or written, this is set to ``True``. Used by</span>
<span class="gi">+    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``</span>
<span class="gi">+    #: header, which allows caching proxies to cache different pages for</span>
<span class="gi">+    #: different users.</span>
<span class="gi">+    accessed = False</span>

<span class="gd">-        def on_update(self: te.Self) -&gt;None:</span>
<span class="gi">+    def __init__(self, initial: t.Any = None) -&gt; None:</span>
<span class="gi">+        def on_update(self: te.Self) -&gt; None:</span>
<span class="w"> </span>            self.modified = True
<span class="w"> </span>            self.accessed = True
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(initial, on_update)

<span class="gd">-    def __getitem__(self, key: str) -&gt;t.Any:</span>
<span class="gi">+    def __getitem__(self, key: str) -&gt; t.Any:</span>
<span class="w"> </span>        self.accessed = True
<span class="w"> </span>        return super().__getitem__(key)

<span class="gi">+    def get(self, key: str, default: t.Any = None) -&gt; t.Any:</span>
<span class="gi">+        self.accessed = True</span>
<span class="gi">+        return super().get(key, default)</span>
<span class="gi">+</span>
<span class="gi">+    def setdefault(self, key: str, default: t.Any = None) -&gt; t.Any:</span>
<span class="gi">+        self.accessed = True</span>
<span class="gi">+        return super().setdefault(key, default)</span>
<span class="gi">+</span>

<span class="w"> </span>class NullSession(SecureCookieSession):
<span class="w"> </span>    &quot;&quot;&quot;Class used to generate nicer error messages if sessions are not
<span class="w"> </span>    available.  Will still allow read-only access to the empty session
<span class="w"> </span>    but fail on setting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    (__setitem__) = (__delitem__) = (clear) = (pop) = (popitem) = (update) = (</span>
<span class="gd">-        setdefault) = _fail</span>
<span class="gi">+</span>
<span class="gi">+    def _fail(self, *args: t.Any, **kwargs: t.Any) -&gt; t.NoReturn:</span>
<span class="gi">+        raise RuntimeError(</span>
<span class="gi">+            &quot;The session is unavailable because no secret &quot;</span>
<span class="gi">+            &quot;key was set.  Set the secret_key on the &quot;</span>
<span class="gi">+            &quot;application to something unique and secret.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail  # type: ignore # noqa: B950</span>
<span class="w"> </span>    del _fail


<span class="gu">@@ -96,10 +145,21 @@ class SessionInterface:</span>

<span class="w"> </span>    .. versionadded:: 0.8
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: :meth:`make_null_session` will look here for the class that should</span>
<span class="gi">+    #: be created when a null session is requested.  Likewise the</span>
<span class="gi">+    #: :meth:`is_null_session` method will perform a typecheck against</span>
<span class="gi">+    #: this type.</span>
<span class="w"> </span>    null_session_class = NullSession
<span class="gi">+</span>
<span class="gi">+    #: A flag that indicates if the session interface is pickle based.</span>
<span class="gi">+    #: This can be used by Flask extensions to make a decision in regards</span>
<span class="gi">+    #: to how to deal with the session object.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.10</span>
<span class="w"> </span>    pickle_based = False

<span class="gd">-    def make_null_session(self, app: Flask) -&gt;NullSession:</span>
<span class="gi">+    def make_null_session(self, app: Flask) -&gt; NullSession:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a null session which acts as a replacement object if the
<span class="w"> </span>        real session support could not be loaded due to a configuration
<span class="w"> </span>        error.  This mainly aids the user experience because the job of the
<span class="gu">@@ -109,22 +169,22 @@ class SessionInterface:</span>

<span class="w"> </span>        This creates an instance of :attr:`null_session_class` by default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.null_session_class()</span>

<span class="gd">-    def is_null_session(self, obj: object) -&gt;bool:</span>
<span class="gi">+    def is_null_session(self, obj: object) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if a given object is a null session.  Null sessions are
<span class="w"> </span>        not asked to be saved.

<span class="w"> </span>        This checks if the object is an instance of :attr:`null_session_class`
<span class="w"> </span>        by default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return isinstance(obj, self.null_session_class)</span>

<span class="gd">-    def get_cookie_name(self, app: Flask) -&gt;str:</span>
<span class="gi">+    def get_cookie_name(self, app: Flask) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;The name of the session cookie. Uses``app.config[&quot;SESSION_COOKIE_NAME&quot;]``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return app.config[&quot;SESSION_COOKIE_NAME&quot;]  # type: ignore[no-any-return]</span>

<span class="gd">-    def get_cookie_domain(self, app: Flask) -&gt;(str | None):</span>
<span class="gi">+    def get_cookie_domain(self, app: Flask) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The value of the ``Domain`` parameter on the session cookie. If not set,
<span class="w"> </span>        browsers will only send the cookie to the exact domain it was set from.
<span class="w"> </span>        Otherwise, they will send it to any subdomain of the given value as well.
<span class="gu">@@ -134,46 +194,47 @@ class SessionInterface:</span>
<span class="w"> </span>        .. versionchanged:: 2.3
<span class="w"> </span>            Not set by default, does not fall back to ``SERVER_NAME``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return app.config[&quot;SESSION_COOKIE_DOMAIN&quot;]  # type: ignore[no-any-return]</span>

<span class="gd">-    def get_cookie_path(self, app: Flask) -&gt;str:</span>
<span class="gi">+    def get_cookie_path(self, app: Flask) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the path for which the cookie should be valid.  The
<span class="w"> </span>        default implementation uses the value from the ``SESSION_COOKIE_PATH``
<span class="w"> </span>        config var if it&#39;s set, and falls back to ``APPLICATION_ROOT`` or
<span class="w"> </span>        uses ``/`` if it&#39;s ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return app.config[&quot;SESSION_COOKIE_PATH&quot;] or app.config[&quot;APPLICATION_ROOT&quot;]  # type: ignore[no-any-return]</span>

<span class="gd">-    def get_cookie_httponly(self, app: Flask) -&gt;bool:</span>
<span class="gi">+    def get_cookie_httponly(self, app: Flask) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns True if the session cookie should be httponly.  This
<span class="w"> </span>        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``
<span class="w"> </span>        config var.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return app.config[&quot;SESSION_COOKIE_HTTPONLY&quot;]  # type: ignore[no-any-return]</span>

<span class="gd">-    def get_cookie_secure(self, app: Flask) -&gt;bool:</span>
<span class="gi">+    def get_cookie_secure(self, app: Flask) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns True if the cookie should be secure.  This currently
<span class="w"> </span>        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return app.config[&quot;SESSION_COOKIE_SECURE&quot;]  # type: ignore[no-any-return]</span>

<span class="gd">-    def get_cookie_samesite(self, app: Flask) -&gt;(str | None):</span>
<span class="gi">+    def get_cookie_samesite(self, app: Flask) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return ``&#39;Strict&#39;`` or ``&#39;Lax&#39;`` if the cookie should use the
<span class="w"> </span>        ``SameSite`` attribute. This currently just returns the value of
<span class="w"> </span>        the :data:`SESSION_COOKIE_SAMESITE` setting.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return app.config[&quot;SESSION_COOKIE_SAMESITE&quot;]  # type: ignore[no-any-return]</span>

<span class="gd">-    def get_expiration_time(self, app: Flask, session: SessionMixin) -&gt;(</span>
<span class="gd">-        datetime | None):</span>
<span class="gi">+    def get_expiration_time(self, app: Flask, session: SessionMixin) -&gt; datetime | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;A helper method that returns an expiration date for the session
<span class="w"> </span>        or ``None`` if the session is linked to the browser session.  The
<span class="w"> </span>        default implementation returns now + the permanent session
<span class="w"> </span>        lifetime configured on the application.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if session.permanent:</span>
<span class="gi">+            return datetime.now(timezone.utc) + app.permanent_session_lifetime</span>
<span class="gi">+        return None</span>

<span class="gd">-    def should_set_cookie(self, app: Flask, session: SessionMixin) -&gt;bool:</span>
<span class="gi">+    def should_set_cookie(self, app: Flask, session: SessionMixin) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used by session backends to determine if a ``Set-Cookie`` header
<span class="w"> </span>        should be set for this session cookie for this response. If the session
<span class="w"> </span>        has been modified, the cookie is set. If the session is permanent and
<span class="gu">@@ -184,10 +245,12 @@ class SessionInterface:</span>

<span class="w"> </span>        .. versionadded:: 0.11
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def open_session(self, app: Flask, request: Request) -&gt;(SessionMixin | None</span>
<span class="gd">-        ):</span>
<span class="gi">+        return session.modified or (</span>
<span class="gi">+            session.permanent and app.config[&quot;SESSION_REFRESH_EACH_REQUEST&quot;]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def open_session(self, app: Flask, request: Request) -&gt; SessionMixin | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is called at the beginning of each request, after
<span class="w"> </span>        pushing the request context, before matching the URL.

<span class="gu">@@ -199,34 +262,118 @@ class SessionInterface:</span>
<span class="w"> </span>        context will fall back to using :meth:`make_null_session`
<span class="w"> </span>        in this case.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def save_session(self, app: Flask, session: SessionMixin, response:</span>
<span class="gd">-        Response) -&gt;None:</span>
<span class="gi">+    def save_session(</span>
<span class="gi">+        self, app: Flask, session: SessionMixin, response: Response</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is called at the end of each request, after generating
<span class="w"> </span>        a response, before removing the request context. It is skipped
<span class="w"> </span>        if :meth:`is_null_session` returns ``True``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>


<span class="w"> </span>session_json_serializer = TaggedJSONSerializer()


<span class="gd">-def _lazy_sha1(string: bytes=b&#39;&#39;) -&gt;t.Any:</span>
<span class="gi">+def _lazy_sha1(string: bytes = b&quot;&quot;) -&gt; t.Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Don&#39;t access ``hashlib.sha1`` until runtime. FIPS builds may not include
<span class="w"> </span>    SHA-1, in which case the import and use as a default would fail before the
<span class="w"> </span>    developer can configure something else.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hashlib.sha1(string)</span>


<span class="w"> </span>class SecureCookieSessionInterface(SessionInterface):
<span class="w"> </span>    &quot;&quot;&quot;The default session interface that stores sessions in signed cookies
<span class="w"> </span>    through the :mod:`itsdangerous` module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    salt = &#39;cookie-session&#39;</span>
<span class="gi">+</span>
<span class="gi">+    #: the salt that should be applied on top of the secret key for the</span>
<span class="gi">+    #: signing of cookie based sessions.</span>
<span class="gi">+    salt = &quot;cookie-session&quot;</span>
<span class="gi">+    #: the hash function to use for the signature.  The default is sha1</span>
<span class="w"> </span>    digest_method = staticmethod(_lazy_sha1)
<span class="gd">-    key_derivation = &#39;hmac&#39;</span>
<span class="gi">+    #: the name of the itsdangerous supported key derivation.  The default</span>
<span class="gi">+    #: is hmac.</span>
<span class="gi">+    key_derivation = &quot;hmac&quot;</span>
<span class="gi">+    #: A python serializer for the payload.  The default is a compact</span>
<span class="gi">+    #: JSON derived serializer with support for some extra Python types</span>
<span class="gi">+    #: such as datetime objects or tuples.</span>
<span class="w"> </span>    serializer = session_json_serializer
<span class="w"> </span>    session_class = SecureCookieSession
<span class="gi">+</span>
<span class="gi">+    def get_signing_serializer(self, app: Flask) -&gt; URLSafeTimedSerializer | None:</span>
<span class="gi">+        if not app.secret_key:</span>
<span class="gi">+            return None</span>
<span class="gi">+        signer_kwargs = dict(</span>
<span class="gi">+            key_derivation=self.key_derivation, digest_method=self.digest_method</span>
<span class="gi">+        )</span>
<span class="gi">+        return URLSafeTimedSerializer(</span>
<span class="gi">+            app.secret_key,</span>
<span class="gi">+            salt=self.salt,</span>
<span class="gi">+            serializer=self.serializer,</span>
<span class="gi">+            signer_kwargs=signer_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def open_session(self, app: Flask, request: Request) -&gt; SecureCookieSession | None:</span>
<span class="gi">+        s = self.get_signing_serializer(app)</span>
<span class="gi">+        if s is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        val = request.cookies.get(self.get_cookie_name(app))</span>
<span class="gi">+        if not val:</span>
<span class="gi">+            return self.session_class()</span>
<span class="gi">+        max_age = int(app.permanent_session_lifetime.total_seconds())</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = s.loads(val, max_age=max_age)</span>
<span class="gi">+            return self.session_class(data)</span>
<span class="gi">+        except BadSignature:</span>
<span class="gi">+            return self.session_class()</span>
<span class="gi">+</span>
<span class="gi">+    def save_session(</span>
<span class="gi">+        self, app: Flask, session: SessionMixin, response: Response</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        name = self.get_cookie_name(app)</span>
<span class="gi">+        domain = self.get_cookie_domain(app)</span>
<span class="gi">+        path = self.get_cookie_path(app)</span>
<span class="gi">+        secure = self.get_cookie_secure(app)</span>
<span class="gi">+        samesite = self.get_cookie_samesite(app)</span>
<span class="gi">+        httponly = self.get_cookie_httponly(app)</span>
<span class="gi">+</span>
<span class="gi">+        # Add a &quot;Vary: Cookie&quot; header if the session was accessed at all.</span>
<span class="gi">+        if session.accessed:</span>
<span class="gi">+            response.vary.add(&quot;Cookie&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # If the session is modified to be empty, remove the cookie.</span>
<span class="gi">+        # If the session is empty, return without setting the cookie.</span>
<span class="gi">+        if not session:</span>
<span class="gi">+            if session.modified:</span>
<span class="gi">+                response.delete_cookie(</span>
<span class="gi">+                    name,</span>
<span class="gi">+                    domain=domain,</span>
<span class="gi">+                    path=path,</span>
<span class="gi">+                    secure=secure,</span>
<span class="gi">+                    samesite=samesite,</span>
<span class="gi">+                    httponly=httponly,</span>
<span class="gi">+                )</span>
<span class="gi">+                response.vary.add(&quot;Cookie&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not self.should_set_cookie(app, session):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        expires = self.get_expiration_time(app, session)</span>
<span class="gi">+        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore</span>
<span class="gi">+        response.set_cookie(</span>
<span class="gi">+            name,</span>
<span class="gi">+            val,  # type: ignore</span>
<span class="gi">+            expires=expires,</span>
<span class="gi">+            httponly=httponly,</span>
<span class="gi">+            domain=domain,</span>
<span class="gi">+            path=path,</span>
<span class="gi">+            secure=secure,</span>
<span class="gi">+            samesite=samesite,</span>
<span class="gi">+        )</span>
<span class="gi">+        response.vary.add(&quot;Cookie&quot;)</span>
<span class="gh">diff --git a/src/flask/signals.py b/src/flask/signals.py</span>
<span class="gh">index 140a1137..444fda99 100644</span>
<span class="gd">--- a/src/flask/signals.py</span>
<span class="gi">+++ b/src/flask/signals.py</span>
<span class="gu">@@ -1,13 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from blinker import Namespace
<span class="gi">+</span>
<span class="gi">+# This namespace is only for signals provided by Flask itself.</span>
<span class="w"> </span>_signals = Namespace()
<span class="gd">-template_rendered = _signals.signal(&#39;template-rendered&#39;)</span>
<span class="gd">-before_render_template = _signals.signal(&#39;before-render-template&#39;)</span>
<span class="gd">-request_started = _signals.signal(&#39;request-started&#39;)</span>
<span class="gd">-request_finished = _signals.signal(&#39;request-finished&#39;)</span>
<span class="gd">-request_tearing_down = _signals.signal(&#39;request-tearing-down&#39;)</span>
<span class="gd">-got_request_exception = _signals.signal(&#39;got-request-exception&#39;)</span>
<span class="gd">-appcontext_tearing_down = _signals.signal(&#39;appcontext-tearing-down&#39;)</span>
<span class="gd">-appcontext_pushed = _signals.signal(&#39;appcontext-pushed&#39;)</span>
<span class="gd">-appcontext_popped = _signals.signal(&#39;appcontext-popped&#39;)</span>
<span class="gd">-message_flashed = _signals.signal(&#39;message-flashed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+template_rendered = _signals.signal(&quot;template-rendered&quot;)</span>
<span class="gi">+before_render_template = _signals.signal(&quot;before-render-template&quot;)</span>
<span class="gi">+request_started = _signals.signal(&quot;request-started&quot;)</span>
<span class="gi">+request_finished = _signals.signal(&quot;request-finished&quot;)</span>
<span class="gi">+request_tearing_down = _signals.signal(&quot;request-tearing-down&quot;)</span>
<span class="gi">+got_request_exception = _signals.signal(&quot;got-request-exception&quot;)</span>
<span class="gi">+appcontext_tearing_down = _signals.signal(&quot;appcontext-tearing-down&quot;)</span>
<span class="gi">+appcontext_pushed = _signals.signal(&quot;appcontext-pushed&quot;)</span>
<span class="gi">+appcontext_popped = _signals.signal(&quot;appcontext-popped&quot;)</span>
<span class="gi">+message_flashed = _signals.signal(&quot;message-flashed&quot;)</span>
<span class="gh">diff --git a/src/flask/templating.py b/src/flask/templating.py</span>
<span class="gh">index 861e328e..618a3b35 100644</span>
<span class="gd">--- a/src/flask/templating.py</span>
<span class="gi">+++ b/src/flask/templating.py</span>
<span class="gu">@@ -1,9 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from jinja2 import BaseLoader
<span class="w"> </span>from jinja2 import Environment as BaseEnvironment
<span class="w"> </span>from jinja2 import Template
<span class="w"> </span>from jinja2 import TemplateNotFound
<span class="gi">+</span>
<span class="w"> </span>from .globals import _cv_app
<span class="w"> </span>from .globals import _cv_request
<span class="w"> </span>from .globals import current_app
<span class="gu">@@ -11,17 +14,26 @@ from .globals import request</span>
<span class="w"> </span>from .helpers import stream_with_context
<span class="w"> </span>from .signals import before_render_template
<span class="w"> </span>from .signals import template_rendered
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from .app import Flask
<span class="w"> </span>    from .sansio.app import App
<span class="w"> </span>    from .sansio.scaffold import Scaffold


<span class="gd">-def _default_template_ctx_processor() -&gt;dict[str, t.Any]:</span>
<span class="gi">+def _default_template_ctx_processor() -&gt; dict[str, t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Default template context processor.  Injects `request`,
<span class="w"> </span>    `session` and `g`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    appctx = _cv_app.get(None)</span>
<span class="gi">+    reqctx = _cv_request.get(None)</span>
<span class="gi">+    rv: dict[str, t.Any] = {}</span>
<span class="gi">+    if appctx is not None:</span>
<span class="gi">+        rv[&quot;g&quot;] = appctx.g</span>
<span class="gi">+    if reqctx is not None:</span>
<span class="gi">+        rv[&quot;request&quot;] = reqctx.request</span>
<span class="gi">+        rv[&quot;session&quot;] = reqctx.session</span>
<span class="gi">+    return rv</span>


<span class="w"> </span>class Environment(BaseEnvironment):
<span class="gu">@@ -30,9 +42,9 @@ class Environment(BaseEnvironment):</span>
<span class="w"> </span>    name of the blueprint to referenced templates if necessary.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: App, **options: t.Any) -&gt;None:</span>
<span class="gd">-        if &#39;loader&#39; not in options:</span>
<span class="gd">-            options[&#39;loader&#39;] = app.create_global_jinja_loader()</span>
<span class="gi">+    def __init__(self, app: App, **options: t.Any) -&gt; None:</span>
<span class="gi">+        if &quot;loader&quot; not in options:</span>
<span class="gi">+            options[&quot;loader&quot;] = app.create_global_jinja_loader()</span>
<span class="w"> </span>        BaseEnvironment.__init__(self, **options)
<span class="w"> </span>        self.app = app

<span class="gu">@@ -42,33 +54,141 @@ class DispatchingJinjaLoader(BaseLoader):</span>
<span class="w"> </span>    the blueprint folders.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: App) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: App) -&gt; None:</span>
<span class="w"> </span>        self.app = app

<span class="gd">-</span>
<span class="gd">-def render_template(template_name_or_list: (str | Template | list[str |</span>
<span class="gd">-    Template]), **context: t.Any) -&gt;str:</span>
<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: BaseEnvironment, template: str</span>
<span class="gi">+    ) -&gt; tuple[str, str | None, t.Callable[[], bool] | None]:</span>
<span class="gi">+        if self.app.config[&quot;EXPLAIN_TEMPLATE_LOADING&quot;]:</span>
<span class="gi">+            return self._get_source_explained(environment, template)</span>
<span class="gi">+        return self._get_source_fast(environment, template)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_source_explained(</span>
<span class="gi">+        self, environment: BaseEnvironment, template: str</span>
<span class="gi">+    ) -&gt; tuple[str, str | None, t.Callable[[], bool] | None]:</span>
<span class="gi">+        attempts = []</span>
<span class="gi">+        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None</span>
<span class="gi">+        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None</span>
<span class="gi">+</span>
<span class="gi">+        for srcobj, loader in self._iter_loaders(template):</span>
<span class="gi">+            try:</span>
<span class="gi">+                rv = loader.get_source(environment, template)</span>
<span class="gi">+                if trv is None:</span>
<span class="gi">+                    trv = rv</span>
<span class="gi">+            except TemplateNotFound:</span>
<span class="gi">+                rv = None</span>
<span class="gi">+            attempts.append((loader, srcobj, rv))</span>
<span class="gi">+</span>
<span class="gi">+        from .debughelpers import explain_template_loading_attempts</span>
<span class="gi">+</span>
<span class="gi">+        explain_template_loading_attempts(self.app, template, attempts)</span>
<span class="gi">+</span>
<span class="gi">+        if trv is not None:</span>
<span class="gi">+            return trv</span>
<span class="gi">+        raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_source_fast(</span>
<span class="gi">+        self, environment: BaseEnvironment, template: str</span>
<span class="gi">+    ) -&gt; tuple[str, str | None, t.Callable[[], bool] | None]:</span>
<span class="gi">+        for _srcobj, loader in self._iter_loaders(template):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return loader.get_source(environment, template)</span>
<span class="gi">+            except TemplateNotFound:</span>
<span class="gi">+                continue</span>
<span class="gi">+        raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+    def _iter_loaders(self, template: str) -&gt; t.Iterator[tuple[Scaffold, BaseLoader]]:</span>
<span class="gi">+        loader = self.app.jinja_loader</span>
<span class="gi">+        if loader is not None:</span>
<span class="gi">+            yield self.app, loader</span>
<span class="gi">+</span>
<span class="gi">+        for blueprint in self.app.iter_blueprints():</span>
<span class="gi">+            loader = blueprint.jinja_loader</span>
<span class="gi">+            if loader is not None:</span>
<span class="gi">+                yield blueprint, loader</span>
<span class="gi">+</span>
<span class="gi">+    def list_templates(self) -&gt; list[str]:</span>
<span class="gi">+        result = set()</span>
<span class="gi">+        loader = self.app.jinja_loader</span>
<span class="gi">+        if loader is not None:</span>
<span class="gi">+            result.update(loader.list_templates())</span>
<span class="gi">+</span>
<span class="gi">+        for blueprint in self.app.iter_blueprints():</span>
<span class="gi">+            loader = blueprint.jinja_loader</span>
<span class="gi">+            if loader is not None:</span>
<span class="gi">+                for template in loader.list_templates():</span>
<span class="gi">+                    result.add(template)</span>
<span class="gi">+</span>
<span class="gi">+        return list(result)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _render(app: Flask, template: Template, context: dict[str, t.Any]) -&gt; str:</span>
<span class="gi">+    app.update_template_context(context)</span>
<span class="gi">+    before_render_template.send(</span>
<span class="gi">+        app, _async_wrapper=app.ensure_sync, template=template, context=context</span>
<span class="gi">+    )</span>
<span class="gi">+    rv = template.render(context)</span>
<span class="gi">+    template_rendered.send(</span>
<span class="gi">+        app, _async_wrapper=app.ensure_sync, template=template, context=context</span>
<span class="gi">+    )</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def render_template(</span>
<span class="gi">+    template_name_or_list: str | Template | list[str | Template],</span>
<span class="gi">+    **context: t.Any,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Render a template by name with the given context.

<span class="w"> </span>    :param template_name_or_list: The name of the template to render. If
<span class="w"> </span>        a list is given, the first name to exist will be rendered.
<span class="w"> </span>    :param context: The variables to make available in the template.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = current_app._get_current_object()  # type: ignore[attr-defined]</span>
<span class="gi">+    template = app.jinja_env.get_or_select_template(template_name_or_list)</span>
<span class="gi">+    return _render(app, template, context)</span>


<span class="gd">-def render_template_string(source: str, **context: t.Any) -&gt;str:</span>
<span class="gi">+def render_template_string(source: str, **context: t.Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Render a template from the given source string with the given
<span class="w"> </span>    context.

<span class="w"> </span>    :param source: The source code of the template to render.
<span class="w"> </span>    :param context: The variables to make available in the template.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = current_app._get_current_object()  # type: ignore[attr-defined]</span>
<span class="gi">+    template = app.jinja_env.from_string(source)</span>
<span class="gi">+    return _render(app, template, context)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _stream(</span>
<span class="gi">+    app: Flask, template: Template, context: dict[str, t.Any]</span>
<span class="gi">+) -&gt; t.Iterator[str]:</span>
<span class="gi">+    app.update_template_context(context)</span>
<span class="gi">+    before_render_template.send(</span>
<span class="gi">+        app, _async_wrapper=app.ensure_sync, template=template, context=context</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def generate() -&gt; t.Iterator[str]:</span>
<span class="gi">+        yield from template.generate(context)</span>
<span class="gi">+        template_rendered.send(</span>
<span class="gi">+            app, _async_wrapper=app.ensure_sync, template=template, context=context</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    rv = generate()</span>
<span class="gi">+</span>
<span class="gi">+    # If a request context is active, keep it while generating.</span>
<span class="gi">+    if request:</span>
<span class="gi">+        rv = stream_with_context(rv)</span>
<span class="gi">+</span>
<span class="gi">+    return rv</span>


<span class="gd">-def stream_template(template_name_or_list: (str | Template | list[str |</span>
<span class="gd">-    Template]), **context: t.Any) -&gt;t.Iterator[str]:</span>
<span class="gi">+def stream_template(</span>
<span class="gi">+    template_name_or_list: str | Template | list[str | Template],</span>
<span class="gi">+    **context: t.Any,</span>
<span class="gi">+) -&gt; t.Iterator[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Render a template by name with the given context as a stream.
<span class="w"> </span>    This returns an iterator of strings, which can be used as a
<span class="w"> </span>    streaming response from a view.
<span class="gu">@@ -79,10 +199,12 @@ def stream_template(template_name_or_list: (str | Template | list[str |</span>

<span class="w"> </span>    .. versionadded:: 2.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = current_app._get_current_object()  # type: ignore[attr-defined]</span>
<span class="gi">+    template = app.jinja_env.get_or_select_template(template_name_or_list)</span>
<span class="gi">+    return _stream(app, template, context)</span>


<span class="gd">-def stream_template_string(source: str, **context: t.Any) -&gt;t.Iterator[str]:</span>
<span class="gi">+def stream_template_string(source: str, **context: t.Any) -&gt; t.Iterator[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Render a template from the given source string with the given
<span class="w"> </span>    context as a stream. This returns an iterator of strings, which can
<span class="w"> </span>    be used as a streaming response from a view.
<span class="gu">@@ -92,4 +214,6 @@ def stream_template_string(source: str, **context: t.Any) -&gt;t.Iterator[str]:</span>

<span class="w"> </span>    .. versionadded:: 2.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = current_app._get_current_object()  # type: ignore[attr-defined]</span>
<span class="gi">+    template = app.jinja_env.from_string(source)</span>
<span class="gi">+    return _stream(app, template, context)</span>
<span class="gh">diff --git a/src/flask/testing.py b/src/flask/testing.py</span>
<span class="gh">index 7c533f33..a27b7c8f 100644</span>
<span class="gd">--- a/src/flask/testing.py</span>
<span class="gi">+++ b/src/flask/testing.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import importlib.metadata
<span class="w"> </span>import typing as t
<span class="w"> </span>from contextlib import contextmanager
<span class="gu">@@ -6,15 +7,19 @@ from contextlib import ExitStack</span>
<span class="w"> </span>from copy import copy
<span class="w"> </span>from types import TracebackType
<span class="w"> </span>from urllib.parse import urlsplit
<span class="gi">+</span>
<span class="w"> </span>import werkzeug.test
<span class="w"> </span>from click.testing import CliRunner
<span class="w"> </span>from werkzeug.test import Client
<span class="w"> </span>from werkzeug.wrappers import Request as BaseRequest
<span class="gi">+</span>
<span class="w"> </span>from .cli import ScriptInfo
<span class="w"> </span>from .sessions import SessionMixin
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from _typeshed.wsgi import WSGIEnvironment
<span class="w"> </span>    from werkzeug.test import TestResponse
<span class="gi">+</span>
<span class="w"> </span>    from .app import Flask


<span class="gu">@@ -40,40 +45,65 @@ class EnvironBuilder(werkzeug.test.EnvironBuilder):</span>
<span class="w"> </span>        :class:`~werkzeug.test.EnvironBuilder`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Flask, path: str=&#39;/&#39;, base_url: (str | None)=</span>
<span class="gd">-        None, subdomain: (str | None)=None, url_scheme: (str | None)=None,</span>
<span class="gd">-        *args: t.Any, **kwargs: t.Any) -&gt;None:</span>
<span class="gd">-        assert not (base_url or subdomain or url_scheme) or (base_url is not</span>
<span class="gd">-            None) != bool(subdomain or url_scheme</span>
<span class="gd">-            ), &#39;Cannot pass &quot;subdomain&quot; or &quot;url_scheme&quot; with &quot;base_url&quot;.&#39;</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        app: Flask,</span>
<span class="gi">+        path: str = &quot;/&quot;,</span>
<span class="gi">+        base_url: str | None = None,</span>
<span class="gi">+        subdomain: str | None = None,</span>
<span class="gi">+        url_scheme: str | None = None,</span>
<span class="gi">+        *args: t.Any,</span>
<span class="gi">+        **kwargs: t.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert not (base_url or subdomain or url_scheme) or (</span>
<span class="gi">+            base_url is not None</span>
<span class="gi">+        ) != bool(</span>
<span class="gi">+            subdomain or url_scheme</span>
<span class="gi">+        ), &#39;Cannot pass &quot;subdomain&quot; or &quot;url_scheme&quot; with &quot;base_url&quot;.&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        if base_url is None:
<span class="gd">-            http_host = app.config.get(&#39;SERVER_NAME&#39;) or &#39;localhost&#39;</span>
<span class="gd">-            app_root = app.config[&#39;APPLICATION_ROOT&#39;]</span>
<span class="gi">+            http_host = app.config.get(&quot;SERVER_NAME&quot;) or &quot;localhost&quot;</span>
<span class="gi">+            app_root = app.config[&quot;APPLICATION_ROOT&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>            if subdomain:
<span class="gd">-                http_host = f&#39;{subdomain}.{http_host}&#39;</span>
<span class="gi">+                http_host = f&quot;{subdomain}.{http_host}&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>            if url_scheme is None:
<span class="gd">-                url_scheme = app.config[&#39;PREFERRED_URL_SCHEME&#39;]</span>
<span class="gi">+                url_scheme = app.config[&quot;PREFERRED_URL_SCHEME&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>            url = urlsplit(path)
<span class="w"> </span>            base_url = (
<span class="gd">-                f&quot;{url.scheme or url_scheme}://{url.netloc or http_host}/{app_root.lstrip(&#39;/&#39;)}&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;{url.scheme or url_scheme}://{url.netloc or http_host}&quot;</span>
<span class="gi">+                f&quot;/{app_root.lstrip(&#39;/&#39;)}&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>            path = url.path
<span class="gi">+</span>
<span class="w"> </span>            if url.query:
<span class="gd">-                sep = b&#39;?&#39; if isinstance(url.query, bytes) else &#39;?&#39;</span>
<span class="gi">+                sep = b&quot;?&quot; if isinstance(url.query, bytes) else &quot;?&quot;</span>
<span class="w"> </span>                path += sep + url.query
<span class="gi">+</span>
<span class="w"> </span>        self.app = app
<span class="w"> </span>        super().__init__(path, base_url, *args, **kwargs)

<span class="gd">-    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -&gt;str:</span>
<span class="gi">+    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -&gt; str:  # type: ignore</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize ``obj`` to a JSON-formatted string.

<span class="w"> </span>        The serialization will be configured according to the config associated
<span class="w"> </span>        with this EnvironBuilder&#39;s ``app``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.app.json.dumps(obj, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_werkzeug_version = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_werkzeug_version() -&gt; str:</span>
<span class="gi">+    global _werkzeug_version</span>

<span class="gi">+    if not _werkzeug_version:</span>
<span class="gi">+        _werkzeug_version = importlib.metadata.version(&quot;werkzeug&quot;)</span>

<span class="gd">-_werkzeug_version = &#39;&#39;</span>
<span class="gi">+    return _werkzeug_version</span>


<span class="w"> </span>class FlaskClient(Client):
<span class="gu">@@ -89,19 +119,23 @@ class FlaskClient(Client):</span>

<span class="w"> </span>    Basic usage is outlined in the :doc:`/testing` chapter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    application: Flask

<span class="gd">-    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.preserve_context = False
<span class="w"> </span>        self._new_contexts: list[t.ContextManager[t.Any]] = []
<span class="w"> </span>        self._context_stack = ExitStack()
<span class="gd">-        self.environ_base = {&#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;HTTP_USER_AGENT&#39;:</span>
<span class="gd">-            f&#39;Werkzeug/{_get_werkzeug_version()}&#39;}</span>
<span class="gi">+        self.environ_base = {</span>
<span class="gi">+            &quot;REMOTE_ADDR&quot;: &quot;127.0.0.1&quot;,</span>
<span class="gi">+            &quot;HTTP_USER_AGENT&quot;: f&quot;Werkzeug/{_get_werkzeug_version()}&quot;,</span>
<span class="gi">+        }</span>

<span class="w"> </span>    @contextmanager
<span class="gd">-    def session_transaction(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Iterator[</span>
<span class="gd">-        SessionMixin]:</span>
<span class="gi">+    def session_transaction(</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Iterator[SessionMixin]:</span>
<span class="w"> </span>        &quot;&quot;&quot;When used in combination with a ``with`` statement this opens a
<span class="w"> </span>        session transaction.  This can be used to modify the session that
<span class="w"> </span>        the test client uses.  Once the ``with`` block is left the session is
<span class="gu">@@ -118,16 +152,112 @@ class FlaskClient(Client):</span>
<span class="w"> </span>        :meth:`~flask.Flask.test_request_context` which are directly
<span class="w"> </span>        passed through.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._cookies is None:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Cookies are disabled. Create a client with &#39;use_cookies=True&#39;.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        app = self.application</span>
<span class="gi">+        ctx = app.test_request_context(*args, **kwargs)</span>
<span class="gi">+        self._add_cookies_to_wsgi(ctx.request.environ)</span>
<span class="gi">+</span>
<span class="gi">+        with ctx:</span>
<span class="gi">+            sess = app.session_interface.open_session(app, ctx.request)</span>
<span class="gi">+</span>
<span class="gi">+        if sess is None:</span>
<span class="gi">+            raise RuntimeError(&quot;Session backend did not open a session.&quot;)</span>

<span class="gd">-    def __enter__(self) -&gt;FlaskClient:</span>
<span class="gi">+        yield sess</span>
<span class="gi">+        resp = app.response_class()</span>
<span class="gi">+</span>
<span class="gi">+        if app.session_interface.is_null_session(sess):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        with ctx:</span>
<span class="gi">+            app.session_interface.save_session(app, sess, resp)</span>
<span class="gi">+</span>
<span class="gi">+        self._update_cookies_from_response(</span>
<span class="gi">+            ctx.request.host.partition(&quot;:&quot;)[0],</span>
<span class="gi">+            ctx.request.path,</span>
<span class="gi">+            resp.headers.getlist(&quot;Set-Cookie&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _copy_environ(self, other: WSGIEnvironment) -&gt; WSGIEnvironment:</span>
<span class="gi">+        out = {**self.environ_base, **other}</span>
<span class="gi">+</span>
<span class="gi">+        if self.preserve_context:</span>
<span class="gi">+            out[&quot;werkzeug.debug.preserve_context&quot;] = self._new_contexts.append</span>
<span class="gi">+</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def _request_from_builder_args(</span>
<span class="gi">+        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]</span>
<span class="gi">+    ) -&gt; BaseRequest:</span>
<span class="gi">+        kwargs[&quot;environ_base&quot;] = self._copy_environ(kwargs.get(&quot;environ_base&quot;, {}))</span>
<span class="gi">+        builder = EnvironBuilder(self.application, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return builder.get_request()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            builder.close()</span>
<span class="gi">+</span>
<span class="gi">+    def open(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *args: t.Any,</span>
<span class="gi">+        buffered: bool = False,</span>
<span class="gi">+        follow_redirects: bool = False,</span>
<span class="gi">+        **kwargs: t.Any,</span>
<span class="gi">+    ) -&gt; TestResponse:</span>
<span class="gi">+        if args and isinstance(</span>
<span class="gi">+            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)</span>
<span class="gi">+        ):</span>
<span class="gi">+            if isinstance(args[0], werkzeug.test.EnvironBuilder):</span>
<span class="gi">+                builder = copy(args[0])</span>
<span class="gi">+                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]</span>
<span class="gi">+                request = builder.get_request()</span>
<span class="gi">+            elif isinstance(args[0], dict):</span>
<span class="gi">+                request = EnvironBuilder.from_environ(</span>
<span class="gi">+                    args[0], app=self.application, environ_base=self._copy_environ({})</span>
<span class="gi">+                ).get_request()</span>
<span class="gi">+            else:</span>
<span class="gi">+                # isinstance(args[0], BaseRequest)</span>
<span class="gi">+                request = copy(args[0])</span>
<span class="gi">+                request.environ = self._copy_environ(request.environ)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # request is None</span>
<span class="gi">+            request = self._request_from_builder_args(args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Pop any previously preserved contexts. This prevents contexts</span>
<span class="gi">+        # from being preserved across redirects or multiple requests</span>
<span class="gi">+        # within a single block.</span>
<span class="gi">+        self._context_stack.close()</span>
<span class="gi">+</span>
<span class="gi">+        response = super().open(</span>
<span class="gi">+            request,</span>
<span class="gi">+            buffered=buffered,</span>
<span class="gi">+            follow_redirects=follow_redirects,</span>
<span class="gi">+        )</span>
<span class="gi">+        response.json_module = self.application.json  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+        # Re-push contexts that were preserved during the request.</span>
<span class="gi">+        while self._new_contexts:</span>
<span class="gi">+            cm = self._new_contexts.pop()</span>
<span class="gi">+            self._context_stack.enter_context(cm)</span>
<span class="gi">+</span>
<span class="gi">+        return response</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; FlaskClient:</span>
<span class="w"> </span>        if self.preserve_context:
<span class="gd">-            raise RuntimeError(&#39;Cannot nest client invocations&#39;)</span>
<span class="gi">+            raise RuntimeError(&quot;Cannot nest client invocations&quot;)</span>
<span class="w"> </span>        self.preserve_context = True
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: (type | None), exc_value: (BaseException |</span>
<span class="gd">-        None), tb: (TracebackType | None)) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: type | None,</span>
<span class="gi">+        exc_value: BaseException | None,</span>
<span class="gi">+        tb: TracebackType | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.preserve_context = False
<span class="w"> </span>        self._context_stack.close()

<span class="gu">@@ -138,12 +268,13 @@ class FlaskCliRunner(CliRunner):</span>
<span class="w"> </span>    :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Flask, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Flask, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        self.app = app
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gd">-    def invoke(self, cli: t.Any=None, args: t.Any=None, **kwargs: t.Any</span>
<span class="gd">-        ) -&gt;t.Any:</span>
<span class="gi">+    def invoke(  # type: ignore</span>
<span class="gi">+        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invokes a CLI command in an isolated environment. See
<span class="w"> </span>        :meth:`CliRunner.invoke &lt;click.testing.CliRunner.invoke&gt;` for
<span class="w"> </span>        full method documentation. See :ref:`testing-cli` for examples.
<span class="gu">@@ -158,4 +289,10 @@ class FlaskCliRunner(CliRunner):</span>

<span class="w"> </span>        :return: a :class:`~click.testing.Result` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cli is None:</span>
<span class="gi">+            cli = self.app.cli</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;obj&quot; not in kwargs:</span>
<span class="gi">+            kwargs[&quot;obj&quot;] = ScriptInfo(create_app=lambda: self.app)</span>
<span class="gi">+</span>
<span class="gi">+        return super().invoke(cli, args, **kwargs)</span>
<span class="gh">diff --git a/src/flask/typing.py b/src/flask/typing.py</span>
<span class="gh">index cc21de38..cf6d4ae6 100644</span>
<span class="gd">--- a/src/flask/typing.py</span>
<span class="gi">+++ b/src/flask/typing.py</span>
<span class="gu">@@ -1,38 +1,90 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gd">-    from _typeshed.wsgi import WSGIApplication</span>
<span class="gd">-    from werkzeug.datastructures import Headers</span>
<span class="gd">-    from werkzeug.sansio.response import Response</span>
<span class="gd">-ResponseValue = t.Union[&#39;Response&#39;, str, bytes, t.List[t.Any], t.Mapping[</span>
<span class="gd">-    str, t.Any], t.Iterator[str], t.Iterator[bytes]]</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="gi">+    from _typeshed.wsgi import WSGIApplication  # noqa: F401</span>
<span class="gi">+    from werkzeug.datastructures import Headers  # noqa: F401</span>
<span class="gi">+    from werkzeug.sansio.response import Response  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+# The possible types that are directly convertible or are a Response object.</span>
<span class="gi">+ResponseValue = t.Union[</span>
<span class="gi">+    &quot;Response&quot;,</span>
<span class="gi">+    str,</span>
<span class="gi">+    bytes,</span>
<span class="gi">+    t.List[t.Any],</span>
<span class="gi">+    # Only dict is actually accepted, but Mapping allows for TypedDict.</span>
<span class="gi">+    t.Mapping[str, t.Any],</span>
<span class="gi">+    t.Iterator[str],</span>
<span class="gi">+    t.Iterator[bytes],</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# the possible types for an individual HTTP header</span>
<span class="gi">+# This should be a Union, but mypy doesn&#39;t pass unless it&#39;s a TypeVar.</span>
<span class="w"> </span>HeaderValue = t.Union[str, t.List[str], t.Tuple[str, ...]]
<span class="gd">-HeadersValue = t.Union[&#39;Headers&#39;, t.Mapping[str, HeaderValue], t.Sequence[t</span>
<span class="gd">-    .Tuple[str, HeaderValue]]]</span>
<span class="gd">-ResponseReturnValue = t.Union[ResponseValue, t.Tuple[ResponseValue,</span>
<span class="gd">-    HeadersValue], t.Tuple[ResponseValue, int], t.Tuple[ResponseValue, int,</span>
<span class="gd">-    HeadersValue], &#39;WSGIApplication&#39;]</span>
<span class="gd">-ResponseClass = t.TypeVar(&#39;ResponseClass&#39;, bound=&#39;Response&#39;)</span>
<span class="gd">-AppOrBlueprintKey = t.Optional[str]</span>
<span class="gd">-AfterRequestCallable = t.Union[t.Callable[[ResponseClass], ResponseClass],</span>
<span class="gd">-    t.Callable[[ResponseClass], t.Awaitable[ResponseClass]]]</span>
<span class="gd">-BeforeFirstRequestCallable = t.Union[t.Callable[[], None], t.Callable[[], t</span>
<span class="gd">-    .Awaitable[None]]]</span>
<span class="gd">-BeforeRequestCallable = t.Union[t.Callable[[], t.Optional[</span>
<span class="gd">-    ResponseReturnValue]], t.Callable[[], t.Awaitable[t.Optional[</span>
<span class="gd">-    ResponseReturnValue]]]]</span>
<span class="gi">+</span>
<span class="gi">+# the possible types for HTTP headers</span>
<span class="gi">+HeadersValue = t.Union[</span>
<span class="gi">+    &quot;Headers&quot;,</span>
<span class="gi">+    t.Mapping[str, HeaderValue],</span>
<span class="gi">+    t.Sequence[t.Tuple[str, HeaderValue]],</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# The possible types returned by a route function.</span>
<span class="gi">+ResponseReturnValue = t.Union[</span>
<span class="gi">+    ResponseValue,</span>
<span class="gi">+    t.Tuple[ResponseValue, HeadersValue],</span>
<span class="gi">+    t.Tuple[ResponseValue, int],</span>
<span class="gi">+    t.Tuple[ResponseValue, int, HeadersValue],</span>
<span class="gi">+    &quot;WSGIApplication&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# Allow any subclass of werkzeug.Response, such as the one from Flask,</span>
<span class="gi">+# as a callback argument. Using werkzeug.Response directly makes a</span>
<span class="gi">+# callback annotated with flask.Response fail type checking.</span>
<span class="gi">+ResponseClass = t.TypeVar(&quot;ResponseClass&quot;, bound=&quot;Response&quot;)</span>
<span class="gi">+</span>
<span class="gi">+AppOrBlueprintKey = t.Optional[str]  # The App key is None, whereas blueprints are named</span>
<span class="gi">+AfterRequestCallable = t.Union[</span>
<span class="gi">+    t.Callable[[ResponseClass], ResponseClass],</span>
<span class="gi">+    t.Callable[[ResponseClass], t.Awaitable[ResponseClass]],</span>
<span class="gi">+]</span>
<span class="gi">+BeforeFirstRequestCallable = t.Union[</span>
<span class="gi">+    t.Callable[[], None], t.Callable[[], t.Awaitable[None]]</span>
<span class="gi">+]</span>
<span class="gi">+BeforeRequestCallable = t.Union[</span>
<span class="gi">+    t.Callable[[], t.Optional[ResponseReturnValue]],</span>
<span class="gi">+    t.Callable[[], t.Awaitable[t.Optional[ResponseReturnValue]]],</span>
<span class="gi">+]</span>
<span class="w"> </span>ShellContextProcessorCallable = t.Callable[[], t.Dict[str, t.Any]]
<span class="gd">-TeardownCallable = t.Union[t.Callable[[t.Optional[BaseException]], None], t</span>
<span class="gd">-    .Callable[[t.Optional[BaseException]], t.Awaitable[None]]]</span>
<span class="gd">-TemplateContextProcessorCallable = t.Union[t.Callable[[], t.Dict[str, t.Any</span>
<span class="gd">-    ]], t.Callable[[], t.Awaitable[t.Dict[str, t.Any]]]]</span>
<span class="gi">+TeardownCallable = t.Union[</span>
<span class="gi">+    t.Callable[[t.Optional[BaseException]], None],</span>
<span class="gi">+    t.Callable[[t.Optional[BaseException]], t.Awaitable[None]],</span>
<span class="gi">+]</span>
<span class="gi">+TemplateContextProcessorCallable = t.Union[</span>
<span class="gi">+    t.Callable[[], t.Dict[str, t.Any]],</span>
<span class="gi">+    t.Callable[[], t.Awaitable[t.Dict[str, t.Any]]],</span>
<span class="gi">+]</span>
<span class="w"> </span>TemplateFilterCallable = t.Callable[..., t.Any]
<span class="w"> </span>TemplateGlobalCallable = t.Callable[..., t.Any]
<span class="w"> </span>TemplateTestCallable = t.Callable[..., bool]
<span class="w"> </span>URLDefaultCallable = t.Callable[[str, t.Dict[str, t.Any]], None]
<span class="gd">-URLValuePreprocessorCallable = t.Callable[[t.Optional[str], t.Optional[t.</span>
<span class="gd">-    Dict[str, t.Any]]], None]</span>
<span class="gd">-ErrorHandlerCallable = t.Union[t.Callable[[t.Any], ResponseReturnValue], t.</span>
<span class="gd">-    Callable[[t.Any], t.Awaitable[ResponseReturnValue]]]</span>
<span class="gd">-RouteCallable = t.Union[t.Callable[..., ResponseReturnValue], t.Callable[</span>
<span class="gd">-    ..., t.Awaitable[ResponseReturnValue]]]</span>
<span class="gi">+URLValuePreprocessorCallable = t.Callable[</span>
<span class="gi">+    [t.Optional[str], t.Optional[t.Dict[str, t.Any]]], None</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# This should take Exception, but that either breaks typing the argument</span>
<span class="gi">+# with a specific exception, or decorating multiple times with different</span>
<span class="gi">+# exceptions (and using a union type on the argument).</span>
<span class="gi">+# https://github.com/pallets/flask/issues/4095</span>
<span class="gi">+# https://github.com/pallets/flask/issues/4295</span>
<span class="gi">+# https://github.com/pallets/flask/issues/4297</span>
<span class="gi">+ErrorHandlerCallable = t.Union[</span>
<span class="gi">+    t.Callable[[t.Any], ResponseReturnValue],</span>
<span class="gi">+    t.Callable[[t.Any], t.Awaitable[ResponseReturnValue]],</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+RouteCallable = t.Union[</span>
<span class="gi">+    t.Callable[..., ResponseReturnValue],</span>
<span class="gi">+    t.Callable[..., t.Awaitable[ResponseReturnValue]],</span>
<span class="gi">+]</span>
<span class="gh">diff --git a/src/flask/views.py b/src/flask/views.py</span>
<span class="gh">index 25272f32..794fdc06 100644</span>
<span class="gd">--- a/src/flask/views.py</span>
<span class="gi">+++ b/src/flask/views.py</span>
<span class="gu">@@ -1,11 +1,16 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from . import typing as ft
<span class="w"> </span>from .globals import current_app
<span class="w"> </span>from .globals import request
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gd">-http_method_funcs = frozenset([&#39;get&#39;, &#39;post&#39;, &#39;head&#39;, &#39;options&#39;, &#39;delete&#39;,</span>
<span class="gd">-    &#39;put&#39;, &#39;trace&#39;, &#39;patch&#39;])</span>
<span class="gi">+</span>
<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+</span>
<span class="gi">+http_method_funcs = frozenset(</span>
<span class="gi">+    [&quot;get&quot;, &quot;post&quot;, &quot;head&quot;, &quot;options&quot;, &quot;delete&quot;, &quot;put&quot;, &quot;trace&quot;, &quot;patch&quot;]</span>
<span class="gi">+)</span>


<span class="w"> </span>class View:
<span class="gu">@@ -39,21 +44,48 @@ class View:</span>
<span class="w"> </span>    Set :attr:`init_every_request` to ``False`` for efficiency, unless
<span class="w"> </span>    you need to store request-global data on ``self``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: The methods this view is registered for. Uses the same default</span>
<span class="gi">+    #: (``[&quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;]``) as ``route`` and</span>
<span class="gi">+    #: ``add_url_rule`` by default.</span>
<span class="w"> </span>    methods: t.ClassVar[t.Collection[str] | None] = None
<span class="gi">+</span>
<span class="gi">+    #: Control whether the ``OPTIONS`` method is handled automatically.</span>
<span class="gi">+    #: Uses the same default (``True``) as ``route`` and</span>
<span class="gi">+    #: ``add_url_rule`` by default.</span>
<span class="w"> </span>    provide_automatic_options: t.ClassVar[bool | None] = None
<span class="gi">+</span>
<span class="gi">+    #: A list of decorators to apply, in order, to the generated view</span>
<span class="gi">+    #: function. Remember that ``@decorator`` syntax is applied bottom</span>
<span class="gi">+    #: to top, so the first decorator in the list would be the bottom</span>
<span class="gi">+    #: decorator.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.8</span>
<span class="w"> </span>    decorators: t.ClassVar[list[t.Callable[[F], F]]] = []
<span class="gi">+</span>
<span class="gi">+    #: Create a new instance of this view class for every request by</span>
<span class="gi">+    #: default. If a view subclass sets this to ``False``, the same</span>
<span class="gi">+    #: instance is used for every request.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: A single instance is more efficient, especially if complex setup</span>
<span class="gi">+    #: is done during init. However, storing data on ``self`` is no</span>
<span class="gi">+    #: longer safe across requests, and :data:`~flask.g` should be used</span>
<span class="gi">+    #: instead.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 2.2</span>
<span class="w"> </span>    init_every_request: t.ClassVar[bool] = True

<span class="gd">-    def dispatch_request(self) -&gt;ft.ResponseReturnValue:</span>
<span class="gi">+    def dispatch_request(self) -&gt; ft.ResponseReturnValue:</span>
<span class="w"> </span>        &quot;&quot;&quot;The actual view function behavior. Subclasses must override
<span class="w"> </span>        this and return a valid response. Any variables from the URL
<span class="w"> </span>        rule are passed as keyword arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def as_view(cls, name: str, *class_args: t.Any, **class_kwargs: t.Any</span>
<span class="gd">-        ) -&gt;ft.RouteCallable:</span>
<span class="gi">+    def as_view(</span>
<span class="gi">+        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any</span>
<span class="gi">+    ) -&gt; ft.RouteCallable:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the class into a view function that can be registered
<span class="w"> </span>        for a route.

<span class="gu">@@ -69,7 +101,38 @@ class View:</span>
<span class="w"> </span>        .. versionchanged:: 2.2
<span class="w"> </span>            Added the ``init_every_request`` class attribute.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cls.init_every_request:</span>
<span class="gi">+</span>
<span class="gi">+            def view(**kwargs: t.Any) -&gt; ft.ResponseReturnValue:</span>
<span class="gi">+                self = view.view_class(  # type: ignore[attr-defined]</span>
<span class="gi">+                    *class_args, **class_kwargs</span>
<span class="gi">+                )</span>
<span class="gi">+                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            self = cls(*class_args, **class_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            def view(**kwargs: t.Any) -&gt; ft.ResponseReturnValue:</span>
<span class="gi">+                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+        if cls.decorators:</span>
<span class="gi">+            view.__name__ = name</span>
<span class="gi">+            view.__module__ = cls.__module__</span>
<span class="gi">+            for decorator in cls.decorators:</span>
<span class="gi">+                view = decorator(view)</span>
<span class="gi">+</span>
<span class="gi">+        # We attach the view class to the view function for two reasons:</span>
<span class="gi">+        # first of all it allows us to easily figure out what class-based</span>
<span class="gi">+        # view this thing came from, secondly it&#39;s also used for instantiating</span>
<span class="gi">+        # the view class so you can actually replace it with something else</span>
<span class="gi">+        # for testing purposes and debugging.</span>
<span class="gi">+        view.view_class = cls  # type: ignore</span>
<span class="gi">+        view.__name__ = name</span>
<span class="gi">+        view.__doc__ = cls.__doc__</span>
<span class="gi">+        view.__module__ = cls.__module__</span>
<span class="gi">+        view.methods = cls.methods  # type: ignore</span>
<span class="gi">+        view.provide_automatic_options = cls.provide_automatic_options  # type: ignore</span>
<span class="gi">+        return view</span>


<span class="w"> </span>class MethodView(View):
<span class="gu">@@ -99,15 +162,30 @@ class MethodView(View):</span>
<span class="w"> </span>        )
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init_subclass__(cls, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def __init_subclass__(cls, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        super().__init_subclass__(**kwargs)
<span class="gd">-        if &#39;methods&#39; not in cls.__dict__:</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;methods&quot; not in cls.__dict__:</span>
<span class="w"> </span>            methods = set()
<span class="gi">+</span>
<span class="w"> </span>            for base in cls.__bases__:
<span class="gd">-                if getattr(base, &#39;methods&#39;, None):</span>
<span class="gd">-                    methods.update(base.methods)</span>
<span class="gi">+                if getattr(base, &quot;methods&quot;, None):</span>
<span class="gi">+                    methods.update(base.methods)  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="w"> </span>            for key in http_method_funcs:
<span class="w"> </span>                if hasattr(cls, key):
<span class="w"> </span>                    methods.add(key.upper())
<span class="gi">+</span>
<span class="w"> </span>            if methods:
<span class="w"> </span>                cls.methods = methods
<span class="gi">+</span>
<span class="gi">+    def dispatch_request(self, **kwargs: t.Any) -&gt; ft.ResponseReturnValue:</span>
<span class="gi">+        meth = getattr(self, request.method.lower(), None)</span>
<span class="gi">+</span>
<span class="gi">+        # If the request method is HEAD and we don&#39;t have a handler for it</span>
<span class="gi">+        # retry with GET.</span>
<span class="gi">+        if meth is None and request.method == &quot;HEAD&quot;:</span>
<span class="gi">+            meth = getattr(self, &quot;get&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        assert meth is not None, f&quot;Unimplemented method {request.method!r}&quot;</span>
<span class="gi">+        return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]</span>
<span class="gh">diff --git a/src/flask/wrappers.py b/src/flask/wrappers.py</span>
<span class="gh">index e086f271..c1eca807 100644</span>
<span class="gd">--- a/src/flask/wrappers.py</span>
<span class="gi">+++ b/src/flask/wrappers.py</span>
<span class="gu">@@ -1,13 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from werkzeug.exceptions import BadRequest
<span class="w"> </span>from werkzeug.exceptions import HTTPException
<span class="w"> </span>from werkzeug.wrappers import Request as RequestBase
<span class="w"> </span>from werkzeug.wrappers import Response as ResponseBase
<span class="gi">+</span>
<span class="w"> </span>from . import json
<span class="w"> </span>from .globals import current_app
<span class="w"> </span>from .helpers import _split_blueprint_path
<span class="gd">-if t.TYPE_CHECKING:</span>
<span class="gi">+</span>
<span class="gi">+if t.TYPE_CHECKING:  # pragma: no cover</span>
<span class="w"> </span>    from werkzeug.routing import Rule


<span class="gu">@@ -23,18 +27,41 @@ class Request(RequestBase):</span>
<span class="w"> </span>    provides all of the attributes Werkzeug defines plus a few Flask
<span class="w"> </span>    specific ones.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    json_module: t.Any = json
<span class="gi">+</span>
<span class="gi">+    #: The internal URL rule that matched the request.  This can be</span>
<span class="gi">+    #: useful to inspect which methods are allowed for the URL from</span>
<span class="gi">+    #: a before/after handler (``request.url_rule.methods``) etc.</span>
<span class="gi">+    #: Though if the request&#39;s method was invalid for the URL rule,</span>
<span class="gi">+    #: the valid list is available in ``routing_exception.valid_methods``</span>
<span class="gi">+    #: instead (an attribute of the Werkzeug exception</span>
<span class="gi">+    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)</span>
<span class="gi">+    #: because the request was never internally bound.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 0.6</span>
<span class="w"> </span>    url_rule: Rule | None = None
<span class="gi">+</span>
<span class="gi">+    #: A dict of view arguments that matched the request.  If an exception</span>
<span class="gi">+    #: happened when matching, this will be ``None``.</span>
<span class="w"> </span>    view_args: dict[str, t.Any] | None = None
<span class="gi">+</span>
<span class="gi">+    #: If matching the URL failed, this is the exception that will be</span>
<span class="gi">+    #: raised / was raised as part of the request handling.  This is</span>
<span class="gi">+    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or</span>
<span class="gi">+    #: something similar.</span>
<span class="w"> </span>    routing_exception: HTTPException | None = None

<span class="w"> </span>    @property
<span class="gd">-    def max_content_length(self) -&gt;(int | None):</span>
<span class="gi">+    def max_content_length(self) -&gt; int | None:  # type: ignore[override]</span>
<span class="w"> </span>        &quot;&quot;&quot;Read-only view of the ``MAX_CONTENT_LENGTH`` config key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if current_app:</span>
<span class="gi">+            return current_app.config[&quot;MAX_CONTENT_LENGTH&quot;]  # type: ignore[no-any-return]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    @property
<span class="gd">-    def endpoint(self) -&gt;(str | None):</span>
<span class="gi">+    def endpoint(self) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The endpoint that matched the request URL.

<span class="w"> </span>        This will be ``None`` if matching failed or has not been
<span class="gu">@@ -43,10 +70,13 @@ class Request(RequestBase):</span>
<span class="w"> </span>        This in combination with :attr:`view_args` can be used to
<span class="w"> </span>        reconstruct the same URL or a modified URL.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.url_rule is not None:</span>
<span class="gi">+            return self.url_rule.endpoint</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="gd">-    def blueprint(self) -&gt;(str | None):</span>
<span class="gi">+    def blueprint(self) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The registered name of the current blueprint.

<span class="w"> </span>        This will be ``None`` if the endpoint is not part of a
<span class="gu">@@ -57,10 +87,15 @@ class Request(RequestBase):</span>
<span class="w"> </span>        created with. It may have been nested, or registered with a
<span class="w"> </span>        different name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        endpoint = self.endpoint</span>
<span class="gi">+</span>
<span class="gi">+        if endpoint is not None and &quot;.&quot; in endpoint:</span>
<span class="gi">+            return endpoint.rpartition(&quot;.&quot;)[0]</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="gd">-    def blueprints(self) -&gt;list[str]:</span>
<span class="gi">+    def blueprints(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The registered names of the current blueprint upwards through
<span class="w"> </span>        parent blueprints.

<span class="gu">@@ -69,7 +104,36 @@ class Request(RequestBase):</span>

<span class="w"> </span>        .. versionadded:: 2.0.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = self.blueprint</span>
<span class="gi">+</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        return _split_blueprint_path(name)</span>
<span class="gi">+</span>
<span class="gi">+    def _load_form_data(self) -&gt; None:</span>
<span class="gi">+        super()._load_form_data()</span>
<span class="gi">+</span>
<span class="gi">+        # In debug mode we&#39;re replacing the files multidict with an ad-hoc</span>
<span class="gi">+        # subclass that raises a different error for key errors.</span>
<span class="gi">+        if (</span>
<span class="gi">+            current_app</span>
<span class="gi">+            and current_app.debug</span>
<span class="gi">+            and self.mimetype != &quot;multipart/form-data&quot;</span>
<span class="gi">+            and not self.files</span>
<span class="gi">+        ):</span>
<span class="gi">+            from .debughelpers import attach_enctype_error_multidict</span>
<span class="gi">+</span>
<span class="gi">+            attach_enctype_error_multidict(self)</span>
<span class="gi">+</span>
<span class="gi">+    def on_json_loading_failed(self, e: ValueError | None) -&gt; t.Any:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return super().on_json_loading_failed(e)</span>
<span class="gi">+        except BadRequest as e:</span>
<span class="gi">+            if current_app and current_app.debug:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            raise BadRequest() from e</span>


<span class="w"> </span>class Response(ResponseBase):
<span class="gu">@@ -89,15 +153,22 @@ class Response(ResponseBase):</span>

<span class="w"> </span>        Added :attr:`max_cookie_size`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_mimetype: str | None = &#39;text/html&#39;</span>
<span class="gi">+</span>
<span class="gi">+    default_mimetype: str | None = &quot;text/html&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    json_module = json
<span class="gi">+</span>
<span class="w"> </span>    autocorrect_location_header = False

<span class="w"> </span>    @property
<span class="gd">-    def max_cookie_size(self) -&gt;int:</span>
<span class="gi">+    def max_cookie_size(self) -&gt; int:  # type: ignore</span>
<span class="w"> </span>        &quot;&quot;&quot;Read-only view of the :data:`MAX_COOKIE_SIZE` config key.

<span class="w"> </span>        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in
<span class="w"> </span>        Werkzeug&#39;s docs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if current_app:</span>
<span class="gi">+            return current_app.config[&quot;MAX_COOKIE_SIZE&quot;]  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+        # return Werkzeug&#39;s default when not in an app context</span>
<span class="gi">+        return super().max_cookie_size</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>