
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference paramiko - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-paramiko" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference paramiko
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-paramiko"><strong>Reference (Gold)</strong>: paramiko</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">557</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">21</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">578</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">578</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/paramiko/_version.py b/paramiko/_version.py</span>
<span class="gh">index 9890fe29..65688cab 100644</span>
<span class="gd">--- a/paramiko/_version.py</span>
<span class="gi">+++ b/paramiko/_version.py</span>
<span class="gu">@@ -1,2 +1,2 @@</span>
<span class="gd">-__version_info__ = 3, 4, 1</span>
<span class="gd">-__version__ = &#39;.&#39;.join(map(str, __version_info__))</span>
<span class="gi">+__version_info__ = (3, 4, 1)</span>
<span class="gi">+__version__ = &quot;.&quot;.join(map(str, __version_info__))</span>
<span class="gh">diff --git a/paramiko/_winapi.py b/paramiko/_winapi.py</span>
<span class="gh">index f02b3c7d..42954574 100644</span>
<span class="gd">--- a/paramiko/_winapi.py</span>
<span class="gi">+++ b/paramiko/_winapi.py</span>
<span class="gu">@@ -5,17 +5,51 @@ in jaraco.windows (3.4.1).</span>
<span class="w"> </span>If you encounter issues with this module, please consider reporting the issues
<span class="w"> </span>in jaraco.windows and asking the author to port the fixes back here.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import builtins
<span class="w"> </span>import ctypes.wintypes
<span class="gi">+</span>
<span class="w"> </span>from paramiko.util import u


<span class="gi">+######################</span>
<span class="gi">+# jaraco.windows.error</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def format_system_message(errno):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Call FormatMessage with a system error number to retrieve
<span class="w"> </span>    the descriptive error message.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # first some flags used by FormatMessageW</span>
<span class="gi">+    ALLOCATE_BUFFER = 0x100</span>
<span class="gi">+    FROM_SYSTEM = 0x1000</span>
<span class="gi">+</span>
<span class="gi">+    # Let FormatMessageW allocate the buffer (we&#39;ll free it below)</span>
<span class="gi">+    # Also, let it know we want a system error message.</span>
<span class="gi">+    flags = ALLOCATE_BUFFER | FROM_SYSTEM</span>
<span class="gi">+    source = None</span>
<span class="gi">+    message_id = errno</span>
<span class="gi">+    language_id = 0</span>
<span class="gi">+    result_buffer = ctypes.wintypes.LPWSTR()</span>
<span class="gi">+    buffer_size = 0</span>
<span class="gi">+    arguments = None</span>
<span class="gi">+    bytes = ctypes.windll.kernel32.FormatMessageW(</span>
<span class="gi">+        flags,</span>
<span class="gi">+        source,</span>
<span class="gi">+        message_id,</span>
<span class="gi">+        language_id,</span>
<span class="gi">+        ctypes.byref(result_buffer),</span>
<span class="gi">+        buffer_size,</span>
<span class="gi">+        arguments,</span>
<span class="gi">+    )</span>
<span class="gi">+    # note the following will cause an infinite loop if GetLastError</span>
<span class="gi">+    #  repeatedly returns an error that cannot be formatted, although</span>
<span class="gi">+    #  this should not happen.</span>
<span class="gi">+    handle_nonzero_success(bytes)</span>
<span class="gi">+    message = result_buffer.value</span>
<span class="gi">+    ctypes.windll.kernel32.LocalFree(result_buffer)</span>
<span class="gi">+    return message</span>


<span class="w"> </span>class WindowsError(builtins.WindowsError):
<span class="gu">@@ -29,38 +63,71 @@ class WindowsError(builtins.WindowsError):</span>
<span class="w"> </span>        args = 0, strerror, None, value
<span class="w"> </span>        super().__init__(*args)

<span class="gi">+    @property</span>
<span class="gi">+    def message(self):</span>
<span class="gi">+        return self.strerror</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def code(self):</span>
<span class="gi">+        return self.winerror</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.message

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;{self.__class__.__name__}({self.winerror})&#39;.format(**vars())</span>
<span class="gi">+        return &quot;{self.__class__.__name__}({self.winerror})&quot;.format(**vars())</span>
<span class="gi">+</span>

<span class="gi">+def handle_nonzero_success(result):</span>
<span class="gi">+    if result == 0:</span>
<span class="gi">+        raise WindowsError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+###########################</span>
<span class="gi">+# jaraco.windows.api.memory</span>
<span class="gi">+</span>
<span class="gi">+GMEM_MOVEABLE = 0x2</span>

<span class="gd">-GMEM_MOVEABLE = 2</span>
<span class="w"> </span>GlobalAlloc = ctypes.windll.kernel32.GlobalAlloc
<span class="w"> </span>GlobalAlloc.argtypes = ctypes.wintypes.UINT, ctypes.c_size_t
<span class="w"> </span>GlobalAlloc.restype = ctypes.wintypes.HANDLE
<span class="gi">+</span>
<span class="w"> </span>GlobalLock = ctypes.windll.kernel32.GlobalLock
<span class="gd">-GlobalLock.argtypes = ctypes.wintypes.HGLOBAL,</span>
<span class="gi">+GlobalLock.argtypes = (ctypes.wintypes.HGLOBAL,)</span>
<span class="w"> </span>GlobalLock.restype = ctypes.wintypes.LPVOID
<span class="gi">+</span>
<span class="w"> </span>GlobalUnlock = ctypes.windll.kernel32.GlobalUnlock
<span class="gd">-GlobalUnlock.argtypes = ctypes.wintypes.HGLOBAL,</span>
<span class="gi">+GlobalUnlock.argtypes = (ctypes.wintypes.HGLOBAL,)</span>
<span class="w"> </span>GlobalUnlock.restype = ctypes.wintypes.BOOL
<span class="gi">+</span>
<span class="w"> </span>GlobalSize = ctypes.windll.kernel32.GlobalSize
<span class="gd">-GlobalSize.argtypes = ctypes.wintypes.HGLOBAL,</span>
<span class="gi">+GlobalSize.argtypes = (ctypes.wintypes.HGLOBAL,)</span>
<span class="w"> </span>GlobalSize.restype = ctypes.c_size_t
<span class="gi">+</span>
<span class="w"> </span>CreateFileMapping = ctypes.windll.kernel32.CreateFileMappingW
<span class="gd">-CreateFileMapping.argtypes = [ctypes.wintypes.HANDLE, ctypes.c_void_p,</span>
<span class="gd">-    ctypes.wintypes.DWORD, ctypes.wintypes.DWORD, ctypes.wintypes.DWORD,</span>
<span class="gd">-    ctypes.wintypes.LPWSTR]</span>
<span class="gi">+CreateFileMapping.argtypes = [</span>
<span class="gi">+    ctypes.wintypes.HANDLE,</span>
<span class="gi">+    ctypes.c_void_p,</span>
<span class="gi">+    ctypes.wintypes.DWORD,</span>
<span class="gi">+    ctypes.wintypes.DWORD,</span>
<span class="gi">+    ctypes.wintypes.DWORD,</span>
<span class="gi">+    ctypes.wintypes.LPWSTR,</span>
<span class="gi">+]</span>
<span class="w"> </span>CreateFileMapping.restype = ctypes.wintypes.HANDLE
<span class="gi">+</span>
<span class="w"> </span>MapViewOfFile = ctypes.windll.kernel32.MapViewOfFile
<span class="w"> </span>MapViewOfFile.restype = ctypes.wintypes.HANDLE
<span class="gi">+</span>
<span class="w"> </span>UnmapViewOfFile = ctypes.windll.kernel32.UnmapViewOfFile
<span class="gd">-UnmapViewOfFile.argtypes = ctypes.wintypes.HANDLE,</span>
<span class="gi">+UnmapViewOfFile.argtypes = (ctypes.wintypes.HANDLE,)</span>
<span class="gi">+</span>
<span class="w"> </span>RtlMoveMemory = ctypes.windll.kernel32.RtlMoveMemory
<span class="gd">-RtlMoveMemory.argtypes = ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t</span>
<span class="gd">-ctypes.windll.kernel32.LocalFree.argtypes = ctypes.wintypes.HLOCAL,</span>
<span class="gi">+RtlMoveMemory.argtypes = (ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t)</span>
<span class="gi">+</span>
<span class="gi">+ctypes.windll.kernel32.LocalFree.argtypes = (ctypes.wintypes.HLOCAL,)</span>
<span class="gi">+</span>
<span class="gi">+#####################</span>
<span class="gi">+# jaraco.windows.mmap</span>


<span class="w"> </span>class MemoryMap:
<span class="gu">@@ -75,69 +142,128 @@ class MemoryMap:</span>
<span class="w"> </span>        self.pos = 0

<span class="w"> </span>    def __enter__(self):
<span class="gd">-        p_SA = ctypes.byref(self.security_attributes</span>
<span class="gd">-            ) if self.security_attributes else None</span>
<span class="gi">+        p_SA = (</span>
<span class="gi">+            ctypes.byref(self.security_attributes)</span>
<span class="gi">+            if self.security_attributes</span>
<span class="gi">+            else None</span>
<span class="gi">+        )</span>
<span class="w"> </span>        INVALID_HANDLE_VALUE = -1
<span class="gd">-        PAGE_READWRITE = 4</span>
<span class="gd">-        FILE_MAP_WRITE = 2</span>
<span class="gi">+        PAGE_READWRITE = 0x4</span>
<span class="gi">+        FILE_MAP_WRITE = 0x2</span>
<span class="w"> </span>        filemap = ctypes.windll.kernel32.CreateFileMappingW(
<span class="gd">-            INVALID_HANDLE_VALUE, p_SA, PAGE_READWRITE, 0, self.length, u(</span>
<span class="gd">-            self.name))</span>
<span class="gi">+            INVALID_HANDLE_VALUE,</span>
<span class="gi">+            p_SA,</span>
<span class="gi">+            PAGE_READWRITE,</span>
<span class="gi">+            0,</span>
<span class="gi">+            self.length,</span>
<span class="gi">+            u(self.name),</span>
<span class="gi">+        )</span>
<span class="w"> </span>        handle_nonzero_success(filemap)
<span class="w"> </span>        if filemap == INVALID_HANDLE_VALUE:
<span class="gd">-            raise Exception(&#39;Failed to create file mapping&#39;)</span>
<span class="gi">+            raise Exception(&quot;Failed to create file mapping&quot;)</span>
<span class="w"> </span>        self.filemap = filemap
<span class="w"> </span>        self.view = MapViewOfFile(filemap, FILE_MAP_WRITE, 0, 0, 0)
<span class="w"> </span>        return self

<span class="gi">+    def seek(self, pos):</span>
<span class="gi">+        self.pos = pos</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, msg):</span>
<span class="gi">+        assert isinstance(msg, bytes)</span>
<span class="gi">+        n = len(msg)</span>
<span class="gi">+        if self.pos + n &gt;= self.length:  # A little safety.</span>
<span class="gi">+            raise ValueError(f&quot;Refusing to write {n} bytes&quot;)</span>
<span class="gi">+        dest = self.view + self.pos</span>
<span class="gi">+        length = ctypes.c_size_t(n)</span>
<span class="gi">+        ctypes.windll.kernel32.RtlMoveMemory(dest, msg, length)</span>
<span class="gi">+        self.pos += n</span>
<span class="gi">+</span>
<span class="w"> </span>    def read(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Read n bytes from mapped view.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        out = ctypes.create_string_buffer(n)</span>
<span class="gi">+        source = self.view + self.pos</span>
<span class="gi">+        length = ctypes.c_size_t(n)</span>
<span class="gi">+        ctypes.windll.kernel32.RtlMoveMemory(out, source, length)</span>
<span class="gi">+        self.pos += n</span>
<span class="gi">+        return out.raw</span>

<span class="w"> </span>    def __exit__(self, exc_type, exc_val, tb):
<span class="w"> </span>        ctypes.windll.kernel32.UnmapViewOfFile(self.view)
<span class="w"> </span>        ctypes.windll.kernel32.CloseHandle(self.filemap)


<span class="gd">-READ_CONTROL = 131072</span>
<span class="gd">-STANDARD_RIGHTS_REQUIRED = 983040</span>
<span class="gi">+#############################</span>
<span class="gi">+# jaraco.windows.api.security</span>
<span class="gi">+</span>
<span class="gi">+# from WinNT.h</span>
<span class="gi">+READ_CONTROL = 0x00020000</span>
<span class="gi">+STANDARD_RIGHTS_REQUIRED = 0x000F0000</span>
<span class="w"> </span>STANDARD_RIGHTS_READ = READ_CONTROL
<span class="w"> </span>STANDARD_RIGHTS_WRITE = READ_CONTROL
<span class="w"> </span>STANDARD_RIGHTS_EXECUTE = READ_CONTROL
<span class="gd">-STANDARD_RIGHTS_ALL = 2031616</span>
<span class="gd">-POLICY_VIEW_LOCAL_INFORMATION = 1</span>
<span class="gd">-POLICY_VIEW_AUDIT_INFORMATION = 2</span>
<span class="gd">-POLICY_GET_PRIVATE_INFORMATION = 4</span>
<span class="gd">-POLICY_TRUST_ADMIN = 8</span>
<span class="gd">-POLICY_CREATE_ACCOUNT = 16</span>
<span class="gd">-POLICY_CREATE_SECRET = 32</span>
<span class="gd">-POLICY_CREATE_PRIVILEGE = 64</span>
<span class="gd">-POLICY_SET_DEFAULT_QUOTA_LIMITS = 128</span>
<span class="gd">-POLICY_SET_AUDIT_REQUIREMENTS = 256</span>
<span class="gd">-POLICY_AUDIT_LOG_ADMIN = 512</span>
<span class="gd">-POLICY_SERVER_ADMIN = 1024</span>
<span class="gd">-POLICY_LOOKUP_NAMES = 2048</span>
<span class="gd">-POLICY_NOTIFICATION = 4096</span>
<span class="gd">-POLICY_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED |</span>
<span class="gd">-    POLICY_VIEW_LOCAL_INFORMATION | POLICY_VIEW_AUDIT_INFORMATION |</span>
<span class="gd">-    POLICY_GET_PRIVATE_INFORMATION | POLICY_TRUST_ADMIN |</span>
<span class="gd">-    POLICY_CREATE_ACCOUNT | POLICY_CREATE_SECRET | POLICY_CREATE_PRIVILEGE |</span>
<span class="gd">-    POLICY_SET_DEFAULT_QUOTA_LIMITS | POLICY_SET_AUDIT_REQUIREMENTS |</span>
<span class="gd">-    POLICY_AUDIT_LOG_ADMIN | POLICY_SERVER_ADMIN | POLICY_LOOKUP_NAMES)</span>
<span class="gd">-POLICY_READ = (STANDARD_RIGHTS_READ | POLICY_VIEW_AUDIT_INFORMATION |</span>
<span class="gd">-    POLICY_GET_PRIVATE_INFORMATION)</span>
<span class="gd">-POLICY_WRITE = (STANDARD_RIGHTS_WRITE | POLICY_TRUST_ADMIN |</span>
<span class="gd">-    POLICY_CREATE_ACCOUNT | POLICY_CREATE_SECRET | POLICY_CREATE_PRIVILEGE |</span>
<span class="gd">-    POLICY_SET_DEFAULT_QUOTA_LIMITS | POLICY_SET_AUDIT_REQUIREMENTS |</span>
<span class="gd">-    POLICY_AUDIT_LOG_ADMIN | POLICY_SERVER_ADMIN)</span>
<span class="gd">-POLICY_EXECUTE = (STANDARD_RIGHTS_EXECUTE | POLICY_VIEW_LOCAL_INFORMATION |</span>
<span class="gd">-    POLICY_LOOKUP_NAMES)</span>
<span class="gi">+STANDARD_RIGHTS_ALL = 0x001F0000</span>
<span class="gi">+</span>
<span class="gi">+# from NTSecAPI.h</span>
<span class="gi">+POLICY_VIEW_LOCAL_INFORMATION = 0x00000001</span>
<span class="gi">+POLICY_VIEW_AUDIT_INFORMATION = 0x00000002</span>
<span class="gi">+POLICY_GET_PRIVATE_INFORMATION = 0x00000004</span>
<span class="gi">+POLICY_TRUST_ADMIN = 0x00000008</span>
<span class="gi">+POLICY_CREATE_ACCOUNT = 0x00000010</span>
<span class="gi">+POLICY_CREATE_SECRET = 0x00000020</span>
<span class="gi">+POLICY_CREATE_PRIVILEGE = 0x00000040</span>
<span class="gi">+POLICY_SET_DEFAULT_QUOTA_LIMITS = 0x00000080</span>
<span class="gi">+POLICY_SET_AUDIT_REQUIREMENTS = 0x00000100</span>
<span class="gi">+POLICY_AUDIT_LOG_ADMIN = 0x00000200</span>
<span class="gi">+POLICY_SERVER_ADMIN = 0x00000400</span>
<span class="gi">+POLICY_LOOKUP_NAMES = 0x00000800</span>
<span class="gi">+POLICY_NOTIFICATION = 0x00001000</span>
<span class="gi">+</span>
<span class="gi">+POLICY_ALL_ACCESS = (</span>
<span class="gi">+    STANDARD_RIGHTS_REQUIRED</span>
<span class="gi">+    | POLICY_VIEW_LOCAL_INFORMATION</span>
<span class="gi">+    | POLICY_VIEW_AUDIT_INFORMATION</span>
<span class="gi">+    | POLICY_GET_PRIVATE_INFORMATION</span>
<span class="gi">+    | POLICY_TRUST_ADMIN</span>
<span class="gi">+    | POLICY_CREATE_ACCOUNT</span>
<span class="gi">+    | POLICY_CREATE_SECRET</span>
<span class="gi">+    | POLICY_CREATE_PRIVILEGE</span>
<span class="gi">+    | POLICY_SET_DEFAULT_QUOTA_LIMITS</span>
<span class="gi">+    | POLICY_SET_AUDIT_REQUIREMENTS</span>
<span class="gi">+    | POLICY_AUDIT_LOG_ADMIN</span>
<span class="gi">+    | POLICY_SERVER_ADMIN</span>
<span class="gi">+    | POLICY_LOOKUP_NAMES</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+POLICY_READ = (</span>
<span class="gi">+    STANDARD_RIGHTS_READ</span>
<span class="gi">+    | POLICY_VIEW_AUDIT_INFORMATION</span>
<span class="gi">+    | POLICY_GET_PRIVATE_INFORMATION</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+POLICY_WRITE = (</span>
<span class="gi">+    STANDARD_RIGHTS_WRITE</span>
<span class="gi">+    | POLICY_TRUST_ADMIN</span>
<span class="gi">+    | POLICY_CREATE_ACCOUNT</span>
<span class="gi">+    | POLICY_CREATE_SECRET</span>
<span class="gi">+    | POLICY_CREATE_PRIVILEGE</span>
<span class="gi">+    | POLICY_SET_DEFAULT_QUOTA_LIMITS</span>
<span class="gi">+    | POLICY_SET_AUDIT_REQUIREMENTS</span>
<span class="gi">+    | POLICY_AUDIT_LOG_ADMIN</span>
<span class="gi">+    | POLICY_SERVER_ADMIN</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+POLICY_EXECUTE = (</span>
<span class="gi">+    STANDARD_RIGHTS_EXECUTE</span>
<span class="gi">+    | POLICY_VIEW_LOCAL_INFORMATION</span>
<span class="gi">+    | POLICY_LOOKUP_NAMES</span>
<span class="gi">+)</span>


<span class="w"> </span>class TokenAccess:
<span class="gd">-    TOKEN_QUERY = 8</span>
<span class="gi">+    TOKEN_QUERY = 0x8</span>


<span class="w"> </span>class TokenInformationClass:
<span class="gu">@@ -146,8 +272,10 @@ class TokenInformationClass:</span>

<span class="w"> </span>class TOKEN_USER(ctypes.Structure):
<span class="w"> </span>    num = 1
<span class="gd">-    _fields_ = [(&#39;SID&#39;, ctypes.c_void_p), (&#39;ATTRIBUTES&#39;, ctypes.wintypes.DWORD)</span>
<span class="gd">-        ]</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;SID&quot;, ctypes.c_void_p),</span>
<span class="gi">+        (&quot;ATTRIBUTES&quot;, ctypes.wintypes.DWORD),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>class SECURITY_DESCRIPTOR(ctypes.Structure):
<span class="gu">@@ -163,12 +291,19 @@ class SECURITY_DESCRIPTOR(ctypes.Structure):</span>
<span class="w"> </span>        PACL Dacl;
<span class="w"> </span>        }   SECURITY_DESCRIPTOR;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    SECURITY_DESCRIPTOR_CONTROL = ctypes.wintypes.USHORT
<span class="w"> </span>    REVISION = 1
<span class="gd">-    _fields_ = [(&#39;Revision&#39;, ctypes.c_ubyte), (&#39;Sbz1&#39;, ctypes.c_ubyte), (</span>
<span class="gd">-        &#39;Control&#39;, SECURITY_DESCRIPTOR_CONTROL), (&#39;Owner&#39;, ctypes.c_void_p),</span>
<span class="gd">-        (&#39;Group&#39;, ctypes.c_void_p), (&#39;Sacl&#39;, ctypes.c_void_p), (&#39;Dacl&#39;,</span>
<span class="gd">-        ctypes.c_void_p)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;Revision&quot;, ctypes.c_ubyte),</span>
<span class="gi">+        (&quot;Sbz1&quot;, ctypes.c_ubyte),</span>
<span class="gi">+        (&quot;Control&quot;, SECURITY_DESCRIPTOR_CONTROL),</span>
<span class="gi">+        (&quot;Owner&quot;, ctypes.c_void_p),</span>
<span class="gi">+        (&quot;Group&quot;, ctypes.c_void_p),</span>
<span class="gi">+        (&quot;Sacl&quot;, ctypes.c_void_p),</span>
<span class="gi">+        (&quot;Dacl&quot;, ctypes.c_void_p),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>class SECURITY_ATTRIBUTES(ctypes.Structure):
<span class="gu">@@ -179,30 +314,77 @@ class SECURITY_ATTRIBUTES(ctypes.Structure):</span>
<span class="w"> </span>        BOOL   bInheritHandle;
<span class="w"> </span>    } SECURITY_ATTRIBUTES;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _fields_ = [(&#39;nLength&#39;, ctypes.wintypes.DWORD), (&#39;lpSecurityDescriptor&#39;,</span>
<span class="gd">-        ctypes.c_void_p), (&#39;bInheritHandle&#39;, ctypes.wintypes.BOOL)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;nLength&quot;, ctypes.wintypes.DWORD),</span>
<span class="gi">+        (&quot;lpSecurityDescriptor&quot;, ctypes.c_void_p),</span>
<span class="gi">+        (&quot;bInheritHandle&quot;, ctypes.wintypes.BOOL),</span>
<span class="gi">+    ]</span>

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.nLength = ctypes.sizeof(SECURITY_ATTRIBUTES)

<span class="gi">+    @property</span>
<span class="gi">+    def descriptor(self):</span>
<span class="gi">+        return self._descriptor</span>
<span class="gi">+</span>
<span class="gi">+    @descriptor.setter</span>
<span class="gi">+    def descriptor(self, value):</span>
<span class="gi">+        self._descriptor = value</span>
<span class="gi">+        self.lpSecurityDescriptor = ctypes.addressof(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ctypes.windll.advapi32.SetSecurityDescriptorOwner.argtypes = (</span>
<span class="gi">+    ctypes.POINTER(SECURITY_DESCRIPTOR),</span>
<span class="gi">+    ctypes.c_void_p,</span>
<span class="gi">+    ctypes.wintypes.BOOL,</span>
<span class="gi">+)</span>

<span class="gd">-ctypes.windll.advapi32.SetSecurityDescriptorOwner.argtypes = ctypes.POINTER(</span>
<span class="gd">-    SECURITY_DESCRIPTOR), ctypes.c_void_p, ctypes.wintypes.BOOL</span>
<span class="gi">+#########################</span>
<span class="gi">+# jaraco.windows.security</span>


<span class="w"> </span>def GetTokenInformation(token, information_class):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Given a token, get the token information for it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data_size = ctypes.wintypes.DWORD()</span>
<span class="gi">+    ctypes.windll.advapi32.GetTokenInformation(</span>
<span class="gi">+        token, information_class.num, 0, 0, ctypes.byref(data_size)</span>
<span class="gi">+    )</span>
<span class="gi">+    data = ctypes.create_string_buffer(data_size.value)</span>
<span class="gi">+    handle_nonzero_success(</span>
<span class="gi">+        ctypes.windll.advapi32.GetTokenInformation(</span>
<span class="gi">+            token,</span>
<span class="gi">+            information_class.num,</span>
<span class="gi">+            ctypes.byref(data),</span>
<span class="gi">+            ctypes.sizeof(data),</span>
<span class="gi">+            ctypes.byref(data_size),</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    return ctypes.cast(data, ctypes.POINTER(TOKEN_USER)).contents</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def OpenProcessToken(proc_handle, access):</span>
<span class="gi">+    result = ctypes.wintypes.HANDLE()</span>
<span class="gi">+    proc_handle = ctypes.wintypes.HANDLE(proc_handle)</span>
<span class="gi">+    handle_nonzero_success(</span>
<span class="gi">+        ctypes.windll.advapi32.OpenProcessToken(</span>
<span class="gi">+            proc_handle, access, ctypes.byref(result)</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def get_current_user():
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return a TOKEN_USER for the owner of this process.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    process = OpenProcessToken(</span>
<span class="gi">+        ctypes.windll.kernel32.GetCurrentProcess(), TokenAccess.TOKEN_QUERY</span>
<span class="gi">+    )</span>
<span class="gi">+    return GetTokenInformation(process, TOKEN_USER)</span>


<span class="w"> </span>def get_security_attributes_for_user(user=None):
<span class="gu">@@ -210,4 +392,22 @@ def get_security_attributes_for_user(user=None):</span>
<span class="w"> </span>    Return a SECURITY_ATTRIBUTES structure with the SID set to the
<span class="w"> </span>    specified user (uses current user if none is specified).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if user is None:</span>
<span class="gi">+        user = get_current_user()</span>
<span class="gi">+</span>
<span class="gi">+    assert isinstance(user, TOKEN_USER), &quot;user must be TOKEN_USER instance&quot;</span>
<span class="gi">+</span>
<span class="gi">+    SD = SECURITY_DESCRIPTOR()</span>
<span class="gi">+    SA = SECURITY_ATTRIBUTES()</span>
<span class="gi">+    # by attaching the actual security descriptor, it will be garbage-</span>
<span class="gi">+    # collected with the security attributes</span>
<span class="gi">+    SA.descriptor = SD</span>
<span class="gi">+    SA.bInheritHandle = 1</span>
<span class="gi">+</span>
<span class="gi">+    ctypes.windll.advapi32.InitializeSecurityDescriptor(</span>
<span class="gi">+        ctypes.byref(SD), SECURITY_DESCRIPTOR.REVISION</span>
<span class="gi">+    )</span>
<span class="gi">+    ctypes.windll.advapi32.SetSecurityDescriptorOwner(</span>
<span class="gi">+        ctypes.byref(SD), user.SID, 0</span>
<span class="gi">+    )</span>
<span class="gi">+    return SA</span>
<span class="gh">diff --git a/paramiko/agent.py b/paramiko/agent.py</span>
<span class="gh">index 440c59d9..b29a0d14 100644</span>
<span class="gd">--- a/paramiko/agent.py</span>
<span class="gi">+++ b/paramiko/agent.py</span>
<span class="gu">@@ -1,6 +1,25 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  John Rochester &lt;john@jrochester.org&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>SSH Agent interface
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import socket
<span class="w"> </span>import struct
<span class="gu">@@ -12,24 +31,34 @@ import stat</span>
<span class="w"> </span>from logging import DEBUG
<span class="w"> </span>from select import select
<span class="w"> </span>from paramiko.common import io_sleep, byte_chr
<span class="gi">+</span>
<span class="w"> </span>from paramiko.ssh_exception import SSHException, AuthenticationException
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.pkey import PKey, UnknownKeyType
<span class="w"> </span>from paramiko.util import asbytes, get_logger
<span class="gi">+</span>
<span class="w"> </span>cSSH2_AGENTC_REQUEST_IDENTITIES = byte_chr(11)
<span class="w"> </span>SSH2_AGENT_IDENTITIES_ANSWER = 12
<span class="w"> </span>cSSH2_AGENTC_SIGN_REQUEST = byte_chr(13)
<span class="w"> </span>SSH2_AGENT_SIGN_RESPONSE = 14
<span class="gi">+</span>
<span class="w"> </span>SSH_AGENT_RSA_SHA2_256 = 2
<span class="w"> </span>SSH_AGENT_RSA_SHA2_512 = 4
<span class="gd">-ALGORITHM_FLAG_MAP = {&#39;rsa-sha2-256&#39;: SSH_AGENT_RSA_SHA2_256,</span>
<span class="gd">-    &#39;rsa-sha2-512&#39;: SSH_AGENT_RSA_SHA2_512}</span>
<span class="gi">+# NOTE: RFC mildly confusing; while these flags are OR&#39;d together, OpenSSH at</span>
<span class="gi">+# least really treats them like &quot;AND&quot;s, in the sense that if it finds the</span>
<span class="gi">+# SHA256 flag set it won&#39;t continue looking at the SHA512 one; it</span>
<span class="gi">+# short-circuits right away.</span>
<span class="gi">+# Thus, we never want to eg submit 6 to say &quot;either&#39;s good&quot;.</span>
<span class="gi">+ALGORITHM_FLAG_MAP = {</span>
<span class="gi">+    &quot;rsa-sha2-256&quot;: SSH_AGENT_RSA_SHA2_256,</span>
<span class="gi">+    &quot;rsa-sha2-512&quot;: SSH_AGENT_RSA_SHA2_512,</span>
<span class="gi">+}</span>
<span class="w"> </span>for key, value in list(ALGORITHM_FLAG_MAP.items()):
<span class="gd">-    ALGORITHM_FLAG_MAP[f&#39;{key}-cert-v01@openssh.com&#39;] = value</span>
<span class="gi">+    ALGORITHM_FLAG_MAP[f&quot;{key}-cert-v01@openssh.com&quot;] = value</span>


<span class="gi">+# TODO 4.0: rename all these - including making some of their methods public?</span>
<span class="w"> </span>class AgentSSH:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._conn = None
<span class="w"> </span>        self._keys = ()
<span class="gu">@@ -47,7 +76,47 @@ class AgentSSH:</span>
<span class="w"> </span>            a tuple of `.AgentKey` objects representing keys available on the
<span class="w"> </span>            SSH agent
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._keys</span>
<span class="gi">+</span>
<span class="gi">+    def _connect(self, conn):</span>
<span class="gi">+        self._conn = conn</span>
<span class="gi">+        ptype, result = self._send_message(cSSH2_AGENTC_REQUEST_IDENTITIES)</span>
<span class="gi">+        if ptype != SSH2_AGENT_IDENTITIES_ANSWER:</span>
<span class="gi">+            raise SSHException(&quot;could not get keys from ssh-agent&quot;)</span>
<span class="gi">+        keys = []</span>
<span class="gi">+        for i in range(result.get_int()):</span>
<span class="gi">+            keys.append(</span>
<span class="gi">+                AgentKey(</span>
<span class="gi">+                    agent=self,</span>
<span class="gi">+                    blob=result.get_binary(),</span>
<span class="gi">+                    comment=result.get_text(),</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        self._keys = tuple(keys)</span>
<span class="gi">+</span>
<span class="gi">+    def _close(self):</span>
<span class="gi">+        if self._conn is not None:</span>
<span class="gi">+            self._conn.close()</span>
<span class="gi">+        self._conn = None</span>
<span class="gi">+        self._keys = ()</span>
<span class="gi">+</span>
<span class="gi">+    def _send_message(self, msg):</span>
<span class="gi">+        msg = asbytes(msg)</span>
<span class="gi">+        self._conn.send(struct.pack(&quot;&gt;I&quot;, len(msg)) + msg)</span>
<span class="gi">+        data = self._read_all(4)</span>
<span class="gi">+        msg = Message(self._read_all(struct.unpack(&quot;&gt;I&quot;, data)[0]))</span>
<span class="gi">+        return ord(msg.get_byte()), msg</span>
<span class="gi">+</span>
<span class="gi">+    def _read_all(self, wanted):</span>
<span class="gi">+        result = self._conn.recv(wanted)</span>
<span class="gi">+        while len(result) &lt; wanted:</span>
<span class="gi">+            if len(result) == 0:</span>
<span class="gi">+                raise SSHException(&quot;lost ssh-agent&quot;)</span>
<span class="gi">+            extra = self._conn.recv(wanted - len(result))</span>
<span class="gi">+            if len(extra) == 0:</span>
<span class="gi">+                raise SSHException(&quot;lost ssh-agent&quot;)</span>
<span class="gi">+            result += extra</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class AgentProxyThread(threading.Thread):
<span class="gu">@@ -60,6 +129,54 @@ class AgentProxyThread(threading.Thread):</span>
<span class="w"> </span>        self._agent = agent
<span class="w"> </span>        self._exit = False

<span class="gi">+    def run(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            (r, addr) = self.get_connection()</span>
<span class="gi">+            # Found that r should be either</span>
<span class="gi">+            # a socket from the socket library or None</span>
<span class="gi">+            self.__inr = r</span>
<span class="gi">+            # The address should be an IP address as a string? or None</span>
<span class="gi">+            self.__addr = addr</span>
<span class="gi">+            self._agent.connect()</span>
<span class="gi">+            if not isinstance(self._agent, int) and (</span>
<span class="gi">+                self._agent._conn is None</span>
<span class="gi">+                or not hasattr(self._agent._conn, &quot;fileno&quot;)</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise AuthenticationException(&quot;Unable to connect to SSH agent&quot;)</span>
<span class="gi">+            self._communicate()</span>
<span class="gi">+        except:</span>
<span class="gi">+            # XXX Not sure what to do here ... raise or pass ?</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _communicate(self):</span>
<span class="gi">+        import fcntl</span>
<span class="gi">+</span>
<span class="gi">+        oldflags = fcntl.fcntl(self.__inr, fcntl.F_GETFL)</span>
<span class="gi">+        fcntl.fcntl(self.__inr, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)</span>
<span class="gi">+        while not self._exit:</span>
<span class="gi">+            events = select([self._agent._conn, self.__inr], [], [], 0.5)</span>
<span class="gi">+            for fd in events[0]:</span>
<span class="gi">+                if self._agent._conn == fd:</span>
<span class="gi">+                    data = self._agent._conn.recv(512)</span>
<span class="gi">+                    if len(data) != 0:</span>
<span class="gi">+                        self.__inr.send(data)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self._close()</span>
<span class="gi">+                        break</span>
<span class="gi">+                elif self.__inr == fd:</span>
<span class="gi">+                    data = self.__inr.recv(512)</span>
<span class="gi">+                    if len(data) != 0:</span>
<span class="gi">+                        self._agent._conn.send(data)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self._close()</span>
<span class="gi">+                        break</span>
<span class="gi">+            time.sleep(io_sleep)</span>
<span class="gi">+</span>
<span class="gi">+    def _close(self):</span>
<span class="gi">+        self._exit = True</span>
<span class="gi">+        self.__inr.close()</span>
<span class="gi">+        self._agent._conn.close()</span>
<span class="gi">+</span>

<span class="w"> </span>class AgentLocalProxy(AgentProxyThread):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -76,7 +193,14 @@ class AgentLocalProxy(AgentProxyThread):</span>

<span class="w"> </span>        May block!
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        conn = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span>
<span class="gi">+        try:</span>
<span class="gi">+            conn.bind(self._agent._get_filename())</span>
<span class="gi">+            conn.listen(1)</span>
<span class="gi">+            (r, addr) = conn.accept()</span>
<span class="gi">+            return r, addr</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise</span>


<span class="w"> </span>class AgentRemoteProxy(AgentProxyThread):
<span class="gu">@@ -88,6 +212,9 @@ class AgentRemoteProxy(AgentProxyThread):</span>
<span class="w"> </span>        AgentProxyThread.__init__(self, agent)
<span class="w"> </span>        self.__chan = chan

<span class="gi">+    def get_connection(self):</span>
<span class="gi">+        return self.__chan, None</span>
<span class="gi">+</span>

<span class="w"> </span>def get_agent_connection():
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -95,7 +222,26 @@ def get_agent_connection():</span>

<span class="w"> </span>    .. versionadded:: 2.10
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (&quot;SSH_AUTH_SOCK&quot; in os.environ) and (sys.platform != &quot;win32&quot;):</span>
<span class="gi">+        conn = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span>
<span class="gi">+        try:</span>
<span class="gi">+            conn.connect(os.environ[&quot;SSH_AUTH_SOCK&quot;])</span>
<span class="gi">+            return conn</span>
<span class="gi">+        except:</span>
<span class="gi">+            # probably a dangling env var: the ssh agent is gone</span>
<span class="gi">+            return</span>
<span class="gi">+    elif sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        from . import win_pageant, win_openssh</span>
<span class="gi">+</span>
<span class="gi">+        conn = None</span>
<span class="gi">+        if win_pageant.can_talk_to_agent():</span>
<span class="gi">+            conn = win_pageant.PageantConnection()</span>
<span class="gi">+        elif win_openssh.can_talk_to_agent():</span>
<span class="gi">+            conn = win_openssh.OpenSSHAgentConnection()</span>
<span class="gi">+        return conn</span>
<span class="gi">+    else:</span>
<span class="gi">+        # no agent support</span>
<span class="gi">+        return</span>


<span class="w"> </span>class AgentClientProxy:
<span class="gu">@@ -124,14 +270,21 @@ class AgentClientProxy:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Method automatically called by ``AgentProxyThread.run``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        conn = get_agent_connection()</span>
<span class="gi">+        if not conn:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._conn = conn</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close the current connection and terminate the agent
<span class="w"> </span>        Should be called manually
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &quot;thread&quot;):</span>
<span class="gi">+            self.thread._exit = True</span>
<span class="gi">+            self.thread.join(1000)</span>
<span class="gi">+        if self._conn is not None:</span>
<span class="gi">+            self._conn.close()</span>


<span class="w"> </span>class AgentServerProxy(AgentSSH):
<span class="gu">@@ -155,21 +308,32 @@ class AgentServerProxy(AgentSSH):</span>
<span class="w"> </span>    def __init__(self, t):
<span class="w"> </span>        AgentSSH.__init__(self)
<span class="w"> </span>        self.__t = t
<span class="gd">-        self._dir = tempfile.mkdtemp(&#39;sshproxy&#39;)</span>
<span class="gi">+        self._dir = tempfile.mkdtemp(&quot;sshproxy&quot;)</span>
<span class="w"> </span>        os.chmod(self._dir, stat.S_IRWXU)
<span class="gd">-        self._file = self._dir + &#39;/sshproxy.ssh&#39;</span>
<span class="gi">+        self._file = self._dir + &quot;/sshproxy.ssh&quot;</span>
<span class="w"> </span>        self.thread = AgentLocalProxy(self)
<span class="w"> </span>        self.thread.start()

<span class="w"> </span>    def __del__(self):
<span class="w"> </span>        self.close()

<span class="gi">+    def connect(self):</span>
<span class="gi">+        conn_sock = self.__t.open_forward_agent_channel()</span>
<span class="gi">+        if conn_sock is None:</span>
<span class="gi">+            raise SSHException(&quot;lost ssh-agent&quot;)</span>
<span class="gi">+        conn_sock.set_name(&quot;auth-agent&quot;)</span>
<span class="gi">+        self._connect(conn_sock)</span>
<span class="gi">+</span>
<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Terminate the agent, clean the files, close connections
<span class="w"> </span>        Should be called manually
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        os.remove(self._file)</span>
<span class="gi">+        os.rmdir(self._dir)</span>
<span class="gi">+        self.thread._exit = True</span>
<span class="gi">+        self.thread.join(1000)</span>
<span class="gi">+        self._close()</span>

<span class="w"> </span>    def get_env(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -178,7 +342,10 @@ class AgentServerProxy(AgentSSH):</span>
<span class="w"> </span>        :return:
<span class="w"> </span>            a dict containing the ``SSH_AUTH_SOCK`` environment variables
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {&quot;SSH_AUTH_SOCK&quot;: self._get_filename()}</span>
<span class="gi">+</span>
<span class="gi">+    def _get_filename(self):</span>
<span class="gi">+        return self._file</span>


<span class="w"> </span>class AgentRequestHandler:
<span class="gu">@@ -209,9 +376,16 @@ class AgentRequestHandler:</span>
<span class="w"> </span>        chanClient.request_forward_agent(self._forward_agent_handler)
<span class="w"> </span>        self.__clientProxys = []

<span class="gi">+    def _forward_agent_handler(self, chanRemote):</span>
<span class="gi">+        self.__clientProxys.append(AgentClientProxy(chanRemote))</span>
<span class="gi">+</span>
<span class="w"> </span>    def __del__(self):
<span class="w"> </span>        self.close()

<span class="gi">+    def close(self):</span>
<span class="gi">+        for p in self.__clientProxys:</span>
<span class="gi">+            p.close()</span>
<span class="gi">+</span>

<span class="w"> </span>class Agent(AgentSSH):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -234,6 +408,7 @@ class Agent(AgentSSH):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        AgentSSH.__init__(self)
<span class="gi">+</span>
<span class="w"> </span>        conn = get_agent_connection()
<span class="w"> </span>        if not conn:
<span class="w"> </span>            return
<span class="gu">@@ -243,7 +418,7 @@ class Agent(AgentSSH):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close the SSH agent connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._close()</span>


<span class="w"> </span>class AgentKey(PKey):
<span class="gu">@@ -260,7 +435,7 @@ class AgentKey(PKey):</span>
<span class="w"> </span>        key instance this key is a proxy for, if one was obtainable, else None.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, agent, blob, comment=&#39;&#39;):</span>
<span class="gi">+    def __init__(self, agent, blob, comment=&quot;&quot;):</span>
<span class="w"> </span>        self.agent = agent
<span class="w"> </span>        self.blob = blob
<span class="w"> </span>        self.comment = comment
<span class="gu">@@ -269,16 +444,54 @@ class AgentKey(PKey):</span>
<span class="w"> </span>        self._logger = get_logger(__file__)
<span class="w"> </span>        self.inner_key = None
<span class="w"> </span>        try:
<span class="gd">-            self.inner_key = PKey.from_type_string(key_type=self.name,</span>
<span class="gd">-                key_bytes=blob)</span>
<span class="gi">+            self.inner_key = PKey.from_type_string(</span>
<span class="gi">+                key_type=self.name, key_bytes=blob</span>
<span class="gi">+            )</span>
<span class="w"> </span>        except UnknownKeyType:
<span class="gd">-            err = &#39;Unable to derive inner_key for agent key of type {!r}&#39;</span>
<span class="gi">+            # Log, but don&#39;t explode, since inner_key is a best-effort thing.</span>
<span class="gi">+            err = &quot;Unable to derive inner_key for agent key of type {!r}&quot;</span>
<span class="w"> </span>            self.log(DEBUG, err.format(self.name))

<span class="gi">+    def log(self, *args, **kwargs):</span>
<span class="gi">+        return self._logger.log(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def asbytes(self):</span>
<span class="gi">+        # Prefer inner_key.asbytes, since that will differ for eg RSA-CERT</span>
<span class="gi">+        return self.inner_key.asbytes() if self.inner_key else self.blob</span>
<span class="gi">+</span>
<span class="gi">+    def get_name(self):</span>
<span class="gi">+        return self.name</span>
<span class="gi">+</span>
<span class="gi">+    def get_bits(self):</span>
<span class="gi">+        # Have to work around PKey&#39;s default get_bits being crap</span>
<span class="gi">+        if self.inner_key is not None:</span>
<span class="gi">+            return self.inner_key.get_bits()</span>
<span class="gi">+        return super().get_bits()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __getattr__(self, name):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Proxy any un-implemented methods/properties to the inner_key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        if self.inner_key is None:</span>
<span class="gi">+        if self.inner_key is None:  # nothing to proxy to</span>
<span class="w"> </span>            raise AttributeError(name)
<span class="w"> </span>        return getattr(self.inner_key, name)
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _fields(self):</span>
<span class="gi">+        fallback = [self.get_name(), self.blob]</span>
<span class="gi">+        return self.inner_key._fields if self.inner_key else fallback</span>
<span class="gi">+</span>
<span class="gi">+    def sign_ssh_data(self, data, algorithm=None):</span>
<span class="gi">+        msg = Message()</span>
<span class="gi">+        msg.add_byte(cSSH2_AGENTC_SIGN_REQUEST)</span>
<span class="gi">+        # NOTE: this used to be just self.blob, which is not entirely right for</span>
<span class="gi">+        # RSA-CERT &#39;keys&#39; - those end up always degrading to ssh-rsa type</span>
<span class="gi">+        # signatures, for reasons probably internal to OpenSSH&#39;s agent code,</span>
<span class="gi">+        # even if everything else wants SHA2 (including our flag map).</span>
<span class="gi">+        msg.add_string(self.asbytes())</span>
<span class="gi">+        msg.add_string(data)</span>
<span class="gi">+        msg.add_int(ALGORITHM_FLAG_MAP.get(algorithm, 0))</span>
<span class="gi">+        ptype, result = self.agent._send_message(msg)</span>
<span class="gi">+        if ptype != SSH2_AGENT_SIGN_RESPONSE:</span>
<span class="gi">+            raise SSHException(&quot;key cannot be used for signing&quot;)</span>
<span class="gi">+        return result.get_binary()</span>
<span class="gh">diff --git a/paramiko/auth_handler.py b/paramiko/auth_handler.py</span>
<span class="gh">index 679ae516..bc7f298f 100644</span>
<span class="gd">--- a/paramiko/auth_handler.py</span>
<span class="gi">+++ b/paramiko/auth_handler.py</span>
<span class="gu">@@ -1,14 +1,75 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>`.AuthHandler`
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import weakref
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="w"> </span>import re
<span class="gd">-from paramiko.common import cMSG_SERVICE_REQUEST, cMSG_DISCONNECT, DISCONNECT_SERVICE_NOT_AVAILABLE, DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE, cMSG_USERAUTH_REQUEST, cMSG_SERVICE_ACCEPT, DEBUG, AUTH_SUCCESSFUL, INFO, cMSG_USERAUTH_SUCCESS, cMSG_USERAUTH_FAILURE, AUTH_PARTIALLY_SUCCESSFUL, cMSG_USERAUTH_INFO_REQUEST, WARNING, AUTH_FAILED, cMSG_USERAUTH_PK_OK, cMSG_USERAUTH_INFO_RESPONSE, MSG_SERVICE_REQUEST, MSG_SERVICE_ACCEPT, MSG_USERAUTH_REQUEST, MSG_USERAUTH_SUCCESS, MSG_USERAUTH_FAILURE, MSG_USERAUTH_BANNER, MSG_USERAUTH_INFO_REQUEST, MSG_USERAUTH_INFO_RESPONSE, cMSG_USERAUTH_GSSAPI_RESPONSE, cMSG_USERAUTH_GSSAPI_TOKEN, cMSG_USERAUTH_GSSAPI_MIC, MSG_USERAUTH_GSSAPI_RESPONSE, MSG_USERAUTH_GSSAPI_TOKEN, MSG_USERAUTH_GSSAPI_ERROR, MSG_USERAUTH_GSSAPI_ERRTOK, MSG_USERAUTH_GSSAPI_MIC, MSG_NAMES, cMSG_USERAUTH_BANNER</span>
<span class="gi">+</span>
<span class="gi">+from paramiko.common import (</span>
<span class="gi">+    cMSG_SERVICE_REQUEST,</span>
<span class="gi">+    cMSG_DISCONNECT,</span>
<span class="gi">+    DISCONNECT_SERVICE_NOT_AVAILABLE,</span>
<span class="gi">+    DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE,</span>
<span class="gi">+    cMSG_USERAUTH_REQUEST,</span>
<span class="gi">+    cMSG_SERVICE_ACCEPT,</span>
<span class="gi">+    DEBUG,</span>
<span class="gi">+    AUTH_SUCCESSFUL,</span>
<span class="gi">+    INFO,</span>
<span class="gi">+    cMSG_USERAUTH_SUCCESS,</span>
<span class="gi">+    cMSG_USERAUTH_FAILURE,</span>
<span class="gi">+    AUTH_PARTIALLY_SUCCESSFUL,</span>
<span class="gi">+    cMSG_USERAUTH_INFO_REQUEST,</span>
<span class="gi">+    WARNING,</span>
<span class="gi">+    AUTH_FAILED,</span>
<span class="gi">+    cMSG_USERAUTH_PK_OK,</span>
<span class="gi">+    cMSG_USERAUTH_INFO_RESPONSE,</span>
<span class="gi">+    MSG_SERVICE_REQUEST,</span>
<span class="gi">+    MSG_SERVICE_ACCEPT,</span>
<span class="gi">+    MSG_USERAUTH_REQUEST,</span>
<span class="gi">+    MSG_USERAUTH_SUCCESS,</span>
<span class="gi">+    MSG_USERAUTH_FAILURE,</span>
<span class="gi">+    MSG_USERAUTH_BANNER,</span>
<span class="gi">+    MSG_USERAUTH_INFO_REQUEST,</span>
<span class="gi">+    MSG_USERAUTH_INFO_RESPONSE,</span>
<span class="gi">+    cMSG_USERAUTH_GSSAPI_RESPONSE,</span>
<span class="gi">+    cMSG_USERAUTH_GSSAPI_TOKEN,</span>
<span class="gi">+    cMSG_USERAUTH_GSSAPI_MIC,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_RESPONSE,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_TOKEN,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_ERROR,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_ERRTOK,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_MIC,</span>
<span class="gi">+    MSG_NAMES,</span>
<span class="gi">+    cMSG_USERAUTH_BANNER,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.util import b, u
<span class="gd">-from paramiko.ssh_exception import SSHException, AuthenticationException, BadAuthenticationType, PartialAuthentication</span>
<span class="gi">+from paramiko.ssh_exception import (</span>
<span class="gi">+    SSHException,</span>
<span class="gi">+    AuthenticationException,</span>
<span class="gi">+    BadAuthenticationType,</span>
<span class="gi">+    PartialAuthentication,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.server import InteractiveQuery
<span class="w"> </span>from paramiko.ssh_gss import GSSAuth, GSS_EXCEPTIONS

<span class="gu">@@ -23,22 +84,129 @@ class AuthHandler:</span>
<span class="w"> </span>        self.username = None
<span class="w"> </span>        self.authenticated = False
<span class="w"> </span>        self.auth_event = None
<span class="gd">-        self.auth_method = &#39;&#39;</span>
<span class="gi">+        self.auth_method = &quot;&quot;</span>
<span class="w"> </span>        self.banner = None
<span class="w"> </span>        self.password = None
<span class="w"> </span>        self.private_key = None
<span class="w"> </span>        self.interactive_handler = None
<span class="w"> </span>        self.submethods = None
<span class="gi">+        # for server mode:</span>
<span class="w"> </span>        self.auth_username = None
<span class="w"> </span>        self.auth_fail_count = 0
<span class="gi">+        # for GSSAPI</span>
<span class="w"> </span>        self.gss_host = None
<span class="w"> </span>        self.gss_deleg_creds = True

<span class="gd">-    def auth_interactive(self, username, handler, event, submethods=&#39;&#39;):</span>
<span class="gi">+    def _log(self, *args):</span>
<span class="gi">+        return self.transport._log(*args)</span>
<span class="gi">+</span>
<span class="gi">+    def is_authenticated(self):</span>
<span class="gi">+        return self.authenticated</span>
<span class="gi">+</span>
<span class="gi">+    def get_username(self):</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            return self.auth_username</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.username</span>
<span class="gi">+</span>
<span class="gi">+    def auth_none(self, username, event):</span>
<span class="gi">+        self.transport.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.auth_event = event</span>
<span class="gi">+            self.auth_method = &quot;none&quot;</span>
<span class="gi">+            self.username = username</span>
<span class="gi">+            self._request_auth()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.transport.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def auth_publickey(self, username, key, event):</span>
<span class="gi">+        self.transport.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.auth_event = event</span>
<span class="gi">+            self.auth_method = &quot;publickey&quot;</span>
<span class="gi">+            self.username = username</span>
<span class="gi">+            self.private_key = key</span>
<span class="gi">+            self._request_auth()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.transport.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def auth_password(self, username, password, event):</span>
<span class="gi">+        self.transport.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.auth_event = event</span>
<span class="gi">+            self.auth_method = &quot;password&quot;</span>
<span class="gi">+            self.username = username</span>
<span class="gi">+            self.password = password</span>
<span class="gi">+            self._request_auth()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.transport.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def auth_interactive(self, username, handler, event, submethods=&quot;&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        response_list = handler(title, instructions, prompt_list)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.transport.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.auth_event = event</span>
<span class="gi">+            self.auth_method = &quot;keyboard-interactive&quot;</span>
<span class="gi">+            self.username = username</span>
<span class="gi">+            self.interactive_handler = handler</span>
<span class="gi">+            self.submethods = submethods</span>
<span class="gi">+            self._request_auth()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.transport.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def auth_gssapi_with_mic(self, username, gss_host, gss_deleg_creds, event):</span>
<span class="gi">+        self.transport.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.auth_event = event</span>
<span class="gi">+            self.auth_method = &quot;gssapi-with-mic&quot;</span>
<span class="gi">+            self.username = username</span>
<span class="gi">+            self.gss_host = gss_host</span>
<span class="gi">+            self.gss_deleg_creds = gss_deleg_creds</span>
<span class="gi">+            self._request_auth()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.transport.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def auth_gssapi_keyex(self, username, event):</span>
<span class="gi">+        self.transport.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.auth_event = event</span>
<span class="gi">+            self.auth_method = &quot;gssapi-keyex&quot;</span>
<span class="gi">+            self.username = username</span>
<span class="gi">+            self._request_auth()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.transport.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def abort(self):</span>
<span class="gi">+        if self.auth_event is not None:</span>
<span class="gi">+            self.auth_event.set()</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _request_auth(self):</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_SERVICE_REQUEST)</span>
<span class="gi">+        m.add_string(&quot;ssh-userauth&quot;)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+</span>
<span class="gi">+    def _disconnect_service_not_available(self):</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_DISCONNECT)</span>
<span class="gi">+        m.add_int(DISCONNECT_SERVICE_NOT_AVAILABLE)</span>
<span class="gi">+        m.add_string(&quot;Service not available&quot;)</span>
<span class="gi">+        m.add_string(&quot;en&quot;)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport.close()</span>
<span class="gi">+</span>
<span class="gi">+    def _disconnect_no_more_auth(self):</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_DISCONNECT)</span>
<span class="gi">+        m.add_int(DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE)</span>
<span class="gi">+        m.add_string(&quot;No more auth methods available&quot;)</span>
<span class="gi">+        m.add_string(&quot;en&quot;)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport.close()</span>

<span class="w"> </span>    def _get_key_type_and_bits(self, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -46,7 +214,647 @@ class AuthHandler:</span>

<span class="w"> </span>        Intended for input to or verification of, key signatures.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Use certificate contents, if available, plain pubkey otherwise</span>
<span class="gi">+        if key.public_blob:</span>
<span class="gi">+            return key.public_blob.key_type, key.public_blob.key_blob</span>
<span class="gi">+        else:</span>
<span class="gi">+            return key.get_name(), key</span>
<span class="gi">+</span>
<span class="gi">+    def _get_session_blob(self, key, service, username, algorithm):</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_string(self.transport.session_id)</span>
<span class="gi">+        m.add_byte(cMSG_USERAUTH_REQUEST)</span>
<span class="gi">+        m.add_string(username)</span>
<span class="gi">+        m.add_string(service)</span>
<span class="gi">+        m.add_string(&quot;publickey&quot;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        _, bits = self._get_key_type_and_bits(key)</span>
<span class="gi">+        m.add_string(algorithm)</span>
<span class="gi">+        m.add_string(bits)</span>
<span class="gi">+        return m.asbytes()</span>
<span class="gi">+</span>
<span class="gi">+    def wait_for_response(self, event):</span>
<span class="gi">+        max_ts = None</span>
<span class="gi">+        if self.transport.auth_timeout is not None:</span>
<span class="gi">+            max_ts = time.time() + self.transport.auth_timeout</span>
<span class="gi">+        while True:</span>
<span class="gi">+            event.wait(0.1)</span>
<span class="gi">+            if not self.transport.is_active():</span>
<span class="gi">+                e = self.transport.get_exception()</span>
<span class="gi">+                if (e is None) or issubclass(e.__class__, EOFError):</span>
<span class="gi">+                    e = AuthenticationException(</span>
<span class="gi">+                        &quot;Authentication failed: transport shut down or saw EOF&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                raise e</span>
<span class="gi">+            if event.is_set():</span>
<span class="gi">+                break</span>
<span class="gi">+            if max_ts is not None and max_ts &lt;= time.time():</span>
<span class="gi">+                raise AuthenticationException(&quot;Authentication timeout.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.is_authenticated():</span>
<span class="gi">+            e = self.transport.get_exception()</span>
<span class="gi">+            if e is None:</span>
<span class="gi">+                e = AuthenticationException(&quot;Authentication failed.&quot;)</span>
<span class="gi">+            # this is horrible.  Python Exception isn&#39;t yet descended from</span>
<span class="gi">+            # object, so type(e) won&#39;t work. :(</span>
<span class="gi">+            # TODO 4.0: lol. just lmao.</span>
<span class="gi">+            if issubclass(e.__class__, PartialAuthentication):</span>
<span class="gi">+                return e.allowed_types</span>
<span class="gi">+            raise e</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_service_request(self, m):</span>
<span class="gi">+        service = m.get_text()</span>
<span class="gi">+        if self.transport.server_mode and (service == &quot;ssh-userauth&quot;):</span>
<span class="gi">+            # accepted</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_SERVICE_ACCEPT)</span>
<span class="gi">+            m.add_string(service)</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+            banner, language = self.transport.server_object.get_banner()</span>
<span class="gi">+            if banner:</span>
<span class="gi">+                m = Message()</span>
<span class="gi">+                m.add_byte(cMSG_USERAUTH_BANNER)</span>
<span class="gi">+                m.add_string(banner)</span>
<span class="gi">+                m.add_string(language)</span>
<span class="gi">+                self.transport._send_message(m)</span>
<span class="gi">+            return</span>
<span class="gi">+        # dunno this one</span>
<span class="gi">+        self._disconnect_service_not_available()</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_key_from_request(self, algorithm, keyblob):</span>
<span class="gi">+        # For use in server mode.</span>
<span class="gi">+        options = self.transport.preferred_pubkeys</span>
<span class="gi">+        if algorithm.replace(&quot;-cert-v01@openssh.com&quot;, &quot;&quot;) not in options:</span>
<span class="gi">+            err = (</span>
<span class="gi">+                &quot;Auth rejected: pubkey algorithm &#39;{}&#39; unsupported or disabled&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self._log(INFO, err.format(algorithm))</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self.transport._key_info[algorithm](Message(keyblob))</span>
<span class="gi">+</span>
<span class="gi">+    def _choose_fallback_pubkey_algorithm(self, key_type, my_algos):</span>
<span class="gi">+        # Fallback: first one in our (possibly tweaked by caller) list</span>
<span class="gi">+        pubkey_algo = my_algos[0]</span>
<span class="gi">+        msg = &quot;Server did not send a server-sig-algs list; defaulting to our first preferred algo ({!r})&quot;  # noqa</span>
<span class="gi">+        self._log(DEBUG, msg.format(pubkey_algo))</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            DEBUG,</span>
<span class="gi">+            &quot;NOTE: you may use the &#39;disabled_algorithms&#39; SSHClient/Transport init kwarg to disable that or other algorithms if your server does not support them!&quot;,  # noqa</span>
<span class="gi">+        )</span>
<span class="gi">+        return pubkey_algo</span>
<span class="gi">+</span>
<span class="gi">+    def _finalize_pubkey_algorithm(self, key_type):</span>
<span class="gi">+        # Short-circuit for non-RSA keys</span>
<span class="gi">+        if &quot;rsa&quot; not in key_type:</span>
<span class="gi">+            return key_type</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            DEBUG,</span>
<span class="gi">+            &quot;Finalizing pubkey algorithm for key of type {!r}&quot;.format(</span>
<span class="gi">+                key_type</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        # NOTE re #2017: When the key is an RSA cert and the remote server is</span>
<span class="gi">+        # OpenSSH 7.7 or earlier, always use ssh-rsa-cert-v01@openssh.com.</span>
<span class="gi">+        # Those versions of the server won&#39;t support rsa-sha2 family sig algos</span>
<span class="gi">+        # for certs specifically, and in tandem with various server bugs</span>
<span class="gi">+        # regarding server-sig-algs, it&#39;s impossible to fit this into the rest</span>
<span class="gi">+        # of the logic here.</span>
<span class="gi">+        if key_type.endswith(&quot;-cert-v01@openssh.com&quot;) and re.search(</span>
<span class="gi">+            r&quot;-OpenSSH_(?:[1-6]|7\.[0-7])&quot;, self.transport.remote_version</span>
<span class="gi">+        ):</span>
<span class="gi">+            pubkey_algo = &quot;ssh-rsa-cert-v01@openssh.com&quot;</span>
<span class="gi">+            self.transport._agreed_pubkey_algorithm = pubkey_algo</span>
<span class="gi">+            self._log(DEBUG, &quot;OpenSSH&lt;7.8 + RSA cert = forcing ssh-rsa!&quot;)</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG, &quot;Agreed upon {!r} pubkey algorithm&quot;.format(pubkey_algo)</span>
<span class="gi">+            )</span>
<span class="gi">+            return pubkey_algo</span>
<span class="gi">+        # Normal attempts to handshake follow from here.</span>
<span class="gi">+        # Only consider RSA algos from our list, lest we agree on another!</span>
<span class="gi">+        my_algos = [x for x in self.transport.preferred_pubkeys if &quot;rsa&quot; in x]</span>
<span class="gi">+        self._log(DEBUG, &quot;Our pubkey algorithm list: {}&quot;.format(my_algos))</span>
<span class="gi">+        # Short-circuit negatively if user disabled all RSA algos (heh)</span>
<span class="gi">+        if not my_algos:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;An RSA key was specified, but no RSA pubkey algorithms are configured!&quot;  # noqa</span>
<span class="gi">+            )</span>
<span class="gi">+        # Check for server-sig-algs if supported &amp; sent</span>
<span class="gi">+        server_algo_str = u(</span>
<span class="gi">+            self.transport.server_extensions.get(&quot;server-sig-algs&quot;, b(&quot;&quot;))</span>
<span class="gi">+        )</span>
<span class="gi">+        pubkey_algo = None</span>
<span class="gi">+        # Prefer to match against server-sig-algs</span>
<span class="gi">+        if server_algo_str:</span>
<span class="gi">+            server_algos = server_algo_str.split(&quot;,&quot;)</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG, &quot;Server-side algorithm list: {}&quot;.format(server_algos)</span>
<span class="gi">+            )</span>
<span class="gi">+            # Only use algos from our list that the server likes, in our own</span>
<span class="gi">+            # preference order. (NOTE: purposefully using same style as in</span>
<span class="gi">+            # Transport...expect to refactor later)</span>
<span class="gi">+            agreement = list(filter(server_algos.__contains__, my_algos))</span>
<span class="gi">+            if agreement:</span>
<span class="gi">+                pubkey_algo = agreement[0]</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG,</span>
<span class="gi">+                    &quot;Agreed upon {!r} pubkey algorithm&quot;.format(pubkey_algo),</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._log(DEBUG, &quot;No common pubkey algorithms exist! Dying.&quot;)</span>
<span class="gi">+                # TODO: MAY want to use IncompatiblePeer again here but that&#39;s</span>
<span class="gi">+                # technically for initial key exchange, not pubkey auth.</span>
<span class="gi">+                err = &quot;Unable to agree on a pubkey algorithm for signing a {!r} key!&quot;  # noqa</span>
<span class="gi">+                raise AuthenticationException(err.format(key_type))</span>
<span class="gi">+        # Fallback to something based purely on the key &amp; our configuration</span>
<span class="gi">+        else:</span>
<span class="gi">+            pubkey_algo = self._choose_fallback_pubkey_algorithm(</span>
<span class="gi">+                key_type, my_algos</span>
<span class="gi">+            )</span>
<span class="gi">+        if key_type.endswith(&quot;-cert-v01@openssh.com&quot;):</span>
<span class="gi">+            pubkey_algo += &quot;-cert-v01@openssh.com&quot;</span>
<span class="gi">+        self.transport._agreed_pubkey_algorithm = pubkey_algo</span>
<span class="gi">+        return pubkey_algo</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_service_accept(self, m):</span>
<span class="gi">+        service = m.get_text()</span>
<span class="gi">+        if service == &quot;ssh-userauth&quot;:</span>
<span class="gi">+            self._log(DEBUG, &quot;userauth is OK&quot;)</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_REQUEST)</span>
<span class="gi">+            m.add_string(self.username)</span>
<span class="gi">+            m.add_string(&quot;ssh-connection&quot;)</span>
<span class="gi">+            m.add_string(self.auth_method)</span>
<span class="gi">+            if self.auth_method == &quot;password&quot;:</span>
<span class="gi">+                m.add_boolean(False)</span>
<span class="gi">+                password = b(self.password)</span>
<span class="gi">+                m.add_string(password)</span>
<span class="gi">+            elif self.auth_method == &quot;publickey&quot;:</span>
<span class="gi">+                m.add_boolean(True)</span>
<span class="gi">+                key_type, bits = self._get_key_type_and_bits(self.private_key)</span>
<span class="gi">+                algorithm = self._finalize_pubkey_algorithm(key_type)</span>
<span class="gi">+                m.add_string(algorithm)</span>
<span class="gi">+                m.add_string(bits)</span>
<span class="gi">+                blob = self._get_session_blob(</span>
<span class="gi">+                    self.private_key,</span>
<span class="gi">+                    &quot;ssh-connection&quot;,</span>
<span class="gi">+                    self.username,</span>
<span class="gi">+                    algorithm,</span>
<span class="gi">+                )</span>
<span class="gi">+                sig = self.private_key.sign_ssh_data(blob, algorithm)</span>
<span class="gi">+                m.add_string(sig)</span>
<span class="gi">+            elif self.auth_method == &quot;keyboard-interactive&quot;:</span>
<span class="gi">+                m.add_string(&quot;&quot;)</span>
<span class="gi">+                m.add_string(self.submethods)</span>
<span class="gi">+            elif self.auth_method == &quot;gssapi-with-mic&quot;:</span>
<span class="gi">+                sshgss = GSSAuth(self.auth_method, self.gss_deleg_creds)</span>
<span class="gi">+                m.add_bytes(sshgss.ssh_gss_oids())</span>
<span class="gi">+                # send the supported GSSAPI OIDs to the server</span>
<span class="gi">+                self.transport._send_message(m)</span>
<span class="gi">+                ptype, m = self.transport.packetizer.read_message()</span>
<span class="gi">+                if ptype == MSG_USERAUTH_BANNER:</span>
<span class="gi">+                    self._parse_userauth_banner(m)</span>
<span class="gi">+                    ptype, m = self.transport.packetizer.read_message()</span>
<span class="gi">+                if ptype == MSG_USERAUTH_GSSAPI_RESPONSE:</span>
<span class="gi">+                    # Read the mechanism selected by the server. We send just</span>
<span class="gi">+                    # the Kerberos V5 OID, so the server can only respond with</span>
<span class="gi">+                    # this OID.</span>
<span class="gi">+                    mech = m.get_string()</span>
<span class="gi">+                    m = Message()</span>
<span class="gi">+                    m.add_byte(cMSG_USERAUTH_GSSAPI_TOKEN)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        m.add_string(</span>
<span class="gi">+                            sshgss.ssh_init_sec_context(</span>
<span class="gi">+                                self.gss_host, mech, self.username</span>
<span class="gi">+                            )</span>
<span class="gi">+                        )</span>
<span class="gi">+                    except GSS_EXCEPTIONS as e:</span>
<span class="gi">+                        return self._handle_local_gss_failure(e)</span>
<span class="gi">+                    self.transport._send_message(m)</span>
<span class="gi">+                    while True:</span>
<span class="gi">+                        ptype, m = self.transport.packetizer.read_message()</span>
<span class="gi">+                        if ptype == MSG_USERAUTH_GSSAPI_TOKEN:</span>
<span class="gi">+                            srv_token = m.get_string()</span>
<span class="gi">+                            try:</span>
<span class="gi">+                                next_token = sshgss.ssh_init_sec_context(</span>
<span class="gi">+                                    self.gss_host,</span>
<span class="gi">+                                    mech,</span>
<span class="gi">+                                    self.username,</span>
<span class="gi">+                                    srv_token,</span>
<span class="gi">+                                )</span>
<span class="gi">+                            except GSS_EXCEPTIONS as e:</span>
<span class="gi">+                                return self._handle_local_gss_failure(e)</span>
<span class="gi">+                            # After this step the GSSAPI should not return any</span>
<span class="gi">+                            # token. If it does, we keep sending the token to</span>
<span class="gi">+                            # the server until no more token is returned.</span>
<span class="gi">+                            if next_token is None:</span>
<span class="gi">+                                break</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                m = Message()</span>
<span class="gi">+                                m.add_byte(cMSG_USERAUTH_GSSAPI_TOKEN)</span>
<span class="gi">+                                m.add_string(next_token)</span>
<span class="gi">+                                self.transport.send_message(m)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise SSHException(</span>
<span class="gi">+                            &quot;Received Package: {}&quot;.format(MSG_NAMES[ptype])</span>
<span class="gi">+                        )</span>
<span class="gi">+                    m = Message()</span>
<span class="gi">+                    m.add_byte(cMSG_USERAUTH_GSSAPI_MIC)</span>
<span class="gi">+                    # send the MIC to the server</span>
<span class="gi">+                    m.add_string(sshgss.ssh_get_mic(self.transport.session_id))</span>
<span class="gi">+                elif ptype == MSG_USERAUTH_GSSAPI_ERRTOK:</span>
<span class="gi">+                    # RFC 4462 says we are not required to implement GSS-API</span>
<span class="gi">+                    # error messages.</span>
<span class="gi">+                    # See RFC 4462 Section 3.8 in</span>
<span class="gi">+                    # http://www.ietf.org/rfc/rfc4462.txt</span>
<span class="gi">+                    raise SSHException(&quot;Server returned an error token&quot;)</span>
<span class="gi">+                elif ptype == MSG_USERAUTH_GSSAPI_ERROR:</span>
<span class="gi">+                    maj_status = m.get_int()</span>
<span class="gi">+                    min_status = m.get_int()</span>
<span class="gi">+                    err_msg = m.get_string()</span>
<span class="gi">+                    m.get_string()  # Lang tag - discarded</span>
<span class="gi">+                    raise SSHException(</span>
<span class="gi">+                        &quot;&quot;&quot;GSS-API Error:</span>
<span class="gi">+Major Status: {}</span>
<span class="gi">+Minor Status: {}</span>
<span class="gi">+Error Message: {}</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+                            maj_status, min_status, err_msg</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif ptype == MSG_USERAUTH_FAILURE:</span>
<span class="gi">+                    self._parse_userauth_failure(m)</span>
<span class="gi">+                    return</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise SSHException(</span>
<span class="gi">+                        &quot;Received Package: {}&quot;.format(MSG_NAMES[ptype])</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif (</span>
<span class="gi">+                self.auth_method == &quot;gssapi-keyex&quot;</span>
<span class="gi">+                and self.transport.gss_kex_used</span>
<span class="gi">+            ):</span>
<span class="gi">+                kexgss = self.transport.kexgss_ctxt</span>
<span class="gi">+                kexgss.set_username(self.username)</span>
<span class="gi">+                mic_token = kexgss.ssh_get_mic(self.transport.session_id)</span>
<span class="gi">+                m.add_string(mic_token)</span>
<span class="gi">+            elif self.auth_method == &quot;none&quot;:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise SSHException(</span>
<span class="gi">+                    &#39;Unknown auth method &quot;{}&quot;&#39;.format(self.auth_method)</span>
<span class="gi">+                )</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG, &#39;Service request &quot;{}&quot; accepted (?)&#39;.format(service)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _send_auth_result(self, username, method, result):</span>
<span class="gi">+        # okay, send result</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        if result == AUTH_SUCCESSFUL:</span>
<span class="gi">+            self._log(INFO, &quot;Auth granted ({}).&quot;.format(method))</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_SUCCESS)</span>
<span class="gi">+            self.authenticated = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._log(INFO, &quot;Auth rejected ({}).&quot;.format(method))</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_FAILURE)</span>
<span class="gi">+            m.add_string(</span>
<span class="gi">+                self.transport.server_object.get_allowed_auths(username)</span>
<span class="gi">+            )</span>
<span class="gi">+            if result == AUTH_PARTIALLY_SUCCESSFUL:</span>
<span class="gi">+                m.add_boolean(True)</span>
<span class="gi">+            else:</span>
<span class="gi">+                m.add_boolean(False)</span>
<span class="gi">+                self.auth_fail_count += 1</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        if self.auth_fail_count &gt;= 10:</span>
<span class="gi">+            self._disconnect_no_more_auth()</span>
<span class="gi">+        if result == AUTH_SUCCESSFUL:</span>
<span class="gi">+            self.transport._auth_trigger()</span>
<span class="gi">+</span>
<span class="gi">+    def _interactive_query(self, q):</span>
<span class="gi">+        # make interactive query instead of response</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_USERAUTH_INFO_REQUEST)</span>
<span class="gi">+        m.add_string(q.name)</span>
<span class="gi">+        m.add_string(q.instructions)</span>
<span class="gi">+        m.add_string(bytes())</span>
<span class="gi">+        m.add_int(len(q.prompts))</span>
<span class="gi">+        for p in q.prompts:</span>
<span class="gi">+            m.add_string(p[0])</span>
<span class="gi">+            m.add_boolean(p[1])</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_request(self, m):</span>
<span class="gi">+        if not self.transport.server_mode:</span>
<span class="gi">+            # er, uh... what?</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_FAILURE)</span>
<span class="gi">+            m.add_string(&quot;none&quot;)</span>
<span class="gi">+            m.add_boolean(False)</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+            return</span>
<span class="gi">+        if self.authenticated:</span>
<span class="gi">+            # ignore</span>
<span class="gi">+            return</span>
<span class="gi">+        username = m.get_text()</span>
<span class="gi">+        service = m.get_text()</span>
<span class="gi">+        method = m.get_text()</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            DEBUG,</span>
<span class="gi">+            &quot;Auth request (type={}) service={}, username={}&quot;.format(</span>
<span class="gi">+                method, service, username</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        if service != &quot;ssh-connection&quot;:</span>
<span class="gi">+            self._disconnect_service_not_available()</span>
<span class="gi">+            return</span>
<span class="gi">+        if (self.auth_username is not None) and (</span>
<span class="gi">+            self.auth_username != username</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                WARNING,</span>
<span class="gi">+                &quot;Auth rejected because the client attempted to change username in mid-flight&quot;,  # noqa</span>
<span class="gi">+            )</span>
<span class="gi">+            self._disconnect_no_more_auth()</span>
<span class="gi">+            return</span>
<span class="gi">+        self.auth_username = username</span>
<span class="gi">+        # check if GSS-API authentication is enabled</span>
<span class="gi">+        gss_auth = self.transport.server_object.enable_auth_gssapi()</span>
<span class="gi">+</span>
<span class="gi">+        if method == &quot;none&quot;:</span>
<span class="gi">+            result = self.transport.server_object.check_auth_none(username)</span>
<span class="gi">+        elif method == &quot;password&quot;:</span>
<span class="gi">+            changereq = m.get_boolean()</span>
<span class="gi">+            password = m.get_binary()</span>
<span class="gi">+            try:</span>
<span class="gi">+                password = password.decode(&quot;UTF-8&quot;)</span>
<span class="gi">+            except UnicodeError:</span>
<span class="gi">+                # some clients/servers expect non-utf-8 passwords!</span>
<span class="gi">+                # in this case, just return the raw byte string.</span>
<span class="gi">+                pass</span>
<span class="gi">+            if changereq:</span>
<span class="gi">+                # always treated as failure, since we don&#39;t support changing</span>
<span class="gi">+                # passwords, but collect the list of valid auth types from</span>
<span class="gi">+                # the callback anyway</span>
<span class="gi">+                self._log(DEBUG, &quot;Auth request to change passwords (rejected)&quot;)</span>
<span class="gi">+                newpassword = m.get_binary()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    newpassword = newpassword.decode(&quot;UTF-8&quot;, &quot;replace&quot;)</span>
<span class="gi">+                except UnicodeError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                result = AUTH_FAILED</span>
<span class="gi">+            else:</span>
<span class="gi">+                result = self.transport.server_object.check_auth_password(</span>
<span class="gi">+                    username, password</span>
<span class="gi">+                )</span>
<span class="gi">+        elif method == &quot;publickey&quot;:</span>
<span class="gi">+            sig_attached = m.get_boolean()</span>
<span class="gi">+            # NOTE: server never wants to guess a client&#39;s algo, they&#39;re</span>
<span class="gi">+            # telling us directly. No need for _finalize_pubkey_algorithm</span>
<span class="gi">+            # anywhere in this flow.</span>
<span class="gi">+            algorithm = m.get_text()</span>
<span class="gi">+            keyblob = m.get_binary()</span>
<span class="gi">+            try:</span>
<span class="gi">+                key = self._generate_key_from_request(algorithm, keyblob)</span>
<span class="gi">+            except SSHException as e:</span>
<span class="gi">+                self._log(INFO, &quot;Auth rejected: public key: {}&quot;.format(str(e)))</span>
<span class="gi">+                key = None</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                msg = &quot;Auth rejected: unsupported or mangled public key ({}: {})&quot;  # noqa</span>
<span class="gi">+                self._log(INFO, msg.format(e.__class__.__name__, e))</span>
<span class="gi">+                key = None</span>
<span class="gi">+            if key is None:</span>
<span class="gi">+                self._disconnect_no_more_auth()</span>
<span class="gi">+                return</span>
<span class="gi">+            # first check if this key is okay... if not, we can skip the verify</span>
<span class="gi">+            result = self.transport.server_object.check_auth_publickey(</span>
<span class="gi">+                username, key</span>
<span class="gi">+            )</span>
<span class="gi">+            if result != AUTH_FAILED:</span>
<span class="gi">+                # key is okay, verify it</span>
<span class="gi">+                if not sig_attached:</span>
<span class="gi">+                    # client wants to know if this key is acceptable, before it</span>
<span class="gi">+                    # signs anything...  send special &quot;ok&quot; message</span>
<span class="gi">+                    m = Message()</span>
<span class="gi">+                    m.add_byte(cMSG_USERAUTH_PK_OK)</span>
<span class="gi">+                    m.add_string(algorithm)</span>
<span class="gi">+                    m.add_string(keyblob)</span>
<span class="gi">+                    self.transport._send_message(m)</span>
<span class="gi">+                    return</span>
<span class="gi">+                sig = Message(m.get_binary())</span>
<span class="gi">+                blob = self._get_session_blob(</span>
<span class="gi">+                    key, service, username, algorithm</span>
<span class="gi">+                )</span>
<span class="gi">+                if not key.verify_ssh_sig(blob, sig):</span>
<span class="gi">+                    self._log(INFO, &quot;Auth rejected: invalid signature&quot;)</span>
<span class="gi">+                    result = AUTH_FAILED</span>
<span class="gi">+        elif method == &quot;keyboard-interactive&quot;:</span>
<span class="gi">+            submethods = m.get_string()</span>
<span class="gi">+            result = self.transport.server_object.check_auth_interactive(</span>
<span class="gi">+                username, submethods</span>
<span class="gi">+            )</span>
<span class="gi">+            if isinstance(result, InteractiveQuery):</span>
<span class="gi">+                # make interactive query instead of response</span>
<span class="gi">+                self._interactive_query(result)</span>
<span class="gi">+                return</span>
<span class="gi">+        elif method == &quot;gssapi-with-mic&quot; and gss_auth:</span>
<span class="gi">+            sshgss = GSSAuth(method)</span>
<span class="gi">+            # Read the number of OID mechanisms supported by the client.</span>
<span class="gi">+            # OpenSSH sends just one OID. It&#39;s the Kerveros V5 OID and that&#39;s</span>
<span class="gi">+            # the only OID we support.</span>
<span class="gi">+            mechs = m.get_int()</span>
<span class="gi">+            # We can&#39;t accept more than one OID, so if the SSH client sends</span>
<span class="gi">+            # more than one, disconnect.</span>
<span class="gi">+            if mechs &gt; 1:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    INFO,</span>
<span class="gi">+                    &quot;Disconnect: Received more than one GSS-API OID mechanism&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+                self._disconnect_no_more_auth()</span>
<span class="gi">+            desired_mech = m.get_string()</span>
<span class="gi">+            mech_ok = sshgss.ssh_check_mech(desired_mech)</span>
<span class="gi">+            # if we don&#39;t support the mechanism, disconnect.</span>
<span class="gi">+            if not mech_ok:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    INFO,</span>
<span class="gi">+                    &quot;Disconnect: Received an invalid GSS-API OID mechanism&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+                self._disconnect_no_more_auth()</span>
<span class="gi">+            # send the Kerberos V5 GSSAPI OID to the client</span>
<span class="gi">+            supported_mech = sshgss.ssh_gss_oids(&quot;server&quot;)</span>
<span class="gi">+            # RFC 4462 says we are not required to implement GSS-API error</span>
<span class="gi">+            # messages. See section 3.8 in http://www.ietf.org/rfc/rfc4462.txt</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_GSSAPI_RESPONSE)</span>
<span class="gi">+            m.add_bytes(supported_mech)</span>
<span class="gi">+            self.transport.auth_handler = GssapiWithMicAuthHandler(</span>
<span class="gi">+                self, sshgss</span>
<span class="gi">+            )</span>
<span class="gi">+            self.transport._expected_packet = (</span>
<span class="gi">+                MSG_USERAUTH_GSSAPI_TOKEN,</span>
<span class="gi">+                MSG_USERAUTH_REQUEST,</span>
<span class="gi">+                MSG_SERVICE_REQUEST,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+            return</span>
<span class="gi">+        elif method == &quot;gssapi-keyex&quot; and gss_auth:</span>
<span class="gi">+            mic_token = m.get_string()</span>
<span class="gi">+            sshgss = self.transport.kexgss_ctxt</span>
<span class="gi">+            if sshgss is None:</span>
<span class="gi">+                # If there is no valid context, we reject the authentication</span>
<span class="gi">+                result = AUTH_FAILED</span>
<span class="gi">+                self._send_auth_result(username, method, result)</span>
<span class="gi">+            try:</span>
<span class="gi">+                sshgss.ssh_check_mic(</span>
<span class="gi">+                    mic_token, self.transport.session_id, self.auth_username</span>
<span class="gi">+                )</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                result = AUTH_FAILED</span>
<span class="gi">+                self._send_auth_result(username, method, result)</span>
<span class="gi">+                raise</span>
<span class="gi">+            result = AUTH_SUCCESSFUL</span>
<span class="gi">+            self.transport.server_object.check_auth_gssapi_keyex(</span>
<span class="gi">+                username, result</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = self.transport.server_object.check_auth_none(username)</span>
<span class="gi">+        # okay, send result</span>
<span class="gi">+        self._send_auth_result(username, method, result)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_success(self, m):</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            INFO, &quot;Authentication ({}) successful!&quot;.format(self.auth_method)</span>
<span class="gi">+        )</span>
<span class="gi">+        self.authenticated = True</span>
<span class="gi">+        self.transport._auth_trigger()</span>
<span class="gi">+        if self.auth_event is not None:</span>
<span class="gi">+            self.auth_event.set()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_failure(self, m):</span>
<span class="gi">+        authlist = m.get_list()</span>
<span class="gi">+        # TODO 4.0: we aren&#39;t giving callers access to authlist _unless_ it&#39;s</span>
<span class="gi">+        # partial authentication, so eg authtype=none can&#39;t work unless we</span>
<span class="gi">+        # tweak this.</span>
<span class="gi">+        partial = m.get_boolean()</span>
<span class="gi">+        if partial:</span>
<span class="gi">+            self._log(INFO, &quot;Authentication continues...&quot;)</span>
<span class="gi">+            self._log(DEBUG, &quot;Methods: &quot; + str(authlist))</span>
<span class="gi">+            self.transport.saved_exception = PartialAuthentication(authlist)</span>
<span class="gi">+        elif self.auth_method not in authlist:</span>
<span class="gi">+            for msg in (</span>
<span class="gi">+                &quot;Authentication type ({}) not permitted.&quot;.format(</span>
<span class="gi">+                    self.auth_method</span>
<span class="gi">+                ),</span>
<span class="gi">+                &quot;Allowed methods: {}&quot;.format(authlist),</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._log(DEBUG, msg)</span>
<span class="gi">+            self.transport.saved_exception = BadAuthenticationType(</span>
<span class="gi">+                &quot;Bad authentication type&quot;, authlist</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                INFO, &quot;Authentication ({}) failed.&quot;.format(self.auth_method)</span>
<span class="gi">+            )</span>
<span class="gi">+        self.authenticated = False</span>
<span class="gi">+        self.username = None</span>
<span class="gi">+        if self.auth_event is not None:</span>
<span class="gi">+            self.auth_event.set()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_banner(self, m):</span>
<span class="gi">+        banner = m.get_string()</span>
<span class="gi">+        self.banner = banner</span>
<span class="gi">+        self._log(INFO, &quot;Auth banner: {}&quot;.format(banner))</span>
<span class="gi">+        # who cares.</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_info_request(self, m):</span>
<span class="gi">+        if self.auth_method != &quot;keyboard-interactive&quot;:</span>
<span class="gi">+            raise SSHException(&quot;Illegal info request from server&quot;)</span>
<span class="gi">+        title = m.get_text()</span>
<span class="gi">+        instructions = m.get_text()</span>
<span class="gi">+        m.get_binary()  # lang</span>
<span class="gi">+        prompts = m.get_int()</span>
<span class="gi">+        prompt_list = []</span>
<span class="gi">+        for i in range(prompts):</span>
<span class="gi">+            prompt_list.append((m.get_text(), m.get_boolean()))</span>
<span class="gi">+        response_list = self.interactive_handler(</span>
<span class="gi">+            title, instructions, prompt_list</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_USERAUTH_INFO_RESPONSE)</span>
<span class="gi">+        m.add_int(len(response_list))</span>
<span class="gi">+        for r in response_list:</span>
<span class="gi">+            m.add_string(r)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_info_response(self, m):</span>
<span class="gi">+        if not self.transport.server_mode:</span>
<span class="gi">+            raise SSHException(&quot;Illegal info response from server&quot;)</span>
<span class="gi">+        n = m.get_int()</span>
<span class="gi">+        responses = []</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            responses.append(m.get_text())</span>
<span class="gi">+        result = self.transport.server_object.check_auth_interactive_response(</span>
<span class="gi">+            responses</span>
<span class="gi">+        )</span>
<span class="gi">+        if isinstance(result, InteractiveQuery):</span>
<span class="gi">+            # make interactive query instead of response</span>
<span class="gi">+            self._interactive_query(result)</span>
<span class="gi">+            return</span>
<span class="gi">+        self._send_auth_result(</span>
<span class="gi">+            self.auth_username, &quot;keyboard-interactive&quot;, result</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_local_gss_failure(self, e):</span>
<span class="gi">+        self.transport.saved_exception = e</span>
<span class="gi">+        self._log(DEBUG, &quot;GSSAPI failure: {}&quot;.format(e))</span>
<span class="gi">+        self._log(INFO, &quot;Authentication ({}) failed.&quot;.format(self.auth_method))</span>
<span class="gi">+        self.authenticated = False</span>
<span class="gi">+        self.username = None</span>
<span class="gi">+        if self.auth_event is not None:</span>
<span class="gi">+            self.auth_event.set()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # TODO 4.0: MAY make sense to make these tables into actual</span>
<span class="gi">+    # classes/instances that can be fed a mode bool or whatever. Or,</span>
<span class="gi">+    # alternately (both?) make the message types small classes or enums that</span>
<span class="gi">+    # embed this info within themselves (which could also then tidy up the</span>
<span class="gi">+    # current &#39;integer -&gt; human readable short string&#39; stuff in common.py).</span>
<span class="gi">+    # TODO: if we do that, also expose &#39;em publicly.</span>
<span class="gi">+</span>
<span class="gi">+    # Messages which should be handled _by_ servers (sent by clients)</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _server_handler_table(self):</span>
<span class="gi">+        return {</span>
<span class="gi">+            # TODO 4.0: MSG_SERVICE_REQUEST ought to eventually move into</span>
<span class="gi">+            # Transport&#39;s server mode like the client side did, just for</span>
<span class="gi">+            # consistency.</span>
<span class="gi">+            MSG_SERVICE_REQUEST: self._parse_service_request,</span>
<span class="gi">+            MSG_USERAUTH_REQUEST: self._parse_userauth_request,</span>
<span class="gi">+            MSG_USERAUTH_INFO_RESPONSE: self._parse_userauth_info_response,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    # Messages which should be handled _by_ clients (sent by servers)</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _client_handler_table(self):</span>
<span class="gi">+        return {</span>
<span class="gi">+            MSG_SERVICE_ACCEPT: self._parse_service_accept,</span>
<span class="gi">+            MSG_USERAUTH_SUCCESS: self._parse_userauth_success,</span>
<span class="gi">+            MSG_USERAUTH_FAILURE: self._parse_userauth_failure,</span>
<span class="gi">+            MSG_USERAUTH_BANNER: self._parse_userauth_banner,</span>
<span class="gi">+            MSG_USERAUTH_INFO_REQUEST: self._parse_userauth_info_request,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: prior to the fix for #1283, this was a static dict instead of a</span>
<span class="gi">+    # property. Should be backwards compatible in most/all cases.</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _handler_table(self):</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            return self._server_handler_table</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._client_handler_table</span>


<span class="w"> </span>class GssapiWithMicAuthHandler:
<span class="gu">@@ -55,15 +863,106 @@ class GssapiWithMicAuthHandler:</span>
<span class="w"> </span>    During the GSSAPI token exchange we need a modified dispatch table,
<span class="w"> </span>    because the packet type numbers are not unique.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    method = &#39;gssapi-with-mic&#39;</span>
<span class="gi">+</span>
<span class="gi">+    method = &quot;gssapi-with-mic&quot;</span>

<span class="w"> </span>    def __init__(self, delegate, sshgss):
<span class="w"> </span>        self._delegate = delegate
<span class="w"> </span>        self.sshgss = sshgss
<span class="gd">-    __handler_table = {MSG_SERVICE_REQUEST: _parse_service_request,</span>
<span class="gi">+</span>
<span class="gi">+    def abort(self):</span>
<span class="gi">+        self._restore_delegate_auth_handler()</span>
<span class="gi">+        return self._delegate.abort()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def transport(self):</span>
<span class="gi">+        return self._delegate.transport</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _send_auth_result(self):</span>
<span class="gi">+        return self._delegate._send_auth_result</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def auth_username(self):</span>
<span class="gi">+        return self._delegate.auth_username</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def gss_host(self):</span>
<span class="gi">+        return self._delegate.gss_host</span>
<span class="gi">+</span>
<span class="gi">+    def _restore_delegate_auth_handler(self):</span>
<span class="gi">+        self.transport.auth_handler = self._delegate</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_gssapi_token(self, m):</span>
<span class="gi">+        client_token = m.get_string()</span>
<span class="gi">+        # use the client token as input to establish a secure</span>
<span class="gi">+        # context.</span>
<span class="gi">+        sshgss = self.sshgss</span>
<span class="gi">+        try:</span>
<span class="gi">+            token = sshgss.ssh_accept_sec_context(</span>
<span class="gi">+                self.gss_host, client_token, self.auth_username</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            self.transport.saved_exception = e</span>
<span class="gi">+            result = AUTH_FAILED</span>
<span class="gi">+            self._restore_delegate_auth_handler()</span>
<span class="gi">+            self._send_auth_result(self.auth_username, self.method, result)</span>
<span class="gi">+            raise</span>
<span class="gi">+        if token is not None:</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_GSSAPI_TOKEN)</span>
<span class="gi">+            m.add_string(token)</span>
<span class="gi">+            self.transport._expected_packet = (</span>
<span class="gi">+                MSG_USERAUTH_GSSAPI_TOKEN,</span>
<span class="gi">+                MSG_USERAUTH_GSSAPI_MIC,</span>
<span class="gi">+                MSG_USERAUTH_REQUEST,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_gssapi_mic(self, m):</span>
<span class="gi">+        mic_token = m.get_string()</span>
<span class="gi">+        sshgss = self.sshgss</span>
<span class="gi">+        username = self.auth_username</span>
<span class="gi">+        self._restore_delegate_auth_handler()</span>
<span class="gi">+        try:</span>
<span class="gi">+            sshgss.ssh_check_mic(</span>
<span class="gi">+                mic_token, self.transport.session_id, username</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            self.transport.saved_exception = e</span>
<span class="gi">+            result = AUTH_FAILED</span>
<span class="gi">+            self._send_auth_result(username, self.method, result)</span>
<span class="gi">+            raise</span>
<span class="gi">+        # TODO: Implement client credential saving.</span>
<span class="gi">+        # The OpenSSH server is able to create a TGT with the delegated</span>
<span class="gi">+        # client credentials, but this is not supported by GSS-API.</span>
<span class="gi">+        result = AUTH_SUCCESSFUL</span>
<span class="gi">+        self.transport.server_object.check_auth_gssapi_with_mic(</span>
<span class="gi">+            username, result</span>
<span class="gi">+        )</span>
<span class="gi">+        # okay, send result</span>
<span class="gi">+        self._send_auth_result(username, self.method, result)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_service_request(self, m):</span>
<span class="gi">+        self._restore_delegate_auth_handler()</span>
<span class="gi">+        return self._delegate._parse_service_request(m)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_request(self, m):</span>
<span class="gi">+        self._restore_delegate_auth_handler()</span>
<span class="gi">+        return self._delegate._parse_userauth_request(m)</span>
<span class="gi">+</span>
<span class="gi">+    __handler_table = {</span>
<span class="gi">+        MSG_SERVICE_REQUEST: _parse_service_request,</span>
<span class="w"> </span>        MSG_USERAUTH_REQUEST: _parse_userauth_request,
<span class="w"> </span>        MSG_USERAUTH_GSSAPI_TOKEN: _parse_userauth_gssapi_token,
<span class="gd">-        MSG_USERAUTH_GSSAPI_MIC: _parse_userauth_gssapi_mic}</span>
<span class="gi">+        MSG_USERAUTH_GSSAPI_MIC: _parse_userauth_gssapi_mic,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _handler_table(self):</span>
<span class="gi">+        # TODO: determine if we can cut this up like we did for the primary</span>
<span class="gi">+        # AuthHandler class.</span>
<span class="gi">+        return self.__handler_table</span>


<span class="w"> </span>class AuthOnlyHandler(AuthHandler):
<span class="gu">@@ -73,6 +972,16 @@ class AuthOnlyHandler(AuthHandler):</span>
<span class="w"> </span>    .. versionadded:: 3.2
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    # NOTE: this purposefully duplicates some of the parent class in order to</span>
<span class="gi">+    # modernize, refactor, etc. The intent is that eventually we will collapse</span>
<span class="gi">+    # this one onto the parent in a backwards incompatible release.</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _client_handler_table(self):</span>
<span class="gi">+        my_table = super()._client_handler_table.copy()</span>
<span class="gi">+        del my_table[MSG_SERVICE_ACCEPT]</span>
<span class="gi">+        return my_table</span>
<span class="gi">+</span>
<span class="w"> </span>    def send_auth_request(self, username, method, finish_message=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Submit a userauth request message &amp; wait for response.
<span class="gu">@@ -85,10 +994,99 @@ class AuthOnlyHandler(AuthHandler):</span>
<span class="w"> </span>        which accepts a Message ``m`` and may call mutator methods on it to add
<span class="w"> </span>        more fields.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Store a few things for reference in handlers, including auth failure</span>
<span class="gi">+        # handler (which needs to know if we were using a bad method, etc)</span>
<span class="gi">+        self.auth_method = method</span>
<span class="gi">+        self.username = username</span>
<span class="gi">+        # Generic userauth request fields</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_USERAUTH_REQUEST)</span>
<span class="gi">+        m.add_string(username)</span>
<span class="gi">+        m.add_string(&quot;ssh-connection&quot;)</span>
<span class="gi">+        m.add_string(method)</span>
<span class="gi">+        # Caller usually has more to say, such as injecting password, key etc</span>
<span class="gi">+        finish_message(m)</span>
<span class="gi">+        # TODO 4.0: seems odd to have the client handle the lock and not</span>
<span class="gi">+        # Transport; that _may_ have been an artifact of allowing user</span>
<span class="gi">+        # threading event injection? Regardless, we don&#39;t want to move _this_</span>
<span class="gi">+        # locking into Transport._send_message now, because lots of other</span>
<span class="gi">+        # untouched code also uses that method and we might end up</span>
<span class="gi">+        # double-locking (?) but 4.0 would be a good time to revisit.</span>
<span class="gi">+        with self.transport.lock:</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+        # We have cut out the higher level event args, but self.auth_event is</span>
<span class="gi">+        # still required for self.wait_for_response to function correctly (it&#39;s</span>
<span class="gi">+        # the mechanism used by the auth success/failure handlers, the abort</span>
<span class="gi">+        # handler, and a few other spots like in gssapi.</span>
<span class="gi">+        # TODO: interestingly, wait_for_response itself doesn&#39;t actually</span>
<span class="gi">+        # enforce that its event argument and self.auth_event are the same...</span>
<span class="gi">+        self.auth_event = threading.Event()</span>
<span class="gi">+        return self.wait_for_response(self.auth_event)</span>
<span class="gi">+</span>
<span class="gi">+    def auth_none(self, username):</span>
<span class="gi">+        return self.send_auth_request(username, &quot;none&quot;)</span>

<span class="gd">-    def auth_interactive(self, username, handler, submethods=&#39;&#39;):</span>
<span class="gi">+    def auth_publickey(self, username, key):</span>
<span class="gi">+        key_type, bits = self._get_key_type_and_bits(key)</span>
<span class="gi">+        algorithm = self._finalize_pubkey_algorithm(key_type)</span>
<span class="gi">+        blob = self._get_session_blob(</span>
<span class="gi">+            key,</span>
<span class="gi">+            &quot;ssh-connection&quot;,</span>
<span class="gi">+            username,</span>
<span class="gi">+            algorithm,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def finish(m):</span>
<span class="gi">+            # This field doesn&#39;t appear to be named, but is False when querying</span>
<span class="gi">+            # for permission (ie knowing whether to even prompt a user for</span>
<span class="gi">+            # passphrase, etc) or True when just going for it. Paramiko has</span>
<span class="gi">+            # never bothered with the former type of message, apparently.</span>
<span class="gi">+            m.add_boolean(True)</span>
<span class="gi">+            m.add_string(algorithm)</span>
<span class="gi">+            m.add_string(bits)</span>
<span class="gi">+            m.add_string(key.sign_ssh_data(blob, algorithm))</span>
<span class="gi">+</span>
<span class="gi">+        return self.send_auth_request(username, &quot;publickey&quot;, finish)</span>
<span class="gi">+</span>
<span class="gi">+    def auth_password(self, username, password):</span>
<span class="gi">+        def finish(m):</span>
<span class="gi">+            # Unnamed field that equates to &quot;I am changing my password&quot;, which</span>
<span class="gi">+            # Paramiko clientside never supported and serverside only sort of</span>
<span class="gi">+            # supported.</span>
<span class="gi">+            m.add_boolean(False)</span>
<span class="gi">+            m.add_string(b(password))</span>
<span class="gi">+</span>
<span class="gi">+        return self.send_auth_request(username, &quot;password&quot;, finish)</span>
<span class="gi">+</span>
<span class="gi">+    def auth_interactive(self, username, handler, submethods=&quot;&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        response_list = handler(title, instructions, prompt_list)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Unlike most siblings, this auth method _does_ require other</span>
<span class="gi">+        # superclass handlers (eg userauth info request) to understand</span>
<span class="gi">+        # what&#39;s going on, so we still set some self attributes.</span>
<span class="gi">+        self.auth_method = &quot;keyboard_interactive&quot;</span>
<span class="gi">+        self.interactive_handler = handler</span>
<span class="gi">+</span>
<span class="gi">+        def finish(m):</span>
<span class="gi">+            # Empty string for deprecated language tag field, per RFC 4256:</span>
<span class="gi">+            # https://www.rfc-editor.org/rfc/rfc4256#section-3.1</span>
<span class="gi">+            m.add_string(&quot;&quot;)</span>
<span class="gi">+            m.add_string(submethods)</span>
<span class="gi">+</span>
<span class="gi">+        return self.send_auth_request(username, &quot;keyboard-interactive&quot;, finish)</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: not strictly &#39;auth only&#39; related, but allows users to opt-in.</span>
<span class="gi">+    def _choose_fallback_pubkey_algorithm(self, key_type, my_algos):</span>
<span class="gi">+        msg = &quot;Server did not send a server-sig-algs list; defaulting to something in our preferred algorithms list&quot;  # noqa</span>
<span class="gi">+        self._log(DEBUG, msg)</span>
<span class="gi">+        noncert_key_type = key_type.replace(&quot;-cert-v01@openssh.com&quot;, &quot;&quot;)</span>
<span class="gi">+        if key_type in my_algos or noncert_key_type in my_algos:</span>
<span class="gi">+            actual = key_type if key_type in my_algos else noncert_key_type</span>
<span class="gi">+            msg = f&quot;Current key type, {actual!r}, is in our preferred list; using that&quot;  # noqa</span>
<span class="gi">+            algo = actual</span>
<span class="gi">+        else:</span>
<span class="gi">+            algo = my_algos[0]</span>
<span class="gi">+            msg = f&quot;{key_type!r} not in our list - trying first list item instead, {algo!r}&quot;  # noqa</span>
<span class="gi">+        self._log(DEBUG, msg)</span>
<span class="gi">+        return algo</span>
<span class="gh">diff --git a/paramiko/auth_strategy.py b/paramiko/auth_strategy.py</span>
<span class="gh">index 318c2713..03c1d877 100644</span>
<span class="gd">--- a/paramiko/auth_strategy.py</span>
<span class="gi">+++ b/paramiko/auth_strategy.py</span>
<span class="gu">@@ -4,7 +4,9 @@ Modern, adaptable authentication machinery.</span>
<span class="w"> </span>Replaces certain parts of `.SSHClient`. For a concrete implementation, see the
<span class="w"> </span>``OpenSSHAuthStrategy`` class in `Fabric &lt;https://fabfile.org&gt;`_.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import namedtuple
<span class="gi">+</span>
<span class="w"> </span>from .agent import AgentKey
<span class="w"> </span>from .util import get_logger
<span class="w"> </span>from .ssh_exception import AuthenticationException
<span class="gu">@@ -22,6 +24,13 @@ class AuthSource:</span>
<span class="w"> </span>    def __init__(self, username):
<span class="w"> </span>        self.username = username

<span class="gi">+    def _repr(self, **kwargs):</span>
<span class="gi">+        # TODO: are there any good libs for this? maybe some helper from</span>
<span class="gi">+        # structlog?</span>
<span class="gi">+        pairs = [f&quot;{k}={v!r}&quot; for k, v in kwargs.items()]</span>
<span class="gi">+        joined = &quot;, &quot;.join(pairs)</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({joined})&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return self._repr()

<span class="gu">@@ -29,7 +38,7 @@ class AuthSource:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Perform authentication.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class NoneAuth(AuthSource):
<span class="gu">@@ -37,6 +46,9 @@ class NoneAuth(AuthSource):</span>
<span class="w"> </span>    Auth type &quot;none&quot;, ie https://www.rfc-editor.org/rfc/rfc4252#section-5.2 .
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def authenticate(self, transport):</span>
<span class="gi">+        return transport.auth_none(self.username)</span>
<span class="gi">+</span>

<span class="w"> </span>class Password(AuthSource):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -58,9 +70,21 @@ class Password(AuthSource):</span>
<span class="w"> </span>        self.password_getter = password_getter

<span class="w"> </span>    def __repr__(self):
<span class="gi">+        # Password auth is marginally more &#39;username-caring&#39; than pkeys, so may</span>
<span class="gi">+        # as well log that info here.</span>
<span class="w"> </span>        return super()._repr(user=self.username)

<span class="gi">+    def authenticate(self, transport):</span>
<span class="gi">+        # Lazily get the password, in case it&#39;s prompting a user</span>
<span class="gi">+        # TODO: be nice to log source _of_ the password?</span>
<span class="gi">+        password = self.password_getter()</span>
<span class="gi">+        return transport.auth_password(self.username, password)</span>
<span class="gi">+</span>

<span class="gi">+# TODO 4.0: twiddle this, or PKey, or both, so they&#39;re more obviously distinct.</span>
<span class="gi">+# TODO 4.0: the obvious is to make this more wordy (PrivateKeyAuth), the</span>
<span class="gi">+# minimalist approach might be to rename PKey to just Key (esp given all the</span>
<span class="gi">+# subclasses are WhateverKey and not WhateverPKey)</span>
<span class="w"> </span>class PrivateKey(AuthSource):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Essentially a mixin for private keys.
<span class="gu">@@ -74,6 +98,9 @@ class PrivateKey(AuthSource):</span>
<span class="w"> </span>    its `super` call.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def authenticate(self, transport):</span>
<span class="gi">+        return transport.auth_publickey(self.username, self.pkey)</span>
<span class="gi">+</span>

<span class="w"> </span>class InMemoryPrivateKey(PrivateKey):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -82,12 +109,15 @@ class InMemoryPrivateKey(PrivateKey):</span>

<span class="w"> </span>    def __init__(self, username, pkey):
<span class="w"> </span>        super().__init__(username=username)
<span class="gi">+        # No decryption (presumably) necessary!</span>
<span class="w"> </span>        self.pkey = pkey

<span class="w"> </span>    def __repr__(self):
<span class="gi">+        # NOTE: most of interesting repr-bits for private keys is in PKey.</span>
<span class="gi">+        # TODO: tacking on agent-ness like this is a bit awkward, but, eh?</span>
<span class="w"> </span>        rep = super()._repr(pkey=self.pkey)
<span class="w"> </span>        if isinstance(self.pkey, AgentKey):
<span class="gd">-            rep += &#39; [agent]&#39;</span>
<span class="gi">+            rep += &quot; [agent]&quot;</span>
<span class="w"> </span>        return rep


<span class="gu">@@ -107,20 +137,34 @@ class OnDiskPrivateKey(PrivateKey):</span>
<span class="w"> </span>    def __init__(self, username, source, path, pkey):
<span class="w"> </span>        super().__init__(username=username)
<span class="w"> </span>        self.source = source
<span class="gd">-        allowed = &#39;ssh-config&#39;, &#39;python-config&#39;, &#39;implicit-home&#39;</span>
<span class="gi">+        allowed = (&quot;ssh-config&quot;, &quot;python-config&quot;, &quot;implicit-home&quot;)</span>
<span class="w"> </span>        if source not in allowed:
<span class="gd">-            raise ValueError(f&#39;source argument must be one of: {allowed!r}&#39;)</span>
<span class="gi">+            raise ValueError(f&quot;source argument must be one of: {allowed!r}&quot;)</span>
<span class="w"> </span>        self.path = path
<span class="gi">+        # Superclass wants .pkey, other two are mostly for display/debugging.</span>
<span class="w"> </span>        self.pkey = pkey

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return self._repr(key=self.pkey, source=self.source, path=str(self.</span>
<span class="gd">-            path))</span>
<span class="gi">+        return self._repr(</span>
<span class="gi">+            key=self.pkey, source=self.source, path=str(self.path)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="gi">+# TODO re sources: is there anything in an OpenSSH config file that doesn&#39;t fit</span>
<span class="gi">+# into what Paramiko already had kwargs for?</span>

<span class="gd">-SourceResult = namedtuple(&#39;SourceResult&#39;, [&#39;source&#39;, &#39;result&#39;])</span>

<span class="gi">+SourceResult = namedtuple(&quot;SourceResult&quot;, [&quot;source&quot;, &quot;result&quot;])</span>

<span class="gi">+# TODO: tempting to make this an OrderedDict, except the keys essentially want</span>
<span class="gi">+# to be rich objects (AuthSources) which do not make for useful user indexing?</span>
<span class="gi">+# TODO: members being vanilla tuples is pretty old-school/expedient; they</span>
<span class="gi">+# &quot;really&quot; want to be something that&#39;s type friendlier (unless the tuple&#39;s 2nd</span>
<span class="gi">+# member being a Union of two types is &quot;fine&quot;?), which I assume means yet more</span>
<span class="gi">+# classes, eg an abstract SourceResult with concrete AuthSuccess and</span>
<span class="gi">+# AuthFailure children?</span>
<span class="gi">+# TODO: arguably we want __init__ typechecking of the members (or to leverage</span>
<span class="gi">+# mypy by classifying this literally as list-of-AuthSource?)</span>
<span class="w"> </span>class AuthResult(list):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Represents a partial or complete SSH authentication attempt.
<span class="gu">@@ -157,10 +201,16 @@ class AuthResult(list):</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;\n&#39;.join(f&quot;{x.source} -&gt; {x.result or &#39;success&#39;}&quot; for x in self</span>
<span class="gd">-            )</span>
<span class="gi">+        # NOTE: meaningfully distinct from __repr__, which still wants to use</span>
<span class="gi">+        # superclass&#39; implementation.</span>
<span class="gi">+        # TODO: go hog wild, use rich.Table? how is that on degraded term&#39;s?</span>
<span class="gi">+        # TODO: test this lol</span>
<span class="gi">+        return &quot;\n&quot;.join(</span>
<span class="gi">+            f&quot;{x.source} -&gt; {x.result or &#39;success&#39;}&quot; for x in self</span>
<span class="gi">+        )</span>


<span class="gi">+# TODO 4.0: descend from SSHException or even just Exception</span>
<span class="w"> </span>class AuthFailure(AuthenticationException):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Basic exception wrapping an `AuthResult` indicating overall auth failure.
<span class="gu">@@ -176,7 +226,7 @@ class AuthFailure(AuthenticationException):</span>
<span class="w"> </span>        self.result = result

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;\n&#39; + str(self.result)</span>
<span class="gi">+        return &quot;\n&quot; + str(self.result)</span>


<span class="w"> </span>class AuthStrategy:
<span class="gu">@@ -188,7 +238,10 @@ class AuthStrategy:</span>
<span class="w"> </span>    their particular strategy.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, ssh_config):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ssh_config,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.ssh_config = ssh_config
<span class="w"> </span>        self.log = get_logger(__name__)

<span class="gu">@@ -202,7 +255,7 @@ class AuthStrategy:</span>
<span class="w"> </span>        Subclasses _of_ subclasses may find themselves wanting to do things
<span class="w"> </span>        like filtering or discarding around a call to `super`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def authenticate(self, transport):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -211,4 +264,43 @@ class AuthStrategy:</span>
<span class="w"> </span>        You *normally* won&#39;t need to override this, but it&#39;s an option for
<span class="w"> </span>        advanced users.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        succeeded = False</span>
<span class="gi">+        overall_result = AuthResult(strategy=self)</span>
<span class="gi">+        # TODO: arguably we could fit in a &quot;send none auth, record allowed auth</span>
<span class="gi">+        # types sent back&quot; thing here as OpenSSH-client does, but that likely</span>
<span class="gi">+        # wants to live in fabric.OpenSSHAuthStrategy as not all target servers</span>
<span class="gi">+        # will implement it!</span>
<span class="gi">+        # TODO: needs better &quot;server told us too many attempts&quot; checking!</span>
<span class="gi">+        for source in self.get_sources():</span>
<span class="gi">+            self.log.debug(f&quot;Trying {source}&quot;)</span>
<span class="gi">+            try:  # NOTE: this really wants to _only_ wrap the authenticate()!</span>
<span class="gi">+                result = source.authenticate(transport)</span>
<span class="gi">+                succeeded = True</span>
<span class="gi">+            # TODO: &#39;except PartialAuthentication&#39; is needed for 2FA and</span>
<span class="gi">+            # similar, as per old SSHClient.connect - it is the only way</span>
<span class="gi">+            # AuthHandler supplies access to the &#39;name-list&#39; field from</span>
<span class="gi">+            # MSG_USERAUTH_FAILURE, at present.</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                result = e</span>
<span class="gi">+                # TODO: look at what this could possibly raise, we don&#39;t really</span>
<span class="gi">+                # want Exception here, right? just SSHException subclasses? or</span>
<span class="gi">+                # do we truly want to capture anything at all with assumption</span>
<span class="gi">+                # it&#39;s easy enough for users to look afterwards?</span>
<span class="gi">+                # NOTE: showing type, not message, for tersity &amp; also most of</span>
<span class="gi">+                # the time it&#39;s basically just &quot;Authentication failed.&quot;</span>
<span class="gi">+                source_class = e.__class__.__name__</span>
<span class="gi">+                self.log.info(</span>
<span class="gi">+                    f&quot;Authentication via {source} failed with {source_class}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            overall_result.append(SourceResult(source, result))</span>
<span class="gi">+            if succeeded:</span>
<span class="gi">+                break</span>
<span class="gi">+        # Gotta die here if nothing worked, otherwise Transport&#39;s main loop</span>
<span class="gi">+        # just kinda hangs out until something times out!</span>
<span class="gi">+        if not succeeded:</span>
<span class="gi">+            raise AuthFailure(result=overall_result)</span>
<span class="gi">+        # Success: give back what was done, in case they care.</span>
<span class="gi">+        return overall_result</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: is there anything OpenSSH client does which _can&#39;t_ cleanly map to</span>
<span class="gi">+    # iterating a generator?</span>
<span class="gh">diff --git a/paramiko/ber.py b/paramiko/ber.py</span>
<span class="gh">index 18f67749..b8287f5d 100644</span>
<span class="gd">--- a/paramiko/ber.py</span>
<span class="gi">+++ b/paramiko/ber.py</span>
<span class="gu">@@ -1,4 +1,22 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="w"> </span>from paramiko.common import max_byte, zero_byte, byte_ord, byte_chr
<span class="gi">+</span>
<span class="w"> </span>import paramiko.util as util
<span class="w"> </span>from paramiko.util import b
<span class="w"> </span>from paramiko.sftp import int64
<span class="gu">@@ -17,8 +35,105 @@ class BER:</span>
<span class="w"> </span>        self.content = b(content)
<span class="w"> </span>        self.idx = 0

<span class="gi">+    def asbytes(self):</span>
<span class="gi">+        return self.content</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.asbytes()

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &quot;BER(&#39;&quot; + repr(self.content) + &quot;&#39;)&quot;
<span class="gi">+</span>
<span class="gi">+    def decode(self):</span>
<span class="gi">+        return self.decode_next()</span>
<span class="gi">+</span>
<span class="gi">+    def decode_next(self):</span>
<span class="gi">+        if self.idx &gt;= len(self.content):</span>
<span class="gi">+            return None</span>
<span class="gi">+        ident = byte_ord(self.content[self.idx])</span>
<span class="gi">+        self.idx += 1</span>
<span class="gi">+        if (ident &amp; 31) == 31:</span>
<span class="gi">+            # identifier &gt; 30</span>
<span class="gi">+            ident = 0</span>
<span class="gi">+            while self.idx &lt; len(self.content):</span>
<span class="gi">+                t = byte_ord(self.content[self.idx])</span>
<span class="gi">+                self.idx += 1</span>
<span class="gi">+                ident = (ident &lt;&lt; 7) | (t &amp; 0x7F)</span>
<span class="gi">+                if not (t &amp; 0x80):</span>
<span class="gi">+                    break</span>
<span class="gi">+        if self.idx &gt;= len(self.content):</span>
<span class="gi">+            return None</span>
<span class="gi">+        # now fetch length</span>
<span class="gi">+        size = byte_ord(self.content[self.idx])</span>
<span class="gi">+        self.idx += 1</span>
<span class="gi">+        if size &amp; 0x80:</span>
<span class="gi">+            # more complimicated...</span>
<span class="gi">+            # FIXME: theoretically should handle indefinite-length (0x80)</span>
<span class="gi">+            t = size &amp; 0x7F</span>
<span class="gi">+            if self.idx + t &gt; len(self.content):</span>
<span class="gi">+                return None</span>
<span class="gi">+            size = util.inflate_long(</span>
<span class="gi">+                self.content[self.idx : self.idx + t], True</span>
<span class="gi">+            )</span>
<span class="gi">+            self.idx += t</span>
<span class="gi">+        if self.idx + size &gt; len(self.content):</span>
<span class="gi">+            # can&#39;t fit</span>
<span class="gi">+            return None</span>
<span class="gi">+        data = self.content[self.idx : self.idx + size]</span>
<span class="gi">+        self.idx += size</span>
<span class="gi">+        # now switch on id</span>
<span class="gi">+        if ident == 0x30:</span>
<span class="gi">+            # sequence</span>
<span class="gi">+            return self.decode_sequence(data)</span>
<span class="gi">+        elif ident == 2:</span>
<span class="gi">+            # int</span>
<span class="gi">+            return util.inflate_long(data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # 1: boolean (00 false, otherwise true)</span>
<span class="gi">+            msg = &quot;Unknown ber encoding type {:d} (robey is lazy)&quot;</span>
<span class="gi">+            raise BERException(msg.format(ident))</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def decode_sequence(data):</span>
<span class="gi">+        out = []</span>
<span class="gi">+        ber = BER(data)</span>
<span class="gi">+        while True:</span>
<span class="gi">+            x = ber.decode_next()</span>
<span class="gi">+            if x is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            out.append(x)</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def encode_tlv(self, ident, val):</span>
<span class="gi">+        # no need to support ident &gt; 31 here</span>
<span class="gi">+        self.content += byte_chr(ident)</span>
<span class="gi">+        if len(val) &gt; 0x7F:</span>
<span class="gi">+            lenstr = util.deflate_long(len(val))</span>
<span class="gi">+            self.content += byte_chr(0x80 + len(lenstr)) + lenstr</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.content += byte_chr(len(val))</span>
<span class="gi">+        self.content += val</span>
<span class="gi">+</span>
<span class="gi">+    def encode(self, x):</span>
<span class="gi">+        if type(x) is bool:</span>
<span class="gi">+            if x:</span>
<span class="gi">+                self.encode_tlv(1, max_byte)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.encode_tlv(1, zero_byte)</span>
<span class="gi">+        elif (type(x) is int) or (type(x) is int64):</span>
<span class="gi">+            self.encode_tlv(2, util.deflate_long(x))</span>
<span class="gi">+        elif type(x) is str:</span>
<span class="gi">+            self.encode_tlv(4, x)</span>
<span class="gi">+        elif (type(x) is list) or (type(x) is tuple):</span>
<span class="gi">+            self.encode_tlv(0x30, self.encode_sequence(x))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise BERException(</span>
<span class="gi">+                &quot;Unknown type for encoding: {!r}&quot;.format(type(x))</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def encode_sequence(data):</span>
<span class="gi">+        ber = BER()</span>
<span class="gi">+        for item in data:</span>
<span class="gi">+            ber.encode(item)</span>
<span class="gi">+        return ber.asbytes()</span>
<span class="gh">diff --git a/paramiko/buffered_pipe.py b/paramiko/buffered_pipe.py</span>
<span class="gh">index 0e56ca4d..c19279c0 100644</span>
<span class="gd">--- a/paramiko/buffered_pipe.py</span>
<span class="gi">+++ b/paramiko/buffered_pipe.py</span>
<span class="gu">@@ -1,8 +1,27 @@</span>
<span class="gi">+# Copyright (C) 2006-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Attempt to generalize the &quot;feeder&quot; part of a `.Channel`: an object which can be
<span class="w"> </span>read from and closed, but is reading from a buffer fed by another thread.  The
<span class="w"> </span>read operations are blocking and can have a timeout set.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import array
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="gu">@@ -13,6 +32,7 @@ class PipeTimeout(IOError):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Indicates that a timeout was reached on a read from a `.BufferedPipe`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -27,9 +47,15 @@ class BufferedPipe:</span>
<span class="w"> </span>        self._lock = threading.Lock()
<span class="w"> </span>        self._cv = threading.Condition(self._lock)
<span class="w"> </span>        self._event = None
<span class="gd">-        self._buffer = array.array(&#39;B&#39;)</span>
<span class="gi">+        self._buffer = array.array(&quot;B&quot;)</span>
<span class="w"> </span>        self._closed = False

<span class="gi">+    def _buffer_frombytes(self, data):</span>
<span class="gi">+        self._buffer.frombytes(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _buffer_tobytes(self, limit=None):</span>
<span class="gi">+        return self._buffer[:limit].tobytes()</span>
<span class="gi">+</span>
<span class="w"> </span>    def set_event(self, event):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set an event on this buffer.  When data is ready to be read (or the
<span class="gu">@@ -38,7 +64,20 @@ class BufferedPipe:</span>

<span class="w"> </span>        :param threading.Event event: the event to set/clear
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._event = event</span>
<span class="gi">+            # Make sure the event starts in `set` state if we appear to already</span>
<span class="gi">+            # be closed; otherwise, if we start in `clear` state &amp; are closed,</span>
<span class="gi">+            # nothing will ever call `.feed` and the event (&amp; OS pipe, if we&#39;re</span>
<span class="gi">+            # wrapping one - see `Channel.fileno`) will permanently stay in</span>
<span class="gi">+            # `clear`, causing deadlock if e.g. `select`ed upon.</span>
<span class="gi">+            if self._closed or len(self._buffer) &gt; 0:</span>
<span class="gi">+                event.set()</span>
<span class="gi">+            else:</span>
<span class="gi">+                event.clear()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>

<span class="w"> </span>    def feed(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -47,7 +86,14 @@ class BufferedPipe:</span>

<span class="w"> </span>        :param data: the data to add, as a ``str`` or ``bytes``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self._event is not None:</span>
<span class="gi">+                self._event.set()</span>
<span class="gi">+            self._buffer_frombytes(b(data))</span>
<span class="gi">+            self._cv.notify_all()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>

<span class="w"> </span>    def read_ready(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -59,7 +105,13 @@ class BufferedPipe:</span>
<span class="w"> </span>            ``True`` if a `read` call would immediately return at least one
<span class="w"> </span>            byte; ``False`` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if len(self._buffer) == 0:</span>
<span class="gi">+                return False</span>
<span class="gi">+            return True</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>

<span class="w"> </span>    def read(self, nbytes, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -82,7 +134,38 @@ class BufferedPipe:</span>
<span class="w"> </span>            `.PipeTimeout` -- if a timeout was specified and no data was ready
<span class="w"> </span>            before that timeout
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        out = bytes()</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if len(self._buffer) == 0:</span>
<span class="gi">+                if self._closed:</span>
<span class="gi">+                    return out</span>
<span class="gi">+                # should we block?</span>
<span class="gi">+                if timeout == 0.0:</span>
<span class="gi">+                    raise PipeTimeout()</span>
<span class="gi">+                # loop here in case we get woken up but a different thread has</span>
<span class="gi">+                # grabbed everything in the buffer.</span>
<span class="gi">+                while (len(self._buffer) == 0) and not self._closed:</span>
<span class="gi">+                    then = time.time()</span>
<span class="gi">+                    self._cv.wait(timeout)</span>
<span class="gi">+                    if timeout is not None:</span>
<span class="gi">+                        timeout -= time.time() - then</span>
<span class="gi">+                        if timeout &lt;= 0.0:</span>
<span class="gi">+                            raise PipeTimeout()</span>
<span class="gi">+</span>
<span class="gi">+            # something&#39;s in the buffer and we have the lock!</span>
<span class="gi">+            if len(self._buffer) &lt;= nbytes:</span>
<span class="gi">+                out = self._buffer_tobytes()</span>
<span class="gi">+                del self._buffer[:]</span>
<span class="gi">+                if (self._event is not None) and not self._closed:</span>
<span class="gi">+                    self._event.clear()</span>
<span class="gi">+            else:</span>
<span class="gi">+                out = self._buffer_tobytes(nbytes)</span>
<span class="gi">+                del self._buffer[:nbytes]</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>
<span class="gi">+</span>
<span class="gi">+        return out</span>

<span class="w"> </span>    def empty(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -92,14 +175,29 @@ class BufferedPipe:</span>
<span class="w"> </span>            any data that was in the buffer prior to clearing it out, as a
<span class="w"> </span>            `str`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            out = self._buffer_tobytes()</span>
<span class="gi">+            del self._buffer[:]</span>
<span class="gi">+            if (self._event is not None) and not self._closed:</span>
<span class="gi">+                self._event.clear()</span>
<span class="gi">+            return out</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close this pipe object.  Future calls to `read` after the buffer
<span class="w"> </span>        has been emptied will return immediately with an empty string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+            self._cv.notify_all()</span>
<span class="gi">+            if self._event is not None:</span>
<span class="gi">+                self._event.set()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/channel.py b/paramiko/channel.py</span>
<span class="gh">index 45548521..2757450b 100644</span>
<span class="gd">--- a/paramiko/channel.py</span>
<span class="gi">+++ b/paramiko/channel.py</span>
<span class="gu">@@ -1,14 +1,46 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Abstraction for an SSH2 channel.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import os
<span class="w"> </span>import socket
<span class="w"> </span>import time
<span class="w"> </span>import threading
<span class="gi">+</span>
<span class="w"> </span>from functools import wraps
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="gd">-from paramiko.common import cMSG_CHANNEL_REQUEST, cMSG_CHANNEL_WINDOW_ADJUST, cMSG_CHANNEL_DATA, cMSG_CHANNEL_EXTENDED_DATA, DEBUG, ERROR, cMSG_CHANNEL_SUCCESS, cMSG_CHANNEL_FAILURE, cMSG_CHANNEL_EOF, cMSG_CHANNEL_CLOSE</span>
<span class="gi">+from paramiko.common import (</span>
<span class="gi">+    cMSG_CHANNEL_REQUEST,</span>
<span class="gi">+    cMSG_CHANNEL_WINDOW_ADJUST,</span>
<span class="gi">+    cMSG_CHANNEL_DATA,</span>
<span class="gi">+    cMSG_CHANNEL_EXTENDED_DATA,</span>
<span class="gi">+    DEBUG,</span>
<span class="gi">+    ERROR,</span>
<span class="gi">+    cMSG_CHANNEL_SUCCESS,</span>
<span class="gi">+    cMSG_CHANNEL_FAILURE,</span>
<span class="gi">+    cMSG_CHANNEL_EOF,</span>
<span class="gi">+    cMSG_CHANNEL_CLOSE,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="w"> </span>from paramiko.file import BufferedFile
<span class="gu">@@ -25,7 +57,19 @@ def open_only(func):</span>
<span class="w"> </span>        `.SSHException` -- If the wrapped method is called on an unopened
<span class="w"> </span>        `.Channel`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    @wraps(func)</span>
<span class="gi">+    def _check(self, *args, **kwds):</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.closed</span>
<span class="gi">+            or self.eof_received</span>
<span class="gi">+            or self.eof_sent</span>
<span class="gi">+            or not self.active</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise SSHException(&quot;Channel is not open&quot;)</span>
<span class="gi">+        return func(self, *args, **kwds)</span>
<span class="gi">+</span>
<span class="gi">+    return _check</span>


<span class="w"> </span>class Channel(ClosingContextManager):
<span class="gu">@@ -55,15 +99,20 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        :param int chanid:
<span class="w"> </span>            the ID of this channel, as passed by an existing `.Transport`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        #: Channel ID</span>
<span class="w"> </span>        self.chanid = chanid
<span class="gi">+        #: Remote channel ID</span>
<span class="w"> </span>        self.remote_chanid = 0
<span class="gi">+        #: `.Transport` managing this channel</span>
<span class="w"> </span>        self.transport = None
<span class="gi">+        #: Whether the connection is presently active</span>
<span class="w"> </span>        self.active = False
<span class="w"> </span>        self.eof_received = 0
<span class="w"> </span>        self.eof_sent = 0
<span class="w"> </span>        self.in_buffer = BufferedPipe()
<span class="w"> </span>        self.in_stderr_buffer = BufferedPipe()
<span class="w"> </span>        self.timeout = None
<span class="gi">+        #: Whether the connection has been closed</span>
<span class="w"> </span>        self.closed = False
<span class="w"> </span>        self.ultra_debug = False
<span class="w"> </span>        self.lock = threading.Lock()
<span class="gu">@@ -76,7 +125,7 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        self.in_window_sofar = 0
<span class="w"> </span>        self.status_event = threading.Event()
<span class="w"> </span>        self._name = str(chanid)
<span class="gd">-        self.logger = util.get_logger(&#39;paramiko.transport&#39;)</span>
<span class="gi">+        self.logger = util.get_logger(&quot;paramiko.transport&quot;)</span>
<span class="w"> </span>        self._pipe = None
<span class="w"> </span>        self.event = threading.Event()
<span class="w"> </span>        self.event_ready = False
<span class="gu">@@ -94,24 +143,30 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a string representation of this object, for debugging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        out = &#39;&lt;paramiko.Channel {}&#39;.format(self.chanid)</span>
<span class="gi">+        out = &quot;&lt;paramiko.Channel {}&quot;.format(self.chanid)</span>
<span class="w"> </span>        if self.closed:
<span class="gd">-            out += &#39; (closed)&#39;</span>
<span class="gi">+            out += &quot; (closed)&quot;</span>
<span class="w"> </span>        elif self.active:
<span class="w"> </span>            if self.eof_received:
<span class="gd">-                out += &#39; (EOF received)&#39;</span>
<span class="gi">+                out += &quot; (EOF received)&quot;</span>
<span class="w"> </span>            if self.eof_sent:
<span class="gd">-                out += &#39; (EOF sent)&#39;</span>
<span class="gd">-            out += &#39; (open) window={}&#39;.format(self.out_window_size)</span>
<span class="gi">+                out += &quot; (EOF sent)&quot;</span>
<span class="gi">+            out += &quot; (open) window={}&quot;.format(self.out_window_size)</span>
<span class="w"> </span>            if len(self.in_buffer) &gt; 0:
<span class="gd">-                out += &#39; in-buffer={}&#39;.format(len(self.in_buffer))</span>
<span class="gd">-        out += &#39; -&gt; &#39; + repr(self.transport)</span>
<span class="gd">-        out += &#39;&gt;&#39;</span>
<span class="gi">+                out += &quot; in-buffer={}&quot;.format(len(self.in_buffer))</span>
<span class="gi">+        out += &quot; -&gt; &quot; + repr(self.transport)</span>
<span class="gi">+        out += &quot;&gt;&quot;</span>
<span class="w"> </span>        return out

<span class="w"> </span>    @open_only
<span class="gd">-    def get_pty(self, term=&#39;vt100&#39;, width=80, height=24, width_pixels=0,</span>
<span class="gd">-        height_pixels=0):</span>
<span class="gi">+    def get_pty(</span>
<span class="gi">+        self,</span>
<span class="gi">+        term=&quot;vt100&quot;,</span>
<span class="gi">+        width=80,</span>
<span class="gi">+        height=24,</span>
<span class="gi">+        width_pixels=0,</span>
<span class="gi">+        height_pixels=0,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Request a pseudo-terminal from the server.  This is usually used right
<span class="w"> </span>        after creating a client channel, to ask the server to provide some
<span class="gu">@@ -130,7 +185,20 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;pty-req&quot;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        m.add_string(term)</span>
<span class="gi">+        m.add_int(width)</span>
<span class="gi">+        m.add_int(height)</span>
<span class="gi">+        m.add_int(width_pixels)</span>
<span class="gi">+        m.add_int(height_pixels)</span>
<span class="gi">+        m.add_string(bytes())</span>
<span class="gi">+        self._event_pending()</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self._wait_for_event()</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def invoke_shell(self):
<span class="gu">@@ -150,7 +218,14 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;shell&quot;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        self._event_pending()</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self._wait_for_event()</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def exec_command(self, command):
<span class="gu">@@ -169,7 +244,15 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;exec&quot;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        m.add_string(command)</span>
<span class="gi">+        self._event_pending()</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self._wait_for_event()</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def invoke_subsystem(self, subsystem):
<span class="gu">@@ -187,7 +270,15 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;subsystem&quot;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        m.add_string(subsystem)</span>
<span class="gi">+        self._event_pending()</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self._wait_for_event()</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def resize_pty(self, width=80, height=24, width_pixels=0, height_pixels=0):
<span class="gu">@@ -204,7 +295,16 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;window-change&quot;)</span>
<span class="gi">+        m.add_boolean(False)</span>
<span class="gi">+        m.add_int(width)</span>
<span class="gi">+        m.add_int(height)</span>
<span class="gi">+        m.add_int(width_pixels)</span>
<span class="gi">+        m.add_int(height_pixels)</span>
<span class="gi">+        self.transport._send_user_message(m)</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def update_environment(self, environment):
<span class="gu">@@ -225,7 +325,12 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if any of the environment variables was rejected
<span class="w"> </span>            by the server or the channel was closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, value in environment.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.set_environment_variable(name, value)</span>
<span class="gi">+            except SSHException as e:</span>
<span class="gi">+                err = &#39;Failed to set environment variable &quot;{}&quot;.&#39;</span>
<span class="gi">+                raise SSHException(err.format(name), e)</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def set_environment_variable(self, name, value):
<span class="gu">@@ -245,7 +350,14 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;env&quot;)</span>
<span class="gi">+        m.add_boolean(False)</span>
<span class="gi">+        m.add_string(name)</span>
<span class="gi">+        m.add_string(value)</span>
<span class="gi">+        self.transport._send_user_message(m)</span>

<span class="w"> </span>    def exit_status_ready(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -260,7 +372,7 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.7.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.closed or self.status_event.is_set()</span>

<span class="w"> </span>    def recv_exit_status(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -285,7 +397,9 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.status_event.wait()</span>
<span class="gi">+        assert self.status_event.is_set()</span>
<span class="gi">+        return self.exit_status</span>

<span class="w"> </span>    def send_exit_status(self, status):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -298,11 +412,25 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # in many cases, the channel will not still be open here.</span>
<span class="gi">+        # that&#39;s fine.</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;exit-status&quot;)</span>
<span class="gi">+        m.add_boolean(False)</span>
<span class="gi">+        m.add_int(status)</span>
<span class="gi">+        self.transport._send_user_message(m)</span>

<span class="w"> </span>    @open_only
<span class="gd">-    def request_x11(self, screen_number=0, auth_protocol=None, auth_cookie=</span>
<span class="gd">-        None, single_connection=False, handler=None):</span>
<span class="gi">+    def request_x11(</span>
<span class="gi">+        self,</span>
<span class="gi">+        screen_number=0,</span>
<span class="gi">+        auth_protocol=None,</span>
<span class="gi">+        auth_cookie=None,</span>
<span class="gi">+        single_connection=False,</span>
<span class="gi">+        handler=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Request an x11 session on this channel.  If the server allows it,
<span class="w"> </span>        further x11 requests can be made from the server to the client,
<span class="gu">@@ -341,7 +469,25 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            an optional callable handler to use for incoming X11 connections
<span class="w"> </span>        :return: the auth_cookie used
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if auth_protocol is None:</span>
<span class="gi">+            auth_protocol = &quot;MIT-MAGIC-COOKIE-1&quot;</span>
<span class="gi">+        if auth_cookie is None:</span>
<span class="gi">+            auth_cookie = binascii.hexlify(os.urandom(16))</span>
<span class="gi">+</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;x11-req&quot;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        m.add_boolean(single_connection)</span>
<span class="gi">+        m.add_string(auth_protocol)</span>
<span class="gi">+        m.add_string(auth_cookie)</span>
<span class="gi">+        m.add_int(screen_number)</span>
<span class="gi">+        self._event_pending()</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self._wait_for_event()</span>
<span class="gi">+        self.transport._set_x11_handler(handler)</span>
<span class="gi">+        return auth_cookie</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def request_forward_agent(self, handler):
<span class="gu">@@ -358,13 +504,20 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        :raises: SSHException in case of channel problem.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&quot;auth-agent-req@openssh.com&quot;)</span>
<span class="gi">+        m.add_boolean(False)</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self.transport._set_forward_agent_handler(handler)</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def get_transport(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the `.Transport` associated with this channel.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.transport</span>

<span class="w"> </span>    def set_name(self, name):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -374,13 +527,13 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        :param str name: new channel name
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._name = name</span>

<span class="w"> </span>    def get_name(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the name of this channel that was previously set by `set_name`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._name</span>

<span class="w"> </span>    def get_id(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -391,7 +544,7 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        `.ServerInterface.check_channel_request` when determining whether to
<span class="w"> </span>        accept a channel request in server mode.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.chanid</span>

<span class="w"> </span>    def set_combine_stderr(self, combine):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -414,7 +567,21 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = bytes()</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            old = self.combine_stderr</span>
<span class="gi">+            self.combine_stderr = combine</span>
<span class="gi">+            if combine and not old:</span>
<span class="gi">+                # copy old stderr buffer into primary buffer</span>
<span class="gi">+                data = self.in_stderr_buffer.empty()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        if len(data) &gt; 0:</span>
<span class="gi">+            self._feed(data)</span>
<span class="gi">+        return old</span>
<span class="gi">+</span>
<span class="gi">+    # ...socket API...</span>

<span class="w"> </span>    def settimeout(self, timeout):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -432,7 +599,7 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            seconds to wait for a pending read/write operation before raising
<span class="w"> </span>            ``socket.timeout``, or ``None`` for no timeout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.timeout = timeout</span>

<span class="w"> </span>    def gettimeout(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -440,7 +607,7 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        operations, or ``None`` if no timeout is set.  This reflects the last
<span class="w"> </span>        call to `setblocking` or `settimeout`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.timeout</span>

<span class="w"> </span>    def setblocking(self, blocking):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -460,7 +627,10 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        :param int blocking:
<span class="w"> </span>            0 to set non-blocking mode; non-0 to set blocking mode.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if blocking:</span>
<span class="gi">+            self.settimeout(None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.settimeout(0.0)</span>

<span class="w"> </span>    def getpeername(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -470,7 +640,7 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        socket-like interface to allow asyncore to work. (asyncore likes to
<span class="w"> </span>        call ``&#39;getpeername&#39;``.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.transport.getpeername()</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -479,7 +649,24 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        is flushed).  Channels are automatically closed when their `.Transport`
<span class="w"> </span>        is closed or when they are garbage collected.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            # only close the pipe when the user explicitly closes the channel.</span>
<span class="gi">+            # otherwise they will get unpleasant surprises.  (and do it before</span>
<span class="gi">+            # checking self.closed, since the remote host may have already</span>
<span class="gi">+            # closed the connection.)</span>
<span class="gi">+            if self._pipe is not None:</span>
<span class="gi">+                self._pipe.close()</span>
<span class="gi">+                self._pipe = None</span>
<span class="gi">+</span>
<span class="gi">+            if not self.active or self.closed:</span>
<span class="gi">+                return</span>
<span class="gi">+            msgs = self._close_internal()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        for m in msgs:</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                self.transport._send_user_message(m)</span>

<span class="w"> </span>    def recv_ready(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -491,7 +678,7 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            ``True`` if a `recv` call on this channel would immediately return
<span class="w"> </span>            at least one byte; ``False`` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.in_buffer.read_ready()</span>

<span class="w"> </span>    def recv(self, nbytes):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -506,7 +693,21 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        :raises socket.timeout:
<span class="w"> </span>            if no data is ready before the timeout set by `settimeout`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            out = self.in_buffer.read(nbytes, self.timeout)</span>
<span class="gi">+        except PipeTimeout:</span>
<span class="gi">+            raise socket.timeout()</span>
<span class="gi">+</span>
<span class="gi">+        ack = self._check_add_window(len(out))</span>
<span class="gi">+        # no need to hold the channel lock when sending this</span>
<span class="gi">+        if ack &gt; 0:</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_CHANNEL_WINDOW_ADJUST)</span>
<span class="gi">+            m.add_int(self.remote_chanid)</span>
<span class="gi">+            m.add_int(ack)</span>
<span class="gi">+            self.transport._send_user_message(m)</span>
<span class="gi">+</span>
<span class="gi">+        return out</span>

<span class="w"> </span>    def recv_stderr_ready(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -521,7 +722,7 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.in_stderr_buffer.read_ready()</span>

<span class="w"> </span>    def recv_stderr(self, nbytes):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -540,7 +741,21 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            out = self.in_stderr_buffer.read(nbytes, self.timeout)</span>
<span class="gi">+        except PipeTimeout:</span>
<span class="gi">+            raise socket.timeout()</span>
<span class="gi">+</span>
<span class="gi">+        ack = self._check_add_window(len(out))</span>
<span class="gi">+        # no need to hold the channel lock when sending this</span>
<span class="gi">+        if ack &gt; 0:</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_CHANNEL_WINDOW_ADJUST)</span>
<span class="gi">+            m.add_int(self.remote_chanid)</span>
<span class="gi">+            m.add_int(ack)</span>
<span class="gi">+            self.transport._send_user_message(m)</span>
<span class="gi">+</span>
<span class="gi">+        return out</span>

<span class="w"> </span>    def send_ready(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -555,7 +770,13 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            ``True`` if a `send` call on this channel would immediately succeed
<span class="w"> </span>            or fail
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.closed or self.eof_sent:</span>
<span class="gi">+                return True</span>
<span class="gi">+            return self.out_window_size &gt; 0</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>

<span class="w"> </span>    def send(self, s):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -571,7 +792,11 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        :raises socket.timeout: if no data could be sent before the timeout set
<span class="w"> </span>            by `settimeout`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_DATA)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        return self._send(s, m)</span>

<span class="w"> </span>    def send_stderr(self, s):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -590,7 +815,12 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_EXTENDED_DATA)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_int(1)</span>
<span class="gi">+        return self._send(s, m)</span>

<span class="w"> </span>    def sendall(self, s):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -610,7 +840,10 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            sent, there is no way to determine how much data (if any) was sent.
<span class="w"> </span>            This is irritating, but identically follows Python&#39;s API.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while s:</span>
<span class="gi">+            sent = self.send(s)</span>
<span class="gi">+            s = s[sent:]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def sendall_stderr(self, s):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -628,7 +861,10 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while s:</span>
<span class="gi">+            sent = self.send_stderr(s)</span>
<span class="gi">+            s = s[sent:]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def makefile(self, *params):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -638,7 +874,7 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        :return: `.ChannelFile` object which can be used for Python file I/O.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ChannelFile(*([self] + list(params)))</span>

<span class="w"> </span>    def makefile_stderr(self, *params):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -656,7 +892,7 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ChannelStderrFile(*([self] + list(params)))</span>

<span class="w"> </span>    def makefile_stdin(self, *params):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -673,7 +909,7 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 2.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ChannelStdinFile(*([self] + list(params)))</span>

<span class="w"> </span>    def fileno(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -692,7 +928,18 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        .. warning::
<span class="w"> </span>            This method causes channel reads to be slightly less efficient.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self._pipe is not None:</span>
<span class="gi">+                return self._pipe.fileno()</span>
<span class="gi">+            # create the pipe and feed in any existing data</span>
<span class="gi">+            self._pipe = pipe.make_pipe()</span>
<span class="gi">+            p1, p2 = pipe.make_or_pipe(self._pipe)</span>
<span class="gi">+            self.in_buffer.set_event(p1)</span>
<span class="gi">+            self.in_stderr_buffer.set_event(p2)</span>
<span class="gi">+            return self._pipe.fileno()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>

<span class="w"> </span>    def shutdown(self, how):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -705,7 +952,17 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            0 (stop receiving), 1 (stop sending), or 2 (stop receiving and
<span class="w"> </span>              sending).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (how == 0) or (how == 2):</span>
<span class="gi">+            # feign &quot;read&quot; shutdown</span>
<span class="gi">+            self.eof_received = 1</span>
<span class="gi">+        if (how == 1) or (how == 2):</span>
<span class="gi">+            self.lock.acquire()</span>
<span class="gi">+            try:</span>
<span class="gi">+                m = self._send_eof()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self.lock.release()</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                self.transport._send_user_message(m)</span>

<span class="w"> </span>    def shutdown_read(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -717,7 +974,7 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.shutdown(0)</span>

<span class="w"> </span>    def shutdown_write(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -729,7 +986,310 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.shutdown(1)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _closed(self):</span>
<span class="gi">+        # Concession to Python 3&#39;s socket API, which has a private ._closed</span>
<span class="gi">+        # attribute instead of a semipublic .closed attribute.</span>
<span class="gi">+        return self.closed</span>
<span class="gi">+</span>
<span class="gi">+    # ...calls from Transport</span>
<span class="gi">+</span>
<span class="gi">+    def _set_transport(self, transport):</span>
<span class="gi">+        self.transport = transport</span>
<span class="gi">+        self.logger = util.get_logger(self.transport.get_log_channel())</span>
<span class="gi">+</span>
<span class="gi">+    def _set_window(self, window_size, max_packet_size):</span>
<span class="gi">+        self.in_window_size = window_size</span>
<span class="gi">+        self.in_max_packet_size = max_packet_size</span>
<span class="gi">+        # threshold of bytes we receive before we bother to send</span>
<span class="gi">+        # a window update</span>
<span class="gi">+        self.in_window_threshold = window_size // 10</span>
<span class="gi">+        self.in_window_sofar = 0</span>
<span class="gi">+        self._log(DEBUG, &quot;Max packet in: {} bytes&quot;.format(max_packet_size))</span>
<span class="gi">+</span>
<span class="gi">+    def _set_remote_channel(self, chanid, window_size, max_packet_size):</span>
<span class="gi">+        self.remote_chanid = chanid</span>
<span class="gi">+        self.out_window_size = window_size</span>
<span class="gi">+        self.out_max_packet_size = self.transport._sanitize_packet_size(</span>
<span class="gi">+            max_packet_size</span>
<span class="gi">+        )</span>
<span class="gi">+        self.active = 1</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            DEBUG, &quot;Max packet out: {} bytes&quot;.format(self.out_max_packet_size)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _request_success(self, m):</span>
<span class="gi">+        self._log(DEBUG, &quot;Sesch channel {} request ok&quot;.format(self.chanid))</span>
<span class="gi">+        self.event_ready = True</span>
<span class="gi">+        self.event.set()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def _request_failed(self, m):</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            msgs = self._close_internal()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        for m in msgs:</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                self.transport._send_user_message(m)</span>
<span class="gi">+</span>
<span class="gi">+    def _feed(self, m):</span>
<span class="gi">+        if isinstance(m, bytes):</span>
<span class="gi">+            # passed from _feed_extended</span>
<span class="gi">+            s = m</span>
<span class="gi">+        else:</span>
<span class="gi">+            s = m.get_binary()</span>
<span class="gi">+        self.in_buffer.feed(s)</span>
<span class="gi">+</span>
<span class="gi">+    def _feed_extended(self, m):</span>
<span class="gi">+        code = m.get_int()</span>
<span class="gi">+        s = m.get_binary()</span>
<span class="gi">+        if code != 1:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                ERROR, &quot;unknown extended_data type {}; discarding&quot;.format(code)</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        if self.combine_stderr:</span>
<span class="gi">+            self._feed(s)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.in_stderr_buffer.feed(s)</span>
<span class="gi">+</span>
<span class="gi">+    def _window_adjust(self, m):</span>
<span class="gi">+        nbytes = m.get_int()</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.ultra_debug:</span>
<span class="gi">+                self._log(DEBUG, &quot;window up {}&quot;.format(nbytes))</span>
<span class="gi">+            self.out_window_size += nbytes</span>
<span class="gi">+            self.out_buffer_cv.notify_all()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_request(self, m):</span>
<span class="gi">+        key = m.get_text()</span>
<span class="gi">+        want_reply = m.get_boolean()</span>
<span class="gi">+        server = self.transport.server_object</span>
<span class="gi">+        ok = False</span>
<span class="gi">+        if key == &quot;exit-status&quot;:</span>
<span class="gi">+            self.exit_status = m.get_int()</span>
<span class="gi">+            self.status_event.set()</span>
<span class="gi">+            ok = True</span>
<span class="gi">+        elif key == &quot;xon-xoff&quot;:</span>
<span class="gi">+            # ignore</span>
<span class="gi">+            ok = True</span>
<span class="gi">+        elif key == &quot;pty-req&quot;:</span>
<span class="gi">+            term = m.get_string()</span>
<span class="gi">+            width = m.get_int()</span>
<span class="gi">+            height = m.get_int()</span>
<span class="gi">+            pixelwidth = m.get_int()</span>
<span class="gi">+            pixelheight = m.get_int()</span>
<span class="gi">+            modes = m.get_string()</span>
<span class="gi">+            if server is None:</span>
<span class="gi">+                ok = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                ok = server.check_channel_pty_request(</span>
<span class="gi">+                    self, term, width, height, pixelwidth, pixelheight, modes</span>
<span class="gi">+                )</span>
<span class="gi">+        elif key == &quot;shell&quot;:</span>
<span class="gi">+            if server is None:</span>
<span class="gi">+                ok = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                ok = server.check_channel_shell_request(self)</span>
<span class="gi">+        elif key == &quot;env&quot;:</span>
<span class="gi">+            name = m.get_string()</span>
<span class="gi">+            value = m.get_string()</span>
<span class="gi">+            if server is None:</span>
<span class="gi">+                ok = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                ok = server.check_channel_env_request(self, name, value)</span>
<span class="gi">+        elif key == &quot;exec&quot;:</span>
<span class="gi">+            cmd = m.get_string()</span>
<span class="gi">+            if server is None:</span>
<span class="gi">+                ok = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                ok = server.check_channel_exec_request(self, cmd)</span>
<span class="gi">+        elif key == &quot;subsystem&quot;:</span>
<span class="gi">+            name = m.get_text()</span>
<span class="gi">+            if server is None:</span>
<span class="gi">+                ok = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                ok = server.check_channel_subsystem_request(self, name)</span>
<span class="gi">+        elif key == &quot;window-change&quot;:</span>
<span class="gi">+            width = m.get_int()</span>
<span class="gi">+            height = m.get_int()</span>
<span class="gi">+            pixelwidth = m.get_int()</span>
<span class="gi">+            pixelheight = m.get_int()</span>
<span class="gi">+            if server is None:</span>
<span class="gi">+                ok = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                ok = server.check_channel_window_change_request(</span>
<span class="gi">+                    self, width, height, pixelwidth, pixelheight</span>
<span class="gi">+                )</span>
<span class="gi">+        elif key == &quot;x11-req&quot;:</span>
<span class="gi">+            single_connection = m.get_boolean()</span>
<span class="gi">+            auth_proto = m.get_text()</span>
<span class="gi">+            auth_cookie = m.get_binary()</span>
<span class="gi">+            screen_number = m.get_int()</span>
<span class="gi">+            if server is None:</span>
<span class="gi">+                ok = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                ok = server.check_channel_x11_request(</span>
<span class="gi">+                    self,</span>
<span class="gi">+                    single_connection,</span>
<span class="gi">+                    auth_proto,</span>
<span class="gi">+                    auth_cookie,</span>
<span class="gi">+                    screen_number,</span>
<span class="gi">+                )</span>
<span class="gi">+        elif key == &quot;auth-agent-req@openssh.com&quot;:</span>
<span class="gi">+            if server is None:</span>
<span class="gi">+                ok = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                ok = server.check_channel_forward_agent_request(self)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._log(DEBUG, &#39;Unhandled channel request &quot;{}&quot;&#39;.format(key))</span>
<span class="gi">+            ok = False</span>
<span class="gi">+        if want_reply:</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            if ok:</span>
<span class="gi">+                m.add_byte(cMSG_CHANNEL_SUCCESS)</span>
<span class="gi">+            else:</span>
<span class="gi">+                m.add_byte(cMSG_CHANNEL_FAILURE)</span>
<span class="gi">+            m.add_int(self.remote_chanid)</span>
<span class="gi">+            self.transport._send_user_message(m)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_eof(self, m):</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if not self.eof_received:</span>
<span class="gi">+                self.eof_received = True</span>
<span class="gi">+                self.in_buffer.close()</span>
<span class="gi">+                self.in_stderr_buffer.close()</span>
<span class="gi">+                if self._pipe is not None:</span>
<span class="gi">+                    self._pipe.set_forever()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        self._log(DEBUG, &quot;EOF received ({})&quot;.format(self._name))</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_close(self, m):</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            msgs = self._close_internal()</span>
<span class="gi">+            self.transport._unlink_channel(self.chanid)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        for m in msgs:</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                self.transport._send_user_message(m)</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _send(self, s, m):</span>
<span class="gi">+        size = len(s)</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.closed:</span>
<span class="gi">+                # this doesn&#39;t seem useful, but it is the documented behavior</span>
<span class="gi">+                # of Socket</span>
<span class="gi">+                raise socket.error(&quot;Socket is closed&quot;)</span>
<span class="gi">+            size = self._wait_for_send_window(size)</span>
<span class="gi">+            if size == 0:</span>
<span class="gi">+                # eof or similar</span>
<span class="gi">+                return 0</span>
<span class="gi">+            m.add_string(s[:size])</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        # Note: We release self.lock before calling _send_user_message.</span>
<span class="gi">+        # Otherwise, we can deadlock during re-keying.</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        return size</span>
<span class="gi">+</span>
<span class="gi">+    def _log(self, level, msg, *args):</span>
<span class="gi">+        self.logger.log(level, &quot;[chan &quot; + self._name + &quot;] &quot; + msg, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def _event_pending(self):</span>
<span class="gi">+        self.event.clear()</span>
<span class="gi">+        self.event_ready = False</span>
<span class="gi">+</span>
<span class="gi">+    def _wait_for_event(self):</span>
<span class="gi">+        self.event.wait()</span>
<span class="gi">+        assert self.event.is_set()</span>
<span class="gi">+        if self.event_ready:</span>
<span class="gi">+            return</span>
<span class="gi">+        e = self.transport.get_exception()</span>
<span class="gi">+        if e is None:</span>
<span class="gi">+            e = SSHException(&quot;Channel closed.&quot;)</span>
<span class="gi">+        raise e</span>
<span class="gi">+</span>
<span class="gi">+    def _set_closed(self):</span>
<span class="gi">+        # you are holding the lock.</span>
<span class="gi">+        self.closed = True</span>
<span class="gi">+        self.in_buffer.close()</span>
<span class="gi">+        self.in_stderr_buffer.close()</span>
<span class="gi">+        self.out_buffer_cv.notify_all()</span>
<span class="gi">+        # Notify any waiters that we are closed</span>
<span class="gi">+        self.event.set()</span>
<span class="gi">+        self.status_event.set()</span>
<span class="gi">+        if self._pipe is not None:</span>
<span class="gi">+            self._pipe.set_forever()</span>
<span class="gi">+</span>
<span class="gi">+    def _send_eof(self):</span>
<span class="gi">+        # you are holding the lock.</span>
<span class="gi">+        if self.eof_sent:</span>
<span class="gi">+            return None</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_EOF)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        self.eof_sent = True</span>
<span class="gi">+        self._log(DEBUG, &quot;EOF sent ({})&quot;.format(self._name))</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    def _close_internal(self):</span>
<span class="gi">+        # you are holding the lock.</span>
<span class="gi">+        if not self.active or self.closed:</span>
<span class="gi">+            return None, None</span>
<span class="gi">+        m1 = self._send_eof()</span>
<span class="gi">+        m2 = Message()</span>
<span class="gi">+        m2.add_byte(cMSG_CHANNEL_CLOSE)</span>
<span class="gi">+        m2.add_int(self.remote_chanid)</span>
<span class="gi">+        self._set_closed()</span>
<span class="gi">+        # can&#39;t unlink from the Transport yet -- the remote side may still</span>
<span class="gi">+        # try to send meta-data (exit-status, etc)</span>
<span class="gi">+        return m1, m2</span>
<span class="gi">+</span>
<span class="gi">+    def _unlink(self):</span>
<span class="gi">+        # server connection could die before we become active:</span>
<span class="gi">+        # still signal the close!</span>
<span class="gi">+        if self.closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._set_closed()</span>
<span class="gi">+            self.transport._unlink_channel(self.chanid)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def _check_add_window(self, n):</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.closed or self.eof_received or not self.active:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            if self.ultra_debug:</span>
<span class="gi">+                self._log(DEBUG, &quot;addwindow {}&quot;.format(n))</span>
<span class="gi">+            self.in_window_sofar += n</span>
<span class="gi">+            if self.in_window_sofar &lt;= self.in_window_threshold:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            if self.ultra_debug:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG, &quot;addwindow send {}&quot;.format(self.in_window_sofar)</span>
<span class="gi">+                )</span>
<span class="gi">+            out = self.in_window_sofar</span>
<span class="gi">+            self.in_window_sofar = 0</span>
<span class="gi">+            return out</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>

<span class="w"> </span>    def _wait_for_send_window(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -739,7 +1299,36 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        exception is raised.  Returns the number of bytes available to send
<span class="w"> </span>        (may be less than requested).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # you are already holding the lock</span>
<span class="gi">+        if self.closed or self.eof_sent:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if self.out_window_size == 0:</span>
<span class="gi">+            # should we block?</span>
<span class="gi">+            if self.timeout == 0.0:</span>
<span class="gi">+                raise socket.timeout()</span>
<span class="gi">+            # loop here in case we get woken up but a different thread has</span>
<span class="gi">+            # filled the buffer</span>
<span class="gi">+            timeout = self.timeout</span>
<span class="gi">+            while self.out_window_size == 0:</span>
<span class="gi">+                if self.closed or self.eof_sent:</span>
<span class="gi">+                    return 0</span>
<span class="gi">+                then = time.time()</span>
<span class="gi">+                self.out_buffer_cv.wait(timeout)</span>
<span class="gi">+                if timeout is not None:</span>
<span class="gi">+                    timeout -= time.time() - then</span>
<span class="gi">+                    if timeout &lt;= 0.0:</span>
<span class="gi">+                        raise socket.timeout()</span>
<span class="gi">+        # we have some window to squeeze into</span>
<span class="gi">+        if self.closed or self.eof_sent:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if self.out_window_size &lt; size:</span>
<span class="gi">+            size = self.out_window_size</span>
<span class="gi">+        if self.out_max_packet_size - 64 &lt; size:</span>
<span class="gi">+            size = self.out_max_packet_size - 64</span>
<span class="gi">+        self.out_window_size -= size</span>
<span class="gi">+        if self.ultra_debug:</span>
<span class="gi">+            self._log(DEBUG, &quot;window down to {}&quot;.format(self.out_window_size))</span>
<span class="gi">+        return size</span>


<span class="w"> </span>class ChannelFile(BufferedFile):
<span class="gu">@@ -755,7 +1344,7 @@ class ChannelFile(BufferedFile):</span>
<span class="w"> </span>        flush the buffer.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, channel, mode=&#39;r&#39;, bufsize=-1):</span>
<span class="gi">+    def __init__(self, channel, mode=&quot;r&quot;, bufsize=-1):</span>
<span class="w"> </span>        self.channel = channel
<span class="w"> </span>        BufferedFile.__init__(self)
<span class="w"> </span>        self._set_mode(mode, bufsize)
<span class="gu">@@ -764,7 +1353,14 @@ class ChannelFile(BufferedFile):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a string representation of this object, for debugging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;&lt;paramiko.ChannelFile from &#39; + repr(self.channel) + &#39;&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;paramiko.ChannelFile from &quot; + repr(self.channel) + &quot;&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _read(self, size):</span>
<span class="gi">+        return self.channel.recv(size)</span>
<span class="gi">+</span>
<span class="gi">+    def _write(self, data):</span>
<span class="gi">+        self.channel.sendall(data)</span>
<span class="gi">+        return len(data)</span>


<span class="w"> </span>class ChannelStderrFile(ChannelFile):
<span class="gu">@@ -774,6 +1370,13 @@ class ChannelStderrFile(ChannelFile):</span>
<span class="w"> </span>    See `Channel.makefile_stderr` for details.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def _read(self, size):</span>
<span class="gi">+        return self.channel.recv_stderr(size)</span>
<span class="gi">+</span>
<span class="gi">+    def _write(self, data):</span>
<span class="gi">+        self.channel.sendall_stderr(data)</span>
<span class="gi">+        return len(data)</span>
<span class="gi">+</span>

<span class="w"> </span>class ChannelStdinFile(ChannelFile):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -781,3 +1384,7 @@ class ChannelStdinFile(ChannelFile):</span>

<span class="w"> </span>    See `Channel.makefile_stdin` for details.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        super().close()</span>
<span class="gi">+        self.channel.shutdown_write()</span>
<span class="gh">diff --git a/paramiko/client.py b/paramiko/client.py</span>
<span class="gh">index a04a5244..d8be9108 100644</span>
<span class="gd">--- a/paramiko/client.py</span>
<span class="gi">+++ b/paramiko/client.py</span>
<span class="gu">@@ -1,6 +1,25 @@</span>
<span class="gi">+# Copyright (C) 2006-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>SSH client &amp; key policies
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from binascii import hexlify
<span class="w"> </span>import getpass
<span class="w"> </span>import inspect
<span class="gu">@@ -8,6 +27,7 @@ import os</span>
<span class="w"> </span>import socket
<span class="w"> </span>import warnings
<span class="w"> </span>from errno import ECONNREFUSED, EHOSTUNREACH
<span class="gi">+</span>
<span class="w"> </span>from paramiko.agent import Agent
<span class="w"> </span>from paramiko.common import DEBUG
<span class="w"> </span>from paramiko.config import SSH_PORT
<span class="gu">@@ -16,7 +36,11 @@ from paramiko.ecdsakey import ECDSAKey</span>
<span class="w"> </span>from paramiko.ed25519key import Ed25519Key
<span class="w"> </span>from paramiko.hostkeys import HostKeys
<span class="w"> </span>from paramiko.rsakey import RSAKey
<span class="gd">-from paramiko.ssh_exception import SSHException, BadHostKeyException, NoValidConnectionsError</span>
<span class="gi">+from paramiko.ssh_exception import (</span>
<span class="gi">+    SSHException,</span>
<span class="gi">+    BadHostKeyException,</span>
<span class="gi">+    NoValidConnectionsError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.transport import Transport
<span class="w"> </span>from paramiko.util import ClosingContextManager

<span class="gu">@@ -72,7 +96,15 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>        :raises: ``IOError`` --
<span class="w"> </span>            if a filename was provided and the file could not be read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if filename is None:</span>
<span class="gi">+            # try the user&#39;s .ssh key file, and mask exceptions</span>
<span class="gi">+            filename = os.path.expanduser(&quot;~/.ssh/known_hosts&quot;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._system_host_keys.load(filename)</span>
<span class="gi">+            except IOError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            return</span>
<span class="gi">+        self._system_host_keys.load(filename)</span>

<span class="w"> </span>    def load_host_keys(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -90,7 +122,8 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the filename could not be read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._host_keys_filename = filename</span>
<span class="gi">+        self._host_keys.load(filename)</span>

<span class="w"> </span>    def save_host_keys(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -102,7 +135,20 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the file could not be written
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # update local host keys from file (in case other SSH clients</span>
<span class="gi">+        # have written to the known_hosts file meanwhile.</span>
<span class="gi">+        if self._host_keys_filename is not None:</span>
<span class="gi">+            self.load_host_keys(self._host_keys_filename)</span>
<span class="gi">+</span>
<span class="gi">+        with open(filename, &quot;w&quot;) as f:</span>
<span class="gi">+            for hostname, keys in self._host_keys.items():</span>
<span class="gi">+                for keytype, key in keys.items():</span>
<span class="gi">+                    f.write(</span>
<span class="gi">+                        &quot;{} {} {}\n&quot;.format(</span>
<span class="gi">+                            hostname, keytype, key.get_base64()</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>

<span class="w"> </span>    def get_host_keys(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -111,7 +157,7 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :return: the local host keys as a `.HostKeys` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._host_keys</span>

<span class="w"> </span>    def set_log_channel(self, name):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -120,7 +166,7 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :param str name: new channel name for logging
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._log_channel = name</span>

<span class="w"> </span>    def set_missing_host_key_policy(self, policy):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -140,7 +186,9 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>            the policy to use when receiving a host key from a
<span class="w"> </span>            previously-unknown server
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if inspect.isclass(policy):</span>
<span class="gi">+            policy = policy()</span>
<span class="gi">+        self._policy = policy</span>

<span class="w"> </span>    def _families_and_addresses(self, hostname, port):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -150,15 +198,48 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>        :param int port: the server port to connect to
<span class="w"> </span>        :returns: Yields an iterable of ``(family, address)`` tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def connect(self, hostname, port=SSH_PORT, username=None, password=None,</span>
<span class="gd">-        pkey=None, key_filename=None, timeout=None, allow_agent=True,</span>
<span class="gd">-        look_for_keys=True, compress=False, sock=None, gss_auth=False,</span>
<span class="gd">-        gss_kex=False, gss_deleg_creds=True, gss_host=None, banner_timeout=</span>
<span class="gd">-        None, auth_timeout=None, channel_timeout=None, gss_trust_dns=True,</span>
<span class="gd">-        passphrase=None, disabled_algorithms=None, transport_factory=None,</span>
<span class="gd">-        auth_strategy=None):</span>
<span class="gi">+        guess = True</span>
<span class="gi">+        addrinfos = socket.getaddrinfo(</span>
<span class="gi">+            hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM</span>
<span class="gi">+        )</span>
<span class="gi">+        for (family, socktype, proto, canonname, sockaddr) in addrinfos:</span>
<span class="gi">+            if socktype == socket.SOCK_STREAM:</span>
<span class="gi">+                yield family, sockaddr</span>
<span class="gi">+                guess = False</span>
<span class="gi">+</span>
<span class="gi">+        # some OS like AIX don&#39;t indicate SOCK_STREAM support, so just</span>
<span class="gi">+        # guess. :(  We only do this if we did not get a single result marked</span>
<span class="gi">+        # as socktype == SOCK_STREAM.</span>
<span class="gi">+        if guess:</span>
<span class="gi">+            for family, _, _, _, sockaddr in addrinfos:</span>
<span class="gi">+                yield family, sockaddr</span>
<span class="gi">+</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        hostname,</span>
<span class="gi">+        port=SSH_PORT,</span>
<span class="gi">+        username=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        pkey=None,</span>
<span class="gi">+        key_filename=None,</span>
<span class="gi">+        timeout=None,</span>
<span class="gi">+        allow_agent=True,</span>
<span class="gi">+        look_for_keys=True,</span>
<span class="gi">+        compress=False,</span>
<span class="gi">+        sock=None,</span>
<span class="gi">+        gss_auth=False,</span>
<span class="gi">+        gss_kex=False,</span>
<span class="gi">+        gss_deleg_creds=True,</span>
<span class="gi">+        gss_host=None,</span>
<span class="gi">+        banner_timeout=None,</span>
<span class="gi">+        auth_timeout=None,</span>
<span class="gi">+        channel_timeout=None,</span>
<span class="gi">+        gss_trust_dns=True,</span>
<span class="gi">+        passphrase=None,</span>
<span class="gi">+        disabled_algorithms=None,</span>
<span class="gi">+        transport_factory=None,</span>
<span class="gi">+        auth_strategy=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Connect to an SSH server and authenticate to it.  The server&#39;s host key
<span class="w"> </span>        is checked against the system host keys (see `load_system_host_keys`)
<span class="gu">@@ -290,7 +371,130 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 3.2
<span class="w"> </span>            Added the ``auth_strategy`` argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not sock:</span>
<span class="gi">+            errors = {}</span>
<span class="gi">+            # Try multiple possible address families (e.g. IPv4 vs IPv6)</span>
<span class="gi">+            to_try = list(self._families_and_addresses(hostname, port))</span>
<span class="gi">+            for af, addr in to_try:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    sock = socket.socket(af, socket.SOCK_STREAM)</span>
<span class="gi">+                    if timeout is not None:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            sock.settimeout(timeout)</span>
<span class="gi">+                        except:</span>
<span class="gi">+                            pass</span>
<span class="gi">+                    sock.connect(addr)</span>
<span class="gi">+                    # Break out of the loop on success</span>
<span class="gi">+                    break</span>
<span class="gi">+                except socket.error as e:</span>
<span class="gi">+                    # As mentioned in socket docs it is better</span>
<span class="gi">+                    # to close sockets explicitly</span>
<span class="gi">+                    if sock:</span>
<span class="gi">+                        sock.close()</span>
<span class="gi">+                    # Raise anything that isn&#39;t a straight up connection error</span>
<span class="gi">+                    # (such as a resolution error)</span>
<span class="gi">+                    if e.errno not in (ECONNREFUSED, EHOSTUNREACH):</span>
<span class="gi">+                        raise</span>
<span class="gi">+                    # Capture anything else so we know how the run looks once</span>
<span class="gi">+                    # iteration is complete. Retain info about which attempt</span>
<span class="gi">+                    # this was.</span>
<span class="gi">+                    errors[addr] = e</span>
<span class="gi">+</span>
<span class="gi">+            # Make sure we explode usefully if no address family attempts</span>
<span class="gi">+            # succeeded. We&#39;ve no way of knowing which error is the &quot;right&quot;</span>
<span class="gi">+            # one, so we construct a hybrid exception containing all the real</span>
<span class="gi">+            # ones, of a subclass that client code should still be watching for</span>
<span class="gi">+            # (socket.error)</span>
<span class="gi">+            if len(errors) == len(to_try):</span>
<span class="gi">+                raise NoValidConnectionsError(errors)</span>
<span class="gi">+</span>
<span class="gi">+        if transport_factory is None:</span>
<span class="gi">+            transport_factory = Transport</span>
<span class="gi">+        t = self._transport = transport_factory(</span>
<span class="gi">+            sock,</span>
<span class="gi">+            gss_kex=gss_kex,</span>
<span class="gi">+            gss_deleg_creds=gss_deleg_creds,</span>
<span class="gi">+            disabled_algorithms=disabled_algorithms,</span>
<span class="gi">+        )</span>
<span class="gi">+        t.use_compression(compress=compress)</span>
<span class="gi">+        t.set_gss_host(</span>
<span class="gi">+            # t.hostname may be None, but GSS-API requires a target name.</span>
<span class="gi">+            # Therefore use hostname as fallback.</span>
<span class="gi">+            gss_host=gss_host or hostname,</span>
<span class="gi">+            trust_dns=gss_trust_dns,</span>
<span class="gi">+            gssapi_requested=gss_auth or gss_kex,</span>
<span class="gi">+        )</span>
<span class="gi">+        if self._log_channel is not None:</span>
<span class="gi">+            t.set_log_channel(self._log_channel)</span>
<span class="gi">+        if banner_timeout is not None:</span>
<span class="gi">+            t.banner_timeout = banner_timeout</span>
<span class="gi">+        if auth_timeout is not None:</span>
<span class="gi">+            t.auth_timeout = auth_timeout</span>
<span class="gi">+        if channel_timeout is not None:</span>
<span class="gi">+            t.channel_timeout = channel_timeout</span>
<span class="gi">+</span>
<span class="gi">+        if port == SSH_PORT:</span>
<span class="gi">+            server_hostkey_name = hostname</span>
<span class="gi">+        else:</span>
<span class="gi">+            server_hostkey_name = &quot;[{}]:{}&quot;.format(hostname, port)</span>
<span class="gi">+        our_server_keys = None</span>
<span class="gi">+</span>
<span class="gi">+        our_server_keys = self._system_host_keys.get(server_hostkey_name)</span>
<span class="gi">+        if our_server_keys is None:</span>
<span class="gi">+            our_server_keys = self._host_keys.get(server_hostkey_name)</span>
<span class="gi">+        if our_server_keys is not None:</span>
<span class="gi">+            keytype = our_server_keys.keys()[0]</span>
<span class="gi">+            sec_opts = t.get_security_options()</span>
<span class="gi">+            other_types = [x for x in sec_opts.key_types if x != keytype]</span>
<span class="gi">+            sec_opts.key_types = [keytype] + other_types</span>
<span class="gi">+</span>
<span class="gi">+        t.start_client(timeout=timeout)</span>
<span class="gi">+</span>
<span class="gi">+        # If GSS-API Key Exchange is performed we are not required to check the</span>
<span class="gi">+        # host key, because the host is authenticated via GSS-API / SSPI as</span>
<span class="gi">+        # well as our client.</span>
<span class="gi">+        if not self._transport.gss_kex_used:</span>
<span class="gi">+            server_key = t.get_remote_server_key()</span>
<span class="gi">+            if our_server_keys is None:</span>
<span class="gi">+                # will raise exception if the key is rejected</span>
<span class="gi">+                self._policy.missing_host_key(</span>
<span class="gi">+                    self, server_hostkey_name, server_key</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                our_key = our_server_keys.get(server_key.get_name())</span>
<span class="gi">+                if our_key != server_key:</span>
<span class="gi">+                    if our_key is None:</span>
<span class="gi">+                        our_key = list(our_server_keys.values())[0]</span>
<span class="gi">+                    raise BadHostKeyException(hostname, server_key, our_key)</span>
<span class="gi">+</span>
<span class="gi">+        if username is None:</span>
<span class="gi">+            username = getpass.getuser()</span>
<span class="gi">+</span>
<span class="gi">+        # New auth flow!</span>
<span class="gi">+        if auth_strategy is not None:</span>
<span class="gi">+            return auth_strategy.authenticate(transport=t)</span>
<span class="gi">+</span>
<span class="gi">+        # Old auth flow!</span>
<span class="gi">+        if key_filename is None:</span>
<span class="gi">+            key_filenames = []</span>
<span class="gi">+        elif isinstance(key_filename, str):</span>
<span class="gi">+            key_filenames = [key_filename]</span>
<span class="gi">+        else:</span>
<span class="gi">+            key_filenames = key_filename</span>
<span class="gi">+</span>
<span class="gi">+        self._auth(</span>
<span class="gi">+            username,</span>
<span class="gi">+            password,</span>
<span class="gi">+            pkey,</span>
<span class="gi">+            key_filenames,</span>
<span class="gi">+            allow_agent,</span>
<span class="gi">+            look_for_keys,</span>
<span class="gi">+            gss_auth,</span>
<span class="gi">+            gss_kex,</span>
<span class="gi">+            gss_deleg_creds,</span>
<span class="gi">+            t.gss_host,</span>
<span class="gi">+            passphrase,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -304,10 +508,23 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>            reliable. Failure to explicitly close your client after use may
<span class="w"> </span>            lead to end-of-process hangs!
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._transport is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._transport.close()</span>
<span class="gi">+        self._transport = None</span>

<span class="gd">-    def exec_command(self, command, bufsize=-1, timeout=None, get_pty=False,</span>
<span class="gd">-        environment=None):</span>
<span class="gi">+        if self._agent is not None:</span>
<span class="gi">+            self._agent.close()</span>
<span class="gi">+            self._agent = None</span>
<span class="gi">+</span>
<span class="gi">+    def exec_command(</span>
<span class="gi">+        self,</span>
<span class="gi">+        command,</span>
<span class="gi">+        bufsize=-1,</span>
<span class="gi">+        timeout=None,</span>
<span class="gi">+        get_pty=False,</span>
<span class="gi">+        environment=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Execute a command on the SSH server.  A new `.Channel` is opened and
<span class="w"> </span>        the requested command is executed.  The command&#39;s input and output
<span class="gu">@@ -340,10 +557,27 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 1.10
<span class="w"> </span>            Added the ``get_pty`` kwarg.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def invoke_shell(self, term=&#39;vt100&#39;, width=80, height=24, width_pixels=</span>
<span class="gd">-        0, height_pixels=0, environment=None):</span>
<span class="gi">+        chan = self._transport.open_session(timeout=timeout)</span>
<span class="gi">+        if get_pty:</span>
<span class="gi">+            chan.get_pty()</span>
<span class="gi">+        chan.settimeout(timeout)</span>
<span class="gi">+        if environment:</span>
<span class="gi">+            chan.update_environment(environment)</span>
<span class="gi">+        chan.exec_command(command)</span>
<span class="gi">+        stdin = chan.makefile_stdin(&quot;wb&quot;, bufsize)</span>
<span class="gi">+        stdout = chan.makefile(&quot;r&quot;, bufsize)</span>
<span class="gi">+        stderr = chan.makefile_stderr(&quot;r&quot;, bufsize)</span>
<span class="gi">+        return stdin, stdout, stderr</span>
<span class="gi">+</span>
<span class="gi">+    def invoke_shell(</span>
<span class="gi">+        self,</span>
<span class="gi">+        term=&quot;vt100&quot;,</span>
<span class="gi">+        width=80,</span>
<span class="gi">+        height=24,</span>
<span class="gi">+        width_pixels=0,</span>
<span class="gi">+        height_pixels=0,</span>
<span class="gi">+        environment=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start an interactive shell session on the SSH server.  A new `.Channel`
<span class="w"> </span>        is opened and connected to a pseudo-terminal using the requested
<span class="gu">@@ -360,7 +594,10 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :raises: `.SSHException` -- if the server fails to invoke a shell
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        chan = self._transport.open_session()</span>
<span class="gi">+        chan.get_pty(term, width, height, width_pixels, height_pixels)</span>
<span class="gi">+        chan.invoke_shell()</span>
<span class="gi">+        return chan</span>

<span class="w"> </span>    def open_sftp(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -368,7 +605,7 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :return: a new `.SFTPClient` session object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._transport.open_sftp_client()</span>

<span class="w"> </span>    def get_transport(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -378,7 +615,7 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :return: the `.Transport` for this connection
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._transport</span>

<span class="w"> </span>    def _key_from_filepath(self, filename, klass, password):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -389,11 +626,43 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>        - Otherwise, the filename is assumed to be a private key, and the
<span class="w"> </span>          matching public cert will be loaded if it exists.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _auth(self, username, password, pkey, key_filenames, allow_agent,</span>
<span class="gd">-        look_for_keys, gss_auth, gss_kex, gss_deleg_creds, gss_host, passphrase</span>
<span class="gd">-        ):</span>
<span class="gi">+        cert_suffix = &quot;-cert.pub&quot;</span>
<span class="gi">+        # Assume privkey, not cert, by default</span>
<span class="gi">+        if filename.endswith(cert_suffix):</span>
<span class="gi">+            key_path = filename[: -len(cert_suffix)]</span>
<span class="gi">+            cert_path = filename</span>
<span class="gi">+        else:</span>
<span class="gi">+            key_path = filename</span>
<span class="gi">+            cert_path = filename + cert_suffix</span>
<span class="gi">+        # Blindly try the key path; if no private key, nothing will work.</span>
<span class="gi">+        key = klass.from_private_key_file(key_path, password)</span>
<span class="gi">+        # TODO: change this to &#39;Loading&#39; instead of &#39;Trying&#39; sometime; probably</span>
<span class="gi">+        # when #387 is released, since this is a critical log message users are</span>
<span class="gi">+        # likely testing/filtering for (bah.)</span>
<span class="gi">+        msg = &quot;Trying discovered key {} in {}&quot;.format(</span>
<span class="gi">+            hexlify(key.get_fingerprint()), key_path</span>
<span class="gi">+        )</span>
<span class="gi">+        self._log(DEBUG, msg)</span>
<span class="gi">+        # Attempt to load cert if it exists.</span>
<span class="gi">+        if os.path.isfile(cert_path):</span>
<span class="gi">+            key.load_certificate(cert_path)</span>
<span class="gi">+            self._log(DEBUG, &quot;Adding public certificate {}&quot;.format(cert_path))</span>
<span class="gi">+        return key</span>
<span class="gi">+</span>
<span class="gi">+    def _auth(</span>
<span class="gi">+        self,</span>
<span class="gi">+        username,</span>
<span class="gi">+        password,</span>
<span class="gi">+        pkey,</span>
<span class="gi">+        key_filenames,</span>
<span class="gi">+        allow_agent,</span>
<span class="gi">+        look_for_keys,</span>
<span class="gi">+        gss_auth,</span>
<span class="gi">+        gss_kex,</span>
<span class="gi">+        gss_deleg_creds,</span>
<span class="gi">+        gss_host,</span>
<span class="gi">+        passphrase,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Try, in order:

<span class="gu">@@ -407,7 +676,150 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>        isn&#39;t also given], or for two-factor authentication [for which it is
<span class="w"> </span>        required].)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        saved_exception = None</span>
<span class="gi">+        two_factor = False</span>
<span class="gi">+        allowed_types = set()</span>
<span class="gi">+        two_factor_types = {&quot;keyboard-interactive&quot;, &quot;password&quot;}</span>
<span class="gi">+        if passphrase is None and password is not None:</span>
<span class="gi">+            passphrase = password</span>
<span class="gi">+</span>
<span class="gi">+        # If GSS-API support and GSS-PI Key Exchange was performed, we attempt</span>
<span class="gi">+        # authentication with gssapi-keyex.</span>
<span class="gi">+        if gss_kex and self._transport.gss_kex_used:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._transport.auth_gssapi_keyex(username)</span>
<span class="gi">+                return</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                saved_exception = e</span>
<span class="gi">+</span>
<span class="gi">+        # Try GSS-API authentication (gssapi-with-mic) only if GSS-API Key</span>
<span class="gi">+        # Exchange is not performed, because if we use GSS-API for the key</span>
<span class="gi">+        # exchange, there is already a fully established GSS-API context, so</span>
<span class="gi">+        # why should we do that again?</span>
<span class="gi">+        if gss_auth:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self._transport.auth_gssapi_with_mic(</span>
<span class="gi">+                    username, gss_host, gss_deleg_creds</span>
<span class="gi">+                )</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                saved_exception = e</span>
<span class="gi">+</span>
<span class="gi">+        if pkey is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG,</span>
<span class="gi">+                    &quot;Trying SSH key {}&quot;.format(</span>
<span class="gi">+                        hexlify(pkey.get_fingerprint())</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+                allowed_types = set(</span>
<span class="gi">+                    self._transport.auth_publickey(username, pkey)</span>
<span class="gi">+                )</span>
<span class="gi">+                two_factor = allowed_types &amp; two_factor_types</span>
<span class="gi">+                if not two_factor:</span>
<span class="gi">+                    return</span>
<span class="gi">+            except SSHException as e:</span>
<span class="gi">+                saved_exception = e</span>
<span class="gi">+</span>
<span class="gi">+        if not two_factor:</span>
<span class="gi">+            for key_filename in key_filenames:</span>
<span class="gi">+                # TODO 4.0: leverage PKey.from_path() if we don&#39;t end up just</span>
<span class="gi">+                # killing SSHClient entirely</span>
<span class="gi">+                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        key = self._key_from_filepath(</span>
<span class="gi">+                            key_filename, pkey_class, passphrase</span>
<span class="gi">+                        )</span>
<span class="gi">+                        allowed_types = set(</span>
<span class="gi">+                            self._transport.auth_publickey(username, key)</span>
<span class="gi">+                        )</span>
<span class="gi">+                        two_factor = allowed_types &amp; two_factor_types</span>
<span class="gi">+                        if not two_factor:</span>
<span class="gi">+                            return</span>
<span class="gi">+                        break</span>
<span class="gi">+                    except SSHException as e:</span>
<span class="gi">+                        saved_exception = e</span>
<span class="gi">+</span>
<span class="gi">+        if not two_factor and allow_agent:</span>
<span class="gi">+            if self._agent is None:</span>
<span class="gi">+                self._agent = Agent()</span>
<span class="gi">+</span>
<span class="gi">+            for key in self._agent.get_keys():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    id_ = hexlify(key.get_fingerprint())</span>
<span class="gi">+                    self._log(DEBUG, &quot;Trying SSH agent key {}&quot;.format(id_))</span>
<span class="gi">+                    # for 2-factor auth a successfully auth&#39;d key password</span>
<span class="gi">+                    # will return an allowed 2fac auth method</span>
<span class="gi">+                    allowed_types = set(</span>
<span class="gi">+                        self._transport.auth_publickey(username, key)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    two_factor = allowed_types &amp; two_factor_types</span>
<span class="gi">+                    if not two_factor:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    break</span>
<span class="gi">+                except SSHException as e:</span>
<span class="gi">+                    saved_exception = e</span>
<span class="gi">+</span>
<span class="gi">+        if not two_factor:</span>
<span class="gi">+            keyfiles = []</span>
<span class="gi">+</span>
<span class="gi">+            for keytype, name in [</span>
<span class="gi">+                (RSAKey, &quot;rsa&quot;),</span>
<span class="gi">+                (DSSKey, &quot;dsa&quot;),</span>
<span class="gi">+                (ECDSAKey, &quot;ecdsa&quot;),</span>
<span class="gi">+                (Ed25519Key, &quot;ed25519&quot;),</span>
<span class="gi">+            ]:</span>
<span class="gi">+                # ~/ssh/ is for windows</span>
<span class="gi">+                for directory in [&quot;.ssh&quot;, &quot;ssh&quot;]:</span>
<span class="gi">+                    full_path = os.path.expanduser(</span>
<span class="gi">+                        &quot;~/{}/id_{}&quot;.format(directory, name)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if os.path.isfile(full_path):</span>
<span class="gi">+                        # TODO: only do this append if below did not run</span>
<span class="gi">+                        keyfiles.append((keytype, full_path))</span>
<span class="gi">+                        if os.path.isfile(full_path + &quot;-cert.pub&quot;):</span>
<span class="gi">+                            keyfiles.append((keytype, full_path + &quot;-cert.pub&quot;))</span>
<span class="gi">+</span>
<span class="gi">+            if not look_for_keys:</span>
<span class="gi">+                keyfiles = []</span>
<span class="gi">+</span>
<span class="gi">+            for pkey_class, filename in keyfiles:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    key = self._key_from_filepath(</span>
<span class="gi">+                        filename, pkey_class, passphrase</span>
<span class="gi">+                    )</span>
<span class="gi">+                    # for 2-factor auth a successfully auth&#39;d key will result</span>
<span class="gi">+                    # in [&#39;password&#39;]</span>
<span class="gi">+                    allowed_types = set(</span>
<span class="gi">+                        self._transport.auth_publickey(username, key)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    two_factor = allowed_types &amp; two_factor_types</span>
<span class="gi">+                    if not two_factor:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    break</span>
<span class="gi">+                except (SSHException, IOError) as e:</span>
<span class="gi">+                    saved_exception = e</span>
<span class="gi">+</span>
<span class="gi">+        if password is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._transport.auth_password(username, password)</span>
<span class="gi">+                return</span>
<span class="gi">+            except SSHException as e:</span>
<span class="gi">+                saved_exception = e</span>
<span class="gi">+        elif two_factor:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._transport.auth_interactive_dumb(username)</span>
<span class="gi">+                return</span>
<span class="gi">+            except SSHException as e:</span>
<span class="gi">+                saved_exception = e</span>
<span class="gi">+</span>
<span class="gi">+        # if we got an auth-failed exception earlier, re-raise it</span>
<span class="gi">+        if saved_exception is not None:</span>
<span class="gi">+            raise saved_exception</span>
<span class="gi">+        raise SSHException(&quot;No authentication methods available&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _log(self, level, msg):</span>
<span class="gi">+        self._transport._log(level, msg)</span>


<span class="w"> </span>class MissingHostKeyPolicy:
<span class="gu">@@ -437,6 +849,17 @@ class AutoAddPolicy(MissingHostKeyPolicy):</span>
<span class="w"> </span>    local `.HostKeys` object, and saving it.  This is used by `.SSHClient`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def missing_host_key(self, client, hostname, key):</span>
<span class="gi">+        client._host_keys.add(hostname, key.get_name(), key)</span>
<span class="gi">+        if client._host_keys_filename is not None:</span>
<span class="gi">+            client.save_host_keys(client._host_keys_filename)</span>
<span class="gi">+        client._log(</span>
<span class="gi">+            DEBUG,</span>
<span class="gi">+            &quot;Adding {} host key for {}: {}&quot;.format(</span>
<span class="gi">+                key.get_name(), hostname, hexlify(key.get_fingerprint())</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class RejectPolicy(MissingHostKeyPolicy):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -444,9 +867,27 @@ class RejectPolicy(MissingHostKeyPolicy):</span>
<span class="w"> </span>    used by `.SSHClient`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def missing_host_key(self, client, hostname, key):</span>
<span class="gi">+        client._log(</span>
<span class="gi">+            DEBUG,</span>
<span class="gi">+            &quot;Rejecting {} host key for {}: {}&quot;.format(</span>
<span class="gi">+                key.get_name(), hostname, hexlify(key.get_fingerprint())</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        raise SSHException(</span>
<span class="gi">+            &quot;Server {!r} not found in known_hosts&quot;.format(hostname)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class WarningPolicy(MissingHostKeyPolicy):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Policy for logging a Python-style warning for an unknown host key, but
<span class="w"> </span>    accepting it. This is used by `.SSHClient`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def missing_host_key(self, client, hostname, key):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Unknown {} host key for {}: {}&quot;.format(</span>
<span class="gi">+                key.get_name(), hostname, hexlify(key.get_fingerprint())</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/paramiko/common.py b/paramiko/common.py</span>
<span class="gh">index 29e86a9d..b57149b7 100644</span>
<span class="gd">--- a/paramiko/common.py</span>
<span class="gi">+++ b/paramiko/common.py</span>
<span class="gu">@@ -1,24 +1,90 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Common constants and global variables.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import logging
<span class="w"> </span>import struct
<span class="gd">-(MSG_DISCONNECT, MSG_IGNORE, MSG_UNIMPLEMENTED, MSG_DEBUG,</span>
<span class="gd">-    MSG_SERVICE_REQUEST, MSG_SERVICE_ACCEPT, MSG_EXT_INFO) = range(1, 8)</span>
<span class="gd">-MSG_KEXINIT, MSG_NEWKEYS = range(20, 22)</span>
<span class="gd">-(MSG_USERAUTH_REQUEST, MSG_USERAUTH_FAILURE, MSG_USERAUTH_SUCCESS,</span>
<span class="gd">-    MSG_USERAUTH_BANNER) = range(50, 54)</span>
<span class="gi">+</span>
<span class="gi">+#</span>
<span class="gi">+# Formerly of py3compat.py. May be fully delete&#39;able with a deeper look?</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def byte_chr(c):</span>
<span class="gi">+    assert isinstance(c, int)</span>
<span class="gi">+    return struct.pack(&quot;B&quot;, c)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def byte_mask(c, mask):</span>
<span class="gi">+    assert isinstance(c, int)</span>
<span class="gi">+    return struct.pack(&quot;B&quot;, c &amp; mask)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def byte_ord(c):</span>
<span class="gi">+    # In case we&#39;re handed a string instead of an int.</span>
<span class="gi">+    if not isinstance(c, int):</span>
<span class="gi">+        c = ord(c)</span>
<span class="gi">+    return c</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+(</span>
<span class="gi">+    MSG_DISCONNECT,</span>
<span class="gi">+    MSG_IGNORE,</span>
<span class="gi">+    MSG_UNIMPLEMENTED,</span>
<span class="gi">+    MSG_DEBUG,</span>
<span class="gi">+    MSG_SERVICE_REQUEST,</span>
<span class="gi">+    MSG_SERVICE_ACCEPT,</span>
<span class="gi">+    MSG_EXT_INFO,</span>
<span class="gi">+) = range(1, 8)</span>
<span class="gi">+(MSG_KEXINIT, MSG_NEWKEYS) = range(20, 22)</span>
<span class="gi">+(</span>
<span class="gi">+    MSG_USERAUTH_REQUEST,</span>
<span class="gi">+    MSG_USERAUTH_FAILURE,</span>
<span class="gi">+    MSG_USERAUTH_SUCCESS,</span>
<span class="gi">+    MSG_USERAUTH_BANNER,</span>
<span class="gi">+) = range(50, 54)</span>
<span class="w"> </span>MSG_USERAUTH_PK_OK = 60
<span class="gd">-MSG_USERAUTH_INFO_REQUEST, MSG_USERAUTH_INFO_RESPONSE = range(60, 62)</span>
<span class="gd">-MSG_USERAUTH_GSSAPI_RESPONSE, MSG_USERAUTH_GSSAPI_TOKEN = range(60, 62)</span>
<span class="gd">-(MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, MSG_USERAUTH_GSSAPI_ERROR,</span>
<span class="gd">-    MSG_USERAUTH_GSSAPI_ERRTOK, MSG_USERAUTH_GSSAPI_MIC) = range(63, 67)</span>
<span class="gi">+(MSG_USERAUTH_INFO_REQUEST, MSG_USERAUTH_INFO_RESPONSE) = range(60, 62)</span>
<span class="gi">+(MSG_USERAUTH_GSSAPI_RESPONSE, MSG_USERAUTH_GSSAPI_TOKEN) = range(60, 62)</span>
<span class="gi">+(</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_ERROR,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_ERRTOK,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_MIC,</span>
<span class="gi">+) = range(63, 67)</span>
<span class="w"> </span>HIGHEST_USERAUTH_MESSAGE_ID = 79
<span class="gd">-MSG_GLOBAL_REQUEST, MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE = range(80, 83)</span>
<span class="gd">-(MSG_CHANNEL_OPEN, MSG_CHANNEL_OPEN_SUCCESS, MSG_CHANNEL_OPEN_FAILURE,</span>
<span class="gd">-    MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA,</span>
<span class="gd">-    MSG_CHANNEL_EOF, MSG_CHANNEL_CLOSE, MSG_CHANNEL_REQUEST,</span>
<span class="gd">-    MSG_CHANNEL_SUCCESS, MSG_CHANNEL_FAILURE) = range(90, 101)</span>
<span class="gi">+(MSG_GLOBAL_REQUEST, MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE) = range(80, 83)</span>
<span class="gi">+(</span>
<span class="gi">+    MSG_CHANNEL_OPEN,</span>
<span class="gi">+    MSG_CHANNEL_OPEN_SUCCESS,</span>
<span class="gi">+    MSG_CHANNEL_OPEN_FAILURE,</span>
<span class="gi">+    MSG_CHANNEL_WINDOW_ADJUST,</span>
<span class="gi">+    MSG_CHANNEL_DATA,</span>
<span class="gi">+    MSG_CHANNEL_EXTENDED_DATA,</span>
<span class="gi">+    MSG_CHANNEL_EOF,</span>
<span class="gi">+    MSG_CHANNEL_CLOSE,</span>
<span class="gi">+    MSG_CHANNEL_REQUEST,</span>
<span class="gi">+    MSG_CHANNEL_SUCCESS,</span>
<span class="gi">+    MSG_CHANNEL_FAILURE,</span>
<span class="gi">+) = range(90, 101)</span>
<span class="gi">+</span>
<span class="w"> </span>cMSG_DISCONNECT = byte_chr(MSG_DISCONNECT)
<span class="w"> </span>cMSG_IGNORE = byte_chr(MSG_IGNORE)
<span class="w"> </span>cMSG_UNIMPLEMENTED = byte_chr(MSG_UNIMPLEMENTED)
<span class="gu">@@ -38,7 +104,8 @@ cMSG_USERAUTH_INFO_RESPONSE = byte_chr(MSG_USERAUTH_INFO_RESPONSE)</span>
<span class="w"> </span>cMSG_USERAUTH_GSSAPI_RESPONSE = byte_chr(MSG_USERAUTH_GSSAPI_RESPONSE)
<span class="w"> </span>cMSG_USERAUTH_GSSAPI_TOKEN = byte_chr(MSG_USERAUTH_GSSAPI_TOKEN)
<span class="w"> </span>cMSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE = byte_chr(
<span class="gd">-    MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE</span>
<span class="gi">+)</span>
<span class="w"> </span>cMSG_USERAUTH_GSSAPI_ERROR = byte_chr(MSG_USERAUTH_GSSAPI_ERROR)
<span class="w"> </span>cMSG_USERAUTH_GSSAPI_ERRTOK = byte_chr(MSG_USERAUTH_GSSAPI_ERRTOK)
<span class="w"> </span>cMSG_USERAUTH_GSSAPI_MIC = byte_chr(MSG_USERAUTH_GSSAPI_MIC)
<span class="gu">@@ -56,52 +123,95 @@ cMSG_CHANNEL_CLOSE = byte_chr(MSG_CHANNEL_CLOSE)</span>
<span class="w"> </span>cMSG_CHANNEL_REQUEST = byte_chr(MSG_CHANNEL_REQUEST)
<span class="w"> </span>cMSG_CHANNEL_SUCCESS = byte_chr(MSG_CHANNEL_SUCCESS)
<span class="w"> </span>cMSG_CHANNEL_FAILURE = byte_chr(MSG_CHANNEL_FAILURE)
<span class="gd">-MSG_NAMES = {MSG_DISCONNECT: &#39;disconnect&#39;, MSG_IGNORE: &#39;ignore&#39;,</span>
<span class="gd">-    MSG_UNIMPLEMENTED: &#39;unimplemented&#39;, MSG_DEBUG: &#39;debug&#39;,</span>
<span class="gd">-    MSG_SERVICE_REQUEST: &#39;service-request&#39;, MSG_SERVICE_ACCEPT:</span>
<span class="gd">-    &#39;service-accept&#39;, MSG_KEXINIT: &#39;kexinit&#39;, MSG_EXT_INFO: &#39;ext-info&#39;,</span>
<span class="gd">-    MSG_NEWKEYS: &#39;newkeys&#39;, (30): &#39;kex30&#39;, (31): &#39;kex31&#39;, (32): &#39;kex32&#39;, (</span>
<span class="gd">-    33): &#39;kex33&#39;, (34): &#39;kex34&#39;, (40): &#39;kex40&#39;, (41): &#39;kex41&#39;,</span>
<span class="gd">-    MSG_USERAUTH_REQUEST: &#39;userauth-request&#39;, MSG_USERAUTH_FAILURE:</span>
<span class="gd">-    &#39;userauth-failure&#39;, MSG_USERAUTH_SUCCESS: &#39;userauth-success&#39;,</span>
<span class="gd">-    MSG_USERAUTH_BANNER: &#39;userauth--banner&#39;, MSG_USERAUTH_PK_OK:</span>
<span class="gd">-    &#39;userauth-60(pk-ok/info-request)&#39;, MSG_USERAUTH_INFO_RESPONSE:</span>
<span class="gd">-    &#39;userauth-info-response&#39;, MSG_GLOBAL_REQUEST: &#39;global-request&#39;,</span>
<span class="gd">-    MSG_REQUEST_SUCCESS: &#39;request-success&#39;, MSG_REQUEST_FAILURE:</span>
<span class="gd">-    &#39;request-failure&#39;, MSG_CHANNEL_OPEN: &#39;channel-open&#39;,</span>
<span class="gd">-    MSG_CHANNEL_OPEN_SUCCESS: &#39;channel-open-success&#39;,</span>
<span class="gd">-    MSG_CHANNEL_OPEN_FAILURE: &#39;channel-open-failure&#39;,</span>
<span class="gd">-    MSG_CHANNEL_WINDOW_ADJUST: &#39;channel-window-adjust&#39;, MSG_CHANNEL_DATA:</span>
<span class="gd">-    &#39;channel-data&#39;, MSG_CHANNEL_EXTENDED_DATA: &#39;channel-extended-data&#39;,</span>
<span class="gd">-    MSG_CHANNEL_EOF: &#39;channel-eof&#39;, MSG_CHANNEL_CLOSE: &#39;channel-close&#39;,</span>
<span class="gd">-    MSG_CHANNEL_REQUEST: &#39;channel-request&#39;, MSG_CHANNEL_SUCCESS:</span>
<span class="gd">-    &#39;channel-success&#39;, MSG_CHANNEL_FAILURE: &#39;channel-failure&#39;,</span>
<span class="gd">-    MSG_USERAUTH_GSSAPI_RESPONSE: &#39;userauth-gssapi-response&#39;,</span>
<span class="gd">-    MSG_USERAUTH_GSSAPI_TOKEN: &#39;userauth-gssapi-token&#39;,</span>
<span class="gd">-    MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE:</span>
<span class="gd">-    &#39;userauth-gssapi-exchange-complete&#39;, MSG_USERAUTH_GSSAPI_ERROR:</span>
<span class="gd">-    &#39;userauth-gssapi-error&#39;, MSG_USERAUTH_GSSAPI_ERRTOK:</span>
<span class="gd">-    &#39;userauth-gssapi-error-token&#39;, MSG_USERAUTH_GSSAPI_MIC:</span>
<span class="gd">-    &#39;userauth-gssapi-mic&#39;}</span>
<span class="gi">+</span>
<span class="gi">+# for debugging:</span>
<span class="gi">+MSG_NAMES = {</span>
<span class="gi">+    MSG_DISCONNECT: &quot;disconnect&quot;,</span>
<span class="gi">+    MSG_IGNORE: &quot;ignore&quot;,</span>
<span class="gi">+    MSG_UNIMPLEMENTED: &quot;unimplemented&quot;,</span>
<span class="gi">+    MSG_DEBUG: &quot;debug&quot;,</span>
<span class="gi">+    MSG_SERVICE_REQUEST: &quot;service-request&quot;,</span>
<span class="gi">+    MSG_SERVICE_ACCEPT: &quot;service-accept&quot;,</span>
<span class="gi">+    MSG_KEXINIT: &quot;kexinit&quot;,</span>
<span class="gi">+    MSG_EXT_INFO: &quot;ext-info&quot;,</span>
<span class="gi">+    MSG_NEWKEYS: &quot;newkeys&quot;,</span>
<span class="gi">+    30: &quot;kex30&quot;,</span>
<span class="gi">+    31: &quot;kex31&quot;,</span>
<span class="gi">+    32: &quot;kex32&quot;,</span>
<span class="gi">+    33: &quot;kex33&quot;,</span>
<span class="gi">+    34: &quot;kex34&quot;,</span>
<span class="gi">+    40: &quot;kex40&quot;,</span>
<span class="gi">+    41: &quot;kex41&quot;,</span>
<span class="gi">+    MSG_USERAUTH_REQUEST: &quot;userauth-request&quot;,</span>
<span class="gi">+    MSG_USERAUTH_FAILURE: &quot;userauth-failure&quot;,</span>
<span class="gi">+    MSG_USERAUTH_SUCCESS: &quot;userauth-success&quot;,</span>
<span class="gi">+    MSG_USERAUTH_BANNER: &quot;userauth--banner&quot;,</span>
<span class="gi">+    MSG_USERAUTH_PK_OK: &quot;userauth-60(pk-ok/info-request)&quot;,</span>
<span class="gi">+    MSG_USERAUTH_INFO_RESPONSE: &quot;userauth-info-response&quot;,</span>
<span class="gi">+    MSG_GLOBAL_REQUEST: &quot;global-request&quot;,</span>
<span class="gi">+    MSG_REQUEST_SUCCESS: &quot;request-success&quot;,</span>
<span class="gi">+    MSG_REQUEST_FAILURE: &quot;request-failure&quot;,</span>
<span class="gi">+    MSG_CHANNEL_OPEN: &quot;channel-open&quot;,</span>
<span class="gi">+    MSG_CHANNEL_OPEN_SUCCESS: &quot;channel-open-success&quot;,</span>
<span class="gi">+    MSG_CHANNEL_OPEN_FAILURE: &quot;channel-open-failure&quot;,</span>
<span class="gi">+    MSG_CHANNEL_WINDOW_ADJUST: &quot;channel-window-adjust&quot;,</span>
<span class="gi">+    MSG_CHANNEL_DATA: &quot;channel-data&quot;,</span>
<span class="gi">+    MSG_CHANNEL_EXTENDED_DATA: &quot;channel-extended-data&quot;,</span>
<span class="gi">+    MSG_CHANNEL_EOF: &quot;channel-eof&quot;,</span>
<span class="gi">+    MSG_CHANNEL_CLOSE: &quot;channel-close&quot;,</span>
<span class="gi">+    MSG_CHANNEL_REQUEST: &quot;channel-request&quot;,</span>
<span class="gi">+    MSG_CHANNEL_SUCCESS: &quot;channel-success&quot;,</span>
<span class="gi">+    MSG_CHANNEL_FAILURE: &quot;channel-failure&quot;,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_RESPONSE: &quot;userauth-gssapi-response&quot;,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_TOKEN: &quot;userauth-gssapi-token&quot;,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE: &quot;userauth-gssapi-exchange-complete&quot;,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_ERROR: &quot;userauth-gssapi-error&quot;,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_ERRTOK: &quot;userauth-gssapi-error-token&quot;,</span>
<span class="gi">+    MSG_USERAUTH_GSSAPI_MIC: &quot;userauth-gssapi-mic&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# authentication request return codes:</span>
<span class="w"> </span>AUTH_SUCCESSFUL, AUTH_PARTIALLY_SUCCESSFUL, AUTH_FAILED = range(3)
<span class="gd">-(OPEN_SUCCEEDED, OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED,</span>
<span class="gd">-    OPEN_FAILED_CONNECT_FAILED, OPEN_FAILED_UNKNOWN_CHANNEL_TYPE,</span>
<span class="gd">-    OPEN_FAILED_RESOURCE_SHORTAGE) = range(0, 5)</span>
<span class="gd">-CONNECTION_FAILED_CODE = {(1): &#39;Administratively prohibited&#39;, (2):</span>
<span class="gd">-    &#39;Connect failed&#39;, (3): &#39;Unknown channel type&#39;, (4): &#39;Resource shortage&#39;}</span>
<span class="gd">-(DISCONNECT_SERVICE_NOT_AVAILABLE, DISCONNECT_AUTH_CANCELLED_BY_USER,</span>
<span class="gd">-    DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE) = 7, 13, 14</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# channel request failed reasons:</span>
<span class="gi">+(</span>
<span class="gi">+    OPEN_SUCCEEDED,</span>
<span class="gi">+    OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED,</span>
<span class="gi">+    OPEN_FAILED_CONNECT_FAILED,</span>
<span class="gi">+    OPEN_FAILED_UNKNOWN_CHANNEL_TYPE,</span>
<span class="gi">+    OPEN_FAILED_RESOURCE_SHORTAGE,</span>
<span class="gi">+) = range(0, 5)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+CONNECTION_FAILED_CODE = {</span>
<span class="gi">+    1: &quot;Administratively prohibited&quot;,</span>
<span class="gi">+    2: &quot;Connect failed&quot;,</span>
<span class="gi">+    3: &quot;Unknown channel type&quot;,</span>
<span class="gi">+    4: &quot;Resource shortage&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+(</span>
<span class="gi">+    DISCONNECT_SERVICE_NOT_AVAILABLE,</span>
<span class="gi">+    DISCONNECT_AUTH_CANCELLED_BY_USER,</span>
<span class="gi">+    DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE,</span>
<span class="gi">+) = (7, 13, 14)</span>
<span class="gi">+</span>
<span class="w"> </span>zero_byte = byte_chr(0)
<span class="w"> </span>one_byte = byte_chr(1)
<span class="w"> </span>four_byte = byte_chr(4)
<span class="gd">-max_byte = byte_chr(255)</span>
<span class="gi">+max_byte = byte_chr(0xFF)</span>
<span class="w"> </span>cr_byte = byte_chr(13)
<span class="w"> </span>linefeed_byte = byte_chr(10)
<span class="w"> </span>crlf = cr_byte + linefeed_byte
<span class="w"> </span>cr_byte_value = 13
<span class="w"> </span>linefeed_byte_value = 10
<span class="gd">-xffffffff = 4294967295</span>
<span class="gd">-x80000000 = 2147483648</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+xffffffff = 0xFFFFFFFF</span>
<span class="gi">+x80000000 = 0x80000000</span>
<span class="w"> </span>o666 = 438
<span class="w"> </span>o660 = 432
<span class="w"> </span>o644 = 420
<span class="gu">@@ -109,14 +219,27 @@ o600 = 384</span>
<span class="w"> </span>o777 = 511
<span class="w"> </span>o700 = 448
<span class="w"> </span>o70 = 56
<span class="gi">+</span>
<span class="w"> </span>DEBUG = logging.DEBUG
<span class="w"> </span>INFO = logging.INFO
<span class="w"> </span>WARNING = logging.WARNING
<span class="w"> </span>ERROR = logging.ERROR
<span class="w"> </span>CRITICAL = logging.CRITICAL
<span class="gi">+</span>
<span class="gi">+# Common IO/select/etc sleep period, in seconds</span>
<span class="w"> </span>io_sleep = 0.01
<span class="gd">-DEFAULT_WINDOW_SIZE = 64 * 2 ** 15</span>
<span class="gd">-DEFAULT_MAX_PACKET_SIZE = 2 ** 15</span>
<span class="gd">-MIN_WINDOW_SIZE = 2 ** 15</span>
<span class="gd">-MIN_PACKET_SIZE = 2 ** 12</span>
<span class="gd">-MAX_WINDOW_SIZE = 2 ** 32 - 1</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_WINDOW_SIZE = 64 * 2**15</span>
<span class="gi">+DEFAULT_MAX_PACKET_SIZE = 2**15</span>
<span class="gi">+</span>
<span class="gi">+# lower bound on the max packet size we&#39;ll accept from the remote host</span>
<span class="gi">+# Minimum packet size is 32768 bytes according to</span>
<span class="gi">+# http://www.ietf.org/rfc/rfc4254.txt</span>
<span class="gi">+MIN_WINDOW_SIZE = 2**15</span>
<span class="gi">+</span>
<span class="gi">+# However, according to http://www.ietf.org/rfc/rfc4253.txt it is perfectly</span>
<span class="gi">+# legal to accept a size much smaller, as OpenSSH client does as size 16384.</span>
<span class="gi">+MIN_PACKET_SIZE = 2**12</span>
<span class="gi">+</span>
<span class="gi">+# Max windows size according to http://www.ietf.org/rfc/rfc4254.txt</span>
<span class="gi">+MAX_WINDOW_SIZE = 2**32 - 1</span>
<span class="gh">diff --git a/paramiko/compress.py b/paramiko/compress.py</span>
<span class="gh">index 64c87ad4..18ff4843 100644</span>
<span class="gd">--- a/paramiko/compress.py</span>
<span class="gi">+++ b/paramiko/compress.py</span>
<span class="gu">@@ -1,12 +1,31 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Compression implementations for a Transport.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import zlib


<span class="w"> </span>class ZlibCompressor:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="gi">+        # Use the default level of zlib compression</span>
<span class="w"> </span>        self.z = zlib.compressobj()

<span class="w"> </span>    def __call__(self, data):
<span class="gu">@@ -14,7 +33,6 @@ class ZlibCompressor:</span>


<span class="w"> </span>class ZlibDecompressor:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.z = zlib.decompressobj()

<span class="gh">diff --git a/paramiko/config.py b/paramiko/config.py</span>
<span class="gh">index 3301afef..8ab55c64 100644</span>
<span class="gd">--- a/paramiko/config.py</span>
<span class="gi">+++ b/paramiko/config.py</span>
<span class="gu">@@ -1,6 +1,26 @@</span>
<span class="gi">+# Copyright (C) 2006-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+# Copyright (C) 2012  Olle Lundberg &lt;geek@nerd.sh&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Configuration file (aka ``ssh_config``) support.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import fnmatch
<span class="w"> </span>import getpass
<span class="w"> </span>import os
<span class="gu">@@ -10,12 +30,16 @@ import socket</span>
<span class="w"> </span>from hashlib import sha1
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>invoke, invoke_import_error = None, None
<span class="w"> </span>try:
<span class="w"> </span>    import invoke
<span class="w"> </span>except ImportError as e:
<span class="w"> </span>    invoke_import_error = e
<span class="gi">+</span>
<span class="w"> </span>from .ssh_exception import CouldNotCanonicalize, ConfigParseError
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>SSH_PORT = 22


<span class="gu">@@ -29,12 +53,21 @@ class SSHConfig:</span>

<span class="w"> </span>    .. versionadded:: 1.6
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    SETTINGS_REGEX = re.compile(&#39;(\\w+)(?:\\s*=\\s*|\\s+)(.+)&#39;)</span>
<span class="gd">-    TOKENS_BY_CONFIG_KEY = {&#39;controlpath&#39;: [&#39;%C&#39;, &#39;%h&#39;, &#39;%l&#39;, &#39;%L&#39;, &#39;%n&#39;,</span>
<span class="gd">-        &#39;%p&#39;, &#39;%r&#39;, &#39;%u&#39;], &#39;hostname&#39;: [&#39;%h&#39;], &#39;identityfile&#39;: [&#39;%C&#39;, &#39;~&#39;,</span>
<span class="gd">-        &#39;%d&#39;, &#39;%h&#39;, &#39;%l&#39;, &#39;%u&#39;, &#39;%r&#39;], &#39;proxycommand&#39;: [&#39;~&#39;, &#39;%h&#39;, &#39;%p&#39;,</span>
<span class="gd">-        &#39;%r&#39;], &#39;proxyjump&#39;: [&#39;%h&#39;, &#39;%p&#39;, &#39;%r&#39;], &#39;match-exec&#39;: [&#39;%C&#39;, &#39;%d&#39;,</span>
<span class="gd">-        &#39;%h&#39;, &#39;%L&#39;, &#39;%l&#39;, &#39;%n&#39;, &#39;%p&#39;, &#39;%r&#39;, &#39;%u&#39;]}</span>
<span class="gi">+</span>
<span class="gi">+    SETTINGS_REGEX = re.compile(r&quot;(\w+)(?:\s*=\s*|\s+)(.+)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: do a full scan of ssh.c &amp; friends to make sure we&#39;re fully</span>
<span class="gi">+    # compatible across the board, e.g. OpenSSH 8.1 added %n to ProxyCommand.</span>
<span class="gi">+    TOKENS_BY_CONFIG_KEY = {</span>
<span class="gi">+        &quot;controlpath&quot;: [&quot;%C&quot;, &quot;%h&quot;, &quot;%l&quot;, &quot;%L&quot;, &quot;%n&quot;, &quot;%p&quot;, &quot;%r&quot;, &quot;%u&quot;],</span>
<span class="gi">+        &quot;hostname&quot;: [&quot;%h&quot;],</span>
<span class="gi">+        &quot;identityfile&quot;: [&quot;%C&quot;, &quot;~&quot;, &quot;%d&quot;, &quot;%h&quot;, &quot;%l&quot;, &quot;%u&quot;, &quot;%r&quot;],</span>
<span class="gi">+        &quot;proxycommand&quot;: [&quot;~&quot;, &quot;%h&quot;, &quot;%p&quot;, &quot;%r&quot;],</span>
<span class="gi">+        &quot;proxyjump&quot;: [&quot;%h&quot;, &quot;%p&quot;, &quot;%r&quot;],</span>
<span class="gi">+        # Doesn&#39;t seem worth making this &#39;special&#39; for now, it will fit well</span>
<span class="gi">+        # enough (no actual match-exec config key to be confused with).</span>
<span class="gi">+        &quot;match-exec&quot;: [&quot;%C&quot;, &quot;%d&quot;, &quot;%h&quot;, &quot;%L&quot;, &quot;%l&quot;, &quot;%n&quot;, &quot;%p&quot;, &quot;%r&quot;, &quot;%u&quot;],</span>
<span class="gi">+    }</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -64,7 +97,7 @@ class SSHConfig:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls.from_file(StringIO(text))</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_path(cls, path):
<span class="gu">@@ -73,7 +106,8 @@ class SSHConfig:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(path) as flo:</span>
<span class="gi">+            return cls.from_file(flo)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_file(cls, flo):
<span class="gu">@@ -82,7 +116,9 @@ class SSHConfig:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        obj = cls()</span>
<span class="gi">+        obj.parse(flo)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    def parse(self, file_obj):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -90,7 +126,59 @@ class SSHConfig:</span>

<span class="w"> </span>        :param file_obj: a file-like object to read the config file from
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Start out w/ implicit/anonymous global host-like block to hold</span>
<span class="gi">+        # anything not contained by an explicit one.</span>
<span class="gi">+        context = {&quot;host&quot;: [&quot;*&quot;], &quot;config&quot;: {}}</span>
<span class="gi">+        for line in file_obj:</span>
<span class="gi">+            # Strip any leading or trailing whitespace from the line.</span>
<span class="gi">+            # Refer to https://github.com/paramiko/paramiko/issues/499</span>
<span class="gi">+            line = line.strip()</span>
<span class="gi">+            # Skip blanks, comments</span>
<span class="gi">+            if not line or line.startswith(&quot;#&quot;):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Parse line into key, value</span>
<span class="gi">+            match = re.match(self.SETTINGS_REGEX, line)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                raise ConfigParseError(&quot;Unparsable line {}&quot;.format(line))</span>
<span class="gi">+            key = match.group(1).lower()</span>
<span class="gi">+            value = match.group(2)</span>
<span class="gi">+</span>
<span class="gi">+            # Host keyword triggers switch to new block/context</span>
<span class="gi">+            if key in (&quot;host&quot;, &quot;match&quot;):</span>
<span class="gi">+                self._config.append(context)</span>
<span class="gi">+                context = {&quot;config&quot;: {}}</span>
<span class="gi">+                if key == &quot;host&quot;:</span>
<span class="gi">+                    # TODO 4.0: make these real objects or at least name this</span>
<span class="gi">+                    # &quot;hosts&quot; to acknowledge it&#39;s an iterable. (Doing so prior</span>
<span class="gi">+                    # to 3.0, despite it being a private API, feels bad -</span>
<span class="gi">+                    # surely such an old codebase has folks actually relying on</span>
<span class="gi">+                    # these keys.)</span>
<span class="gi">+                    context[&quot;host&quot;] = self._get_hosts(value)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    context[&quot;matches&quot;] = self._get_matches(value)</span>
<span class="gi">+            # Special-case for noop ProxyCommands</span>
<span class="gi">+            elif key == &quot;proxycommand&quot; and value.lower() == &quot;none&quot;:</span>
<span class="gi">+                # Store &#39;none&#39; as None - not as a string implying that the</span>
<span class="gi">+                # proxycommand is the literal shell command &quot;none&quot;!</span>
<span class="gi">+                context[&quot;config&quot;][key] = None</span>
<span class="gi">+            # All other keywords get stored, directly or via append</span>
<span class="gi">+            else:</span>
<span class="gi">+                if value.startswith(&#39;&quot;&#39;) and value.endswith(&#39;&quot;&#39;):</span>
<span class="gi">+                    value = value[1:-1]</span>
<span class="gi">+</span>
<span class="gi">+                # identityfile, localforward, remoteforward keys are special</span>
<span class="gi">+                # cases, since they are allowed to be specified multiple times</span>
<span class="gi">+                # and they should be tried in order of specification.</span>
<span class="gi">+                if key in [&quot;identityfile&quot;, &quot;localforward&quot;, &quot;remoteforward&quot;]:</span>
<span class="gi">+                    if key in context[&quot;config&quot;]:</span>
<span class="gi">+                        context[&quot;config&quot;][key].append(value)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        context[&quot;config&quot;][key] = [value]</span>
<span class="gi">+                elif key not in context[&quot;config&quot;]:</span>
<span class="gi">+                    context[&quot;config&quot;][key] = value</span>
<span class="gi">+        # Store last &#39;open&#39; block and we&#39;re done</span>
<span class="gi">+        self._config.append(context)</span>

<span class="w"> </span>    def lookup(self, hostname):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -133,7 +221,65 @@ class SSHConfig:</span>
<span class="w"> </span>        .. versionchanged:: 3.3
<span class="w"> </span>            Added ``Match final`` support.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First pass</span>
<span class="gi">+        options = self._lookup(hostname=hostname)</span>
<span class="gi">+        # Inject HostName if it was not set (this used to be done incidentally</span>
<span class="gi">+        # during tokenization, for some reason).</span>
<span class="gi">+        if &quot;hostname&quot; not in options:</span>
<span class="gi">+            options[&quot;hostname&quot;] = hostname</span>
<span class="gi">+        # Handle canonicalization</span>
<span class="gi">+        canon = options.get(&quot;canonicalizehostname&quot;, None) in (&quot;yes&quot;, &quot;always&quot;)</span>
<span class="gi">+        maxdots = int(options.get(&quot;canonicalizemaxdots&quot;, 1))</span>
<span class="gi">+        if canon and hostname.count(&quot;.&quot;) &lt;= maxdots:</span>
<span class="gi">+            # NOTE: OpenSSH manpage does not explicitly state this, but its</span>
<span class="gi">+            # implementation for CanonicalDomains is &#39;split on any whitespace&#39;.</span>
<span class="gi">+            domains = options[&quot;canonicaldomains&quot;].split()</span>
<span class="gi">+            hostname = self.canonicalize(hostname, options, domains)</span>
<span class="gi">+            # Overwrite HostName again here (this is also what OpenSSH does)</span>
<span class="gi">+            options[&quot;hostname&quot;] = hostname</span>
<span class="gi">+            options = self._lookup(</span>
<span class="gi">+                hostname, options, canonical=True, final=True</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            options = self._lookup(</span>
<span class="gi">+                hostname, options, canonical=False, final=True</span>
<span class="gi">+            )</span>
<span class="gi">+        return options</span>
<span class="gi">+</span>
<span class="gi">+    def _lookup(self, hostname, options=None, canonical=False, final=False):</span>
<span class="gi">+        # Init</span>
<span class="gi">+        if options is None:</span>
<span class="gi">+            options = SSHConfigDict()</span>
<span class="gi">+        # Iterate all stanzas, applying any that match, in turn (so that things</span>
<span class="gi">+        # like Match can reference currently understood state)</span>
<span class="gi">+        for context in self._config:</span>
<span class="gi">+            if not (</span>
<span class="gi">+                self._pattern_matches(context.get(&quot;host&quot;, []), hostname)</span>
<span class="gi">+                or self._does_match(</span>
<span class="gi">+                    context.get(&quot;matches&quot;, []),</span>
<span class="gi">+                    hostname,</span>
<span class="gi">+                    canonical,</span>
<span class="gi">+                    final,</span>
<span class="gi">+                    options,</span>
<span class="gi">+                )</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            for key, value in context[&quot;config&quot;].items():</span>
<span class="gi">+                if key not in options:</span>
<span class="gi">+                    # Create a copy of the original value,</span>
<span class="gi">+                    # else it will reference the original list</span>
<span class="gi">+                    # in self._config and update that value too</span>
<span class="gi">+                    # when the extend() is being called.</span>
<span class="gi">+                    options[key] = value[:] if value is not None else value</span>
<span class="gi">+                elif key == &quot;identityfile&quot;:</span>
<span class="gi">+                    options[key].extend(</span>
<span class="gi">+                        x for x in value if x not in options[key]</span>
<span class="gi">+                    )</span>
<span class="gi">+        if final:</span>
<span class="gi">+            # Expand variables in resulting values</span>
<span class="gi">+            # (besides &#39;Match exec&#39; which was already handled above)</span>
<span class="gi">+            options = self._expand_variables(options, hostname)</span>
<span class="gi">+        return options</span>

<span class="w"> </span>    def canonicalize(self, hostname, options, domains):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -147,14 +293,120 @@ class SSHConfig:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        found = False</span>
<span class="gi">+        for domain in domains:</span>
<span class="gi">+            candidate = &quot;{}.{}&quot;.format(hostname, domain)</span>
<span class="gi">+            family_specific = _addressfamily_host_lookup(candidate, options)</span>
<span class="gi">+            if family_specific is not None:</span>
<span class="gi">+                # TODO: would we want to dig deeper into other results? e.g. to</span>
<span class="gi">+                # find something that satisfies PermittedCNAMEs when that is</span>
<span class="gi">+                # implemented?</span>
<span class="gi">+                found = family_specific[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                # TODO: what does ssh use here and is there a reason to use</span>
<span class="gi">+                # that instead of gethostbyname?</span>
<span class="gi">+                try:</span>
<span class="gi">+                    found = socket.gethostbyname(candidate)</span>
<span class="gi">+                except socket.gaierror:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            if found:</span>
<span class="gi">+                # TODO: follow CNAME (implied by found != candidate?) if</span>
<span class="gi">+                # CanonicalizePermittedCNAMEs allows it</span>
<span class="gi">+                return candidate</span>
<span class="gi">+        # If we got here, it means canonicalization failed.</span>
<span class="gi">+        # When CanonicalizeFallbackLocal is undefined or &#39;yes&#39;, we just spit</span>
<span class="gi">+        # back the original hostname.</span>
<span class="gi">+        if options.get(&quot;canonicalizefallbacklocal&quot;, &quot;yes&quot;) == &quot;yes&quot;:</span>
<span class="gi">+            return hostname</span>
<span class="gi">+        # And here, we failed AND fallback was set to a non-yes value, so we</span>
<span class="gi">+        # need to get mad.</span>
<span class="gi">+        raise CouldNotCanonicalize(hostname)</span>

<span class="w"> </span>    def get_hostnames(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the set of literal hostnames defined in the SSH config (both
<span class="w"> </span>        explicit hostnames and wildcard entries).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hosts = set()</span>
<span class="gi">+        for entry in self._config:</span>
<span class="gi">+            hosts.update(entry[&quot;host&quot;])</span>
<span class="gi">+        return hosts</span>
<span class="gi">+</span>
<span class="gi">+    def _pattern_matches(self, patterns, target):</span>
<span class="gi">+        # Convenience auto-splitter if not already a list</span>
<span class="gi">+        if hasattr(patterns, &quot;split&quot;):</span>
<span class="gi">+            patterns = patterns.split(&quot;,&quot;)</span>
<span class="gi">+        match = False</span>
<span class="gi">+        for pattern in patterns:</span>
<span class="gi">+            # Short-circuit if target matches a negated pattern</span>
<span class="gi">+            if pattern.startswith(&quot;!&quot;) and fnmatch.fnmatch(</span>
<span class="gi">+                target, pattern[1:]</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+            # Flag a match, but continue (in case of later negation) if regular</span>
<span class="gi">+            # match occurs</span>
<span class="gi">+            elif fnmatch.fnmatch(target, pattern):</span>
<span class="gi">+                match = True</span>
<span class="gi">+        return match</span>
<span class="gi">+</span>
<span class="gi">+    def _does_match(</span>
<span class="gi">+        self, match_list, target_hostname, canonical, final, options</span>
<span class="gi">+    ):</span>
<span class="gi">+        matched = []</span>
<span class="gi">+        candidates = match_list[:]</span>
<span class="gi">+        local_username = getpass.getuser()</span>
<span class="gi">+        while candidates:</span>
<span class="gi">+            candidate = candidates.pop(0)</span>
<span class="gi">+            passed = None</span>
<span class="gi">+            # Obtain latest host/user value every loop, so later Match may</span>
<span class="gi">+            # reference values assigned within a prior Match.</span>
<span class="gi">+            configured_host = options.get(&quot;hostname&quot;, None)</span>
<span class="gi">+            configured_user = options.get(&quot;user&quot;, None)</span>
<span class="gi">+            type_, param = candidate[&quot;type&quot;], candidate[&quot;param&quot;]</span>
<span class="gi">+            # Canonical is a hard pass/fail based on whether this is a</span>
<span class="gi">+            # canonicalized re-lookup.</span>
<span class="gi">+            if type_ == &quot;canonical&quot;:</span>
<span class="gi">+                if self._should_fail(canonical, candidate):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            if type_ == &quot;final&quot;:</span>
<span class="gi">+                passed = final</span>
<span class="gi">+            # The parse step ensures we only see this by itself or after</span>
<span class="gi">+            # canonical, so it&#39;s also an easy hard pass. (No negation here as</span>
<span class="gi">+            # that would be uh, pretty weird?)</span>
<span class="gi">+            elif type_ == &quot;all&quot;:</span>
<span class="gi">+                return True</span>
<span class="gi">+            # From here, we are testing various non-hard criteria,</span>
<span class="gi">+            # short-circuiting only on fail</span>
<span class="gi">+            elif type_ == &quot;host&quot;:</span>
<span class="gi">+                hostval = configured_host or target_hostname</span>
<span class="gi">+                passed = self._pattern_matches(param, hostval)</span>
<span class="gi">+            elif type_ == &quot;originalhost&quot;:</span>
<span class="gi">+                passed = self._pattern_matches(param, target_hostname)</span>
<span class="gi">+            elif type_ == &quot;user&quot;:</span>
<span class="gi">+                user = configured_user or local_username</span>
<span class="gi">+                passed = self._pattern_matches(param, user)</span>
<span class="gi">+            elif type_ == &quot;localuser&quot;:</span>
<span class="gi">+                passed = self._pattern_matches(param, local_username)</span>
<span class="gi">+            elif type_ == &quot;exec&quot;:</span>
<span class="gi">+                exec_cmd = self._tokenize(</span>
<span class="gi">+                    options, target_hostname, &quot;match-exec&quot;, param</span>
<span class="gi">+                )</span>
<span class="gi">+                # This is the laziest spot in which we can get mad about an</span>
<span class="gi">+                # inability to import Invoke.</span>
<span class="gi">+                if invoke is None:</span>
<span class="gi">+                    raise invoke_import_error</span>
<span class="gi">+                # Like OpenSSH, we &#39;redirect&#39; stdout but let stderr bubble up</span>
<span class="gi">+                passed = invoke.run(exec_cmd, hide=&quot;stdout&quot;, warn=True).ok</span>
<span class="gi">+            # Tackle any &#39;passed, but was negated&#39; results from above</span>
<span class="gi">+            if passed is not None and self._should_fail(passed, candidate):</span>
<span class="gi">+                return False</span>
<span class="gi">+            # Made it all the way here? Everything matched!</span>
<span class="gi">+            matched.append(candidate)</span>
<span class="gi">+        # Did anything match? (To be treated as bool, usually.)</span>
<span class="gi">+        return matched</span>
<span class="gi">+</span>
<span class="gi">+    def _should_fail(self, would_pass, candidate):</span>
<span class="gi">+        return would_pass if candidate[&quot;negate&quot;] else not would_pass</span>

<span class="w"> </span>    def _tokenize(self, config, target_hostname, key, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -167,7 +419,56 @@ class SSHConfig:</span>

<span class="w"> </span>        :returns: The tokenized version of the input ``value`` string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        allowed_tokens = self._allowed_tokens(key)</span>
<span class="gi">+        # Short-circuit if no tokenization possible</span>
<span class="gi">+        if not allowed_tokens:</span>
<span class="gi">+            return value</span>
<span class="gi">+        # Obtain potentially configured hostname, for use with %h.</span>
<span class="gi">+        # Special-case where we are tokenizing the hostname itself, to avoid</span>
<span class="gi">+        # replacing %h with a %h-bearing value, etc.</span>
<span class="gi">+        configured_hostname = target_hostname</span>
<span class="gi">+        if key != &quot;hostname&quot;:</span>
<span class="gi">+            configured_hostname = config.get(&quot;hostname&quot;, configured_hostname)</span>
<span class="gi">+        # Ditto the rest of the source values</span>
<span class="gi">+        if &quot;port&quot; in config:</span>
<span class="gi">+            port = config[&quot;port&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            port = SSH_PORT</span>
<span class="gi">+        user = getpass.getuser()</span>
<span class="gi">+        if &quot;user&quot; in config:</span>
<span class="gi">+            remoteuser = config[&quot;user&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            remoteuser = user</span>
<span class="gi">+        local_hostname = socket.gethostname().split(&quot;.&quot;)[0]</span>
<span class="gi">+        local_fqdn = LazyFqdn(config, local_hostname)</span>
<span class="gi">+        homedir = os.path.expanduser(&quot;~&quot;)</span>
<span class="gi">+        tohash = local_hostname + target_hostname + repr(port) + remoteuser</span>
<span class="gi">+        # The actual tokens!</span>
<span class="gi">+        replacements = {</span>
<span class="gi">+            # TODO: %%???</span>
<span class="gi">+            &quot;%C&quot;: sha1(tohash.encode()).hexdigest(),</span>
<span class="gi">+            &quot;%d&quot;: homedir,</span>
<span class="gi">+            &quot;%h&quot;: configured_hostname,</span>
<span class="gi">+            # TODO: %i?</span>
<span class="gi">+            &quot;%L&quot;: local_hostname,</span>
<span class="gi">+            &quot;%l&quot;: local_fqdn,</span>
<span class="gi">+            # also this is pseudo buggy when not in Match exec mode so document</span>
<span class="gi">+            # that. also WHY is that the case?? don&#39;t we do all of this late?</span>
<span class="gi">+            &quot;%n&quot;: target_hostname,</span>
<span class="gi">+            &quot;%p&quot;: port,</span>
<span class="gi">+            &quot;%r&quot;: remoteuser,</span>
<span class="gi">+            # TODO: %T? don&#39;t believe this is possible however</span>
<span class="gi">+            &quot;%u&quot;: user,</span>
<span class="gi">+            &quot;~&quot;: homedir,</span>
<span class="gi">+        }</span>
<span class="gi">+        # Do the thing with the stuff</span>
<span class="gi">+        tokenized = value</span>
<span class="gi">+        for find, replace in replacements.items():</span>
<span class="gi">+            if find not in allowed_tokens:</span>
<span class="gi">+                continue</span>
<span class="gi">+            tokenized = tokenized.replace(find, str(replace))</span>
<span class="gi">+        # TODO: log? eg that value -&gt; tokenized</span>
<span class="gi">+        return tokenized</span>

<span class="w"> </span>    def _allowed_tokens(self, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -178,7 +479,7 @@ class SSHConfig:</span>
<span class="w"> </span>            preserve as-strict-as-possible compatibility with OpenSSH, which
<span class="w"> </span>            for whatever reason only applies some tokens to some config keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.TOKENS_BY_CONFIG_KEY.get(key, [])</span>

<span class="w"> </span>    def _expand_variables(self, config, target_hostname):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -190,13 +491,25 @@ class SSHConfig:</span>
<span class="w"> </span>        :param dict config: the currently parsed config
<span class="w"> </span>        :param str hostname: the hostname whose config is being looked up
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for k in config:</span>
<span class="gi">+            if config[k] is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            tokenizer = partial(self._tokenize, config, target_hostname, k)</span>
<span class="gi">+            if isinstance(config[k], list):</span>
<span class="gi">+                for i, value in enumerate(config[k]):</span>
<span class="gi">+                    config[k][i] = tokenizer(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                config[k] = tokenizer(config[k])</span>
<span class="gi">+        return config</span>

<span class="w"> </span>    def _get_hosts(self, host):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of host_names from host value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return shlex.split(host)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise ConfigParseError(&quot;Unparsable host {}&quot;.format(host))</span>

<span class="w"> </span>    def _get_matches(self, match):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -204,7 +517,43 @@ class SSHConfig:</span>

<span class="w"> </span>        Performs some parse-time validation as well.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        matches = []</span>
<span class="gi">+        tokens = shlex.split(match)</span>
<span class="gi">+        while tokens:</span>
<span class="gi">+            match = {&quot;type&quot;: None, &quot;param&quot;: None, &quot;negate&quot;: False}</span>
<span class="gi">+            type_ = tokens.pop(0)</span>
<span class="gi">+            # Handle per-keyword negation</span>
<span class="gi">+            if type_.startswith(&quot;!&quot;):</span>
<span class="gi">+                match[&quot;negate&quot;] = True</span>
<span class="gi">+                type_ = type_[1:]</span>
<span class="gi">+            match[&quot;type&quot;] = type_</span>
<span class="gi">+            # all/canonical have no params (everything else does)</span>
<span class="gi">+            if type_ in (&quot;all&quot;, &quot;canonical&quot;, &quot;final&quot;):</span>
<span class="gi">+                matches.append(match)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not tokens:</span>
<span class="gi">+                raise ConfigParseError(</span>
<span class="gi">+                    &quot;Missing parameter to Match &#39;{}&#39; keyword&quot;.format(type_)</span>
<span class="gi">+                )</span>
<span class="gi">+            match[&quot;param&quot;] = tokens.pop(0)</span>
<span class="gi">+            matches.append(match)</span>
<span class="gi">+        # Perform some (easier to do now than in the middle) validation that is</span>
<span class="gi">+        # better handled here than at lookup time.</span>
<span class="gi">+        keywords = [x[&quot;type&quot;] for x in matches]</span>
<span class="gi">+        if &quot;all&quot; in keywords:</span>
<span class="gi">+            allowable = (&quot;all&quot;, &quot;canonical&quot;)</span>
<span class="gi">+            ok, bad = (</span>
<span class="gi">+                list(filter(lambda x: x in allowable, keywords)),</span>
<span class="gi">+                list(filter(lambda x: x not in allowable, keywords)),</span>
<span class="gi">+            )</span>
<span class="gi">+            err = None</span>
<span class="gi">+            if any(bad):</span>
<span class="gi">+                err = &quot;Match does not allow &#39;all&#39; mixed with anything but &#39;canonical&#39;&quot;  # noqa</span>
<span class="gi">+            elif &quot;canonical&quot; in ok and ok.index(&quot;canonical&quot;) &gt; ok.index(&quot;all&quot;):</span>
<span class="gi">+                err = &quot;Match does not allow &#39;all&#39; before &#39;canonical&#39;&quot;</span>
<span class="gi">+            if err is not None:</span>
<span class="gi">+                raise ConfigParseError(err)</span>
<span class="gi">+        return matches</span>


<span class="w"> </span>def _addressfamily_host_lookup(hostname, options):
<span class="gu">@@ -225,7 +574,23 @@ def _addressfamily_host_lookup(hostname, options):</span>
<span class="w"> </span>    :param options: `SSHConfigDict` instance w/ parsed options.
<span class="w"> </span>    :returns: ``getaddrinfo``-style tuples, or ``None``, depending.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    address_family = options.get(&quot;addressfamily&quot;, &quot;any&quot;).lower()</span>
<span class="gi">+    if address_family == &quot;any&quot;:</span>
<span class="gi">+        return</span>
<span class="gi">+    try:</span>
<span class="gi">+        family = socket.AF_INET6</span>
<span class="gi">+        if address_family == &quot;inet&quot;:</span>
<span class="gi">+            family = socket.AF_INET</span>
<span class="gi">+        return socket.getaddrinfo(</span>
<span class="gi">+            hostname,</span>
<span class="gi">+            None,</span>
<span class="gi">+            family,</span>
<span class="gi">+            socket.SOCK_DGRAM,</span>
<span class="gi">+            socket.IPPROTO_IP,</span>
<span class="gi">+            socket.AI_CANONNAME,</span>
<span class="gi">+        )</span>
<span class="gi">+    except socket.gaierror:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>class LazyFqdn:
<span class="gu">@@ -240,16 +605,28 @@ class LazyFqdn:</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        if self.fqdn is None:
<span class="gi">+            #</span>
<span class="gi">+            # If the SSH config contains AddressFamily, use that when</span>
<span class="gi">+            # determining  the local host&#39;s FQDN. Using socket.getfqdn() from</span>
<span class="gi">+            # the standard library is the most general solution, but can</span>
<span class="gi">+            # result in noticeable delays on some platforms when IPv6 is</span>
<span class="gi">+            # misconfigured or not available, as it calls getaddrinfo with no</span>
<span class="gi">+            # address family specified, so both IPv4 and IPv6 are checked.</span>
<span class="gi">+            #</span>
<span class="gi">+</span>
<span class="gi">+            # Handle specific option</span>
<span class="w"> </span>            fqdn = None
<span class="w"> </span>            results = _addressfamily_host_lookup(self.host, self.config)
<span class="w"> </span>            if results is not None:
<span class="w"> </span>                for res in results:
<span class="w"> </span>                    af, socktype, proto, canonname, sa = res
<span class="gd">-                    if canonname and &#39;.&#39; in canonname:</span>
<span class="gi">+                    if canonname and &quot;.&quot; in canonname:</span>
<span class="w"> </span>                        fqdn = canonname
<span class="w"> </span>                        break
<span class="gi">+            # Handle &#39;any&#39; / unspecified / lookup failure</span>
<span class="w"> </span>            if fqdn is None:
<span class="w"> </span>                fqdn = socket.getfqdn()
<span class="gi">+            # Cache</span>
<span class="w"> </span>            self.fqdn = fqdn
<span class="w"> </span>        return self.fqdn

<span class="gu">@@ -302,7 +679,10 @@ class SSHConfigDict(dict):</span>

<span class="w"> </span>        .. versionadded:: 2.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        val = self[key]</span>
<span class="gi">+        if isinstance(val, bool):</span>
<span class="gi">+            return val</span>
<span class="gi">+        return val.lower() == &quot;yes&quot;</span>

<span class="w"> </span>    def as_int(self, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -313,4 +693,4 @@ class SSHConfigDict(dict):</span>

<span class="w"> </span>        .. versionadded:: 2.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return int(self[key])</span>
<span class="gh">diff --git a/paramiko/dsskey.py b/paramiko/dsskey.py</span>
<span class="gh">index a2882c5e..5215d282 100644</span>
<span class="gd">--- a/paramiko/dsskey.py</span>
<span class="gi">+++ b/paramiko/dsskey.py</span>
<span class="gu">@@ -1,11 +1,34 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>DSS keys.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from cryptography.exceptions import InvalidSignature
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives import hashes, serialization
<span class="w"> </span>from cryptography.hazmat.primitives.asymmetric import dsa
<span class="gd">-from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature, encode_dss_signature</span>
<span class="gi">+from cryptography.hazmat.primitives.asymmetric.utils import (</span>
<span class="gi">+    decode_dss_signature,</span>
<span class="gi">+    encode_dss_signature,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.common import zero_byte
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="gu">@@ -19,10 +42,18 @@ class DSSKey(PKey):</span>
<span class="w"> </span>    Representation of a DSS key which can be used to sign an verify SSH2
<span class="w"> </span>    data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;ssh-dss&#39;</span>

<span class="gd">-    def __init__(self, msg=None, data=None, filename=None, password=None,</span>
<span class="gd">-        vals=None, file_obj=None):</span>
<span class="gi">+    name = &quot;ssh-dss&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg=None,</span>
<span class="gi">+        data=None,</span>
<span class="gi">+        filename=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        vals=None,</span>
<span class="gi">+        file_obj=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.p = None
<span class="w"> </span>        self.q = None
<span class="w"> </span>        self.g = None
<span class="gu">@@ -35,22 +66,138 @@ class DSSKey(PKey):</span>
<span class="w"> </span>        if filename is not None:
<span class="w"> </span>            self._from_private_key_file(filename, password)
<span class="w"> </span>            return
<span class="gd">-        if msg is None and data is not None:</span>
<span class="gi">+        if (msg is None) and (data is not None):</span>
<span class="w"> </span>            msg = Message(data)
<span class="w"> </span>        if vals is not None:
<span class="w"> </span>            self.p, self.q, self.g, self.y = vals
<span class="w"> </span>        else:
<span class="gd">-            self._check_type_and_load_cert(msg=msg, key_type=self.name,</span>
<span class="gd">-                cert_type=f&#39;{self.name}-cert-v01@openssh.com&#39;)</span>
<span class="gi">+            self._check_type_and_load_cert(</span>
<span class="gi">+                msg=msg,</span>
<span class="gi">+                key_type=self.name,</span>
<span class="gi">+                cert_type=f&quot;{self.name}-cert-v01@openssh.com&quot;,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            self.p = msg.get_mpint()
<span class="w"> </span>            self.q = msg.get_mpint()
<span class="w"> </span>            self.g = msg.get_mpint()
<span class="w"> </span>            self.y = msg.get_mpint()
<span class="w"> </span>        self.size = util.bit_length(self.p)

<span class="gi">+    def asbytes(self):</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_string(self.name)</span>
<span class="gi">+        m.add_mpint(self.p)</span>
<span class="gi">+        m.add_mpint(self.q)</span>
<span class="gi">+        m.add_mpint(self.g)</span>
<span class="gi">+        m.add_mpint(self.y)</span>
<span class="gi">+        return m.asbytes()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.asbytes()

<span class="gi">+    @property</span>
<span class="gi">+    def _fields(self):</span>
<span class="gi">+        return (self.get_name(), self.p, self.q, self.g, self.y)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO 4.0: remove</span>
<span class="gi">+    def get_name(self):</span>
<span class="gi">+        return self.name</span>
<span class="gi">+</span>
<span class="gi">+    def get_bits(self):</span>
<span class="gi">+        return self.size</span>
<span class="gi">+</span>
<span class="gi">+    def can_sign(self):</span>
<span class="gi">+        return self.x is not None</span>
<span class="gi">+</span>
<span class="gi">+    def sign_ssh_data(self, data, algorithm=None):</span>
<span class="gi">+        key = dsa.DSAPrivateNumbers(</span>
<span class="gi">+            x=self.x,</span>
<span class="gi">+            public_numbers=dsa.DSAPublicNumbers(</span>
<span class="gi">+                y=self.y,</span>
<span class="gi">+                parameter_numbers=dsa.DSAParameterNumbers(</span>
<span class="gi">+                    p=self.p, q=self.q, g=self.g</span>
<span class="gi">+                ),</span>
<span class="gi">+            ),</span>
<span class="gi">+        ).private_key(backend=default_backend())</span>
<span class="gi">+        sig = key.sign(data, hashes.SHA1())</span>
<span class="gi">+        r, s = decode_dss_signature(sig)</span>
<span class="gi">+</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_string(self.name)</span>
<span class="gi">+        # apparently, in rare cases, r or s may be shorter than 20 bytes!</span>
<span class="gi">+        rstr = util.deflate_long(r, 0)</span>
<span class="gi">+        sstr = util.deflate_long(s, 0)</span>
<span class="gi">+        if len(rstr) &lt; 20:</span>
<span class="gi">+            rstr = zero_byte * (20 - len(rstr)) + rstr</span>
<span class="gi">+        if len(sstr) &lt; 20:</span>
<span class="gi">+            sstr = zero_byte * (20 - len(sstr)) + sstr</span>
<span class="gi">+        m.add_string(rstr + sstr)</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    def verify_ssh_sig(self, data, msg):</span>
<span class="gi">+        if len(msg.asbytes()) == 40:</span>
<span class="gi">+            # spies.com bug: signature has no header</span>
<span class="gi">+            sig = msg.asbytes()</span>
<span class="gi">+        else:</span>
<span class="gi">+            kind = msg.get_text()</span>
<span class="gi">+            if kind != self.name:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            sig = msg.get_binary()</span>
<span class="gi">+</span>
<span class="gi">+        # pull out (r, s) which are NOT encoded as mpints</span>
<span class="gi">+        sigR = util.inflate_long(sig[:20], 1)</span>
<span class="gi">+        sigS = util.inflate_long(sig[20:], 1)</span>
<span class="gi">+</span>
<span class="gi">+        signature = encode_dss_signature(sigR, sigS)</span>
<span class="gi">+</span>
<span class="gi">+        key = dsa.DSAPublicNumbers(</span>
<span class="gi">+            y=self.y,</span>
<span class="gi">+            parameter_numbers=dsa.DSAParameterNumbers(</span>
<span class="gi">+                p=self.p, q=self.q, g=self.g</span>
<span class="gi">+            ),</span>
<span class="gi">+        ).public_key(backend=default_backend())</span>
<span class="gi">+        try:</span>
<span class="gi">+            key.verify(signature, data, hashes.SHA1())</span>
<span class="gi">+        except InvalidSignature:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    def write_private_key_file(self, filename, password=None):</span>
<span class="gi">+        key = dsa.DSAPrivateNumbers(</span>
<span class="gi">+            x=self.x,</span>
<span class="gi">+            public_numbers=dsa.DSAPublicNumbers(</span>
<span class="gi">+                y=self.y,</span>
<span class="gi">+                parameter_numbers=dsa.DSAParameterNumbers(</span>
<span class="gi">+                    p=self.p, q=self.q, g=self.g</span>
<span class="gi">+                ),</span>
<span class="gi">+            ),</span>
<span class="gi">+        ).private_key(backend=default_backend())</span>
<span class="gi">+</span>
<span class="gi">+        self._write_private_key_file(</span>
<span class="gi">+            filename,</span>
<span class="gi">+            key,</span>
<span class="gi">+            serialization.PrivateFormat.TraditionalOpenSSL,</span>
<span class="gi">+            password=password,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def write_private_key(self, file_obj, password=None):</span>
<span class="gi">+        key = dsa.DSAPrivateNumbers(</span>
<span class="gi">+            x=self.x,</span>
<span class="gi">+            public_numbers=dsa.DSAPublicNumbers(</span>
<span class="gi">+                y=self.y,</span>
<span class="gi">+                parameter_numbers=dsa.DSAParameterNumbers(</span>
<span class="gi">+                    p=self.p, q=self.q, g=self.g</span>
<span class="gi">+                ),</span>
<span class="gi">+            ),</span>
<span class="gi">+        ).private_key(backend=default_backend())</span>
<span class="gi">+</span>
<span class="gi">+        self._write_private_key(</span>
<span class="gi">+            file_obj,</span>
<span class="gi">+            key,</span>
<span class="gi">+            serialization.PrivateFormat.TraditionalOpenSSL,</span>
<span class="gi">+            password=password,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def generate(bits=1024, progress_func=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -61,4 +208,51 @@ class DSSKey(PKey):</span>
<span class="w"> </span>        :param progress_func: Unused
<span class="w"> </span>        :return: new `.DSSKey` private key
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        numbers = dsa.generate_private_key(</span>
<span class="gi">+            bits, backend=default_backend()</span>
<span class="gi">+        ).private_numbers()</span>
<span class="gi">+        key = DSSKey(</span>
<span class="gi">+            vals=(</span>
<span class="gi">+                numbers.public_numbers.parameter_numbers.p,</span>
<span class="gi">+                numbers.public_numbers.parameter_numbers.q,</span>
<span class="gi">+                numbers.public_numbers.parameter_numbers.g,</span>
<span class="gi">+                numbers.public_numbers.y,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        key.x = numbers.x</span>
<span class="gi">+        return key</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _from_private_key_file(self, filename, password):</span>
<span class="gi">+        data = self._read_private_key_file(&quot;DSA&quot;, filename, password)</span>
<span class="gi">+        self._decode_key(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _from_private_key(self, file_obj, password):</span>
<span class="gi">+        data = self._read_private_key(&quot;DSA&quot;, file_obj, password)</span>
<span class="gi">+        self._decode_key(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _decode_key(self, data):</span>
<span class="gi">+        pkformat, data = data</span>
<span class="gi">+        # private key file contains:</span>
<span class="gi">+        # DSAPrivateKey = { version = 0, p, q, g, y, x }</span>
<span class="gi">+        if pkformat == self._PRIVATE_KEY_FORMAT_ORIGINAL:</span>
<span class="gi">+            try:</span>
<span class="gi">+                keylist = BER(data).decode()</span>
<span class="gi">+            except BERException as e:</span>
<span class="gi">+                raise SSHException(&quot;Unable to parse key file: {}&quot;.format(e))</span>
<span class="gi">+        elif pkformat == self._PRIVATE_KEY_FORMAT_OPENSSH:</span>
<span class="gi">+            keylist = self._uint32_cstruct_unpack(data, &quot;iiiii&quot;)</span>
<span class="gi">+            keylist = [0] + list(keylist)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._got_bad_key_format_id(pkformat)</span>
<span class="gi">+        if type(keylist) is not list or len(keylist) &lt; 6 or keylist[0] != 0:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;not a valid DSA private key file (bad ber encoding)&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        self.p = keylist[1]</span>
<span class="gi">+        self.q = keylist[2]</span>
<span class="gi">+        self.g = keylist[3]</span>
<span class="gi">+        self.y = keylist[4]</span>
<span class="gi">+        self.x = keylist[5]</span>
<span class="gi">+        self.size = util.bit_length(self.p)</span>
<span class="gh">diff --git a/paramiko/ecdsakey.py b/paramiko/ecdsakey.py</span>
<span class="gh">index 3c6f2ecf..6fd95fab 100644</span>
<span class="gd">--- a/paramiko/ecdsakey.py</span>
<span class="gi">+++ b/paramiko/ecdsakey.py</span>
<span class="gu">@@ -1,11 +1,34 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>ECDSA keys
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives import hashes, serialization
<span class="w"> </span>from cryptography.hazmat.primitives.asymmetric import ec
<span class="gd">-from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature, encode_dss_signature</span>
<span class="gi">+from cryptography.hazmat.primitives.asymmetric.utils import (</span>
<span class="gi">+    decode_dss_signature,</span>
<span class="gi">+    encode_dss_signature,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from paramiko.common import four_byte
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.pkey import PKey
<span class="gu">@@ -25,13 +48,18 @@ class _ECDSACurve:</span>
<span class="w"> </span>    def __init__(self, curve_class, nist_name):
<span class="w"> </span>        self.nist_name = nist_name
<span class="w"> </span>        self.key_length = curve_class.key_size
<span class="gd">-        self.key_format_identifier = &#39;ecdsa-sha2-&#39; + self.nist_name</span>
<span class="gi">+</span>
<span class="gi">+        # Defined in RFC 5656 6.2</span>
<span class="gi">+        self.key_format_identifier = &quot;ecdsa-sha2-&quot; + self.nist_name</span>
<span class="gi">+</span>
<span class="gi">+        # Defined in RFC 5656 6.2.1</span>
<span class="w"> </span>        if self.key_length &lt;= 256:
<span class="w"> </span>            self.hash_object = hashes.SHA256
<span class="w"> </span>        elif self.key_length &lt;= 384:
<span class="w"> </span>            self.hash_object = hashes.SHA384
<span class="w"> </span>        else:
<span class="w"> </span>            self.hash_object = hashes.SHA512
<span class="gi">+</span>
<span class="w"> </span>        self.curve_class = curve_class


<span class="gu">@@ -45,18 +73,50 @@ class _ECDSACurveSet:</span>
<span class="w"> </span>    def __init__(self, ecdsa_curves):
<span class="w"> </span>        self.ecdsa_curves = ecdsa_curves

<span class="gi">+    def get_key_format_identifier_list(self):</span>
<span class="gi">+        return [curve.key_format_identifier for curve in self.ecdsa_curves]</span>
<span class="gi">+</span>
<span class="gi">+    def get_by_curve_class(self, curve_class):</span>
<span class="gi">+        for curve in self.ecdsa_curves:</span>
<span class="gi">+            if curve.curve_class == curve_class:</span>
<span class="gi">+                return curve</span>
<span class="gi">+</span>
<span class="gi">+    def get_by_key_format_identifier(self, key_format_identifier):</span>
<span class="gi">+        for curve in self.ecdsa_curves:</span>
<span class="gi">+            if curve.key_format_identifier == key_format_identifier:</span>
<span class="gi">+                return curve</span>
<span class="gi">+</span>
<span class="gi">+    def get_by_key_length(self, key_length):</span>
<span class="gi">+        for curve in self.ecdsa_curves:</span>
<span class="gi">+            if curve.key_length == key_length:</span>
<span class="gi">+                return curve</span>
<span class="gi">+</span>

<span class="w"> </span>class ECDSAKey(PKey):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Representation of an ECDSA key which can be used to sign and verify SSH2
<span class="w"> </span>    data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _ECDSA_CURVES = _ECDSACurveSet([_ECDSACurve(ec.SECP256R1, &#39;nistp256&#39;),</span>
<span class="gd">-        _ECDSACurve(ec.SECP384R1, &#39;nistp384&#39;), _ECDSACurve(ec.SECP521R1,</span>
<span class="gd">-        &#39;nistp521&#39;)])</span>

<span class="gd">-    def __init__(self, msg=None, data=None, filename=None, password=None,</span>
<span class="gd">-        vals=None, file_obj=None, validate_point=True):</span>
<span class="gi">+    _ECDSA_CURVES = _ECDSACurveSet(</span>
<span class="gi">+        [</span>
<span class="gi">+            _ECDSACurve(ec.SECP256R1, &quot;nistp256&quot;),</span>
<span class="gi">+            _ECDSACurve(ec.SECP384R1, &quot;nistp384&quot;),</span>
<span class="gi">+            _ECDSACurve(ec.SECP521R1, &quot;nistp521&quot;),</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg=None,</span>
<span class="gi">+        data=None,</span>
<span class="gi">+        filename=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        vals=None,</span>
<span class="gi">+        file_obj=None,</span>
<span class="gi">+        # TODO 4.0: remove; it does nothing since porting to cryptography.io</span>
<span class="gi">+        validate_point=True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.verifying_key = None
<span class="w"> </span>        self.signing_key = None
<span class="w"> </span>        self.public_blob = None
<span class="gu">@@ -66,39 +126,139 @@ class ECDSAKey(PKey):</span>
<span class="w"> </span>        if filename is not None:
<span class="w"> </span>            self._from_private_key_file(filename, password)
<span class="w"> </span>            return
<span class="gd">-        if msg is None and data is not None:</span>
<span class="gi">+        if (msg is None) and (data is not None):</span>
<span class="w"> </span>            msg = Message(data)
<span class="w"> </span>        if vals is not None:
<span class="w"> </span>            self.signing_key, self.verifying_key = vals
<span class="w"> </span>            c_class = self.signing_key.curve.__class__
<span class="w"> </span>            self.ecdsa_curve = self._ECDSA_CURVES.get_by_curve_class(c_class)
<span class="w"> </span>        else:
<span class="gi">+            # Must set ecdsa_curve first; subroutines called herein may need to</span>
<span class="gi">+            # spit out our get_name(), which relies on this.</span>
<span class="w"> </span>            key_type = msg.get_text()
<span class="gd">-            suffix = &#39;-cert-v01@openssh.com&#39;</span>
<span class="gi">+            # But this also means we need to hand it a real key/curve</span>
<span class="gi">+            # identifier, so strip out any cert business. (NOTE: could push</span>
<span class="gi">+            # that into _ECDSACurveSet.get_by_key_format_identifier(), but it</span>
<span class="gi">+            # feels more correct to do it here?)</span>
<span class="gi">+            suffix = &quot;-cert-v01@openssh.com&quot;</span>
<span class="w"> </span>            if key_type.endswith(suffix):
<span class="gd">-                key_type = key_type[:-len(suffix)]</span>
<span class="gi">+                key_type = key_type[: -len(suffix)]</span>
<span class="w"> </span>            self.ecdsa_curve = self._ECDSA_CURVES.get_by_key_format_identifier(
<span class="gd">-                key_type)</span>
<span class="gi">+                key_type</span>
<span class="gi">+            )</span>
<span class="w"> </span>            key_types = self._ECDSA_CURVES.get_key_format_identifier_list()
<span class="gd">-            cert_types = [&#39;{}-cert-v01@openssh.com&#39;.format(x) for x in</span>
<span class="gd">-                key_types]</span>
<span class="gd">-            self._check_type_and_load_cert(msg=msg, key_type=key_types,</span>
<span class="gd">-                cert_type=cert_types)</span>
<span class="gi">+            cert_types = [</span>
<span class="gi">+                &quot;{}-cert-v01@openssh.com&quot;.format(x) for x in key_types</span>
<span class="gi">+            ]</span>
<span class="gi">+            self._check_type_and_load_cert(</span>
<span class="gi">+                msg=msg, key_type=key_types, cert_type=cert_types</span>
<span class="gi">+            )</span>
<span class="w"> </span>            curvename = msg.get_text()
<span class="w"> </span>            if curvename != self.ecdsa_curve.nist_name:
<span class="gd">-                raise SSHException(&quot;Can&#39;t handle curve of type {}&quot;.format(</span>
<span class="gd">-                    curvename))</span>
<span class="gi">+                raise SSHException(</span>
<span class="gi">+                    &quot;Can&#39;t handle curve of type {}&quot;.format(curvename)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>            pointinfo = msg.get_binary()
<span class="w"> </span>            try:
<span class="gd">-                key = ec.EllipticCurvePublicKey.from_encoded_point(self.</span>
<span class="gd">-                    ecdsa_curve.curve_class(), pointinfo)</span>
<span class="gi">+                key = ec.EllipticCurvePublicKey.from_encoded_point(</span>
<span class="gi">+                    self.ecdsa_curve.curve_class(), pointinfo</span>
<span class="gi">+                )</span>
<span class="w"> </span>                self.verifying_key = key
<span class="w"> </span>            except ValueError:
<span class="gd">-                raise SSHException(&#39;Invalid public key&#39;)</span>
<span class="gi">+                raise SSHException(&quot;Invalid public key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def identifiers(cls):</span>
<span class="gi">+        return cls._ECDSA_CURVES.get_key_format_identifier_list()</span>
<span class="gi">+</span>
<span class="gi">+    # TODO 4.0: deprecate/remove</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def supported_key_format_identifiers(cls):</span>
<span class="gi">+        return cls.identifiers()</span>
<span class="gi">+</span>
<span class="gi">+    def asbytes(self):</span>
<span class="gi">+        key = self.verifying_key</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_string(self.ecdsa_curve.key_format_identifier)</span>
<span class="gi">+        m.add_string(self.ecdsa_curve.nist_name)</span>
<span class="gi">+</span>
<span class="gi">+        numbers = key.public_numbers()</span>
<span class="gi">+</span>
<span class="gi">+        key_size_bytes = (key.curve.key_size + 7) // 8</span>
<span class="gi">+</span>
<span class="gi">+        x_bytes = deflate_long(numbers.x, add_sign_padding=False)</span>
<span class="gi">+        x_bytes = b&quot;\x00&quot; * (key_size_bytes - len(x_bytes)) + x_bytes</span>
<span class="gi">+</span>
<span class="gi">+        y_bytes = deflate_long(numbers.y, add_sign_padding=False)</span>
<span class="gi">+        y_bytes = b&quot;\x00&quot; * (key_size_bytes - len(y_bytes)) + y_bytes</span>
<span class="gi">+</span>
<span class="gi">+        point_str = four_byte + x_bytes + y_bytes</span>
<span class="gi">+        m.add_string(point_str)</span>
<span class="gi">+        return m.asbytes()</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.asbytes()

<span class="gi">+    @property</span>
<span class="gi">+    def _fields(self):</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.get_name(),</span>
<span class="gi">+            self.verifying_key.public_numbers().x,</span>
<span class="gi">+            self.verifying_key.public_numbers().y,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_name(self):</span>
<span class="gi">+        return self.ecdsa_curve.key_format_identifier</span>
<span class="gi">+</span>
<span class="gi">+    def get_bits(self):</span>
<span class="gi">+        return self.ecdsa_curve.key_length</span>
<span class="gi">+</span>
<span class="gi">+    def can_sign(self):</span>
<span class="gi">+        return self.signing_key is not None</span>
<span class="gi">+</span>
<span class="gi">+    def sign_ssh_data(self, data, algorithm=None):</span>
<span class="gi">+        ecdsa = ec.ECDSA(self.ecdsa_curve.hash_object())</span>
<span class="gi">+        sig = self.signing_key.sign(data, ecdsa)</span>
<span class="gi">+        r, s = decode_dss_signature(sig)</span>
<span class="gi">+</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_string(self.ecdsa_curve.key_format_identifier)</span>
<span class="gi">+        m.add_string(self._sigencode(r, s))</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    def verify_ssh_sig(self, data, msg):</span>
<span class="gi">+        if msg.get_text() != self.ecdsa_curve.key_format_identifier:</span>
<span class="gi">+            return False</span>
<span class="gi">+        sig = msg.get_binary()</span>
<span class="gi">+        sigR, sigS = self._sigdecode(sig)</span>
<span class="gi">+        signature = encode_dss_signature(sigR, sigS)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.verifying_key.verify(</span>
<span class="gi">+                signature, data, ec.ECDSA(self.ecdsa_curve.hash_object())</span>
<span class="gi">+            )</span>
<span class="gi">+        except InvalidSignature:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    def write_private_key_file(self, filename, password=None):</span>
<span class="gi">+        self._write_private_key_file(</span>
<span class="gi">+            filename,</span>
<span class="gi">+            self.signing_key,</span>
<span class="gi">+            serialization.PrivateFormat.TraditionalOpenSSL,</span>
<span class="gi">+            password=password,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def write_private_key(self, file_obj, password=None):</span>
<span class="gi">+        self._write_private_key(</span>
<span class="gi">+            file_obj,</span>
<span class="gi">+            self.signing_key,</span>
<span class="gi">+            serialization.PrivateFormat.TraditionalOpenSSL,</span>
<span class="gi">+            password=password,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def generate(cls, curve=ec.SECP256R1(), progress_func=None, bits=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -108,4 +268,72 @@ class ECDSAKey(PKey):</span>
<span class="w"> </span>        :param progress_func: Not used for this type of key.
<span class="w"> </span>        :returns: A new private key (`.ECDSAKey`) object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bits is not None:</span>
<span class="gi">+            curve = cls._ECDSA_CURVES.get_by_key_length(bits)</span>
<span class="gi">+            if curve is None:</span>
<span class="gi">+                raise ValueError(&quot;Unsupported key length: {:d}&quot;.format(bits))</span>
<span class="gi">+            curve = curve.curve_class()</span>
<span class="gi">+</span>
<span class="gi">+        private_key = ec.generate_private_key(curve, backend=default_backend())</span>
<span class="gi">+        return ECDSAKey(vals=(private_key, private_key.public_key()))</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _from_private_key_file(self, filename, password):</span>
<span class="gi">+        data = self._read_private_key_file(&quot;EC&quot;, filename, password)</span>
<span class="gi">+        self._decode_key(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _from_private_key(self, file_obj, password):</span>
<span class="gi">+        data = self._read_private_key(&quot;EC&quot;, file_obj, password)</span>
<span class="gi">+        self._decode_key(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _decode_key(self, data):</span>
<span class="gi">+        pkformat, data = data</span>
<span class="gi">+        if pkformat == self._PRIVATE_KEY_FORMAT_ORIGINAL:</span>
<span class="gi">+            try:</span>
<span class="gi">+                key = serialization.load_der_private_key(</span>
<span class="gi">+                    data, password=None, backend=default_backend()</span>
<span class="gi">+                )</span>
<span class="gi">+            except (</span>
<span class="gi">+                ValueError,</span>
<span class="gi">+                AssertionError,</span>
<span class="gi">+                TypeError,</span>
<span class="gi">+                UnsupportedAlgorithm,</span>
<span class="gi">+            ) as e:</span>
<span class="gi">+                raise SSHException(str(e))</span>
<span class="gi">+        elif pkformat == self._PRIVATE_KEY_FORMAT_OPENSSH:</span>
<span class="gi">+            try:</span>
<span class="gi">+                msg = Message(data)</span>
<span class="gi">+                curve_name = msg.get_text()</span>
<span class="gi">+                verkey = msg.get_binary()  # noqa: F841</span>
<span class="gi">+                sigkey = msg.get_mpint()</span>
<span class="gi">+                name = &quot;ecdsa-sha2-&quot; + curve_name</span>
<span class="gi">+                curve = self._ECDSA_CURVES.get_by_key_format_identifier(name)</span>
<span class="gi">+                if not curve:</span>
<span class="gi">+                    raise SSHException(&quot;Invalid key curve identifier&quot;)</span>
<span class="gi">+                key = ec.derive_private_key(</span>
<span class="gi">+                    sigkey, curve.curve_class(), default_backend()</span>
<span class="gi">+                )</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                # PKey._read_private_key_openssh() should check or return</span>
<span class="gi">+                # keytype - parsing could fail for any reason due to wrong type</span>
<span class="gi">+                raise SSHException(str(e))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._got_bad_key_format_id(pkformat)</span>
<span class="gi">+</span>
<span class="gi">+        self.signing_key = key</span>
<span class="gi">+        self.verifying_key = key.public_key()</span>
<span class="gi">+        curve_class = key.curve.__class__</span>
<span class="gi">+        self.ecdsa_curve = self._ECDSA_CURVES.get_by_curve_class(curve_class)</span>
<span class="gi">+</span>
<span class="gi">+    def _sigencode(self, r, s):</span>
<span class="gi">+        msg = Message()</span>
<span class="gi">+        msg.add_mpint(r)</span>
<span class="gi">+        msg.add_mpint(s)</span>
<span class="gi">+        return msg.asbytes()</span>
<span class="gi">+</span>
<span class="gi">+    def _sigdecode(self, sig):</span>
<span class="gi">+        msg = Message(sig)</span>
<span class="gi">+        r = msg.get_mpint()</span>
<span class="gi">+        s = msg.get_mpint()</span>
<span class="gi">+        return r, s</span>
<span class="gh">diff --git a/paramiko/ed25519key.py b/paramiko/ed25519key.py</span>
<span class="gh">index 3b22f73a..e5e81ac5 100644</span>
<span class="gd">--- a/paramiko/ed25519key.py</span>
<span class="gi">+++ b/paramiko/ed25519key.py</span>
<span class="gu">@@ -1,7 +1,26 @@</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>import bcrypt
<span class="gi">+</span>
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives.ciphers import Cipher
<span class="gi">+</span>
<span class="w"> </span>import nacl.signing
<span class="gi">+</span>
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.pkey import PKey, OPENSSH_AUTH_MAGIC, _unpad_openssh
<span class="w"> </span>from paramiko.util import b
<span class="gu">@@ -19,26 +38,175 @@ class Ed25519Key(PKey):</span>
<span class="w"> </span>    .. versionchanged:: 2.3
<span class="w"> </span>        Added a ``file_obj`` parameter to match other key classes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;ssh-ed25519&#39;</span>

<span class="gd">-    def __init__(self, msg=None, data=None, filename=None, password=None,</span>
<span class="gd">-        file_obj=None):</span>
<span class="gi">+    name = &quot;ssh-ed25519&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, msg=None, data=None, filename=None, password=None, file_obj=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.public_blob = None
<span class="w"> </span>        verifying_key = signing_key = None
<span class="w"> </span>        if msg is None and data is not None:
<span class="w"> </span>            msg = Message(data)
<span class="w"> </span>        if msg is not None:
<span class="gd">-            self._check_type_and_load_cert(msg=msg, key_type=self.name,</span>
<span class="gd">-                cert_type=&#39;ssh-ed25519-cert-v01@openssh.com&#39;)</span>
<span class="gi">+            self._check_type_and_load_cert(</span>
<span class="gi">+                msg=msg,</span>
<span class="gi">+                key_type=self.name,</span>
<span class="gi">+                cert_type=&quot;ssh-ed25519-cert-v01@openssh.com&quot;,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            verifying_key = nacl.signing.VerifyKey(msg.get_binary())
<span class="w"> </span>        elif filename is not None:
<span class="gd">-            with open(filename, &#39;r&#39;) as f:</span>
<span class="gd">-                pkformat, data = self._read_private_key(&#39;OPENSSH&#39;, f)</span>
<span class="gi">+            with open(filename, &quot;r&quot;) as f:</span>
<span class="gi">+                pkformat, data = self._read_private_key(&quot;OPENSSH&quot;, f)</span>
<span class="w"> </span>        elif file_obj is not None:
<span class="gd">-            pkformat, data = self._read_private_key(&#39;OPENSSH&#39;, file_obj)</span>
<span class="gi">+            pkformat, data = self._read_private_key(&quot;OPENSSH&quot;, file_obj)</span>
<span class="gi">+</span>
<span class="w"> </span>        if filename or file_obj:
<span class="w"> </span>            signing_key = self._parse_signing_key_data(data, password)
<span class="gi">+</span>
<span class="w"> </span>        if signing_key is None and verifying_key is None:
<span class="gd">-            raise ValueError(&#39;need a key&#39;)</span>
<span class="gi">+            raise ValueError(&quot;need a key&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self._signing_key = signing_key
<span class="w"> </span>        self._verifying_key = verifying_key
<span class="gi">+</span>
<span class="gi">+    def _parse_signing_key_data(self, data, password):</span>
<span class="gi">+        from paramiko.transport import Transport</span>
<span class="gi">+</span>
<span class="gi">+        # We may eventually want this to be usable for other key types, as</span>
<span class="gi">+        # OpenSSH moves to it, but for now this is just for Ed25519 keys.</span>
<span class="gi">+        # This format is described here:</span>
<span class="gi">+        # https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key</span>
<span class="gi">+        # The description isn&#39;t totally complete, and I had to refer to the</span>
<span class="gi">+        # source for a full implementation.</span>
<span class="gi">+        message = Message(data)</span>
<span class="gi">+        if message.get_bytes(len(OPENSSH_AUTH_MAGIC)) != OPENSSH_AUTH_MAGIC:</span>
<span class="gi">+            raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        ciphername = message.get_text()</span>
<span class="gi">+        kdfname = message.get_text()</span>
<span class="gi">+        kdfoptions = message.get_binary()</span>
<span class="gi">+        num_keys = message.get_int()</span>
<span class="gi">+</span>
<span class="gi">+        if kdfname == &quot;none&quot;:</span>
<span class="gi">+            # kdfname of &quot;none&quot; must have an empty kdfoptions, the ciphername</span>
<span class="gi">+            # must be &quot;none&quot;</span>
<span class="gi">+            if kdfoptions or ciphername != &quot;none&quot;:</span>
<span class="gi">+                raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+        elif kdfname == &quot;bcrypt&quot;:</span>
<span class="gi">+            if not password:</span>
<span class="gi">+                raise PasswordRequiredException(</span>
<span class="gi">+                    &quot;Private key file is encrypted&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            kdf = Message(kdfoptions)</span>
<span class="gi">+            bcrypt_salt = kdf.get_binary()</span>
<span class="gi">+            bcrypt_rounds = kdf.get_int()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if ciphername != &quot;none&quot; and ciphername not in Transport._cipher_info:</span>
<span class="gi">+            raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        public_keys = []</span>
<span class="gi">+        for _ in range(num_keys):</span>
<span class="gi">+            pubkey = Message(message.get_binary())</span>
<span class="gi">+            if pubkey.get_text() != self.name:</span>
<span class="gi">+                raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+            public_keys.append(pubkey.get_binary())</span>
<span class="gi">+</span>
<span class="gi">+        private_ciphertext = message.get_binary()</span>
<span class="gi">+        if ciphername == &quot;none&quot;:</span>
<span class="gi">+            private_data = private_ciphertext</span>
<span class="gi">+        else:</span>
<span class="gi">+            cipher = Transport._cipher_info[ciphername]</span>
<span class="gi">+            key = bcrypt.kdf(</span>
<span class="gi">+                password=b(password),</span>
<span class="gi">+                salt=bcrypt_salt,</span>
<span class="gi">+                desired_key_bytes=cipher[&quot;key-size&quot;] + cipher[&quot;block-size&quot;],</span>
<span class="gi">+                rounds=bcrypt_rounds,</span>
<span class="gi">+                # We can&#39;t control how many rounds are on disk, so no sense</span>
<span class="gi">+                # warning about it.</span>
<span class="gi">+                ignore_few_rounds=True,</span>
<span class="gi">+            )</span>
<span class="gi">+            decryptor = Cipher(</span>
<span class="gi">+                cipher[&quot;class&quot;](key[: cipher[&quot;key-size&quot;]]),</span>
<span class="gi">+                cipher[&quot;mode&quot;](key[cipher[&quot;key-size&quot;] :]),</span>
<span class="gi">+                backend=default_backend(),</span>
<span class="gi">+            ).decryptor()</span>
<span class="gi">+            private_data = (</span>
<span class="gi">+                decryptor.update(private_ciphertext) + decryptor.finalize()</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        message = Message(_unpad_openssh(private_data))</span>
<span class="gi">+        if message.get_int() != message.get_int():</span>
<span class="gi">+            raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        signing_keys = []</span>
<span class="gi">+        for i in range(num_keys):</span>
<span class="gi">+            if message.get_text() != self.name:</span>
<span class="gi">+                raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+            # A copy of the public key, again, ignore.</span>
<span class="gi">+            public = message.get_binary()</span>
<span class="gi">+            key_data = message.get_binary()</span>
<span class="gi">+            # The second half of the key data is yet another copy of the public</span>
<span class="gi">+            # key...</span>
<span class="gi">+            signing_key = nacl.signing.SigningKey(key_data[:32])</span>
<span class="gi">+            # Verify that all the public keys are the same...</span>
<span class="gi">+            assert (</span>
<span class="gi">+                signing_key.verify_key.encode()</span>
<span class="gi">+                == public</span>
<span class="gi">+                == public_keys[i]</span>
<span class="gi">+                == key_data[32:]</span>
<span class="gi">+            )</span>
<span class="gi">+            signing_keys.append(signing_key)</span>
<span class="gi">+            # Comment, ignore.</span>
<span class="gi">+            message.get_binary()</span>
<span class="gi">+</span>
<span class="gi">+        if len(signing_keys) != 1:</span>
<span class="gi">+            raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+        return signing_keys[0]</span>
<span class="gi">+</span>
<span class="gi">+    def asbytes(self):</span>
<span class="gi">+        if self.can_sign():</span>
<span class="gi">+            v = self._signing_key.verify_key</span>
<span class="gi">+        else:</span>
<span class="gi">+            v = self._verifying_key</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_string(self.name)</span>
<span class="gi">+        m.add_string(v.encode())</span>
<span class="gi">+        return m.asbytes()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _fields(self):</span>
<span class="gi">+        if self.can_sign():</span>
<span class="gi">+            v = self._signing_key.verify_key</span>
<span class="gi">+        else:</span>
<span class="gi">+            v = self._verifying_key</span>
<span class="gi">+        return (self.get_name(), v)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO 4.0: remove</span>
<span class="gi">+    def get_name(self):</span>
<span class="gi">+        return self.name</span>
<span class="gi">+</span>
<span class="gi">+    def get_bits(self):</span>
<span class="gi">+        return 256</span>
<span class="gi">+</span>
<span class="gi">+    def can_sign(self):</span>
<span class="gi">+        return self._signing_key is not None</span>
<span class="gi">+</span>
<span class="gi">+    def sign_ssh_data(self, data, algorithm=None):</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_string(self.name)</span>
<span class="gi">+        m.add_string(self._signing_key.sign(data).signature)</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    def verify_ssh_sig(self, data, msg):</span>
<span class="gi">+        if msg.get_text() != self.name:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._verifying_key.verify(data, msg.get_binary())</span>
<span class="gi">+        except nacl.exceptions.BadSignatureError:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return True</span>
<span class="gh">diff --git a/paramiko/file.py b/paramiko/file.py</span>
<span class="gh">index 9ff61859..a36abb98 100644</span>
<span class="gd">--- a/paramiko/file.py</span>
<span class="gi">+++ b/paramiko/file.py</span>
<span class="gu">@@ -1,5 +1,30 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="w"> </span>from io import BytesIO
<span class="gd">-from paramiko.common import linefeed_byte_value, crlf, cr_byte, linefeed_byte, cr_byte_value</span>
<span class="gi">+</span>
<span class="gi">+from paramiko.common import (</span>
<span class="gi">+    linefeed_byte_value,</span>
<span class="gi">+    crlf,</span>
<span class="gi">+    cr_byte,</span>
<span class="gi">+    linefeed_byte,</span>
<span class="gi">+    cr_byte_value,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from paramiko.util import ClosingContextManager, u


<span class="gu">@@ -8,17 +33,20 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>    Reusable base class to implement Python-style file buffering around a
<span class="w"> </span>    simpler stream.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _DEFAULT_BUFSIZE = 8192
<span class="gi">+</span>
<span class="w"> </span>    SEEK_SET = 0
<span class="w"> </span>    SEEK_CUR = 1
<span class="w"> </span>    SEEK_END = 2
<span class="gd">-    FLAG_READ = 1</span>
<span class="gd">-    FLAG_WRITE = 2</span>
<span class="gd">-    FLAG_APPEND = 4</span>
<span class="gd">-    FLAG_BINARY = 16</span>
<span class="gd">-    FLAG_BUFFERED = 32</span>
<span class="gd">-    FLAG_LINE_BUFFERED = 64</span>
<span class="gd">-    FLAG_UNIVERSAL_NEWLINE = 128</span>
<span class="gi">+</span>
<span class="gi">+    FLAG_READ = 0x1</span>
<span class="gi">+    FLAG_WRITE = 0x2</span>
<span class="gi">+    FLAG_APPEND = 0x4</span>
<span class="gi">+    FLAG_BINARY = 0x10</span>
<span class="gi">+    FLAG_BUFFERED = 0x20</span>
<span class="gi">+    FLAG_LINE_BUFFERED = 0x40</span>
<span class="gi">+    FLAG_UNIVERSAL_NEWLINE = 0x80</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.newlines = None
<span class="gu">@@ -28,7 +56,11 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        self._rbuffer = bytes()
<span class="w"> </span>        self._at_trailing_cr = False
<span class="w"> </span>        self._closed = False
<span class="gi">+        # pos - position within the file, according to the user</span>
<span class="gi">+        # realpos - position according the OS</span>
<span class="gi">+        # (these may be different because we buffer for line reading)</span>
<span class="w"> </span>        self._pos = self._realpos = 0
<span class="gi">+        # size only matters for seekable files</span>
<span class="w"> </span>        self._size = 0

<span class="w"> </span>    def __del__(self):
<span class="gu">@@ -43,21 +75,24 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        :raises: ``ValueError`` -- if the file is closed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if self._closed:
<span class="gd">-            raise ValueError(&#39;I/O operation on closed file&#39;)</span>
<span class="gi">+            raise ValueError(&quot;I/O operation on closed file&quot;)</span>
<span class="w"> </span>        return self

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close the file.  Future read and write operations will fail.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        self._closed = True</span>

<span class="w"> </span>    def flush(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write out any data in the write buffer.  This may do nothing if write
<span class="w"> </span>        buffering is not turned on.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._write_all(self._wbuffer.getvalue())</span>
<span class="gi">+        self._wbuffer = BytesIO()</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def __next__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -84,7 +119,7 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            `True` if the file can be read from. If `False`, `read` will raise
<span class="w"> </span>            an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self._flags &amp; self.FLAG_READ) == self.FLAG_READ</span>

<span class="w"> </span>    def writable(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -94,7 +129,7 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            `True` if the file can be written to. If `False`, `write` will
<span class="w"> </span>            raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self._flags &amp; self.FLAG_WRITE) == self.FLAG_WRITE</span>

<span class="w"> </span>    def seekable(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -104,7 +139,7 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            `True` if the file supports random access. If `False`, `seek` will
<span class="w"> </span>            raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def readinto(self, buff):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -114,7 +149,9 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        :returns:
<span class="w"> </span>            The number of bytes read.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = self.read(len(buff))</span>
<span class="gi">+        buff[: len(data)] = data</span>
<span class="gi">+        return len(data)</span>

<span class="w"> </span>    def read(self, size=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -133,7 +170,47 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            data read from the file (as bytes), or an empty string if EOF was
<span class="w"> </span>            encountered immediately
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise IOError(&quot;File is closed&quot;)</span>
<span class="gi">+        if not (self._flags &amp; self.FLAG_READ):</span>
<span class="gi">+            raise IOError(&quot;File is not open for reading&quot;)</span>
<span class="gi">+        if (size is None) or (size &lt; 0):</span>
<span class="gi">+            # go for broke</span>
<span class="gi">+            result = bytearray(self._rbuffer)</span>
<span class="gi">+            self._rbuffer = bytes()</span>
<span class="gi">+            self._pos += len(result)</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    new_data = self._read(self._DEFAULT_BUFSIZE)</span>
<span class="gi">+                except EOFError:</span>
<span class="gi">+                    new_data = None</span>
<span class="gi">+                if (new_data is None) or (len(new_data) == 0):</span>
<span class="gi">+                    break</span>
<span class="gi">+                result.extend(new_data)</span>
<span class="gi">+                self._realpos += len(new_data)</span>
<span class="gi">+                self._pos += len(new_data)</span>
<span class="gi">+            return bytes(result)</span>
<span class="gi">+        if size &lt;= len(self._rbuffer):</span>
<span class="gi">+            result = self._rbuffer[:size]</span>
<span class="gi">+            self._rbuffer = self._rbuffer[size:]</span>
<span class="gi">+            self._pos += len(result)</span>
<span class="gi">+            return result</span>
<span class="gi">+        while len(self._rbuffer) &lt; size:</span>
<span class="gi">+            read_size = size - len(self._rbuffer)</span>
<span class="gi">+            if self._flags &amp; self.FLAG_BUFFERED:</span>
<span class="gi">+                read_size = max(self._bufsize, read_size)</span>
<span class="gi">+            try:</span>
<span class="gi">+                new_data = self._read(read_size)</span>
<span class="gi">+            except EOFError:</span>
<span class="gi">+                new_data = None</span>
<span class="gi">+            if (new_data is None) or (len(new_data) == 0):</span>
<span class="gi">+                break</span>
<span class="gi">+            self._rbuffer += new_data</span>
<span class="gi">+            self._realpos += len(new_data)</span>
<span class="gi">+        result = self._rbuffer[:size]</span>
<span class="gi">+        self._rbuffer = self._rbuffer[size:]</span>
<span class="gi">+        self._pos += len(result)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def readline(self, size=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -157,7 +234,88 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            Else: the encoding of the file is assumed to be UTF-8 and character
<span class="w"> </span>            strings (`str`) are returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # it&#39;s almost silly how complex this function is.</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise IOError(&quot;File is closed&quot;)</span>
<span class="gi">+        if not (self._flags &amp; self.FLAG_READ):</span>
<span class="gi">+            raise IOError(&quot;File not open for reading&quot;)</span>
<span class="gi">+        line = self._rbuffer</span>
<span class="gi">+        truncated = False</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if (</span>
<span class="gi">+                self._at_trailing_cr</span>
<span class="gi">+                and self._flags &amp; self.FLAG_UNIVERSAL_NEWLINE</span>
<span class="gi">+                and len(line) &gt; 0</span>
<span class="gi">+            ):</span>
<span class="gi">+                # edge case: the newline may be &#39;\r\n&#39; and we may have read</span>
<span class="gi">+                # only the first &#39;\r&#39; last time.</span>
<span class="gi">+                if line[0] == linefeed_byte_value:</span>
<span class="gi">+                    line = line[1:]</span>
<span class="gi">+                    self._record_newline(crlf)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._record_newline(cr_byte)</span>
<span class="gi">+                self._at_trailing_cr = False</span>
<span class="gi">+            # check size before looking for a linefeed, in case we already have</span>
<span class="gi">+            # enough.</span>
<span class="gi">+            if (size is not None) and (size &gt;= 0):</span>
<span class="gi">+                if len(line) &gt;= size:</span>
<span class="gi">+                    # truncate line</span>
<span class="gi">+                    self._rbuffer = line[size:]</span>
<span class="gi">+                    line = line[:size]</span>
<span class="gi">+                    truncated = True</span>
<span class="gi">+                    break</span>
<span class="gi">+                n = size - len(line)</span>
<span class="gi">+            else:</span>
<span class="gi">+                n = self._bufsize</span>
<span class="gi">+            if linefeed_byte in line or (</span>
<span class="gi">+                self._flags &amp; self.FLAG_UNIVERSAL_NEWLINE and cr_byte in line</span>
<span class="gi">+            ):</span>
<span class="gi">+                break</span>
<span class="gi">+            try:</span>
<span class="gi">+                new_data = self._read(n)</span>
<span class="gi">+            except EOFError:</span>
<span class="gi">+                new_data = None</span>
<span class="gi">+            if (new_data is None) or (len(new_data) == 0):</span>
<span class="gi">+                self._rbuffer = bytes()</span>
<span class="gi">+                self._pos += len(line)</span>
<span class="gi">+                return line if self._flags &amp; self.FLAG_BINARY else u(line)</span>
<span class="gi">+            line += new_data</span>
<span class="gi">+            self._realpos += len(new_data)</span>
<span class="gi">+        # find the newline</span>
<span class="gi">+        pos = line.find(linefeed_byte)</span>
<span class="gi">+        if self._flags &amp; self.FLAG_UNIVERSAL_NEWLINE:</span>
<span class="gi">+            rpos = line.find(cr_byte)</span>
<span class="gi">+            if (rpos &gt;= 0) and (rpos &lt; pos or pos &lt; 0):</span>
<span class="gi">+                pos = rpos</span>
<span class="gi">+        if pos == -1:</span>
<span class="gi">+            # we couldn&#39;t find a newline in the truncated string, return it</span>
<span class="gi">+            self._pos += len(line)</span>
<span class="gi">+            return line if self._flags &amp; self.FLAG_BINARY else u(line)</span>
<span class="gi">+        xpos = pos + 1</span>
<span class="gi">+        if (</span>
<span class="gi">+            line[pos] == cr_byte_value</span>
<span class="gi">+            and xpos &lt; len(line)</span>
<span class="gi">+            and line[xpos] == linefeed_byte_value</span>
<span class="gi">+        ):</span>
<span class="gi">+            xpos += 1</span>
<span class="gi">+        # if the string was truncated, _rbuffer needs to have the string after</span>
<span class="gi">+        # the newline character plus the truncated part of the line we stored</span>
<span class="gi">+        # earlier in _rbuffer</span>
<span class="gi">+        if truncated:</span>
<span class="gi">+            self._rbuffer = line[xpos:] + self._rbuffer</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._rbuffer = line[xpos:]</span>
<span class="gi">+</span>
<span class="gi">+        lf = line[pos:xpos]</span>
<span class="gi">+        line = line[:pos] + linefeed_byte</span>
<span class="gi">+        if (len(self._rbuffer) == 0) and (lf == cr_byte):</span>
<span class="gi">+            # we could read the line up to a &#39;\r&#39; and there could still be a</span>
<span class="gi">+            # &#39;\n&#39; following that we read next time.  note that and eat it.</span>
<span class="gi">+            self._at_trailing_cr = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._record_newline(lf)</span>
<span class="gi">+        self._pos += len(line)</span>
<span class="gi">+        return line if self._flags &amp; self.FLAG_BINARY else u(line)</span>

<span class="w"> </span>    def readlines(self, sizehint=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -169,7 +327,17 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        :param int sizehint: desired maximum number of bytes to read.
<span class="w"> </span>        :returns: list of lines read from the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        byte_count = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            line = self.readline()</span>
<span class="gi">+            if len(line) == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+            lines.append(line)</span>
<span class="gi">+            byte_count += len(line)</span>
<span class="gi">+            if (sizehint is not None) and (byte_count &gt;= sizehint):</span>
<span class="gi">+                break</span>
<span class="gi">+        return lines</span>

<span class="w"> </span>    def seek(self, offset, whence=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -189,7 +357,7 @@ class BufferedFile(ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the file doesn&#39;t support random access.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise IOError(&quot;File does not support seeking.&quot;)</span>

<span class="w"> </span>    def tell(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -199,7 +367,7 @@ class BufferedFile(ClosingContextManager):</span>

<span class="w"> </span>        :returns: file position (`number &lt;int&gt;` of bytes).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._pos</span>

<span class="w"> </span>    def write(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -210,7 +378,32 @@ class BufferedFile(ClosingContextManager):</span>

<span class="w"> </span>        :param data: ``str``/``bytes`` data to write
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(data, str):</span>
<span class="gi">+            # Accept text and encode as utf-8 for compatibility only.</span>
<span class="gi">+            data = data.encode(&quot;utf-8&quot;)</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise IOError(&quot;File is closed&quot;)</span>
<span class="gi">+        if not (self._flags &amp; self.FLAG_WRITE):</span>
<span class="gi">+            raise IOError(&quot;File not open for writing&quot;)</span>
<span class="gi">+        if not (self._flags &amp; self.FLAG_BUFFERED):</span>
<span class="gi">+            self._write_all(data)</span>
<span class="gi">+            return</span>
<span class="gi">+        self._wbuffer.write(data)</span>
<span class="gi">+        if self._flags &amp; self.FLAG_LINE_BUFFERED:</span>
<span class="gi">+            # only scan the new data for linefeed, to avoid wasting time.</span>
<span class="gi">+            last_newline_pos = data.rfind(linefeed_byte)</span>
<span class="gi">+            if last_newline_pos &gt;= 0:</span>
<span class="gi">+                wbuf = self._wbuffer.getvalue()</span>
<span class="gi">+                last_newline_pos += len(wbuf) - len(data)</span>
<span class="gi">+                self._write_all(wbuf[: last_newline_pos + 1])</span>
<span class="gi">+                self._wbuffer = BytesIO()</span>
<span class="gi">+                self._wbuffer.write(wbuf[last_newline_pos + 1 :])</span>
<span class="gi">+            return</span>
<span class="gi">+        # even if we&#39;re line buffering, if the buffer has grown past the</span>
<span class="gi">+        # buffer size, force a flush.</span>
<span class="gi">+        if self._wbuffer.tell() &gt;= self._bufsize:</span>
<span class="gi">+            self.flush()</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def writelines(self, sequence):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -221,14 +414,22 @@ class BufferedFile(ClosingContextManager):</span>

<span class="w"> </span>        :param sequence: an iterable sequence of strings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for line in sequence:</span>
<span class="gi">+            self.write(line)</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def xreadlines(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Identical to ``iter(f)``.  This is a deprecated file interface that
<span class="w"> </span>        predates Python iterator support.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def closed(self):</span>
<span class="gi">+        return self._closed</span>
<span class="gi">+</span>
<span class="gi">+    # ...overrides...</span>

<span class="w"> </span>    def _read(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -236,14 +437,14 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        Read data from the stream.  Return ``None`` or raise ``EOFError`` to
<span class="w"> </span>        indicate EOF.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise EOFError()</span>

<span class="w"> </span>    def _write(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        (subclass override)
<span class="w"> </span>        Write data into the stream.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise IOError(&quot;write not implemented&quot;)</span>

<span class="w"> </span>    def _get_size(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -254,10 +455,74 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        a stream that can&#39;t be randomly accessed, you don&#39;t need to override
<span class="w"> </span>        this method,
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>

<span class="gd">-    def _set_mode(self, mode=&#39;r&#39;, bufsize=-1):</span>
<span class="gi">+    def _set_mode(self, mode=&quot;r&quot;, bufsize=-1):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Subclasses call this method to initialize the BufferedFile.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # set bufsize in any event, because it&#39;s used for readline().</span>
<span class="gi">+        self._bufsize = self._DEFAULT_BUFSIZE</span>
<span class="gi">+        if bufsize &lt; 0:</span>
<span class="gi">+            # do no buffering by default, because otherwise writes will get</span>
<span class="gi">+            # buffered in a way that will probably confuse people.</span>
<span class="gi">+            bufsize = 0</span>
<span class="gi">+        if bufsize == 1:</span>
<span class="gi">+            # apparently, line buffering only affects writes.  reads are only</span>
<span class="gi">+            # buffered if you call readline (directly or indirectly: iterating</span>
<span class="gi">+            # over a file will indirectly call readline).</span>
<span class="gi">+            self._flags |= self.FLAG_BUFFERED | self.FLAG_LINE_BUFFERED</span>
<span class="gi">+        elif bufsize &gt; 1:</span>
<span class="gi">+            self._bufsize = bufsize</span>
<span class="gi">+            self._flags |= self.FLAG_BUFFERED</span>
<span class="gi">+            self._flags &amp;= ~self.FLAG_LINE_BUFFERED</span>
<span class="gi">+        elif bufsize == 0:</span>
<span class="gi">+            # unbuffered</span>
<span class="gi">+            self._flags &amp;= ~(self.FLAG_BUFFERED | self.FLAG_LINE_BUFFERED)</span>
<span class="gi">+</span>
<span class="gi">+        if (&quot;r&quot; in mode) or (&quot;+&quot; in mode):</span>
<span class="gi">+            self._flags |= self.FLAG_READ</span>
<span class="gi">+        if (&quot;w&quot; in mode) or (&quot;+&quot; in mode):</span>
<span class="gi">+            self._flags |= self.FLAG_WRITE</span>
<span class="gi">+        if &quot;a&quot; in mode:</span>
<span class="gi">+            self._flags |= self.FLAG_WRITE | self.FLAG_APPEND</span>
<span class="gi">+            self._size = self._get_size()</span>
<span class="gi">+            self._pos = self._realpos = self._size</span>
<span class="gi">+        if &quot;b&quot; in mode:</span>
<span class="gi">+            self._flags |= self.FLAG_BINARY</span>
<span class="gi">+        if &quot;U&quot; in mode:</span>
<span class="gi">+            self._flags |= self.FLAG_UNIVERSAL_NEWLINE</span>
<span class="gi">+            # built-in file objects have this attribute to store which kinds of</span>
<span class="gi">+            # line terminations they&#39;ve seen:</span>
<span class="gi">+            # &lt;http://www.python.org/doc/current/lib/built-in-funcs.html&gt;</span>
<span class="gi">+            self.newlines = None</span>
<span class="gi">+</span>
<span class="gi">+    def _write_all(self, raw_data):</span>
<span class="gi">+        # the underlying stream may be something that does partial writes (like</span>
<span class="gi">+        # a socket).</span>
<span class="gi">+        data = memoryview(raw_data)</span>
<span class="gi">+        while len(data) &gt; 0:</span>
<span class="gi">+            count = self._write(data)</span>
<span class="gi">+            data = data[count:]</span>
<span class="gi">+            if self._flags &amp; self.FLAG_APPEND:</span>
<span class="gi">+                self._size += count</span>
<span class="gi">+                self._pos = self._realpos = self._size</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._pos += count</span>
<span class="gi">+                self._realpos += count</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _record_newline(self, newline):</span>
<span class="gi">+        # silliness about tracking what kinds of newlines we&#39;ve seen.</span>
<span class="gi">+        # i don&#39;t understand why it can be None, a string, or a tuple, instead</span>
<span class="gi">+        # of just always being a tuple, but we&#39;ll emulate that behavior anyway.</span>
<span class="gi">+        if not (self._flags &amp; self.FLAG_UNIVERSAL_NEWLINE):</span>
<span class="gi">+            return</span>
<span class="gi">+        if self.newlines is None:</span>
<span class="gi">+            self.newlines = newline</span>
<span class="gi">+        elif self.newlines != newline and isinstance(self.newlines, bytes):</span>
<span class="gi">+            self.newlines = (self.newlines, newline)</span>
<span class="gi">+        elif newline not in self.newlines:</span>
<span class="gi">+            self.newlines += (newline,)</span>
<span class="gh">diff --git a/paramiko/hostkeys.py b/paramiko/hostkeys.py</span>
<span class="gh">index f2bbb85b..4d47e950 100644</span>
<span class="gd">--- a/paramiko/hostkeys.py</span>
<span class="gi">+++ b/paramiko/hostkeys.py</span>
<span class="gu">@@ -1,10 +1,32 @@</span>
<span class="gi">+# Copyright (C) 2006-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from base64 import encodebytes, decodebytes
<span class="w"> </span>import binascii
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import MutableMapping
<span class="w"> </span>from hashlib import sha1
<span class="w"> </span>from hmac import HMAC
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from paramiko.pkey import PKey, UnknownKeyType
<span class="w"> </span>from paramiko.util import get_logger, constant_time_bytes_eq, b, u
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="gu">@@ -29,6 +51,7 @@ class HostKeys(MutableMapping):</span>

<span class="w"> </span>        :param str filename: filename to load host keys from, or ``None``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # emulate a dict of { hostname: { keytype: PKey } }</span>
<span class="w"> </span>        self._entries = []
<span class="w"> </span>        if filename is not None:
<span class="w"> </span>            self.load(filename)
<span class="gu">@@ -42,7 +65,11 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>        :param str keytype: key type (``&quot;ssh-rsa&quot;`` or ``&quot;ssh-dss&quot;``)
<span class="w"> </span>        :param .PKey key: the key to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for e in self._entries:</span>
<span class="gi">+            if (hostname in e.hostnames) and (e.key.get_name() == keytype):</span>
<span class="gi">+                e.key = key</span>
<span class="gi">+                return</span>
<span class="gi">+        self._entries.append(HostKeyEntry([hostname], key))</span>

<span class="w"> </span>    def load(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -59,7 +86,22 @@ class HostKeys(MutableMapping):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if there was an error reading the file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(filename, &quot;r&quot;) as f:</span>
<span class="gi">+            for lineno, line in enumerate(f, 1):</span>
<span class="gi">+                line = line.strip()</span>
<span class="gi">+                if (len(line) == 0) or (line[0] == &quot;#&quot;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                try:</span>
<span class="gi">+                    entry = HostKeyEntry.from_line(line, lineno)</span>
<span class="gi">+                except SSHException:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if entry is not None:</span>
<span class="gi">+                    _hostnames = entry.hostnames</span>
<span class="gi">+                    for h in _hostnames:</span>
<span class="gi">+                        if self.check(h, entry.key):</span>
<span class="gi">+                            entry.hostnames.remove(h)</span>
<span class="gi">+                    if len(entry.hostnames):</span>
<span class="gi">+                        self._entries.append(entry)</span>

<span class="w"> </span>    def save(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -74,7 +116,11 @@ class HostKeys(MutableMapping):</span>

<span class="w"> </span>        .. versionadded:: 1.6.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(filename, &quot;w&quot;) as f:</span>
<span class="gi">+            for e in self._entries:</span>
<span class="gi">+                line = e.to_line()</span>
<span class="gi">+                if line:</span>
<span class="gi">+                    f.write(line)</span>

<span class="w"> </span>    def lookup(self, hostname):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -86,7 +132,62 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>        :return: dict of `str` -&gt; `.PKey` keys associated with this host
<span class="w"> </span>            (or ``None``)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        class SubDict(MutableMapping):</span>
<span class="gi">+            def __init__(self, hostname, entries, hostkeys):</span>
<span class="gi">+                self._hostname = hostname</span>
<span class="gi">+                self._entries = entries</span>
<span class="gi">+                self._hostkeys = hostkeys</span>
<span class="gi">+</span>
<span class="gi">+            def __iter__(self):</span>
<span class="gi">+                for k in self.keys():</span>
<span class="gi">+                    yield k</span>
<span class="gi">+</span>
<span class="gi">+            def __len__(self):</span>
<span class="gi">+                return len(self.keys())</span>
<span class="gi">+</span>
<span class="gi">+            def __delitem__(self, key):</span>
<span class="gi">+                for e in list(self._entries):</span>
<span class="gi">+                    if e.key.get_name() == key:</span>
<span class="gi">+                        self._entries.remove(e)</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise KeyError(key)</span>
<span class="gi">+</span>
<span class="gi">+            def __getitem__(self, key):</span>
<span class="gi">+                for e in self._entries:</span>
<span class="gi">+                    if e.key.get_name() == key:</span>
<span class="gi">+                        return e.key</span>
<span class="gi">+                raise KeyError(key)</span>
<span class="gi">+</span>
<span class="gi">+            def __setitem__(self, key, val):</span>
<span class="gi">+                for e in self._entries:</span>
<span class="gi">+                    if e.key is None:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if e.key.get_name() == key:</span>
<span class="gi">+                        # replace</span>
<span class="gi">+                        e.key = val</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # add a new one</span>
<span class="gi">+                    e = HostKeyEntry([hostname], val)</span>
<span class="gi">+                    self._entries.append(e)</span>
<span class="gi">+                    self._hostkeys._entries.append(e)</span>
<span class="gi">+</span>
<span class="gi">+            def keys(self):</span>
<span class="gi">+                return [</span>
<span class="gi">+                    e.key.get_name()</span>
<span class="gi">+                    for e in self._entries</span>
<span class="gi">+                    if e.key is not None</span>
<span class="gi">+                ]</span>
<span class="gi">+</span>
<span class="gi">+        entries = []</span>
<span class="gi">+        for e in self._entries:</span>
<span class="gi">+            if self._hostname_matches(hostname, e):</span>
<span class="gi">+                entries.append(e)</span>
<span class="gi">+        if len(entries) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return SubDict(hostname, entries, self)</span>

<span class="w"> </span>    def _hostname_matches(self, hostname, entry):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -94,7 +195,15 @@ class HostKeys(MutableMapping):</span>

<span class="w"> </span>        :returns bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for h in entry.hostnames:</span>
<span class="gi">+            if (</span>
<span class="gi">+                h == hostname</span>
<span class="gi">+                or h.startswith(&quot;|1|&quot;)</span>
<span class="gi">+                and not hostname.startswith(&quot;|1|&quot;)</span>
<span class="gi">+                and constant_time_bytes_eq(self.hash_host(hostname, h), h)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check(self, hostname, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -106,13 +215,19 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>        :return:
<span class="w"> </span>            ``True`` if the key is associated with the hostname; else ``False``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        k = self.lookup(hostname)</span>
<span class="gi">+        if k is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        host_key = k.get(key.get_name(), None)</span>
<span class="gi">+        if host_key is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return host_key.asbytes() == key.asbytes()</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove all host keys from the dictionary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._entries = []</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        for k in self.keys():
<span class="gu">@@ -138,18 +253,34 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>        self._entries.pop(index)

<span class="w"> </span>    def __setitem__(self, hostname, entry):
<span class="gi">+        # don&#39;t use this please.</span>
<span class="w"> </span>        if len(entry) == 0:
<span class="w"> </span>            self._entries.append(HostKeyEntry([hostname], None))
<span class="w"> </span>            return
<span class="w"> </span>        for key_type in entry.keys():
<span class="w"> </span>            found = False
<span class="w"> </span>            for e in self._entries:
<span class="gd">-                if hostname in e.hostnames and e.key.get_name() == key_type:</span>
<span class="gi">+                if (hostname in e.hostnames) and e.key.get_name() == key_type:</span>
<span class="gi">+                    # replace</span>
<span class="w"> </span>                    e.key = entry[key_type]
<span class="w"> </span>                    found = True
<span class="w"> </span>            if not found:
<span class="w"> </span>                self._entries.append(HostKeyEntry([hostname], entry[key_type]))

<span class="gi">+    def keys(self):</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for e in self._entries:</span>
<span class="gi">+            for h in e.hostnames:</span>
<span class="gi">+                if h not in ret:</span>
<span class="gi">+                    ret.append(h)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for k in self.keys():</span>
<span class="gi">+            ret.append(self.lookup(k))</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def hash_host(hostname, salt=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -161,15 +292,23 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>            (must be 20 bytes long)
<span class="w"> </span>        :return: the hashed hostname as a `str`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if salt is None:</span>
<span class="gi">+            salt = os.urandom(sha1().digest_size)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if salt.startswith(&quot;|1|&quot;):</span>
<span class="gi">+                salt = salt.split(&quot;|&quot;)[2]</span>
<span class="gi">+            salt = decodebytes(b(salt))</span>
<span class="gi">+        assert len(salt) == sha1().digest_size</span>
<span class="gi">+        hmac = HMAC(salt, b(hostname), sha1).digest()</span>
<span class="gi">+        hostkey = &quot;|1|{}|{}&quot;.format(u(encodebytes(salt)), u(encodebytes(hmac)))</span>
<span class="gi">+        return hostkey.replace(&quot;\n&quot;, &quot;&quot;)</span>


<span class="w"> </span>class InvalidHostKey(Exception):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, line, exc):
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.exc = exc
<span class="gd">-        self.args = line, exc</span>
<span class="gi">+        self.args = (line, exc)</span>


<span class="w"> </span>class HostKeyEntry:
<span class="gu">@@ -178,7 +317,7 @@ class HostKeyEntry:</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, hostnames=None, key=None):
<span class="gd">-        self.valid = hostnames is not None and key is not None</span>
<span class="gi">+        self.valid = (hostnames is not None) and (key is not None)</span>
<span class="w"> </span>        self.hostnames = hostnames
<span class="w"> </span>        self.key = key

<span class="gu">@@ -196,7 +335,36 @@ class HostKeyEntry:</span>

<span class="w"> </span>        :param str line: a line from an OpenSSH known_hosts file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        log = get_logger(&quot;paramiko.hostkeys&quot;)</span>
<span class="gi">+        fields = re.split(&quot; |\t&quot;, line)</span>
<span class="gi">+        if len(fields) &lt; 3:</span>
<span class="gi">+            # Bad number of fields</span>
<span class="gi">+            msg = &quot;Not enough fields found in known_hosts in line {} ({!r})&quot;</span>
<span class="gi">+            log.info(msg.format(lineno, line))</span>
<span class="gi">+            return None</span>
<span class="gi">+        fields = fields[:3]</span>
<span class="gi">+</span>
<span class="gi">+        names, key_type, key = fields</span>
<span class="gi">+        names = names.split(&quot;,&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Decide what kind of key we&#39;re looking at and create an object</span>
<span class="gi">+        # to hold it accordingly.</span>
<span class="gi">+        try:</span>
<span class="gi">+            # TODO: this grew organically and doesn&#39;t seem /wrong/ per se (file</span>
<span class="gi">+            # read -&gt; unicode str -&gt; bytes for base64 decode -&gt; decoded bytes);</span>
<span class="gi">+            # but in Python 3 forever land, can we simply use</span>
<span class="gi">+            # `base64.b64decode(str-from-file)` here?</span>
<span class="gi">+            key_bytes = decodebytes(b(key))</span>
<span class="gi">+        except binascii.Error as e:</span>
<span class="gi">+            raise InvalidHostKey(line, e)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return cls(names, PKey.from_type_string(key_type, key_bytes))</span>
<span class="gi">+        except UnknownKeyType:</span>
<span class="gi">+            # TODO 4.0: consider changing HostKeys API so this just raises</span>
<span class="gi">+            # naturally and the exception is muted higher up in the stack?</span>
<span class="gi">+            log.info(&quot;Unable to handle key of type {}&quot;.format(key_type))</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def to_line(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -204,7 +372,13 @@ class HostKeyEntry:</span>
<span class="w"> </span>        the object is not in a valid state.  A trailing newline is
<span class="w"> </span>        included.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.valid:</span>
<span class="gi">+            return &quot;{} {} {}\n&quot;.format(</span>
<span class="gi">+                &quot;,&quot;.join(self.hostnames),</span>
<span class="gi">+                self.key.get_name(),</span>
<span class="gi">+                self.key.get_base64(),</span>
<span class="gi">+            )</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;HostKeyEntry {!r}: {!r}&gt;&#39;.format(self.hostnames, self.key)</span>
<span class="gi">+        return &quot;&lt;HostKeyEntry {!r}: {!r}&gt;&quot;.format(self.hostnames, self.key)</span>
<span class="gh">diff --git a/paramiko/kex_curve25519.py b/paramiko/kex_curve25519.py</span>
<span class="gh">index 1d58fd85..20c23e42 100644</span>
<span class="gd">--- a/paramiko/kex_curve25519.py</span>
<span class="gi">+++ b/paramiko/kex_curve25519.py</span>
<span class="gu">@@ -1,11 +1,18 @@</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import hashlib
<span class="gi">+</span>
<span class="w"> </span>from cryptography.exceptions import UnsupportedAlgorithm
<span class="w"> </span>from cryptography.hazmat.primitives import constant_time, serialization
<span class="gd">-from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey, X25519PublicKey</span>
<span class="gi">+from cryptography.hazmat.primitives.asymmetric.x25519 import (</span>
<span class="gi">+    X25519PrivateKey,</span>
<span class="gi">+    X25519PublicKey,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.common import byte_chr
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_MSG_KEXECDH_INIT, _MSG_KEXECDH_REPLY = range(30, 32)
<span class="w"> </span>c_MSG_KEXECDH_INIT, c_MSG_KEXECDH_REPLY = [byte_chr(c) for c in range(30, 32)]

<span class="gu">@@ -16,3 +23,109 @@ class KexCurve25519:</span>
<span class="w"> </span>    def __init__(self, transport):
<span class="w"> </span>        self.transport = transport
<span class="w"> </span>        self.key = None
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def is_available(cls):</span>
<span class="gi">+        try:</span>
<span class="gi">+            X25519PrivateKey.generate()</span>
<span class="gi">+        except UnsupportedAlgorithm:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    def _perform_exchange(self, peer_key):</span>
<span class="gi">+        secret = self.key.exchange(peer_key)</span>
<span class="gi">+        if constant_time.bytes_eq(secret, b&quot;\x00&quot; * 32):</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;peer&#39;s curve25519 public value has wrong order&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return secret</span>
<span class="gi">+</span>
<span class="gi">+    def start_kex(self):</span>
<span class="gi">+        self.key = X25519PrivateKey.generate()</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            self.transport._expect_packet(_MSG_KEXECDH_INIT)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXECDH_INIT)</span>
<span class="gi">+        m.add_string(</span>
<span class="gi">+            self.key.public_key().public_bytes(</span>
<span class="gi">+                serialization.Encoding.Raw, serialization.PublicFormat.Raw</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(_MSG_KEXECDH_REPLY)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_next(self, ptype, m):</span>
<span class="gi">+        if self.transport.server_mode and (ptype == _MSG_KEXECDH_INIT):</span>
<span class="gi">+            return self._parse_kexecdh_init(m)</span>
<span class="gi">+        elif not self.transport.server_mode and (ptype == _MSG_KEXECDH_REPLY):</span>
<span class="gi">+            return self._parse_kexecdh_reply(m)</span>
<span class="gi">+        raise SSHException(</span>
<span class="gi">+            &quot;KexCurve25519 asked to handle packet type {:d}&quot;.format(ptype)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexecdh_init(self, m):</span>
<span class="gi">+        peer_key_bytes = m.get_string()</span>
<span class="gi">+        peer_key = X25519PublicKey.from_public_bytes(peer_key_bytes)</span>
<span class="gi">+        K = self._perform_exchange(peer_key)</span>
<span class="gi">+        K = int(binascii.hexlify(K), 16)</span>
<span class="gi">+        # compute exchange hash</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+        )</span>
<span class="gi">+        server_key_bytes = self.transport.get_server_key().asbytes()</span>
<span class="gi">+        exchange_key_bytes = self.key.public_key().public_bytes(</span>
<span class="gi">+            serialization.Encoding.Raw, serialization.PublicFormat.Raw</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(server_key_bytes)</span>
<span class="gi">+        hm.add_string(peer_key_bytes)</span>
<span class="gi">+        hm.add_string(exchange_key_bytes)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        H = self.hash_algo(hm.asbytes()).digest()</span>
<span class="gi">+        self.transport._set_K_H(K, H)</span>
<span class="gi">+        sig = self.transport.get_server_key().sign_ssh_data(</span>
<span class="gi">+            H, self.transport.host_key_type</span>
<span class="gi">+        )</span>
<span class="gi">+        # construct reply</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXECDH_REPLY)</span>
<span class="gi">+        m.add_string(server_key_bytes)</span>
<span class="gi">+        m.add_string(exchange_key_bytes)</span>
<span class="gi">+        m.add_string(sig)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._activate_outbound()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexecdh_reply(self, m):</span>
<span class="gi">+        peer_host_key_bytes = m.get_string()</span>
<span class="gi">+        peer_key_bytes = m.get_string()</span>
<span class="gi">+        sig = m.get_binary()</span>
<span class="gi">+</span>
<span class="gi">+        peer_key = X25519PublicKey.from_public_bytes(peer_key_bytes)</span>
<span class="gi">+</span>
<span class="gi">+        K = self._perform_exchange(peer_key)</span>
<span class="gi">+        K = int(binascii.hexlify(K), 16)</span>
<span class="gi">+        # compute exchange hash and verify signature</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(peer_host_key_bytes)</span>
<span class="gi">+        hm.add_string(</span>
<span class="gi">+            self.key.public_key().public_bytes(</span>
<span class="gi">+                serialization.Encoding.Raw, serialization.PublicFormat.Raw</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(peer_key_bytes)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        self.transport._set_K_H(K, self.hash_algo(hm.asbytes()).digest())</span>
<span class="gi">+        self.transport._verify_key(peer_host_key_bytes, sig)</span>
<span class="gi">+        self.transport._activate_outbound()</span>
<span class="gh">diff --git a/paramiko/kex_ecdh_nist.py b/paramiko/kex_ecdh_nist.py</span>
<span class="gh">index b119304b..41fab46b 100644</span>
<span class="gd">--- a/paramiko/kex_ecdh_nist.py</span>
<span class="gi">+++ b/paramiko/kex_ecdh_nist.py</span>
<span class="gu">@@ -2,6 +2,7 @@</span>
<span class="w"> </span>Ephemeral Elliptic Curve Diffie-Hellman (ECDH) key exchange
<span class="w"> </span>RFC 5656, Section 4
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from hashlib import sha256, sha384, sha512
<span class="w"> </span>from paramiko.common import byte_chr
<span class="w"> </span>from paramiko.message import Message
<span class="gu">@@ -10,29 +11,141 @@ from cryptography.hazmat.backends import default_backend</span>
<span class="w"> </span>from cryptography.hazmat.primitives.asymmetric import ec
<span class="w"> </span>from cryptography.hazmat.primitives import serialization
<span class="w"> </span>from binascii import hexlify
<span class="gi">+</span>
<span class="w"> </span>_MSG_KEXECDH_INIT, _MSG_KEXECDH_REPLY = range(30, 32)
<span class="w"> </span>c_MSG_KEXECDH_INIT, c_MSG_KEXECDH_REPLY = [byte_chr(c) for c in range(30, 32)]


<span class="w"> </span>class KexNistp256:
<span class="gd">-    name = &#39;ecdh-sha2-nistp256&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;ecdh-sha2-nistp256&quot;</span>
<span class="w"> </span>    hash_algo = sha256
<span class="w"> </span>    curve = ec.SECP256R1()

<span class="w"> </span>    def __init__(self, transport):
<span class="w"> </span>        self.transport = transport
<span class="gi">+        # private key, client public and server public keys</span>
<span class="w"> </span>        self.P = 0
<span class="w"> </span>        self.Q_C = None
<span class="w"> </span>        self.Q_S = None

<span class="gi">+    def start_kex(self):</span>
<span class="gi">+        self._generate_key_pair()</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            self.transport._expect_packet(_MSG_KEXECDH_INIT)</span>
<span class="gi">+            return</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXECDH_INIT)</span>
<span class="gi">+        # SEC1: V2.0  2.3.3 Elliptic-Curve-Point-to-Octet-String Conversion</span>
<span class="gi">+        m.add_string(</span>
<span class="gi">+            self.Q_C.public_bytes(</span>
<span class="gi">+                serialization.Encoding.X962,</span>
<span class="gi">+                serialization.PublicFormat.UncompressedPoint,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(_MSG_KEXECDH_REPLY)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_next(self, ptype, m):</span>
<span class="gi">+        if self.transport.server_mode and (ptype == _MSG_KEXECDH_INIT):</span>
<span class="gi">+            return self._parse_kexecdh_init(m)</span>
<span class="gi">+        elif not self.transport.server_mode and (ptype == _MSG_KEXECDH_REPLY):</span>
<span class="gi">+            return self._parse_kexecdh_reply(m)</span>
<span class="gi">+        raise SSHException(</span>
<span class="gi">+            &quot;KexECDH asked to handle packet type {:d}&quot;.format(ptype)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_key_pair(self):</span>
<span class="gi">+        self.P = ec.generate_private_key(self.curve, default_backend())</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            self.Q_S = self.P.public_key()</span>
<span class="gi">+            return</span>
<span class="gi">+        self.Q_C = self.P.public_key()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexecdh_init(self, m):</span>
<span class="gi">+        Q_C_bytes = m.get_string()</span>
<span class="gi">+        self.Q_C = ec.EllipticCurvePublicKey.from_encoded_point(</span>
<span class="gi">+            self.curve, Q_C_bytes</span>
<span class="gi">+        )</span>
<span class="gi">+        K_S = self.transport.get_server_key().asbytes()</span>
<span class="gi">+        K = self.P.exchange(ec.ECDH(), self.Q_C)</span>
<span class="gi">+        K = int(hexlify(K), 16)</span>
<span class="gi">+        # compute exchange hash</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(K_S)</span>
<span class="gi">+        hm.add_string(Q_C_bytes)</span>
<span class="gi">+        # SEC1: V2.0  2.3.3 Elliptic-Curve-Point-to-Octet-String Conversion</span>
<span class="gi">+        hm.add_string(</span>
<span class="gi">+            self.Q_S.public_bytes(</span>
<span class="gi">+                serialization.Encoding.X962,</span>
<span class="gi">+                serialization.PublicFormat.UncompressedPoint,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_mpint(int(K))</span>
<span class="gi">+        H = self.hash_algo(hm.asbytes()).digest()</span>
<span class="gi">+        self.transport._set_K_H(K, H)</span>
<span class="gi">+        sig = self.transport.get_server_key().sign_ssh_data(</span>
<span class="gi">+            H, self.transport.host_key_type</span>
<span class="gi">+        )</span>
<span class="gi">+        # construct reply</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXECDH_REPLY)</span>
<span class="gi">+        m.add_string(K_S)</span>
<span class="gi">+        m.add_string(</span>
<span class="gi">+            self.Q_S.public_bytes(</span>
<span class="gi">+                serialization.Encoding.X962,</span>
<span class="gi">+                serialization.PublicFormat.UncompressedPoint,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        m.add_string(sig)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._activate_outbound()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexecdh_reply(self, m):</span>
<span class="gi">+        K_S = m.get_string()</span>
<span class="gi">+        Q_S_bytes = m.get_string()</span>
<span class="gi">+        self.Q_S = ec.EllipticCurvePublicKey.from_encoded_point(</span>
<span class="gi">+            self.curve, Q_S_bytes</span>
<span class="gi">+        )</span>
<span class="gi">+        sig = m.get_binary()</span>
<span class="gi">+        K = self.P.exchange(ec.ECDH(), self.Q_S)</span>
<span class="gi">+        K = int(hexlify(K), 16)</span>
<span class="gi">+        # compute exchange hash and verify signature</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(K_S)</span>
<span class="gi">+        # SEC1: V2.0  2.3.3 Elliptic-Curve-Point-to-Octet-String Conversion</span>
<span class="gi">+        hm.add_string(</span>
<span class="gi">+            self.Q_C.public_bytes(</span>
<span class="gi">+                serialization.Encoding.X962,</span>
<span class="gi">+                serialization.PublicFormat.UncompressedPoint,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(Q_S_bytes)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        self.transport._set_K_H(K, self.hash_algo(hm.asbytes()).digest())</span>
<span class="gi">+        self.transport._verify_key(K_S, sig)</span>
<span class="gi">+        self.transport._activate_outbound()</span>
<span class="gi">+</span>

<span class="w"> </span>class KexNistp384(KexNistp256):
<span class="gd">-    name = &#39;ecdh-sha2-nistp384&#39;</span>
<span class="gi">+    name = &quot;ecdh-sha2-nistp384&quot;</span>
<span class="w"> </span>    hash_algo = sha384
<span class="w"> </span>    curve = ec.SECP384R1()


<span class="w"> </span>class KexNistp521(KexNistp256):
<span class="gd">-    name = &#39;ecdh-sha2-nistp521&#39;</span>
<span class="gi">+    name = &quot;ecdh-sha2-nistp521&quot;</span>
<span class="w"> </span>    hash_algo = sha512
<span class="w"> </span>    curve = ec.SECP521R1()
<span class="gh">diff --git a/paramiko/kex_gex.py b/paramiko/kex_gex.py</span>
<span class="gh">index c7455ab2..baa0803d 100644</span>
<span class="gd">--- a/paramiko/kex_gex.py</span>
<span class="gi">+++ b/paramiko/kex_gex.py</span>
<span class="gu">@@ -1,23 +1,56 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Variant on `KexGroup1 &lt;paramiko.kex_group1.KexGroup1&gt;` where the prime &quot;p&quot; and
<span class="w"> </span>generator &quot;g&quot; are provided by the server.  A bit more work is required on the
<span class="w"> </span>client side, and a **lot** more on the server side.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from hashlib import sha1, sha256
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.common import DEBUG, byte_chr, byte_ord, byte_mask
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="gd">-(_MSG_KEXDH_GEX_REQUEST_OLD, _MSG_KEXDH_GEX_GROUP, _MSG_KEXDH_GEX_INIT,</span>
<span class="gd">-    _MSG_KEXDH_GEX_REPLY, _MSG_KEXDH_GEX_REQUEST) = range(30, 35)</span>
<span class="gd">-(c_MSG_KEXDH_GEX_REQUEST_OLD, c_MSG_KEXDH_GEX_GROUP, c_MSG_KEXDH_GEX_INIT,</span>
<span class="gd">-    c_MSG_KEXDH_GEX_REPLY, c_MSG_KEXDH_GEX_REQUEST) = [byte_chr(c) for c in</span>
<span class="gd">-    range(30, 35)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+(</span>
<span class="gi">+    _MSG_KEXDH_GEX_REQUEST_OLD,</span>
<span class="gi">+    _MSG_KEXDH_GEX_GROUP,</span>
<span class="gi">+    _MSG_KEXDH_GEX_INIT,</span>
<span class="gi">+    _MSG_KEXDH_GEX_REPLY,</span>
<span class="gi">+    _MSG_KEXDH_GEX_REQUEST,</span>
<span class="gi">+) = range(30, 35)</span>
<span class="gi">+</span>
<span class="gi">+(</span>
<span class="gi">+    c_MSG_KEXDH_GEX_REQUEST_OLD,</span>
<span class="gi">+    c_MSG_KEXDH_GEX_GROUP,</span>
<span class="gi">+    c_MSG_KEXDH_GEX_INIT,</span>
<span class="gi">+    c_MSG_KEXDH_GEX_REPLY,</span>
<span class="gi">+    c_MSG_KEXDH_GEX_REQUEST,</span>
<span class="gi">+) = [byte_chr(c) for c in range(30, 35)]</span>


<span class="w"> </span>class KexGex:
<span class="gd">-    name = &#39;diffie-hellman-group-exchange-sha1&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;diffie-hellman-group-exchange-sha1&quot;</span>
<span class="w"> </span>    min_bits = 1024
<span class="w"> </span>    max_bits = 8192
<span class="w"> </span>    preferred_bits = 2048
<span class="gu">@@ -33,7 +66,223 @@ class KexGex:</span>
<span class="w"> </span>        self.f = None
<span class="w"> </span>        self.old_style = False

<span class="gi">+    def start_kex(self, _test_old_style=False):</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            self.transport._expect_packet(</span>
<span class="gi">+                _MSG_KEXDH_GEX_REQUEST, _MSG_KEXDH_GEX_REQUEST_OLD</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        # request a bit range: we accept (min_bits) to (max_bits), but prefer</span>
<span class="gi">+        # (preferred_bits).  according to the spec, we shouldn&#39;t pull the</span>
<span class="gi">+        # minimum up above 1024.</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        if _test_old_style:</span>
<span class="gi">+            # only used for unit tests: we shouldn&#39;t ever send this</span>
<span class="gi">+            m.add_byte(c_MSG_KEXDH_GEX_REQUEST_OLD)</span>
<span class="gi">+            m.add_int(self.preferred_bits)</span>
<span class="gi">+            self.old_style = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            m.add_byte(c_MSG_KEXDH_GEX_REQUEST)</span>
<span class="gi">+            m.add_int(self.min_bits)</span>
<span class="gi">+            m.add_int(self.preferred_bits)</span>
<span class="gi">+            m.add_int(self.max_bits)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(_MSG_KEXDH_GEX_GROUP)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_next(self, ptype, m):</span>
<span class="gi">+        if ptype == _MSG_KEXDH_GEX_REQUEST:</span>
<span class="gi">+            return self._parse_kexdh_gex_request(m)</span>
<span class="gi">+        elif ptype == _MSG_KEXDH_GEX_GROUP:</span>
<span class="gi">+            return self._parse_kexdh_gex_group(m)</span>
<span class="gi">+        elif ptype == _MSG_KEXDH_GEX_INIT:</span>
<span class="gi">+            return self._parse_kexdh_gex_init(m)</span>
<span class="gi">+        elif ptype == _MSG_KEXDH_GEX_REPLY:</span>
<span class="gi">+            return self._parse_kexdh_gex_reply(m)</span>
<span class="gi">+        elif ptype == _MSG_KEXDH_GEX_REQUEST_OLD:</span>
<span class="gi">+            return self._parse_kexdh_gex_request_old(m)</span>
<span class="gi">+        msg = &quot;KexGex {} asked to handle packet type {:d}&quot;</span>
<span class="gi">+        raise SSHException(msg.format(self.name, ptype))</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_x(self):</span>
<span class="gi">+        # generate an &quot;x&quot; (1 &lt; x &lt; (p-1)/2).</span>
<span class="gi">+        q = (self.p - 1) // 2</span>
<span class="gi">+        qnorm = util.deflate_long(q, 0)</span>
<span class="gi">+        qhbyte = byte_ord(qnorm[0])</span>
<span class="gi">+        byte_count = len(qnorm)</span>
<span class="gi">+        qmask = 0xFF</span>
<span class="gi">+        while not (qhbyte &amp; 0x80):</span>
<span class="gi">+            qhbyte &lt;&lt;= 1</span>
<span class="gi">+            qmask &gt;&gt;= 1</span>
<span class="gi">+        while True:</span>
<span class="gi">+            x_bytes = os.urandom(byte_count)</span>
<span class="gi">+            x_bytes = byte_mask(x_bytes[0], qmask) + x_bytes[1:]</span>
<span class="gi">+            x = util.inflate_long(x_bytes, 1)</span>
<span class="gi">+            if (x &gt; 1) and (x &lt; q):</span>
<span class="gi">+                break</span>
<span class="gi">+        self.x = x</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexdh_gex_request(self, m):</span>
<span class="gi">+        minbits = m.get_int()</span>
<span class="gi">+        preferredbits = m.get_int()</span>
<span class="gi">+        maxbits = m.get_int()</span>
<span class="gi">+        # smoosh the user&#39;s preferred size into our own limits</span>
<span class="gi">+        if preferredbits &gt; self.max_bits:</span>
<span class="gi">+            preferredbits = self.max_bits</span>
<span class="gi">+        if preferredbits &lt; self.min_bits:</span>
<span class="gi">+            preferredbits = self.min_bits</span>
<span class="gi">+        # fix min/max if they&#39;re inconsistent.  technically, we could just pout</span>
<span class="gi">+        # and hang up, but there&#39;s no harm in giving them the benefit of the</span>
<span class="gi">+        # doubt and just picking a bitsize for them.</span>
<span class="gi">+        if minbits &gt; preferredbits:</span>
<span class="gi">+            minbits = preferredbits</span>
<span class="gi">+        if maxbits &lt; preferredbits:</span>
<span class="gi">+            maxbits = preferredbits</span>
<span class="gi">+        # now save a copy</span>
<span class="gi">+        self.min_bits = minbits</span>
<span class="gi">+        self.preferred_bits = preferredbits</span>
<span class="gi">+        self.max_bits = maxbits</span>
<span class="gi">+        # generate prime</span>
<span class="gi">+        pack = self.transport._get_modulus_pack()</span>
<span class="gi">+        if pack is None:</span>
<span class="gi">+            raise SSHException(&quot;Can&#39;t do server-side gex with no modulus pack&quot;)</span>
<span class="gi">+        self.transport._log(</span>
<span class="gi">+            DEBUG,</span>
<span class="gi">+            &quot;Picking p ({} &lt;= {} &lt;= {} bits)&quot;.format(</span>
<span class="gi">+                minbits, preferredbits, maxbits</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        self.g, self.p = pack.get_modulus(minbits, preferredbits, maxbits)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXDH_GEX_GROUP)</span>
<span class="gi">+        m.add_mpint(self.p)</span>
<span class="gi">+        m.add_mpint(self.g)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(_MSG_KEXDH_GEX_INIT)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexdh_gex_request_old(self, m):</span>
<span class="gi">+        # same as above, but without min_bits or max_bits (used by older</span>
<span class="gi">+        # clients like putty)</span>
<span class="gi">+        self.preferred_bits = m.get_int()</span>
<span class="gi">+        # smoosh the user&#39;s preferred size into our own limits</span>
<span class="gi">+        if self.preferred_bits &gt; self.max_bits:</span>
<span class="gi">+            self.preferred_bits = self.max_bits</span>
<span class="gi">+        if self.preferred_bits &lt; self.min_bits:</span>
<span class="gi">+            self.preferred_bits = self.min_bits</span>
<span class="gi">+        # generate prime</span>
<span class="gi">+        pack = self.transport._get_modulus_pack()</span>
<span class="gi">+        if pack is None:</span>
<span class="gi">+            raise SSHException(&quot;Can&#39;t do server-side gex with no modulus pack&quot;)</span>
<span class="gi">+        self.transport._log(</span>
<span class="gi">+            DEBUG, &quot;Picking p (~ {} bits)&quot;.format(self.preferred_bits)</span>
<span class="gi">+        )</span>
<span class="gi">+        self.g, self.p = pack.get_modulus(</span>
<span class="gi">+            self.min_bits, self.preferred_bits, self.max_bits</span>
<span class="gi">+        )</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXDH_GEX_GROUP)</span>
<span class="gi">+        m.add_mpint(self.p)</span>
<span class="gi">+        m.add_mpint(self.g)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(_MSG_KEXDH_GEX_INIT)</span>
<span class="gi">+        self.old_style = True</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexdh_gex_group(self, m):</span>
<span class="gi">+        self.p = m.get_mpint()</span>
<span class="gi">+        self.g = m.get_mpint()</span>
<span class="gi">+        # reject if p&#39;s bit length &lt; 1024 or &gt; 8192</span>
<span class="gi">+        bitlen = util.bit_length(self.p)</span>
<span class="gi">+        if (bitlen &lt; 1024) or (bitlen &gt; 8192):</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;Server-generated gex p (don&#39;t ask) is out of range &quot;</span>
<span class="gi">+                &quot;({} bits)&quot;.format(bitlen)</span>
<span class="gi">+            )</span>
<span class="gi">+        self.transport._log(DEBUG, &quot;Got server p ({} bits)&quot;.format(bitlen))</span>
<span class="gi">+        self._generate_x()</span>
<span class="gi">+        # now compute e = g^x mod p</span>
<span class="gi">+        self.e = pow(self.g, self.x, self.p)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXDH_GEX_INIT)</span>
<span class="gi">+        m.add_mpint(self.e)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(_MSG_KEXDH_GEX_REPLY)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexdh_gex_init(self, m):</span>
<span class="gi">+        self.e = m.get_mpint()</span>
<span class="gi">+        if (self.e &lt; 1) or (self.e &gt; self.p - 1):</span>
<span class="gi">+            raise SSHException(&#39;Client kex &quot;e&quot; is out of range&#39;)</span>
<span class="gi">+        self._generate_x()</span>
<span class="gi">+        self.f = pow(self.g, self.x, self.p)</span>
<span class="gi">+        K = pow(self.e, self.x, self.p)</span>
<span class="gi">+        key = self.transport.get_server_key().asbytes()</span>
<span class="gi">+        # okay, build up the hash H of</span>
<span class="gi">+        # (V_C || V_S || I_C || I_S || K_S || min || n || max || p || g || e || f || K)  # noqa</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+            key,</span>
<span class="gi">+        )</span>
<span class="gi">+        if not self.old_style:</span>
<span class="gi">+            hm.add_int(self.min_bits)</span>
<span class="gi">+        hm.add_int(self.preferred_bits)</span>
<span class="gi">+        if not self.old_style:</span>
<span class="gi">+            hm.add_int(self.max_bits)</span>
<span class="gi">+        hm.add_mpint(self.p)</span>
<span class="gi">+        hm.add_mpint(self.g)</span>
<span class="gi">+        hm.add_mpint(self.e)</span>
<span class="gi">+        hm.add_mpint(self.f)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        H = self.hash_algo(hm.asbytes()).digest()</span>
<span class="gi">+        self.transport._set_K_H(K, H)</span>
<span class="gi">+        # sign it</span>
<span class="gi">+        sig = self.transport.get_server_key().sign_ssh_data(</span>
<span class="gi">+            H, self.transport.host_key_type</span>
<span class="gi">+        )</span>
<span class="gi">+        # send reply</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXDH_GEX_REPLY)</span>
<span class="gi">+        m.add_string(key)</span>
<span class="gi">+        m.add_mpint(self.f)</span>
<span class="gi">+        m.add_string(sig)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._activate_outbound()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexdh_gex_reply(self, m):</span>
<span class="gi">+        host_key = m.get_string()</span>
<span class="gi">+        self.f = m.get_mpint()</span>
<span class="gi">+        sig = m.get_string()</span>
<span class="gi">+        if (self.f &lt; 1) or (self.f &gt; self.p - 1):</span>
<span class="gi">+            raise SSHException(&#39;Server kex &quot;f&quot; is out of range&#39;)</span>
<span class="gi">+        K = pow(self.f, self.x, self.p)</span>
<span class="gi">+        # okay, build up the hash H of</span>
<span class="gi">+        # (V_C || V_S || I_C || I_S || K_S || min || n || max || p || g || e || f || K)  # noqa</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+            host_key,</span>
<span class="gi">+        )</span>
<span class="gi">+        if not self.old_style:</span>
<span class="gi">+            hm.add_int(self.min_bits)</span>
<span class="gi">+        hm.add_int(self.preferred_bits)</span>
<span class="gi">+        if not self.old_style:</span>
<span class="gi">+            hm.add_int(self.max_bits)</span>
<span class="gi">+        hm.add_mpint(self.p)</span>
<span class="gi">+        hm.add_mpint(self.g)</span>
<span class="gi">+        hm.add_mpint(self.e)</span>
<span class="gi">+        hm.add_mpint(self.f)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        self.transport._set_K_H(K, self.hash_algo(hm.asbytes()).digest())</span>
<span class="gi">+        self.transport._verify_key(host_key, sig)</span>
<span class="gi">+        self.transport._activate_outbound()</span>
<span class="gi">+</span>

<span class="w"> </span>class KexGexSHA256(KexGex):
<span class="gd">-    name = &#39;diffie-hellman-group-exchange-sha256&#39;</span>
<span class="gi">+    name = &quot;diffie-hellman-group-exchange-sha256&quot;</span>
<span class="w"> </span>    hash_algo = sha256
<span class="gh">diff --git a/paramiko/kex_group1.py b/paramiko/kex_group1.py</span>
<span class="gh">index cb6aa737..f0742566 100644</span>
<span class="gd">--- a/paramiko/kex_group1.py</span>
<span class="gi">+++ b/paramiko/kex_group1.py</span>
<span class="gu">@@ -1,25 +1,49 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Standard SSH key exchange (&quot;kex&quot; if you wanna sound cool).  Diffie-Hellman of
<span class="w"> </span>1024 bit key halves, using a known &quot;p&quot; prime and &quot;g&quot; generator.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from hashlib import sha1
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.common import max_byte, zero_byte, byte_chr, byte_mask
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_MSG_KEXDH_INIT, _MSG_KEXDH_REPLY = range(30, 32)
<span class="w"> </span>c_MSG_KEXDH_INIT, c_MSG_KEXDH_REPLY = [byte_chr(c) for c in range(30, 32)]
<span class="gd">-b7fffffffffffffff = byte_chr(127) + max_byte * 7</span>
<span class="gi">+</span>
<span class="gi">+b7fffffffffffffff = byte_chr(0x7F) + max_byte * 7</span>
<span class="w"> </span>b0000000000000000 = zero_byte * 8


<span class="w"> </span>class KexGroup1:
<span class="gd">-    P = (</span>
<span class="gd">-        179769313486231590770839156793787453197860296048756011706444423684197180216158519368947833795864925541502180565485980503646440548199239100050792877003355816639229553136239076508735759914822574862575007425302077447712589550957937778424442426617334727629299387668709205606050270810842907692932019128194467627007</span>
<span class="gd">-        )</span>
<span class="gi">+</span>
<span class="gi">+    # draft-ietf-secsh-transport-09.txt, page 17</span>
<span class="gi">+    P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF  # noqa</span>
<span class="w"> </span>    G = 2
<span class="gd">-    name = &#39;diffie-hellman-group1-sha1&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;diffie-hellman-group1-sha1&quot;</span>
<span class="w"> </span>    hash_algo = sha1

<span class="w"> </span>    def __init__(self, transport):
<span class="gu">@@ -27,3 +51,105 @@ class KexGroup1:</span>
<span class="w"> </span>        self.x = 0
<span class="w"> </span>        self.e = 0
<span class="w"> </span>        self.f = 0
<span class="gi">+</span>
<span class="gi">+    def start_kex(self):</span>
<span class="gi">+        self._generate_x()</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            # compute f = g^x mod p, but don&#39;t send it yet</span>
<span class="gi">+            self.f = pow(self.G, self.x, self.P)</span>
<span class="gi">+            self.transport._expect_packet(_MSG_KEXDH_INIT)</span>
<span class="gi">+            return</span>
<span class="gi">+        # compute e = g^x mod p (where g=2), and send it</span>
<span class="gi">+        self.e = pow(self.G, self.x, self.P)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXDH_INIT)</span>
<span class="gi">+        m.add_mpint(self.e)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(_MSG_KEXDH_REPLY)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_next(self, ptype, m):</span>
<span class="gi">+        if self.transport.server_mode and (ptype == _MSG_KEXDH_INIT):</span>
<span class="gi">+            return self._parse_kexdh_init(m)</span>
<span class="gi">+        elif not self.transport.server_mode and (ptype == _MSG_KEXDH_REPLY):</span>
<span class="gi">+            return self._parse_kexdh_reply(m)</span>
<span class="gi">+        msg = &quot;KexGroup1 asked to handle packet type {:d}&quot;</span>
<span class="gi">+        raise SSHException(msg.format(ptype))</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_x(self):</span>
<span class="gi">+        # generate an &quot;x&quot; (1 &lt; x &lt; q), where q is (p-1)/2.</span>
<span class="gi">+        # p is a 128-byte (1024-bit) number, where the first 64 bits are 1.</span>
<span class="gi">+        # therefore q can be approximated as a 2^1023.  we drop the subset of</span>
<span class="gi">+        # potential x where the first 63 bits are 1, because some of those</span>
<span class="gi">+        # will be larger than q (but this is a tiny tiny subset of</span>
<span class="gi">+        # potential x).</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            x_bytes = os.urandom(128)</span>
<span class="gi">+            x_bytes = byte_mask(x_bytes[0], 0x7F) + x_bytes[1:]</span>
<span class="gi">+            if (</span>
<span class="gi">+                x_bytes[:8] != b7fffffffffffffff</span>
<span class="gi">+                and x_bytes[:8] != b0000000000000000</span>
<span class="gi">+            ):</span>
<span class="gi">+                break</span>
<span class="gi">+        self.x = util.inflate_long(x_bytes)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexdh_reply(self, m):</span>
<span class="gi">+        # client mode</span>
<span class="gi">+        host_key = m.get_string()</span>
<span class="gi">+        self.f = m.get_mpint()</span>
<span class="gi">+        if (self.f &lt; 1) or (self.f &gt; self.P - 1):</span>
<span class="gi">+            raise SSHException(&#39;Server kex &quot;f&quot; is out of range&#39;)</span>
<span class="gi">+        sig = m.get_binary()</span>
<span class="gi">+        K = pow(self.f, self.x, self.P)</span>
<span class="gi">+        # okay, build up the hash H of</span>
<span class="gi">+        # (V_C || V_S || I_C || I_S || K_S || e || f || K)</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(host_key)</span>
<span class="gi">+        hm.add_mpint(self.e)</span>
<span class="gi">+        hm.add_mpint(self.f)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        self.transport._set_K_H(K, self.hash_algo(hm.asbytes()).digest())</span>
<span class="gi">+        self.transport._verify_key(host_key, sig)</span>
<span class="gi">+        self.transport._activate_outbound()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kexdh_init(self, m):</span>
<span class="gi">+        # server mode</span>
<span class="gi">+        self.e = m.get_mpint()</span>
<span class="gi">+        if (self.e &lt; 1) or (self.e &gt; self.P - 1):</span>
<span class="gi">+            raise SSHException(&#39;Client kex &quot;e&quot; is out of range&#39;)</span>
<span class="gi">+        K = pow(self.e, self.x, self.P)</span>
<span class="gi">+        key = self.transport.get_server_key().asbytes()</span>
<span class="gi">+        # okay, build up the hash H of</span>
<span class="gi">+        # (V_C || V_S || I_C || I_S || K_S || e || f || K)</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(key)</span>
<span class="gi">+        hm.add_mpint(self.e)</span>
<span class="gi">+        hm.add_mpint(self.f)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        H = self.hash_algo(hm.asbytes()).digest()</span>
<span class="gi">+        self.transport._set_K_H(K, H)</span>
<span class="gi">+        # sign it</span>
<span class="gi">+        sig = self.transport.get_server_key().sign_ssh_data(</span>
<span class="gi">+            H, self.transport.host_key_type</span>
<span class="gi">+        )</span>
<span class="gi">+        # send reply</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXDH_REPLY)</span>
<span class="gi">+        m.add_string(key)</span>
<span class="gi">+        m.add_mpint(self.f)</span>
<span class="gi">+        m.add_string(sig)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._activate_outbound()</span>
<span class="gh">diff --git a/paramiko/kex_group14.py b/paramiko/kex_group14.py</span>
<span class="gh">index 91525869..8dee5515 100644</span>
<span class="gd">--- a/paramiko/kex_group14.py</span>
<span class="gi">+++ b/paramiko/kex_group14.py</span>
<span class="gu">@@ -1,20 +1,40 @@</span>
<span class="gi">+# Copyright (C) 2013  Torsten Landschoff &lt;torsten@debian.org&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Standard SSH key exchange (&quot;kex&quot; if you wanna sound cool).  Diffie-Hellman of
<span class="w"> </span>2048 bit key halves, using a known &quot;p&quot; prime and &quot;g&quot; generator.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from paramiko.kex_group1 import KexGroup1
<span class="w"> </span>from hashlib import sha1, sha256


<span class="w"> </span>class KexGroup14(KexGroup1):
<span class="gd">-    P = (</span>
<span class="gd">-        32317006071311007300338913926423828248817941241140239112842009751400741706634354222619689417363569347117901737909704191754605873209195028853758986185622153212175412514901774520270235796078236248884246189477587641105928646099411723245426622522193230540919037680524235519125679715870117001058055877651038861847280257976054903569732561526167081339361799541336476559160368317896729073178384589680639671900977202194168647225871031411336429319536193471636533209717077448227988588565369208645296636077250268955505928362751121174096972998068410554359584866583291642136218231078990999448652468262416972035911852507045361090559</span>
<span class="gd">-        )</span>
<span class="gi">+</span>
<span class="gi">+    # http://tools.ietf.org/html/rfc3526#section-3</span>
<span class="gi">+    P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF  # noqa</span>
<span class="w"> </span>    G = 2
<span class="gd">-    name = &#39;diffie-hellman-group14-sha1&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;diffie-hellman-group14-sha1&quot;</span>
<span class="w"> </span>    hash_algo = sha1


<span class="w"> </span>class KexGroup14SHA256(KexGroup14):
<span class="gd">-    name = &#39;diffie-hellman-group14-sha256&#39;</span>
<span class="gi">+    name = &quot;diffie-hellman-group14-sha256&quot;</span>
<span class="w"> </span>    hash_algo = sha256
<span class="gh">diff --git a/paramiko/kex_group16.py b/paramiko/kex_group16.py</span>
<span class="gh">index f1223757..c675f877 100644</span>
<span class="gd">--- a/paramiko/kex_group16.py</span>
<span class="gi">+++ b/paramiko/kex_group16.py</span>
<span class="gu">@@ -1,16 +1,35 @@</span>
<span class="gi">+# Copyright (C) 2019 Edgar Sousa &lt;https://github.com/edgsousa&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Standard SSH key exchange (&quot;kex&quot; if you wanna sound cool).  Diffie-Hellman of
<span class="w"> </span>4096 bit key halves, using a known &quot;p&quot; prime and &quot;g&quot; generator.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from paramiko.kex_group1 import KexGroup1
<span class="w"> </span>from hashlib import sha512


<span class="w"> </span>class KexGroup16SHA512(KexGroup1):
<span class="gd">-    name = &#39;diffie-hellman-group16-sha512&#39;</span>
<span class="gd">-    P = (</span>
<span class="gd">-        1044388881413152506679602719846529545831269060992135009022588756444338172022322690710444046669809783930111585737890362691860127079270495454517218673016928427459146001866885779762982229321192368303346235204368051010309155674155697460347176946394076535157284994895284821633700921811716738972451834979455897010306333468590751358365138782250372269117968985194322444535687415522007151638638141456178420621277822674995027990278673458629544391736919766299005511505446177668154446234882665961680796576903199116089347634947187778906528008004756692571666922964122566174582776707332452371001272163776841229318324903125740713574141005124561965913888899753461735347970011693256316751660678950830027510255804846105583465055446615090444309583050775808509297040039680057435342253926566240898195863631588888936364129920059308455669454034010391478238784189888594672336242763795138176353222845524644040094258962433613354036104643881925238489224010194193088911666165584229424668165441688927790460608264864204237717002054744337988941974661214699689706521543006262604535890998125752275942608772174376107314217749233048217904944409836238235772306749874396760463376480215133461333478395682746608242585133953883882226786118030184028136755970045385534758453247</span>
<span class="gd">-        )</span>
<span class="gi">+    name = &quot;diffie-hellman-group16-sha512&quot;</span>
<span class="gi">+    # http://tools.ietf.org/html/rfc3526#section-5</span>
<span class="gi">+    P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199FFFFFFFFFFFFFFFF  # noqa</span>
<span class="w"> </span>    G = 2
<span class="gd">-    name = &#39;diffie-hellman-group16-sha512&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;diffie-hellman-group16-sha512&quot;</span>
<span class="w"> </span>    hash_algo = sha512
<span class="gh">diff --git a/paramiko/kex_gss.py b/paramiko/kex_gss.py</span>
<span class="gh">index 50d792e4..2a5f29e3 100644</span>
<span class="gd">--- a/paramiko/kex_gss.py</span>
<span class="gi">+++ b/paramiko/kex_gss.py</span>
<span class="gu">@@ -1,3 +1,25 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+# Copyright (C) 2013-2014 science + computing ag</span>
<span class="gi">+# Author: Sebastian Deiss &lt;sebastian.deiss@t-online.de&gt;</span>
<span class="gi">+#</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>This module provides GSS-API / SSPI Key Exchange as defined in :rfc:`4462`.

<span class="gu">@@ -14,20 +36,41 @@ This module provides GSS-API / SSPI Key Exchange as defined in :rfc:`4462`.</span>

<span class="w"> </span>.. versionadded:: 1.15
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from hashlib import sha1
<span class="gd">-from paramiko.common import DEBUG, max_byte, zero_byte, byte_chr, byte_mask, byte_ord</span>
<span class="gi">+</span>
<span class="gi">+from paramiko.common import (</span>
<span class="gi">+    DEBUG,</span>
<span class="gi">+    max_byte,</span>
<span class="gi">+    zero_byte,</span>
<span class="gi">+    byte_chr,</span>
<span class="gi">+    byte_mask,</span>
<span class="gi">+    byte_ord,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="gd">-(MSG_KEXGSS_INIT, MSG_KEXGSS_CONTINUE, MSG_KEXGSS_COMPLETE,</span>
<span class="gd">-    MSG_KEXGSS_HOSTKEY, MSG_KEXGSS_ERROR) = range(30, 35)</span>
<span class="gd">-MSG_KEXGSS_GROUPREQ, MSG_KEXGSS_GROUP = range(40, 42)</span>
<span class="gd">-(c_MSG_KEXGSS_INIT, c_MSG_KEXGSS_CONTINUE, c_MSG_KEXGSS_COMPLETE,</span>
<span class="gd">-    c_MSG_KEXGSS_HOSTKEY, c_MSG_KEXGSS_ERROR) = [byte_chr(c) for c in range</span>
<span class="gd">-    (30, 35)]</span>
<span class="gd">-c_MSG_KEXGSS_GROUPREQ, c_MSG_KEXGSS_GROUP = [byte_chr(c) for c in range(40, 42)</span>
<span class="gd">-    ]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+(</span>
<span class="gi">+    MSG_KEXGSS_INIT,</span>
<span class="gi">+    MSG_KEXGSS_CONTINUE,</span>
<span class="gi">+    MSG_KEXGSS_COMPLETE,</span>
<span class="gi">+    MSG_KEXGSS_HOSTKEY,</span>
<span class="gi">+    MSG_KEXGSS_ERROR,</span>
<span class="gi">+) = range(30, 35)</span>
<span class="gi">+(MSG_KEXGSS_GROUPREQ, MSG_KEXGSS_GROUP) = range(40, 42)</span>
<span class="gi">+(</span>
<span class="gi">+    c_MSG_KEXGSS_INIT,</span>
<span class="gi">+    c_MSG_KEXGSS_CONTINUE,</span>
<span class="gi">+    c_MSG_KEXGSS_COMPLETE,</span>
<span class="gi">+    c_MSG_KEXGSS_HOSTKEY,</span>
<span class="gi">+    c_MSG_KEXGSS_ERROR,</span>
<span class="gi">+) = [byte_chr(c) for c in range(30, 35)]</span>
<span class="gi">+(c_MSG_KEXGSS_GROUPREQ, c_MSG_KEXGSS_GROUP) = [</span>
<span class="gi">+    byte_chr(c) for c in range(40, 42)</span>
<span class="gi">+]</span>


<span class="w"> </span>class KexGSSGroup1:
<span class="gu">@@ -35,13 +78,13 @@ class KexGSSGroup1:</span>
<span class="w"> </span>    GSS-API / SSPI Authenticated Diffie-Hellman Key Exchange as defined in `RFC
<span class="w"> </span>    4462 Section 2 &lt;https://tools.ietf.org/html/rfc4462.html#section-2&gt;`_
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    P = (</span>
<span class="gd">-        179769313486231590770839156793787453197860296048756011706444423684197180216158519368947833795864925541502180565485980503646440548199239100050792877003355816639229553136239076508735759914822574862575007425302077447712589550957937778424442426617334727629299387668709205606050270810842907692932019128194467627007</span>
<span class="gd">-        )</span>
<span class="gi">+</span>
<span class="gi">+    # draft-ietf-secsh-transport-09.txt, page 17</span>
<span class="gi">+    P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF  # noqa</span>
<span class="w"> </span>    G = 2
<span class="gd">-    b7fffffffffffffff = byte_chr(127) + max_byte * 7</span>
<span class="gd">-    b0000000000000000 = zero_byte * 8</span>
<span class="gd">-    NAME = &#39;gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;</span>
<span class="gi">+    b7fffffffffffffff = byte_chr(0x7F) + max_byte * 7  # noqa</span>
<span class="gi">+    b0000000000000000 = zero_byte * 8  # noqa</span>
<span class="gi">+    NAME = &quot;gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;</span>

<span class="w"> </span>    def __init__(self, transport):
<span class="w"> </span>        self.transport = transport
<span class="gu">@@ -55,7 +98,27 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start the GSS-API / SSPI Authenticated Diffie-Hellman Key Exchange.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._generate_x()</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            # compute f = g^x mod p, but don&#39;t send it yet</span>
<span class="gi">+            self.f = pow(self.G, self.x, self.P)</span>
<span class="gi">+            self.transport._expect_packet(MSG_KEXGSS_INIT)</span>
<span class="gi">+            return</span>
<span class="gi">+        # compute e = g^x mod p (where g=2), and send it</span>
<span class="gi">+        self.e = pow(self.G, self.x, self.P)</span>
<span class="gi">+        # Initialize GSS-API Key Exchange</span>
<span class="gi">+        self.gss_host = self.transport.gss_host</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_INIT)</span>
<span class="gi">+        m.add_string(self.kexgss.ssh_init_sec_context(target=self.gss_host))</span>
<span class="gi">+        m.add_mpint(self.e)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(</span>
<span class="gi">+            MSG_KEXGSS_HOSTKEY,</span>
<span class="gi">+            MSG_KEXGSS_CONTINUE,</span>
<span class="gi">+            MSG_KEXGSS_COMPLETE,</span>
<span class="gi">+            MSG_KEXGSS_ERROR,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def parse_next(self, ptype, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -64,7 +127,20 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        :param ptype: The (string) type of the incoming packet
<span class="w"> </span>        :param `.Message` m: The packet content
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.transport.server_mode and (ptype == MSG_KEXGSS_INIT):</span>
<span class="gi">+            return self._parse_kexgss_init(m)</span>
<span class="gi">+        elif not self.transport.server_mode and (ptype == MSG_KEXGSS_HOSTKEY):</span>
<span class="gi">+            return self._parse_kexgss_hostkey(m)</span>
<span class="gi">+        elif self.transport.server_mode and (ptype == MSG_KEXGSS_CONTINUE):</span>
<span class="gi">+            return self._parse_kexgss_continue(m)</span>
<span class="gi">+        elif not self.transport.server_mode and (ptype == MSG_KEXGSS_COMPLETE):</span>
<span class="gi">+            return self._parse_kexgss_complete(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_ERROR:</span>
<span class="gi">+            return self._parse_kexgss_error(m)</span>
<span class="gi">+        msg = &quot;GSS KexGroup1 asked to handle packet type {:d}&quot;</span>
<span class="gi">+        raise SSHException(msg.format(ptype))</span>
<span class="gi">+</span>
<span class="gi">+    # ##  internals...</span>

<span class="w"> </span>    def _generate_x(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -74,7 +150,13 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        potential x where the first 63 bits are 1, because some of those will
<span class="w"> </span>        be larger than q (but this is a tiny tiny subset of potential x).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            x_bytes = os.urandom(128)</span>
<span class="gi">+            x_bytes = byte_mask(x_bytes[0], 0x7F) + x_bytes[1:]</span>
<span class="gi">+            first = x_bytes[:8]</span>
<span class="gi">+            if first not in (self.b7fffffffffffffff, self.b0000000000000000):</span>
<span class="gi">+                break</span>
<span class="gi">+        self.x = util.inflate_long(x_bytes)</span>

<span class="w"> </span>    def _parse_kexgss_hostkey(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -82,7 +164,12 @@ class KexGSSGroup1:</span>

<span class="w"> </span>        :param `.Message` m: The content of the SSH2_MSG_KEXGSS_HOSTKEY message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # client mode</span>
<span class="gi">+        host_key = m.get_string()</span>
<span class="gi">+        self.transport.host_key = host_key</span>
<span class="gi">+        sig = m.get_string()</span>
<span class="gi">+        self.transport._verify_key(host_key, sig)</span>
<span class="gi">+        self.transport._expect_packet(MSG_KEXGSS_CONTINUE, MSG_KEXGSS_COMPLETE)</span>

<span class="w"> </span>    def _parse_kexgss_continue(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -91,7 +178,21 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        :param `.Message` m: The content of the SSH2_MSG_KEXGSS_CONTINUE
<span class="w"> </span>            message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.transport.server_mode:</span>
<span class="gi">+            srv_token = m.get_string()</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(c_MSG_KEXGSS_CONTINUE)</span>
<span class="gi">+            m.add_string(</span>
<span class="gi">+                self.kexgss.ssh_init_sec_context(</span>
<span class="gi">+                    target=self.gss_host, recv_token=srv_token</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            self.transport.send_message(m)</span>
<span class="gi">+            self.transport._expect_packet(</span>
<span class="gi">+                MSG_KEXGSS_CONTINUE, MSG_KEXGSS_COMPLETE, MSG_KEXGSS_ERROR</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def _parse_kexgss_complete(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -100,7 +201,43 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        :param `.Message` m: The content of the
<span class="w"> </span>            SSH2_MSG_KEXGSS_COMPLETE message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # client mode</span>
<span class="gi">+        if self.transport.host_key is None:</span>
<span class="gi">+            self.transport.host_key = NullHostKey()</span>
<span class="gi">+        self.f = m.get_mpint()</span>
<span class="gi">+        if (self.f &lt; 1) or (self.f &gt; self.P - 1):</span>
<span class="gi">+            raise SSHException(&#39;Server kex &quot;f&quot; is out of range&#39;)</span>
<span class="gi">+        mic_token = m.get_string()</span>
<span class="gi">+        # This must be TRUE, if there is a GSS-API token in this message.</span>
<span class="gi">+        bool = m.get_boolean()</span>
<span class="gi">+        srv_token = None</span>
<span class="gi">+        if bool:</span>
<span class="gi">+            srv_token = m.get_string()</span>
<span class="gi">+        K = pow(self.f, self.x, self.P)</span>
<span class="gi">+        # okay, build up the hash H of</span>
<span class="gi">+        # (V_C || V_S || I_C || I_S || K_S || e || f || K)</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(self.transport.host_key.__str__())</span>
<span class="gi">+        hm.add_mpint(self.e)</span>
<span class="gi">+        hm.add_mpint(self.f)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        H = sha1(str(hm)).digest()</span>
<span class="gi">+        self.transport._set_K_H(K, H)</span>
<span class="gi">+        if srv_token is not None:</span>
<span class="gi">+            self.kexgss.ssh_init_sec_context(</span>
<span class="gi">+                target=self.gss_host, recv_token=srv_token</span>
<span class="gi">+            )</span>
<span class="gi">+            self.kexgss.ssh_check_mic(mic_token, H)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.kexgss.ssh_check_mic(mic_token, H)</span>
<span class="gi">+        self.transport.gss_kex_used = True</span>
<span class="gi">+        self.transport._activate_outbound()</span>

<span class="w"> </span>    def _parse_kexgss_init(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -108,7 +245,55 @@ class KexGSSGroup1:</span>

<span class="w"> </span>        :param `.Message` m: The content of the SSH2_MSG_KEXGSS_INIT message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # server mode</span>
<span class="gi">+        client_token = m.get_string()</span>
<span class="gi">+        self.e = m.get_mpint()</span>
<span class="gi">+        if (self.e &lt; 1) or (self.e &gt; self.P - 1):</span>
<span class="gi">+            raise SSHException(&#39;Client kex &quot;e&quot; is out of range&#39;)</span>
<span class="gi">+        K = pow(self.e, self.x, self.P)</span>
<span class="gi">+        self.transport.host_key = NullHostKey()</span>
<span class="gi">+        key = self.transport.host_key.__str__()</span>
<span class="gi">+        # okay, build up the hash H of</span>
<span class="gi">+        # (V_C || V_S || I_C || I_S || K_S || e || f || K)</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_string(key)</span>
<span class="gi">+        hm.add_mpint(self.e)</span>
<span class="gi">+        hm.add_mpint(self.f)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        H = sha1(hm.asbytes()).digest()</span>
<span class="gi">+        self.transport._set_K_H(K, H)</span>
<span class="gi">+        srv_token = self.kexgss.ssh_accept_sec_context(</span>
<span class="gi">+            self.gss_host, client_token</span>
<span class="gi">+        )</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        if self.kexgss._gss_srv_ctxt_status:</span>
<span class="gi">+            mic_token = self.kexgss.ssh_get_mic(</span>
<span class="gi">+                self.transport.session_id, gss_kex=True</span>
<span class="gi">+            )</span>
<span class="gi">+            m.add_byte(c_MSG_KEXGSS_COMPLETE)</span>
<span class="gi">+            m.add_mpint(self.f)</span>
<span class="gi">+            m.add_string(mic_token)</span>
<span class="gi">+            if srv_token is not None:</span>
<span class="gi">+                m.add_boolean(True)</span>
<span class="gi">+                m.add_string(srv_token)</span>
<span class="gi">+            else:</span>
<span class="gi">+                m.add_boolean(False)</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+            self.transport.gss_kex_used = True</span>
<span class="gi">+            self.transport._activate_outbound()</span>
<span class="gi">+        else:</span>
<span class="gi">+            m.add_byte(c_MSG_KEXGSS_CONTINUE)</span>
<span class="gi">+            m.add_string(srv_token)</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+            self.transport._expect_packet(</span>
<span class="gi">+                MSG_KEXGSS_CONTINUE, MSG_KEXGSS_COMPLETE, MSG_KEXGSS_ERROR</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def _parse_kexgss_error(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -121,7 +306,19 @@ class KexGSSGroup1:</span>
<span class="w"> </span>                             the error message and the language tag of the
<span class="w"> </span>                             message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        maj_status = m.get_int()</span>
<span class="gi">+        min_status = m.get_int()</span>
<span class="gi">+        err_msg = m.get_string()</span>
<span class="gi">+        m.get_string()  # we don&#39;t care about the language!</span>
<span class="gi">+        raise SSHException(</span>
<span class="gi">+            &quot;&quot;&quot;GSS-API Error:</span>
<span class="gi">+Major Status: {}</span>
<span class="gi">+Minor Status: {}</span>
<span class="gi">+Error Message: {}</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+                maj_status, min_status, err_msg</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>


<span class="w"> </span>class KexGSSGroup14(KexGSSGroup1):
<span class="gu">@@ -130,11 +327,10 @@ class KexGSSGroup14(KexGSSGroup1):</span>
<span class="w"> </span>    in `RFC 4462 Section 2
<span class="w"> </span>    &lt;https://tools.ietf.org/html/rfc4462.html#section-2&gt;`_
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    P = (</span>
<span class="gd">-        32317006071311007300338913926423828248817941241140239112842009751400741706634354222619689417363569347117901737909704191754605873209195028853758986185622153212175412514901774520270235796078236248884246189477587641105928646099411723245426622522193230540919037680524235519125679715870117001058055877651038861847280257976054903569732561526167081339361799541336476559160368317896729073178384589680639671900977202194168647225871031411336429319536193471636533209717077448227988588565369208645296636077250268955505928362751121174096972998068410554359584866583291642136218231078990999448652468262416972035911852507045361090559</span>
<span class="gd">-        )</span>
<span class="gi">+</span>
<span class="gi">+    P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF  # noqa</span>
<span class="w"> </span>    G = 2
<span class="gd">-    NAME = &#39;gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;</span>
<span class="gi">+    NAME = &quot;gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;</span>


<span class="w"> </span>class KexGSSGex:
<span class="gu">@@ -142,7 +338,8 @@ class KexGSSGex:</span>
<span class="w"> </span>    GSS-API / SSPI Authenticated Diffie-Hellman Group Exchange as defined in
<span class="w"> </span>    `RFC 4462 Section 2 &lt;https://tools.ietf.org/html/rfc4462.html#section-2&gt;`_
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    NAME = &#39;gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;</span>
<span class="gi">+</span>
<span class="gi">+    NAME = &quot;gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;</span>
<span class="w"> </span>    min_bits = 1024
<span class="w"> </span>    max_bits = 8192
<span class="w"> </span>    preferred_bits = 2048
<span class="gu">@@ -163,7 +360,20 @@ class KexGSSGex:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start the GSS-API / SSPI Authenticated Diffie-Hellman Group Exchange
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            self.transport._expect_packet(MSG_KEXGSS_GROUPREQ)</span>
<span class="gi">+            return</span>
<span class="gi">+        # request a bit range: we accept (min_bits) to (max_bits), but prefer</span>
<span class="gi">+        # (preferred_bits).  according to the spec, we shouldn&#39;t pull the</span>
<span class="gi">+        # minimum up above 1024.</span>
<span class="gi">+        self.gss_host = self.transport.gss_host</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_GROUPREQ)</span>
<span class="gi">+        m.add_int(self.min_bits)</span>
<span class="gi">+        m.add_int(self.preferred_bits)</span>
<span class="gi">+        m.add_int(self.max_bits)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(MSG_KEXGSS_GROUP)</span>

<span class="w"> </span>    def parse_next(self, ptype, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -172,7 +382,42 @@ class KexGSSGex:</span>
<span class="w"> </span>        :param ptype: The (string) type of the incoming packet
<span class="w"> </span>        :param `.Message` m: The packet content
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if ptype == MSG_KEXGSS_GROUPREQ:</span>
<span class="gi">+            return self._parse_kexgss_groupreq(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_GROUP:</span>
<span class="gi">+            return self._parse_kexgss_group(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_INIT:</span>
<span class="gi">+            return self._parse_kexgss_gex_init(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_HOSTKEY:</span>
<span class="gi">+            return self._parse_kexgss_hostkey(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_CONTINUE:</span>
<span class="gi">+            return self._parse_kexgss_continue(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_COMPLETE:</span>
<span class="gi">+            return self._parse_kexgss_complete(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_ERROR:</span>
<span class="gi">+            return self._parse_kexgss_error(m)</span>
<span class="gi">+        msg = &quot;KexGex asked to handle packet type {:d}&quot;</span>
<span class="gi">+        raise SSHException(msg.format(ptype))</span>
<span class="gi">+</span>
<span class="gi">+    # ##  internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_x(self):</span>
<span class="gi">+        # generate an &quot;x&quot; (1 &lt; x &lt; (p-1)/2).</span>
<span class="gi">+        q = (self.p - 1) // 2</span>
<span class="gi">+        qnorm = util.deflate_long(q, 0)</span>
<span class="gi">+        qhbyte = byte_ord(qnorm[0])</span>
<span class="gi">+        byte_count = len(qnorm)</span>
<span class="gi">+        qmask = 0xFF</span>
<span class="gi">+        while not (qhbyte &amp; 0x80):</span>
<span class="gi">+            qhbyte &lt;&lt;= 1</span>
<span class="gi">+            qmask &gt;&gt;= 1</span>
<span class="gi">+        while True:</span>
<span class="gi">+            x_bytes = os.urandom(byte_count)</span>
<span class="gi">+            x_bytes = byte_mask(x_bytes[0], qmask) + x_bytes[1:]</span>
<span class="gi">+            x = util.inflate_long(x_bytes, 1)</span>
<span class="gi">+            if (x &gt; 1) and (x &lt; q):</span>
<span class="gi">+                break</span>
<span class="gi">+        self.x = x</span>

<span class="w"> </span>    def _parse_kexgss_groupreq(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -181,7 +426,42 @@ class KexGSSGex:</span>
<span class="w"> </span>        :param `.Message` m: The content of the
<span class="w"> </span>            SSH2_MSG_KEXGSS_GROUPREQ message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        minbits = m.get_int()</span>
<span class="gi">+        preferredbits = m.get_int()</span>
<span class="gi">+        maxbits = m.get_int()</span>
<span class="gi">+        # smoosh the user&#39;s preferred size into our own limits</span>
<span class="gi">+        if preferredbits &gt; self.max_bits:</span>
<span class="gi">+            preferredbits = self.max_bits</span>
<span class="gi">+        if preferredbits &lt; self.min_bits:</span>
<span class="gi">+            preferredbits = self.min_bits</span>
<span class="gi">+        # fix min/max if they&#39;re inconsistent.  technically, we could just pout</span>
<span class="gi">+        # and hang up, but there&#39;s no harm in giving them the benefit of the</span>
<span class="gi">+        # doubt and just picking a bitsize for them.</span>
<span class="gi">+        if minbits &gt; preferredbits:</span>
<span class="gi">+            minbits = preferredbits</span>
<span class="gi">+        if maxbits &lt; preferredbits:</span>
<span class="gi">+            maxbits = preferredbits</span>
<span class="gi">+        # now save a copy</span>
<span class="gi">+        self.min_bits = minbits</span>
<span class="gi">+        self.preferred_bits = preferredbits</span>
<span class="gi">+        self.max_bits = maxbits</span>
<span class="gi">+        # generate prime</span>
<span class="gi">+        pack = self.transport._get_modulus_pack()</span>
<span class="gi">+        if pack is None:</span>
<span class="gi">+            raise SSHException(&quot;Can&#39;t do server-side gex with no modulus pack&quot;)</span>
<span class="gi">+        self.transport._log(</span>
<span class="gi">+            DEBUG,  # noqa</span>
<span class="gi">+            &quot;Picking p ({} &lt;= {} &lt;= {} bits)&quot;.format(</span>
<span class="gi">+                minbits, preferredbits, maxbits</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        self.g, self.p = pack.get_modulus(minbits, preferredbits, maxbits)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_GROUP)</span>
<span class="gi">+        m.add_mpint(self.p)</span>
<span class="gi">+        m.add_mpint(self.g)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(MSG_KEXGSS_INIT)</span>

<span class="w"> </span>    def _parse_kexgss_group(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -189,7 +469,32 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_GROUP message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.p = m.get_mpint()</span>
<span class="gi">+        self.g = m.get_mpint()</span>
<span class="gi">+        # reject if p&#39;s bit length &lt; 1024 or &gt; 8192</span>
<span class="gi">+        bitlen = util.bit_length(self.p)</span>
<span class="gi">+        if (bitlen &lt; 1024) or (bitlen &gt; 8192):</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;Server-generated gex p (don&#39;t ask) is out of range &quot;</span>
<span class="gi">+                &quot;({} bits)&quot;.format(bitlen)</span>
<span class="gi">+            )</span>
<span class="gi">+        self.transport._log(</span>
<span class="gi">+            DEBUG, &quot;Got server p ({} bits)&quot;.format(bitlen)</span>
<span class="gi">+        )  # noqa</span>
<span class="gi">+        self._generate_x()</span>
<span class="gi">+        # now compute e = g^x mod p</span>
<span class="gi">+        self.e = pow(self.g, self.x, self.p)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_INIT)</span>
<span class="gi">+        m.add_string(self.kexgss.ssh_init_sec_context(target=self.gss_host))</span>
<span class="gi">+        m.add_mpint(self.e)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._expect_packet(</span>
<span class="gi">+            MSG_KEXGSS_HOSTKEY,</span>
<span class="gi">+            MSG_KEXGSS_CONTINUE,</span>
<span class="gi">+            MSG_KEXGSS_COMPLETE,</span>
<span class="gi">+            MSG_KEXGSS_ERROR,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _parse_kexgss_gex_init(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -197,7 +502,61 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_INIT message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        client_token = m.get_string()</span>
<span class="gi">+        self.e = m.get_mpint()</span>
<span class="gi">+        if (self.e &lt; 1) or (self.e &gt; self.p - 1):</span>
<span class="gi">+            raise SSHException(&#39;Client kex &quot;e&quot; is out of range&#39;)</span>
<span class="gi">+        self._generate_x()</span>
<span class="gi">+        self.f = pow(self.g, self.x, self.p)</span>
<span class="gi">+        K = pow(self.e, self.x, self.p)</span>
<span class="gi">+        self.transport.host_key = NullHostKey()</span>
<span class="gi">+        key = self.transport.host_key.__str__()</span>
<span class="gi">+        # okay, build up the hash H of</span>
<span class="gi">+        # (V_C || V_S || I_C || I_S || K_S || min || n || max || p || g || e || f || K)  # noqa</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+            key,</span>
<span class="gi">+        )</span>
<span class="gi">+        hm.add_int(self.min_bits)</span>
<span class="gi">+        hm.add_int(self.preferred_bits)</span>
<span class="gi">+        hm.add_int(self.max_bits)</span>
<span class="gi">+        hm.add_mpint(self.p)</span>
<span class="gi">+        hm.add_mpint(self.g)</span>
<span class="gi">+        hm.add_mpint(self.e)</span>
<span class="gi">+        hm.add_mpint(self.f)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        H = sha1(hm.asbytes()).digest()</span>
<span class="gi">+        self.transport._set_K_H(K, H)</span>
<span class="gi">+        srv_token = self.kexgss.ssh_accept_sec_context(</span>
<span class="gi">+            self.gss_host, client_token</span>
<span class="gi">+        )</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        if self.kexgss._gss_srv_ctxt_status:</span>
<span class="gi">+            mic_token = self.kexgss.ssh_get_mic(</span>
<span class="gi">+                self.transport.session_id, gss_kex=True</span>
<span class="gi">+            )</span>
<span class="gi">+            m.add_byte(c_MSG_KEXGSS_COMPLETE)</span>
<span class="gi">+            m.add_mpint(self.f)</span>
<span class="gi">+            m.add_string(mic_token)</span>
<span class="gi">+            if srv_token is not None:</span>
<span class="gi">+                m.add_boolean(True)</span>
<span class="gi">+                m.add_string(srv_token)</span>
<span class="gi">+            else:</span>
<span class="gi">+                m.add_boolean(False)</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+            self.transport.gss_kex_used = True</span>
<span class="gi">+            self.transport._activate_outbound()</span>
<span class="gi">+        else:</span>
<span class="gi">+            m.add_byte(c_MSG_KEXGSS_CONTINUE)</span>
<span class="gi">+            m.add_string(srv_token)</span>
<span class="gi">+            self.transport._send_message(m)</span>
<span class="gi">+            self.transport._expect_packet(</span>
<span class="gi">+                MSG_KEXGSS_CONTINUE, MSG_KEXGSS_COMPLETE, MSG_KEXGSS_ERROR</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def _parse_kexgss_hostkey(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -205,7 +564,12 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_HOSTKEY message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # client mode</span>
<span class="gi">+        host_key = m.get_string()</span>
<span class="gi">+        self.transport.host_key = host_key</span>
<span class="gi">+        sig = m.get_string()</span>
<span class="gi">+        self.transport._verify_key(host_key, sig)</span>
<span class="gi">+        self.transport._expect_packet(MSG_KEXGSS_CONTINUE, MSG_KEXGSS_COMPLETE)</span>

<span class="w"> </span>    def _parse_kexgss_continue(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -213,7 +577,21 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_CONTINUE message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.transport.server_mode:</span>
<span class="gi">+            srv_token = m.get_string()</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(c_MSG_KEXGSS_CONTINUE)</span>
<span class="gi">+            m.add_string(</span>
<span class="gi">+                self.kexgss.ssh_init_sec_context(</span>
<span class="gi">+                    target=self.gss_host, recv_token=srv_token</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            self.transport.send_message(m)</span>
<span class="gi">+            self.transport._expect_packet(</span>
<span class="gi">+                MSG_KEXGSS_CONTINUE, MSG_KEXGSS_COMPLETE, MSG_KEXGSS_ERROR</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def _parse_kexgss_complete(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -221,7 +599,49 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_COMPLETE message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.transport.host_key is None:</span>
<span class="gi">+            self.transport.host_key = NullHostKey()</span>
<span class="gi">+        self.f = m.get_mpint()</span>
<span class="gi">+        mic_token = m.get_string()</span>
<span class="gi">+        # This must be TRUE, if there is a GSS-API token in this message.</span>
<span class="gi">+        bool = m.get_boolean()</span>
<span class="gi">+        srv_token = None</span>
<span class="gi">+        if bool:</span>
<span class="gi">+            srv_token = m.get_string()</span>
<span class="gi">+        if (self.f &lt; 1) or (self.f &gt; self.p - 1):</span>
<span class="gi">+            raise SSHException(&#39;Server kex &quot;f&quot; is out of range&#39;)</span>
<span class="gi">+        K = pow(self.f, self.x, self.p)</span>
<span class="gi">+        # okay, build up the hash H of</span>
<span class="gi">+        # (V_C || V_S || I_C || I_S || K_S || min || n || max || p || g || e || f || K)  # noqa</span>
<span class="gi">+        hm = Message()</span>
<span class="gi">+        hm.add(</span>
<span class="gi">+            self.transport.local_version,</span>
<span class="gi">+            self.transport.remote_version,</span>
<span class="gi">+            self.transport.local_kex_init,</span>
<span class="gi">+            self.transport.remote_kex_init,</span>
<span class="gi">+            self.transport.host_key.__str__(),</span>
<span class="gi">+        )</span>
<span class="gi">+        if not self.old_style:</span>
<span class="gi">+            hm.add_int(self.min_bits)</span>
<span class="gi">+        hm.add_int(self.preferred_bits)</span>
<span class="gi">+        if not self.old_style:</span>
<span class="gi">+            hm.add_int(self.max_bits)</span>
<span class="gi">+        hm.add_mpint(self.p)</span>
<span class="gi">+        hm.add_mpint(self.g)</span>
<span class="gi">+        hm.add_mpint(self.e)</span>
<span class="gi">+        hm.add_mpint(self.f)</span>
<span class="gi">+        hm.add_mpint(K)</span>
<span class="gi">+        H = sha1(hm.asbytes()).digest()</span>
<span class="gi">+        self.transport._set_K_H(K, H)</span>
<span class="gi">+        if srv_token is not None:</span>
<span class="gi">+            self.kexgss.ssh_init_sec_context(</span>
<span class="gi">+                target=self.gss_host, recv_token=srv_token</span>
<span class="gi">+            )</span>
<span class="gi">+            self.kexgss.ssh_check_mic(mic_token, H)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.kexgss.ssh_check_mic(mic_token, H)</span>
<span class="gi">+        self.transport.gss_kex_used = True</span>
<span class="gi">+        self.transport._activate_outbound()</span>

<span class="w"> </span>    def _parse_kexgss_error(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -234,7 +654,19 @@ class KexGSSGex:</span>
<span class="w"> </span>                             the error message and the language tag of the
<span class="w"> </span>                             message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        maj_status = m.get_int()</span>
<span class="gi">+        min_status = m.get_int()</span>
<span class="gi">+        err_msg = m.get_string()</span>
<span class="gi">+        m.get_string()  # we don&#39;t care about the language (lang_tag)!</span>
<span class="gi">+        raise SSHException(</span>
<span class="gi">+            &quot;&quot;&quot;GSS-API Error:</span>
<span class="gi">+Major Status: {}</span>
<span class="gi">+Minor Status: {}</span>
<span class="gi">+Error Message: {}</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+                maj_status, min_status, err_msg</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>


<span class="w"> </span>class NullHostKey:
<span class="gu">@@ -245,7 +677,10 @@ class NullHostKey:</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self):
<span class="gd">-        self.key = &#39;&#39;</span>
<span class="gi">+        self.key = &quot;&quot;</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.key
<span class="gi">+</span>
<span class="gi">+    def get_name(self):</span>
<span class="gi">+        return self.key</span>
<span class="gh">diff --git a/paramiko/message.py b/paramiko/message.py</span>
<span class="gh">index 7e6e2c5a..8c2b3bd0 100644</span>
<span class="gd">--- a/paramiko/message.py</span>
<span class="gi">+++ b/paramiko/message.py</span>
<span class="gu">@@ -1,8 +1,28 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Implementation of an SSH2 &quot;message&quot;.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="w"> </span>from io import BytesIO
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.common import zero_byte, max_byte, one_byte
<span class="w"> </span>from paramiko.util import u
<span class="gu">@@ -18,7 +38,8 @@ class Message:</span>
<span class="w"> </span>    exposed for people implementing custom extensions, or features that
<span class="w"> </span>    paramiko doesn&#39;t support yet.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    big_int = 4278190080</span>
<span class="gi">+</span>
<span class="gi">+    big_int = 0xFF000000</span>

<span class="w"> </span>    def __init__(self, content=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -40,27 +61,31 @@ class Message:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a string representation of this object, for debugging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;paramiko.Message(&#39; + repr(self.packet.getvalue()) + &#39;)&#39;</span>
<span class="gi">+        return &quot;paramiko.Message(&quot; + repr(self.packet.getvalue()) + &quot;)&quot;</span>

<span class="gi">+    # TODO 4.0: just merge into __bytes__ (everywhere)</span>
<span class="w"> </span>    def asbytes(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the byte stream content of this Message, as a `bytes`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.packet.getvalue()</span>

<span class="w"> </span>    def rewind(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Rewind the message to the beginning as if no items had been parsed
<span class="w"> </span>        out of it yet.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packet.seek(0)</span>

<span class="w"> </span>    def get_remainder(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the `bytes` of this message that haven&#39;t already been parsed and
<span class="w"> </span>        returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        position = self.packet.tell()</span>
<span class="gi">+        remainder = self.packet.read()</span>
<span class="gi">+        self.packet.seek(position)</span>
<span class="gi">+        return remainder</span>

<span class="w"> </span>    def get_so_far(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -68,7 +93,9 @@ class Message:</span>
<span class="w"> </span>        returned. The string passed into a message&#39;s constructor can be
<span class="w"> </span>        regenerated by concatenating ``get_so_far`` and `get_remainder`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        position = self.packet.tell()</span>
<span class="gi">+        self.rewind()</span>
<span class="gi">+        return self.packet.read(position)</span>

<span class="w"> </span>    def get_bytes(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -77,17 +104,29 @@ class Message:</span>
<span class="w"> </span>        string of ``n`` zero bytes if there weren&#39;t ``n`` bytes remaining in
<span class="w"> </span>        the message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = self.packet.read(n)</span>
<span class="gi">+        max_pad_size = 1 &lt;&lt; 20  # Limit padding to 1 MB</span>
<span class="gi">+        if len(b) &lt; n &lt; max_pad_size:</span>
<span class="gi">+            return b + zero_byte * (n - len(b))</span>
<span class="gi">+        return b</span>

<span class="w"> </span>    def get_byte(self):
<span class="gd">-        &quot;\n        Return the next byte of the message, without decomposing it.  This\n        is equivalent to `get_bytes(1) &lt;get_bytes&gt;`.\n\n        :return:\n            the next (`bytes`) byte of the message, or ``b&#39;\x00&#39;`` if there\n            aren&#39;t any bytes remaining.\n        &quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Return the next byte of the message, without decomposing it.  This</span>
<span class="gi">+        is equivalent to `get_bytes(1) &lt;get_bytes&gt;`.</span>
<span class="gi">+</span>
<span class="gi">+        :return:</span>
<span class="gi">+            the next (`bytes`) byte of the message, or ``b&#39;\000&#39;`` if there</span>
<span class="gi">+            aren&#39;t any bytes remaining.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.get_bytes(1)</span>

<span class="w"> </span>    def get_boolean(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fetch a boolean from the stream.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = self.get_bytes(1)</span>
<span class="gi">+        return b != zero_byte</span>

<span class="w"> </span>    def get_adaptive_int(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -95,13 +134,17 @@ class Message:</span>

<span class="w"> </span>        :return: a 32-bit unsigned `int`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        byte = self.get_bytes(1)</span>
<span class="gi">+        if byte == max_byte:</span>
<span class="gi">+            return util.inflate_long(self.get_binary())</span>
<span class="gi">+        byte += self.get_bytes(3)</span>
<span class="gi">+        return struct.unpack(&quot;&gt;I&quot;, byte)[0]</span>

<span class="w"> </span>    def get_int(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fetch an int from the stream.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return struct.unpack(&quot;&gt;I&quot;, self.get_bytes(4))[0]</span>

<span class="w"> </span>    def get_int64(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -109,7 +152,7 @@ class Message:</span>

<span class="w"> </span>        :return: a 64-bit unsigned integer (`int`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return struct.unpack(&quot;&gt;Q&quot;, self.get_bytes(8))[0]</span>

<span class="w"> </span>    def get_mpint(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -117,16 +160,20 @@ class Message:</span>

<span class="w"> </span>        :return: an arbitrary-length integer (`int`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return util.inflate_long(self.get_binary())</span>

<span class="gi">+    # TODO 4.0: depending on where this is used internally or downstream, force</span>
<span class="gi">+    # users to specify get_binary instead and delete this.</span>
<span class="w"> </span>    def get_string(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fetch a &quot;string&quot; from the stream.  This will actually be a `bytes`
<span class="w"> </span>        object, and may contain unprintable characters.  (It&#39;s not unheard of
<span class="w"> </span>        for a string to contain another byte-stream message.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_bytes(self.get_int())</span>

<span class="gi">+    # TODO 4.0: also consider having this take over the get_string name, and</span>
<span class="gi">+    # remove this name instead.</span>
<span class="w"> </span>    def get_text(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fetch a Unicode string from the stream.
<span class="gu">@@ -134,13 +181,13 @@ class Message:</span>
<span class="w"> </span>        This currently operates by attempting to encode the next &quot;string&quot; as
<span class="w"> </span>        ``utf-8``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return u(self.get_string())</span>

<span class="w"> </span>    def get_binary(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Alias for `get_string` (obtains a bytestring).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_bytes(self.get_int())</span>

<span class="w"> </span>    def get_list(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -148,7 +195,7 @@ class Message:</span>

<span class="w"> </span>        These are trivially encoded as comma-separated values in a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_text().split(&quot;,&quot;)</span>

<span class="w"> </span>    def add_bytes(self, b):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -156,7 +203,8 @@ class Message:</span>

<span class="w"> </span>        :param bytes b: bytes to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packet.write(b)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def add_byte(self, b):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -164,7 +212,8 @@ class Message:</span>

<span class="w"> </span>        :param bytes b: byte to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packet.write(b)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def add_boolean(self, b):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -172,7 +221,11 @@ class Message:</span>

<span class="w"> </span>        :param bool b: boolean value to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if b:</span>
<span class="gi">+            self.packet.write(one_byte)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.packet.write(zero_byte)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def add_int(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -180,7 +233,8 @@ class Message:</span>

<span class="w"> </span>        :param int n: integer to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packet.write(struct.pack(&quot;&gt;I&quot;, n))</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def add_adaptive_int(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -188,7 +242,12 @@ class Message:</span>

<span class="w"> </span>        :param int n: integer to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if n &gt;= Message.big_int:</span>
<span class="gi">+            self.packet.write(max_byte)</span>
<span class="gi">+            self.add_string(util.deflate_long(n))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.packet.write(struct.pack(&quot;&gt;I&quot;, n))</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def add_int64(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -196,7 +255,8 @@ class Message:</span>

<span class="w"> </span>        :param int n: long int to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packet.write(struct.pack(&quot;&gt;Q&quot;, n))</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def add_mpint(self, z):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -205,17 +265,23 @@ class Message:</span>

<span class="w"> </span>        :param int z: long int to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_string(util.deflate_long(z))</span>
<span class="gi">+        return self</span>

<span class="gi">+    # TODO: see the TODO for get_string/get_text/et al, this should change</span>
<span class="gi">+    # to match.</span>
<span class="w"> </span>    def add_string(self, s):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add a bytestring to the stream.

<span class="w"> </span>        :param byte s: bytestring to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = util.asbytes(s)</span>
<span class="gi">+        self.add_int(len(s))</span>
<span class="gi">+        self.packet.write(s)</span>
<span class="gi">+        return self</span>

<span class="gd">-    def add_list(self, l):</span>
<span class="gi">+    def add_list(self, l):  # noqa: E741</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add a list of strings to the stream.  They are encoded identically to
<span class="w"> </span>        a single string of values separated by commas.  (Yes, really, that&#39;s
<span class="gu">@@ -223,8 +289,21 @@ class Message:</span>

<span class="w"> </span>        :param l: list of strings to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_string(&quot;,&quot;.join(l))</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _add(self, i):</span>
<span class="gi">+        if type(i) is bool:</span>
<span class="gi">+            return self.add_boolean(i)</span>
<span class="gi">+        elif isinstance(i, int):</span>
<span class="gi">+            return self.add_adaptive_int(i)</span>
<span class="gi">+        elif type(i) is list:</span>
<span class="gi">+            return self.add_list(i)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.add_string(i)</span>

<span class="gi">+    # TODO: this would never have worked for unicode strings under Python 3,</span>
<span class="gi">+    # guessing nobody/nothing ever used it for that purpose?</span>
<span class="w"> </span>    def add(self, *seq):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add a sequence of items to the stream.  The values are encoded based
<span class="gu">@@ -235,4 +314,5 @@ class Message:</span>

<span class="w"> </span>        :param seq: the sequence of items
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in seq:</span>
<span class="gi">+            self._add(item)</span>
<span class="gh">diff --git a/paramiko/packet.py b/paramiko/packet.py</span>
<span class="gh">index 92f24b8c..1274a23c 100644</span>
<span class="gd">--- a/paramiko/packet.py</span>
<span class="gi">+++ b/paramiko/packet.py</span>
<span class="gu">@@ -1,6 +1,25 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Packet handling
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import errno
<span class="w"> </span>import os
<span class="w"> </span>import socket
<span class="gu">@@ -8,27 +27,55 @@ import struct</span>
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="w"> </span>from hmac import HMAC
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="gd">-from paramiko.common import linefeed_byte, cr_byte_value, MSG_NAMES, DEBUG, xffffffff, zero_byte, byte_ord</span>
<span class="gi">+from paramiko.common import (</span>
<span class="gi">+    linefeed_byte,</span>
<span class="gi">+    cr_byte_value,</span>
<span class="gi">+    MSG_NAMES,</span>
<span class="gi">+    DEBUG,</span>
<span class="gi">+    xffffffff,</span>
<span class="gi">+    zero_byte,</span>
<span class="gi">+    byte_ord,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.util import u
<span class="w"> </span>from paramiko.ssh_exception import SSHException, ProxyCommandFailure
<span class="w"> </span>from paramiko.message import Message


<span class="gi">+def compute_hmac(key, message, digest_class):</span>
<span class="gi">+    return HMAC(key, message, digest_class).digest()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class NeedRekeyException(Exception):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Exception indicating a rekey is needed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gi">+def first_arg(e):</span>
<span class="gi">+    arg = None</span>
<span class="gi">+    if type(e.args) is tuple and len(e.args) &gt; 0:</span>
<span class="gi">+        arg = e.args[0]</span>
<span class="gi">+    return arg</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Packetizer:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Implementation of the base SSH packet protocol.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # READ the secsh RFC&#39;s before raising these values.  if anything,</span>
<span class="gi">+    # they should probably be lower.</span>
<span class="w"> </span>    REKEY_PACKETS = pow(2, 29)
<span class="w"> </span>    REKEY_BYTES = pow(2, 29)
<span class="gi">+</span>
<span class="gi">+    # Allow receiving this many packets after a re-key request before</span>
<span class="gi">+    # terminating</span>
<span class="w"> </span>    REKEY_PACKETS_OVERFLOW_MAX = pow(2, 29)
<span class="gi">+    # Allow receiving this many bytes after a re-key request before terminating</span>
<span class="w"> </span>    REKEY_BYTES_OVERFLOW_MAX = pow(2, 29)

<span class="w"> </span>    def __init__(self, socket):
<span class="gu">@@ -40,12 +87,16 @@ class Packetizer:</span>
<span class="w"> </span>        self.__init_count = 0
<span class="w"> </span>        self.__remainder = bytes()
<span class="w"> </span>        self._initial_kex_done = False
<span class="gi">+</span>
<span class="gi">+        # used for noticing when to re-key:</span>
<span class="w"> </span>        self.__sent_bytes = 0
<span class="w"> </span>        self.__sent_packets = 0
<span class="w"> </span>        self.__received_bytes = 0
<span class="w"> </span>        self.__received_packets = 0
<span class="w"> </span>        self.__received_bytes_overflow = 0
<span class="w"> </span>        self.__received_packets_overflow = 0
<span class="gi">+</span>
<span class="gi">+        # current inbound/outbound ciphering:</span>
<span class="w"> </span>        self.__block_size_out = 8
<span class="w"> </span>        self.__block_size_in = 8
<span class="w"> </span>        self.__mac_size_out = 0
<span class="gu">@@ -63,35 +114,116 @@ class Packetizer:</span>
<span class="w"> </span>        self.__sequence_number_in = 0
<span class="w"> </span>        self.__etm_out = False
<span class="w"> </span>        self.__etm_in = False
<span class="gi">+</span>
<span class="gi">+        # lock around outbound writes (packet computation)</span>
<span class="w"> </span>        self.__write_lock = threading.RLock()
<span class="gi">+</span>
<span class="gi">+        # keepalives:</span>
<span class="w"> </span>        self.__keepalive_interval = 0
<span class="w"> </span>        self.__keepalive_last = time.time()
<span class="w"> </span>        self.__keepalive_callback = None
<span class="gi">+</span>
<span class="w"> </span>        self.__timer = None
<span class="w"> </span>        self.__handshake_complete = False
<span class="w"> </span>        self.__timer_expired = False

<span class="gi">+    @property</span>
<span class="gi">+    def closed(self):</span>
<span class="gi">+        return self.__closed</span>
<span class="gi">+</span>
<span class="gi">+    def reset_seqno_out(self):</span>
<span class="gi">+        self.__sequence_number_out = 0</span>
<span class="gi">+</span>
<span class="gi">+    def reset_seqno_in(self):</span>
<span class="gi">+        self.__sequence_number_in = 0</span>
<span class="gi">+</span>
<span class="w"> </span>    def set_log(self, log):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the Python log object to use for logging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__logger = log</span>

<span class="gd">-    def set_outbound_cipher(self, block_engine, block_size, mac_engine,</span>
<span class="gd">-        mac_size, mac_key, sdctr=False, etm=False):</span>
<span class="gi">+    def set_outbound_cipher(</span>
<span class="gi">+        self,</span>
<span class="gi">+        block_engine,</span>
<span class="gi">+        block_size,</span>
<span class="gi">+        mac_engine,</span>
<span class="gi">+        mac_size,</span>
<span class="gi">+        mac_key,</span>
<span class="gi">+        sdctr=False,</span>
<span class="gi">+        etm=False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Switch outbound data cipher.
<span class="w"> </span>        :param etm: Set encrypt-then-mac from OpenSSH
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__block_engine_out = block_engine</span>
<span class="gi">+        self.__sdctr_out = sdctr</span>
<span class="gi">+        self.__block_size_out = block_size</span>
<span class="gi">+        self.__mac_engine_out = mac_engine</span>
<span class="gi">+        self.__mac_size_out = mac_size</span>
<span class="gi">+        self.__mac_key_out = mac_key</span>
<span class="gi">+        self.__sent_bytes = 0</span>
<span class="gi">+        self.__sent_packets = 0</span>
<span class="gi">+        self.__etm_out = etm</span>
<span class="gi">+        # wait until the reset happens in both directions before clearing</span>
<span class="gi">+        # rekey flag</span>
<span class="gi">+        self.__init_count |= 1</span>
<span class="gi">+        if self.__init_count == 3:</span>
<span class="gi">+            self.__init_count = 0</span>
<span class="gi">+            self.__need_rekey = False</span>

<span class="gd">-    def set_inbound_cipher(self, block_engine, block_size, mac_engine,</span>
<span class="gd">-        mac_size, mac_key, etm=False):</span>
<span class="gi">+    def set_inbound_cipher(</span>
<span class="gi">+        self,</span>
<span class="gi">+        block_engine,</span>
<span class="gi">+        block_size,</span>
<span class="gi">+        mac_engine,</span>
<span class="gi">+        mac_size,</span>
<span class="gi">+        mac_key,</span>
<span class="gi">+        etm=False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Switch inbound data cipher.
<span class="w"> </span>        :param etm: Set encrypt-then-mac from OpenSSH
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__block_engine_in = block_engine</span>
<span class="gi">+        self.__block_size_in = block_size</span>
<span class="gi">+        self.__mac_engine_in = mac_engine</span>
<span class="gi">+        self.__mac_size_in = mac_size</span>
<span class="gi">+        self.__mac_key_in = mac_key</span>
<span class="gi">+        self.__received_bytes = 0</span>
<span class="gi">+        self.__received_packets = 0</span>
<span class="gi">+        self.__received_bytes_overflow = 0</span>
<span class="gi">+        self.__received_packets_overflow = 0</span>
<span class="gi">+        self.__etm_in = etm</span>
<span class="gi">+        # wait until the reset happens in both directions before clearing</span>
<span class="gi">+        # rekey flag</span>
<span class="gi">+        self.__init_count |= 2</span>
<span class="gi">+        if self.__init_count == 3:</span>
<span class="gi">+            self.__init_count = 0</span>
<span class="gi">+            self.__need_rekey = False</span>
<span class="gi">+</span>
<span class="gi">+    def set_outbound_compressor(self, compressor):</span>
<span class="gi">+        self.__compress_engine_out = compressor</span>
<span class="gi">+</span>
<span class="gi">+    def set_inbound_compressor(self, compressor):</span>
<span class="gi">+        self.__compress_engine_in = compressor</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        self.__closed = True</span>
<span class="gi">+        self.__socket.close()</span>
<span class="gi">+</span>
<span class="gi">+    def set_hexdump(self, hexdump):</span>
<span class="gi">+        self.__dump_packets = hexdump</span>
<span class="gi">+</span>
<span class="gi">+    def get_hexdump(self):</span>
<span class="gi">+        return self.__dump_packets</span>
<span class="gi">+</span>
<span class="gi">+    def get_mac_size_in(self):</span>
<span class="gi">+        return self.__mac_size_in</span>
<span class="gi">+</span>
<span class="gi">+    def get_mac_size_out(self):</span>
<span class="gi">+        return self.__mac_size_out</span>

<span class="w"> </span>    def need_rekey(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -99,7 +231,7 @@ class Packetizer:</span>
<span class="w"> </span>        will be triggered during a packet read or write, so it should be
<span class="w"> </span>        checked after every read or write, or at least after every few.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__need_rekey</span>

<span class="w"> </span>    def set_keepalive(self, interval, callback):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -107,7 +239,12 @@ class Packetizer:</span>
<span class="w"> </span>        no data read from or written to the socket, the callback will be
<span class="w"> </span>        executed and the timer will be reset.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__keepalive_interval = interval</span>
<span class="gi">+        self.__keepalive_callback = callback</span>
<span class="gi">+        self.__keepalive_last = time.time()</span>
<span class="gi">+</span>
<span class="gi">+    def read_timer(self):</span>
<span class="gi">+        self.__timer_expired = True</span>

<span class="w"> </span>    def start_handshake(self, timeout):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -117,7 +254,9 @@ class Packetizer:</span>

<span class="w"> </span>        :param float timeout: amount of seconds to wait before timing out
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.__timer:</span>
<span class="gi">+            self.__timer = threading.Timer(float(timeout), self.read_timer)</span>
<span class="gi">+            self.__timer.start()</span>

<span class="w"> </span>    def handshake_timed_out(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -129,13 +268,20 @@ class Packetizer:</span>

<span class="w"> </span>        :return: handshake time out status, as a `bool`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.__timer:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if self.__handshake_complete:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return self.__timer_expired</span>

<span class="w"> </span>    def complete_handshake(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Tells `Packetizer` that the handshake has completed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.__timer:</span>
<span class="gi">+            self.__timer.cancel()</span>
<span class="gi">+            self.__timer_expired = False</span>
<span class="gi">+            self.__handshake_complete = True</span>

<span class="w"> </span>    def read_all(self, n, check_rekey=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -148,20 +294,163 @@ class Packetizer:</span>
<span class="w"> </span>            ``EOFError`` -- if the socket was closed before all the bytes could
<span class="w"> </span>            be read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        out = bytes()</span>
<span class="gi">+        # handle over-reading from reading the banner line</span>
<span class="gi">+        if len(self.__remainder) &gt; 0:</span>
<span class="gi">+            out = self.__remainder[:n]</span>
<span class="gi">+            self.__remainder = self.__remainder[n:]</span>
<span class="gi">+            n -= len(out)</span>
<span class="gi">+        while n &gt; 0:</span>
<span class="gi">+            got_timeout = False</span>
<span class="gi">+            if self.handshake_timed_out():</span>
<span class="gi">+                raise EOFError()</span>
<span class="gi">+            try:</span>
<span class="gi">+                x = self.__socket.recv(n)</span>
<span class="gi">+                if len(x) == 0:</span>
<span class="gi">+                    raise EOFError()</span>
<span class="gi">+                out += x</span>
<span class="gi">+                n -= len(x)</span>
<span class="gi">+            except socket.timeout:</span>
<span class="gi">+                got_timeout = True</span>
<span class="gi">+            except socket.error as e:</span>
<span class="gi">+                # on Linux, sometimes instead of socket.timeout, we get</span>
<span class="gi">+                # EAGAIN.  this is a bug in recent (&gt; 2.6.9) kernels but</span>
<span class="gi">+                # we need to work around it.</span>
<span class="gi">+                arg = first_arg(e)</span>
<span class="gi">+                if arg == errno.EAGAIN:</span>
<span class="gi">+                    got_timeout = True</span>
<span class="gi">+                elif self.__closed:</span>
<span class="gi">+                    raise EOFError()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+            if got_timeout:</span>
<span class="gi">+                if self.__closed:</span>
<span class="gi">+                    raise EOFError()</span>
<span class="gi">+                if check_rekey and (len(out) == 0) and self.__need_rekey:</span>
<span class="gi">+                    raise NeedRekeyException()</span>
<span class="gi">+                self._check_keepalive()</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def write_all(self, out):</span>
<span class="gi">+        self.__keepalive_last = time.time()</span>
<span class="gi">+        iteration_with_zero_as_return_value = 0</span>
<span class="gi">+        while len(out) &gt; 0:</span>
<span class="gi">+            retry_write = False</span>
<span class="gi">+            try:</span>
<span class="gi">+                n = self.__socket.send(out)</span>
<span class="gi">+            except socket.timeout:</span>
<span class="gi">+                retry_write = True</span>
<span class="gi">+            except socket.error as e:</span>
<span class="gi">+                arg = first_arg(e)</span>
<span class="gi">+                if arg == errno.EAGAIN:</span>
<span class="gi">+                    retry_write = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    n = -1</span>
<span class="gi">+            except ProxyCommandFailure:</span>
<span class="gi">+                raise  # so it doesn&#39;t get swallowed by the below catchall</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                # could be: (32, &#39;Broken pipe&#39;)</span>
<span class="gi">+                n = -1</span>
<span class="gi">+            if retry_write:</span>
<span class="gi">+                n = 0</span>
<span class="gi">+                if self.__closed:</span>
<span class="gi">+                    n = -1</span>
<span class="gi">+            else:</span>
<span class="gi">+                if n == 0 and iteration_with_zero_as_return_value &gt; 10:</span>
<span class="gi">+                    # We shouldn&#39;t retry the write, but we didn&#39;t</span>
<span class="gi">+                    # manage to send anything over the socket. This might be an</span>
<span class="gi">+                    # indication that we have lost contact with the remote</span>
<span class="gi">+                    # side, but are yet to receive an EOFError or other socket</span>
<span class="gi">+                    # errors. Let&#39;s give it some iteration to try and catch up.</span>
<span class="gi">+                    n = -1</span>
<span class="gi">+                iteration_with_zero_as_return_value += 1</span>
<span class="gi">+            if n &lt; 0:</span>
<span class="gi">+                raise EOFError()</span>
<span class="gi">+            if n == len(out):</span>
<span class="gi">+                break</span>
<span class="gi">+            out = out[n:]</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def readline(self, timeout):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Read a line from the socket.  We assume no data is pending after the
<span class="w"> </span>        line, so it&#39;s okay to attempt large reads.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buf = self.__remainder</span>
<span class="gi">+        while linefeed_byte not in buf:</span>
<span class="gi">+            buf += self._read_timeout(timeout)</span>
<span class="gi">+        n = buf.index(linefeed_byte)</span>
<span class="gi">+        self.__remainder = buf[n + 1 :]</span>
<span class="gi">+        buf = buf[:n]</span>
<span class="gi">+        if (len(buf) &gt; 0) and (buf[-1] == cr_byte_value):</span>
<span class="gi">+            buf = buf[:-1]</span>
<span class="gi">+        return u(buf)</span>

<span class="w"> </span>    def send_message(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write a block of data using the current cipher, as an SSH block.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # encrypt this sucka</span>
<span class="gi">+        data = data.asbytes()</span>
<span class="gi">+        cmd = byte_ord(data[0])</span>
<span class="gi">+        if cmd in MSG_NAMES:</span>
<span class="gi">+            cmd_name = MSG_NAMES[cmd]</span>
<span class="gi">+        else:</span>
<span class="gi">+            cmd_name = &quot;${:x}&quot;.format(cmd)</span>
<span class="gi">+        orig_len = len(data)</span>
<span class="gi">+        self.__write_lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.__compress_engine_out is not None:</span>
<span class="gi">+                data = self.__compress_engine_out(data)</span>
<span class="gi">+            packet = self._build_packet(data)</span>
<span class="gi">+            if self.__dump_packets:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG,</span>
<span class="gi">+                    &quot;Write packet &lt;{}&gt;, length {}&quot;.format(cmd_name, orig_len),</span>
<span class="gi">+                )</span>
<span class="gi">+                self._log(DEBUG, util.format_binary(packet, &quot;OUT: &quot;))</span>
<span class="gi">+            if self.__block_engine_out is not None:</span>
<span class="gi">+                if self.__etm_out:</span>
<span class="gi">+                    # packet length is not encrypted in EtM</span>
<span class="gi">+                    out = packet[0:4] + self.__block_engine_out.update(</span>
<span class="gi">+                        packet[4:]</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    out = self.__block_engine_out.update(packet)</span>
<span class="gi">+            else:</span>
<span class="gi">+                out = packet</span>
<span class="gi">+            # + mac</span>
<span class="gi">+            if self.__block_engine_out is not None:</span>
<span class="gi">+                packed = struct.pack(&quot;&gt;I&quot;, self.__sequence_number_out)</span>
<span class="gi">+                payload = packed + (out if self.__etm_out else packet)</span>
<span class="gi">+                out += compute_hmac(</span>
<span class="gi">+                    self.__mac_key_out, payload, self.__mac_engine_out</span>
<span class="gi">+                )[: self.__mac_size_out]</span>
<span class="gi">+            next_seq = (self.__sequence_number_out + 1) &amp; xffffffff</span>
<span class="gi">+            if next_seq == 0 and not self._initial_kex_done:</span>
<span class="gi">+                raise SSHException(</span>
<span class="gi">+                    &quot;Sequence number rolled over during initial kex!&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            self.__sequence_number_out = next_seq</span>
<span class="gi">+            self.write_all(out)</span>
<span class="gi">+</span>
<span class="gi">+            self.__sent_bytes += len(out)</span>
<span class="gi">+            self.__sent_packets += 1</span>
<span class="gi">+            sent_too_much = (</span>
<span class="gi">+                self.__sent_packets &gt;= self.REKEY_PACKETS</span>
<span class="gi">+                or self.__sent_bytes &gt;= self.REKEY_BYTES</span>
<span class="gi">+            )</span>
<span class="gi">+            if sent_too_much and not self.__need_rekey:</span>
<span class="gi">+                # only ask once for rekeying</span>
<span class="gi">+                msg = &quot;Rekeying (hit {} packets, {} bytes sent)&quot;</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG, msg.format(self.__sent_packets, self.__sent_bytes)</span>
<span class="gi">+                )</span>
<span class="gi">+                self.__received_bytes_overflow = 0</span>
<span class="gi">+                self.__received_packets_overflow = 0</span>
<span class="gi">+                self._trigger_rekey()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.__write_lock.release()</span>

<span class="w"> </span>    def read_message(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -171,4 +460,190 @@ class Packetizer:</span>
<span class="w"> </span>        :raises: `.SSHException` -- if the packet is mangled
<span class="w"> </span>        :raises: `.NeedRekeyException` -- if the transport should rekey
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        header = self.read_all(self.__block_size_in, check_rekey=True)</span>
<span class="gi">+        if self.__etm_in:</span>
<span class="gi">+            packet_size = struct.unpack(&quot;&gt;I&quot;, header[:4])[0]</span>
<span class="gi">+            remaining = packet_size - self.__block_size_in + 4</span>
<span class="gi">+            packet = header[4:] + self.read_all(remaining, check_rekey=False)</span>
<span class="gi">+            mac = self.read_all(self.__mac_size_in, check_rekey=False)</span>
<span class="gi">+            mac_payload = (</span>
<span class="gi">+                struct.pack(&quot;&gt;II&quot;, self.__sequence_number_in, packet_size)</span>
<span class="gi">+                + packet</span>
<span class="gi">+            )</span>
<span class="gi">+            my_mac = compute_hmac(</span>
<span class="gi">+                self.__mac_key_in, mac_payload, self.__mac_engine_in</span>
<span class="gi">+            )[: self.__mac_size_in]</span>
<span class="gi">+            if not util.constant_time_bytes_eq(my_mac, mac):</span>
<span class="gi">+                raise SSHException(&quot;Mismatched MAC&quot;)</span>
<span class="gi">+            header = packet</span>
<span class="gi">+</span>
<span class="gi">+        if self.__block_engine_in is not None:</span>
<span class="gi">+            header = self.__block_engine_in.update(header)</span>
<span class="gi">+        if self.__dump_packets:</span>
<span class="gi">+            self._log(DEBUG, util.format_binary(header, &quot;IN: &quot;))</span>
<span class="gi">+</span>
<span class="gi">+        # When ETM is in play, we&#39;ve already read the packet size &amp; decrypted</span>
<span class="gi">+        # everything, so just set the packet back to the header we obtained.</span>
<span class="gi">+        if self.__etm_in:</span>
<span class="gi">+            packet = header</span>
<span class="gi">+        # Otherwise, use the older non-ETM logic</span>
<span class="gi">+        else:</span>
<span class="gi">+            packet_size = struct.unpack(&quot;&gt;I&quot;, header[:4])[0]</span>
<span class="gi">+</span>
<span class="gi">+            # leftover contains decrypted bytes from the first block (after the</span>
<span class="gi">+            # length field)</span>
<span class="gi">+            leftover = header[4:]</span>
<span class="gi">+            if (packet_size - len(leftover)) % self.__block_size_in != 0:</span>
<span class="gi">+                raise SSHException(&quot;Invalid packet blocking&quot;)</span>
<span class="gi">+            buf = self.read_all(</span>
<span class="gi">+                packet_size + self.__mac_size_in - len(leftover)</span>
<span class="gi">+            )</span>
<span class="gi">+            packet = buf[: packet_size - len(leftover)]</span>
<span class="gi">+            post_packet = buf[packet_size - len(leftover) :]</span>
<span class="gi">+</span>
<span class="gi">+            if self.__block_engine_in is not None:</span>
<span class="gi">+                packet = self.__block_engine_in.update(packet)</span>
<span class="gi">+            packet = leftover + packet</span>
<span class="gi">+</span>
<span class="gi">+        if self.__dump_packets:</span>
<span class="gi">+            self._log(DEBUG, util.format_binary(packet, &quot;IN: &quot;))</span>
<span class="gi">+</span>
<span class="gi">+        if self.__mac_size_in &gt; 0 and not self.__etm_in:</span>
<span class="gi">+            mac = post_packet[: self.__mac_size_in]</span>
<span class="gi">+            mac_payload = (</span>
<span class="gi">+                struct.pack(&quot;&gt;II&quot;, self.__sequence_number_in, packet_size)</span>
<span class="gi">+                + packet</span>
<span class="gi">+            )</span>
<span class="gi">+            my_mac = compute_hmac(</span>
<span class="gi">+                self.__mac_key_in, mac_payload, self.__mac_engine_in</span>
<span class="gi">+            )[: self.__mac_size_in]</span>
<span class="gi">+            if not util.constant_time_bytes_eq(my_mac, mac):</span>
<span class="gi">+                raise SSHException(&quot;Mismatched MAC&quot;)</span>
<span class="gi">+        padding = byte_ord(packet[0])</span>
<span class="gi">+        payload = packet[1 : packet_size - padding]</span>
<span class="gi">+</span>
<span class="gi">+        if self.__dump_packets:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                &quot;Got payload ({} bytes, {} padding)&quot;.format(</span>
<span class="gi">+                    packet_size, padding</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self.__compress_engine_in is not None:</span>
<span class="gi">+            payload = self.__compress_engine_in(payload)</span>
<span class="gi">+</span>
<span class="gi">+        msg = Message(payload[1:])</span>
<span class="gi">+        msg.seqno = self.__sequence_number_in</span>
<span class="gi">+        next_seq = (self.__sequence_number_in + 1) &amp; xffffffff</span>
<span class="gi">+        if next_seq == 0 and not self._initial_kex_done:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;Sequence number rolled over during initial kex!&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        self.__sequence_number_in = next_seq</span>
<span class="gi">+</span>
<span class="gi">+        # check for rekey</span>
<span class="gi">+        raw_packet_size = packet_size + self.__mac_size_in + 4</span>
<span class="gi">+        self.__received_bytes += raw_packet_size</span>
<span class="gi">+        self.__received_packets += 1</span>
<span class="gi">+        if self.__need_rekey:</span>
<span class="gi">+            # we&#39;ve asked to rekey -- give them some packets to comply before</span>
<span class="gi">+            # dropping the connection</span>
<span class="gi">+            self.__received_bytes_overflow += raw_packet_size</span>
<span class="gi">+            self.__received_packets_overflow += 1</span>
<span class="gi">+            if (</span>
<span class="gi">+                self.__received_packets_overflow</span>
<span class="gi">+                &gt;= self.REKEY_PACKETS_OVERFLOW_MAX</span>
<span class="gi">+            ) or (</span>
<span class="gi">+                self.__received_bytes_overflow &gt;= self.REKEY_BYTES_OVERFLOW_MAX</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise SSHException(</span>
<span class="gi">+                    &quot;Remote transport is ignoring rekey requests&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        elif (self.__received_packets &gt;= self.REKEY_PACKETS) or (</span>
<span class="gi">+            self.__received_bytes &gt;= self.REKEY_BYTES</span>
<span class="gi">+        ):</span>
<span class="gi">+            # only ask once for rekeying</span>
<span class="gi">+            err = &quot;Rekeying (hit {} packets, {} bytes received)&quot;</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                err.format(self.__received_packets, self.__received_bytes),</span>
<span class="gi">+            )</span>
<span class="gi">+            self.__received_bytes_overflow = 0</span>
<span class="gi">+            self.__received_packets_overflow = 0</span>
<span class="gi">+            self._trigger_rekey()</span>
<span class="gi">+</span>
<span class="gi">+        cmd = byte_ord(payload[0])</span>
<span class="gi">+        if cmd in MSG_NAMES:</span>
<span class="gi">+            cmd_name = MSG_NAMES[cmd]</span>
<span class="gi">+        else:</span>
<span class="gi">+            cmd_name = &quot;${:x}&quot;.format(cmd)</span>
<span class="gi">+        if self.__dump_packets:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                &quot;Read packet &lt;{}&gt;, length {}&quot;.format(cmd_name, len(payload)),</span>
<span class="gi">+            )</span>
<span class="gi">+        return cmd, msg</span>
<span class="gi">+</span>
<span class="gi">+    # ...protected...</span>
<span class="gi">+</span>
<span class="gi">+    def _log(self, level, msg):</span>
<span class="gi">+        if self.__logger is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        if issubclass(type(msg), list):</span>
<span class="gi">+            for m in msg:</span>
<span class="gi">+                self.__logger.log(level, m)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.__logger.log(level, msg)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_keepalive(self):</span>
<span class="gi">+        if (</span>
<span class="gi">+            not self.__keepalive_interval</span>
<span class="gi">+            or not self.__block_engine_out</span>
<span class="gi">+            or self.__need_rekey</span>
<span class="gi">+        ):</span>
<span class="gi">+            # wait till we&#39;re encrypting, and not in the middle of rekeying</span>
<span class="gi">+            return</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        if now &gt; self.__keepalive_last + self.__keepalive_interval:</span>
<span class="gi">+            self.__keepalive_callback()</span>
<span class="gi">+            self.__keepalive_last = now</span>
<span class="gi">+</span>
<span class="gi">+    def _read_timeout(self, timeout):</span>
<span class="gi">+        start = time.time()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                x = self.__socket.recv(128)</span>
<span class="gi">+                if len(x) == 0:</span>
<span class="gi">+                    raise EOFError()</span>
<span class="gi">+                break</span>
<span class="gi">+            except socket.timeout:</span>
<span class="gi">+                pass</span>
<span class="gi">+            if self.__closed:</span>
<span class="gi">+                raise EOFError()</span>
<span class="gi">+            now = time.time()</span>
<span class="gi">+            if now - start &gt;= timeout:</span>
<span class="gi">+                raise socket.timeout()</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    def _build_packet(self, payload):</span>
<span class="gi">+        # pad up at least 4 bytes, to nearest block-size (usually 8)</span>
<span class="gi">+        bsize = self.__block_size_out</span>
<span class="gi">+        # do not include payload length in computations for padding in EtM mode</span>
<span class="gi">+        # (payload length won&#39;t be encrypted)</span>
<span class="gi">+        addlen = 4 if self.__etm_out else 8</span>
<span class="gi">+        padding = 3 + bsize - ((len(payload) + addlen) % bsize)</span>
<span class="gi">+        packet = struct.pack(&quot;&gt;IB&quot;, len(payload) + padding + 1, padding)</span>
<span class="gi">+        packet += payload</span>
<span class="gi">+        if self.__sdctr_out or self.__block_engine_out is None:</span>
<span class="gi">+            # cute trick i caught openssh doing: if we&#39;re not encrypting or</span>
<span class="gi">+            # SDCTR mode (RFC4344),</span>
<span class="gi">+            # don&#39;t waste random bytes for the padding</span>
<span class="gi">+            packet += zero_byte * padding</span>
<span class="gi">+        else:</span>
<span class="gi">+            packet += os.urandom(padding)</span>
<span class="gi">+        return packet</span>
<span class="gi">+</span>
<span class="gi">+    def _trigger_rekey(self):</span>
<span class="gi">+        # outside code should check for this flag</span>
<span class="gi">+        self.__need_rekey = True</span>
<span class="gh">diff --git a/paramiko/pipe.py b/paramiko/pipe.py</span>
<span class="gh">index 0b740739..65944fad 100644</span>
<span class="gd">--- a/paramiko/pipe.py</span>
<span class="gi">+++ b/paramiko/pipe.py</span>
<span class="gu">@@ -1,3 +1,21 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Abstraction of a one-way pipe where the read end can be used in
<span class="w"> </span>`select.select`. Normally this is trivial, but Windows makes it nearly
<span class="gu">@@ -6,19 +24,52 @@ impossible.</span>
<span class="w"> </span>The pipe acts like an Event, which can be set or cleared. When set, the pipe
<span class="w"> </span>will trigger as readable in `select &lt;select.select&gt;`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import os
<span class="w"> </span>import socket


<span class="gd">-class PosixPipe:</span>
<span class="gi">+def make_pipe():</span>
<span class="gi">+    if sys.platform[:3] != &quot;win&quot;:</span>
<span class="gi">+        p = PosixPipe()</span>
<span class="gi">+    else:</span>
<span class="gi">+        p = WindowsPipe()</span>
<span class="gi">+    return p</span>

<span class="gi">+</span>
<span class="gi">+class PosixPipe:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._rfd, self._wfd = os.pipe()
<span class="w"> </span>        self._set = False
<span class="w"> </span>        self._forever = False
<span class="w"> </span>        self._closed = False

<span class="gi">+    def close(self):</span>
<span class="gi">+        os.close(self._rfd)</span>
<span class="gi">+        os.close(self._wfd)</span>
<span class="gi">+        # used for unit tests:</span>
<span class="gi">+        self._closed = True</span>
<span class="gi">+</span>
<span class="gi">+    def fileno(self):</span>
<span class="gi">+        return self._rfd</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        if not self._set or self._forever:</span>
<span class="gi">+            return</span>
<span class="gi">+        os.read(self._rfd, 1)</span>
<span class="gi">+        self._set = False</span>
<span class="gi">+</span>
<span class="gi">+    def set(self):</span>
<span class="gi">+        if self._set or self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._set = True</span>
<span class="gi">+        os.write(self._wfd, b&quot;*&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def set_forever(self):</span>
<span class="gi">+        self._forever = True</span>
<span class="gi">+        self.set()</span>
<span class="gi">+</span>

<span class="w"> </span>class WindowsPipe:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -28,24 +79,61 @@ class WindowsPipe:</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
<span class="gd">-        serv.bind((&#39;127.0.0.1&#39;, 0))</span>
<span class="gi">+        serv.bind((&quot;127.0.0.1&quot;, 0))</span>
<span class="w"> </span>        serv.listen(1)
<span class="gi">+</span>
<span class="gi">+        # need to save sockets in _rsock/_wsock so they don&#39;t get closed</span>
<span class="w"> </span>        self._rsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
<span class="gd">-        self._rsock.connect((&#39;127.0.0.1&#39;, serv.getsockname()[1]))</span>
<span class="gi">+        self._rsock.connect((&quot;127.0.0.1&quot;, serv.getsockname()[1]))</span>
<span class="gi">+</span>
<span class="w"> </span>        self._wsock, addr = serv.accept()
<span class="w"> </span>        serv.close()
<span class="w"> </span>        self._set = False
<span class="w"> </span>        self._forever = False
<span class="w"> </span>        self._closed = False

<span class="gi">+    def close(self):</span>
<span class="gi">+        self._rsock.close()</span>
<span class="gi">+        self._wsock.close()</span>
<span class="gi">+        # used for unit tests:</span>
<span class="gi">+        self._closed = True</span>

<span class="gd">-class OrPipe:</span>
<span class="gi">+    def fileno(self):</span>
<span class="gi">+        return self._rsock.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        if not self._set or self._forever:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._rsock.recv(1)</span>
<span class="gi">+        self._set = False</span>
<span class="gi">+</span>
<span class="gi">+    def set(self):</span>
<span class="gi">+        if self._set or self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._set = True</span>
<span class="gi">+        self._wsock.send(b&quot;*&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def set_forever(self):</span>
<span class="gi">+        self._forever = True</span>
<span class="gi">+        self.set()</span>

<span class="gi">+</span>
<span class="gi">+class OrPipe:</span>
<span class="w"> </span>    def __init__(self, pipe):
<span class="w"> </span>        self._set = False
<span class="w"> </span>        self._partner = None
<span class="w"> </span>        self._pipe = pipe

<span class="gi">+    def set(self):</span>
<span class="gi">+        self._set = True</span>
<span class="gi">+        if not self._partner._set:</span>
<span class="gi">+            self._pipe.set()</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        self._set = False</span>
<span class="gi">+        if not self._partner._set:</span>
<span class="gi">+            self._pipe.clear()</span>
<span class="gi">+</span>

<span class="w"> </span>def make_or_pipe(pipe):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -53,4 +141,8 @@ def make_or_pipe(pipe):</span>
<span class="w"> </span>    affect the real pipe. if either returned pipe is set, the wrapped pipe
<span class="w"> </span>    is set. when both are cleared, the wrapped pipe is cleared.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    p1 = OrPipe(pipe)</span>
<span class="gi">+    p2 = OrPipe(pipe)</span>
<span class="gi">+    p1._partner = p2</span>
<span class="gi">+    p2._partner = p1</span>
<span class="gi">+    return p1, p2</span>
<span class="gh">diff --git a/paramiko/pkey.py b/paramiko/pkey.py</span>
<span class="gh">index 69923124..f0b2d6d4 100644</span>
<span class="gd">--- a/paramiko/pkey.py</span>
<span class="gi">+++ b/paramiko/pkey.py</span>
<span class="gu">@@ -1,6 +1,25 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Common API for all public keys.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>from base64 import encodebytes, decodebytes
<span class="w"> </span>from binascii import unhexlify
<span class="gu">@@ -9,21 +28,51 @@ from pathlib import Path</span>
<span class="w"> </span>from hashlib import md5, sha256
<span class="w"> </span>import re
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>import bcrypt
<span class="gi">+</span>
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives import serialization
<span class="w"> </span>from cryptography.hazmat.primitives.ciphers import algorithms, modes, Cipher
<span class="w"> </span>from cryptography.hazmat.primitives import asymmetric
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.util import u, b
<span class="w"> </span>from paramiko.common import o600
<span class="w"> </span>from paramiko.ssh_exception import SSHException, PasswordRequiredException
<span class="w"> </span>from paramiko.message import Message
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TripleDES is moving from `cryptography.hazmat.primitives.ciphers.algorithms`</span>
<span class="gi">+# in cryptography&gt;=43.0.0 to `cryptography.hazmat.decrepit.ciphers.algorithms`</span>
<span class="gi">+# It will be removed from `cryptography.hazmat.primitives.ciphers.algorithms`</span>
<span class="gi">+# in cryptography==48.0.0.</span>
<span class="gi">+#</span>
<span class="gi">+# Source References:</span>
<span class="gi">+# - https://github.com/pyca/cryptography/commit/722a6393e61b3ac</span>
<span class="gi">+# - https://github.com/pyca/cryptography/pull/11407/files</span>
<span class="w"> </span>try:
<span class="w"> </span>    from cryptography.hazmat.decrepit.ciphers.algorithms import TripleDES
<span class="w"> </span>except ImportError:
<span class="w"> </span>    from cryptography.hazmat.primitives.ciphers.algorithms import TripleDES
<span class="gd">-OPENSSH_AUTH_MAGIC = b&#39;openssh-key-v1\x00&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+OPENSSH_AUTH_MAGIC = b&quot;openssh-key-v1\x00&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _unpad_openssh(data):</span>
<span class="gi">+    # At the moment, this is only used for unpadding private keys on disk. This</span>
<span class="gi">+    # really ought to be made constant time (possibly by upstreaming this logic</span>
<span class="gi">+    # into pyca/cryptography).</span>
<span class="gi">+    padding_length = data[-1]</span>
<span class="gi">+    if 0x20 &lt;= padding_length &lt; 0x7F:</span>
<span class="gi">+        return data  # no padding, last byte part comment (printable ascii)</span>
<span class="gi">+    if padding_length &gt; 15:</span>
<span class="gi">+        raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+    for i in range(padding_length):</span>
<span class="gi">+        if data[i - padding_length] != i + 1:</span>
<span class="gi">+            raise SSHException(&quot;Invalid key&quot;)</span>
<span class="gi">+    return data[:-padding_length]</span>


<span class="w"> </span>class UnknownKeyType(Exception):
<span class="gu">@@ -36,9 +85,7 @@ class UnknownKeyType(Exception):</span>
<span class="w"> </span>        self.key_bytes = key_bytes

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;UnknownKeyType(type={self.key_type!r}, bytes=&lt;{len(self.key_bytes)}&gt;)&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        return f&quot;UnknownKeyType(type={self.key_type!r}, bytes=&lt;{len(self.key_bytes)}&gt;)&quot;  # noqa</span>


<span class="w"> </span>class PKey:
<span class="gu">@@ -48,16 +95,34 @@ class PKey:</span>
<span class="w"> </span>    Also includes some &quot;meta&quot; level convenience constructors such as
<span class="w"> </span>    `.from_type_string`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _CIPHER_TABLE = {&#39;AES-128-CBC&#39;: {&#39;cipher&#39;: algorithms.AES, &#39;keysize&#39;: </span>
<span class="gd">-        16, &#39;blocksize&#39;: 16, &#39;mode&#39;: modes.CBC}, &#39;AES-256-CBC&#39;: {&#39;cipher&#39;:</span>
<span class="gd">-        algorithms.AES, &#39;keysize&#39;: 32, &#39;blocksize&#39;: 16, &#39;mode&#39;: modes.CBC},</span>
<span class="gd">-        &#39;DES-EDE3-CBC&#39;: {&#39;cipher&#39;: TripleDES, &#39;keysize&#39;: 24, &#39;blocksize&#39;: 8,</span>
<span class="gd">-        &#39;mode&#39;: modes.CBC}}</span>
<span class="gi">+</span>
<span class="gi">+    # known encryption types for private key files:</span>
<span class="gi">+    _CIPHER_TABLE = {</span>
<span class="gi">+        &quot;AES-128-CBC&quot;: {</span>
<span class="gi">+            &quot;cipher&quot;: algorithms.AES,</span>
<span class="gi">+            &quot;keysize&quot;: 16,</span>
<span class="gi">+            &quot;blocksize&quot;: 16,</span>
<span class="gi">+            &quot;mode&quot;: modes.CBC,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;AES-256-CBC&quot;: {</span>
<span class="gi">+            &quot;cipher&quot;: algorithms.AES,</span>
<span class="gi">+            &quot;keysize&quot;: 32,</span>
<span class="gi">+            &quot;blocksize&quot;: 16,</span>
<span class="gi">+            &quot;mode&quot;: modes.CBC,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;DES-EDE3-CBC&quot;: {</span>
<span class="gi">+            &quot;cipher&quot;: TripleDES,</span>
<span class="gi">+            &quot;keysize&quot;: 24,</span>
<span class="gi">+            &quot;blocksize&quot;: 8,</span>
<span class="gi">+            &quot;mode&quot;: modes.CBC,</span>
<span class="gi">+        },</span>
<span class="gi">+    }</span>
<span class="w"> </span>    _PRIVATE_KEY_FORMAT_ORIGINAL = 1
<span class="w"> </span>    _PRIVATE_KEY_FORMAT_OPENSSH = 2
<span class="w"> </span>    BEGIN_TAG = re.compile(
<span class="gd">-        &#39;^-{5}BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-{5}\\s*$&#39;)</span>
<span class="gd">-    END_TAG = re.compile(&#39;^-{5}END (RSA|DSA|EC|OPENSSH) PRIVATE KEY-{5}\\s*$&#39;)</span>
<span class="gi">+        r&quot;^-{5}BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-{5}\s*$&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    END_TAG = re.compile(r&quot;^-{5}END (RSA|DSA|EC|OPENSSH) PRIVATE KEY-{5}\s*$&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def from_path(path, passphrase=None):
<span class="gu">@@ -74,7 +139,64 @@ class PKey:</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: make sure sphinx is reading Path right in param list...</span>
<span class="gi">+</span>
<span class="gi">+        # Lazy import to avoid circular import issues</span>
<span class="gi">+        from paramiko import DSSKey, RSAKey, Ed25519Key, ECDSAKey</span>
<span class="gi">+</span>
<span class="gi">+        # Normalize to string, as cert suffix isn&#39;t quite an extension, so</span>
<span class="gi">+        # pathlib isn&#39;t useful for this.</span>
<span class="gi">+        path = str(path)</span>
<span class="gi">+</span>
<span class="gi">+        # Sort out cert vs key, i.e. it is &#39;legal&#39; to hand this kind of API</span>
<span class="gi">+        # /either/ the key /or/ the cert, when there is a key/cert pair.</span>
<span class="gi">+        cert_suffix = &quot;-cert.pub&quot;</span>
<span class="gi">+        if str(path).endswith(cert_suffix):</span>
<span class="gi">+            key_path = path[: -len(cert_suffix)]</span>
<span class="gi">+            cert_path = path</span>
<span class="gi">+        else:</span>
<span class="gi">+            key_path = path</span>
<span class="gi">+            cert_path = path + cert_suffix</span>
<span class="gi">+</span>
<span class="gi">+        key_path = Path(key_path).expanduser()</span>
<span class="gi">+        cert_path = Path(cert_path).expanduser()</span>
<span class="gi">+</span>
<span class="gi">+        data = key_path.read_bytes()</span>
<span class="gi">+        # Like OpenSSH, try modern/OpenSSH-specific key load first</span>
<span class="gi">+        try:</span>
<span class="gi">+            loaded = serialization.load_ssh_private_key(</span>
<span class="gi">+                data=data, password=passphrase</span>
<span class="gi">+            )</span>
<span class="gi">+        # Then fall back to assuming legacy PEM type</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            loaded = serialization.load_pem_private_key(</span>
<span class="gi">+                data=data, password=passphrase</span>
<span class="gi">+            )</span>
<span class="gi">+        # TODO Python 3.10: match statement? (NOTE: we cannot use a dict</span>
<span class="gi">+        # because the results from the loader are literal backend, eg openssl,</span>
<span class="gi">+        # private classes, so isinstance tests work but exact &#39;x class is y&#39;</span>
<span class="gi">+        # tests will not work)</span>
<span class="gi">+        # TODO: leverage already-parsed/math&#39;d obj to avoid duplicate cpu</span>
<span class="gi">+        # cycles? seemingly requires most of our key subclasses to be rewritten</span>
<span class="gi">+        # to be cryptography-object-forward. this is still likely faster than</span>
<span class="gi">+        # the old SSHClient code that just tried instantiating every class!</span>
<span class="gi">+        key_class = None</span>
<span class="gi">+        if isinstance(loaded, asymmetric.dsa.DSAPrivateKey):</span>
<span class="gi">+            key_class = DSSKey</span>
<span class="gi">+        elif isinstance(loaded, asymmetric.rsa.RSAPrivateKey):</span>
<span class="gi">+            key_class = RSAKey</span>
<span class="gi">+        elif isinstance(loaded, asymmetric.ed25519.Ed25519PrivateKey):</span>
<span class="gi">+            key_class = Ed25519Key</span>
<span class="gi">+        elif isinstance(loaded, asymmetric.ec.EllipticCurvePrivateKey):</span>
<span class="gi">+            key_class = ECDSAKey</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise UnknownKeyType(key_bytes=data, key_type=loaded.__class__)</span>
<span class="gi">+        with key_path.open() as fd:</span>
<span class="gi">+            key = key_class.from_private_key(fd, password=passphrase)</span>
<span class="gi">+        if cert_path.exists():</span>
<span class="gi">+            # load_certificate can take Message, path-str, or value-str</span>
<span class="gi">+            key.load_certificate(str(cert_path))</span>
<span class="gi">+        return key</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def from_type_string(key_type, key_bytes):
<span class="gu">@@ -98,7 +220,13 @@ class PKey:</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from paramiko import key_classes</span>
<span class="gi">+</span>
<span class="gi">+        for key_class in key_classes:</span>
<span class="gi">+            if key_type in key_class.identifiers():</span>
<span class="gi">+                # TODO: needs to passthru things like passphrase</span>
<span class="gi">+                return key_class(data=key_bytes)</span>
<span class="gi">+        raise UnknownKeyType(key_type=key_type, key_bytes=key_bytes)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def identifiers(cls):
<span class="gu">@@ -109,8 +237,14 @@ class PKey:</span>
<span class="w"> </span>        implementation suffices; see `.ECDSAKey` for one example of an
<span class="w"> </span>        override.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [cls.name]</span>

<span class="gi">+    # TODO 4.0: make this and subclasses consistent, some of our own</span>
<span class="gi">+    # classmethods even assume kwargs we don&#39;t define!</span>
<span class="gi">+    # TODO 4.0: prob also raise NotImplementedError instead of pass&#39;ing; the</span>
<span class="gi">+    # contract is pretty obviously that you need to handle msg/data/filename</span>
<span class="gi">+    # appropriately. (If &#39;pass&#39; is a concession to testing, see about doing the</span>
<span class="gi">+    # work to fix the tests instead)</span>
<span class="w"> </span>    def __init__(self, msg=None, data=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new instance of this public key type.  If ``msg`` is given,
<span class="gu">@@ -129,21 +263,27 @@ class PKey:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gi">+    # TODO: arguably this might want to be __str__ instead? ehh</span>
<span class="gi">+    # TODO: ditto the interplay between showing class name (currently we just</span>
<span class="gi">+    # say PKey writ large) and algorithm (usually == class name, but not</span>
<span class="gi">+    # always, also sometimes shows certificate-ness)</span>
<span class="gi">+    # TODO: if we do change it, we also want to tweak eg AgentKey, as it</span>
<span class="gi">+    # currently displays agent-ness with a suffix</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        comment = &#39;&#39;</span>
<span class="gd">-        if hasattr(self, &#39;comment&#39;) and self.comment:</span>
<span class="gd">-            comment = f&#39;, comment={self.comment!r}&#39;</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;PKey(alg={self.algorithm_name}, bits={self.get_bits()}, fp={self.fingerprint}{comment})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        comment = &quot;&quot;</span>
<span class="gi">+        # Works for AgentKey, may work for others?</span>
<span class="gi">+        if hasattr(self, &quot;comment&quot;) and self.comment:</span>
<span class="gi">+            comment = f&quot;, comment={self.comment!r}&quot;</span>
<span class="gi">+        return f&quot;PKey(alg={self.algorithm_name}, bits={self.get_bits()}, fp={self.fingerprint}{comment})&quot;  # noqa</span>

<span class="gi">+    # TODO 4.0: just merge into __bytes__ (everywhere)</span>
<span class="w"> </span>    def asbytes(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a string of an SSH `.Message` made up of the public part(s) of
<span class="w"> </span>        this key.  This string is suitable for passing to `__init__` to
<span class="w"> </span>        re-create the key object later.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bytes()</span>

<span class="w"> </span>    def __bytes__(self):
<span class="w"> </span>        return self.asbytes()
<span class="gu">@@ -154,6 +294,10 @@ class PKey:</span>
<span class="w"> </span>    def __hash__(self):
<span class="w"> </span>        return hash(self._fields)

<span class="gi">+    @property</span>
<span class="gi">+    def _fields(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="w"> </span>    def get_name(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the name of this private key implementation.
<span class="gu">@@ -162,7 +306,7 @@ class PKey:</span>
<span class="w"> </span>            name of this private key type, in SSH terminology, as a `str` (for
<span class="w"> </span>            example, ``&quot;ssh-rsa&quot;``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;&quot;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def algorithm_name(self):
<span class="gu">@@ -172,7 +316,17 @@ class PKey:</span>
<span class="w"> </span>        Similar to `get_name`, but aimed at pure algorithm name instead of SSH
<span class="w"> </span>        protocol field value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Nuke the leading &#39;ssh-&#39;</span>
<span class="gi">+        # TODO in Python 3.9: use .removeprefix()</span>
<span class="gi">+        name = self.get_name().replace(&quot;ssh-&quot;, &quot;&quot;)</span>
<span class="gi">+        # Trim any cert suffix (but leave the -cert, as OpenSSH does)</span>
<span class="gi">+        cert_tail = &quot;-cert-v01@openssh.com&quot;</span>
<span class="gi">+        if cert_tail in name:</span>
<span class="gi">+            name = name.replace(cert_tail, &quot;-cert&quot;)</span>
<span class="gi">+        # Nuke any eg ECDSA suffix, OpenSSH does basically this too.</span>
<span class="gi">+        else:</span>
<span class="gi">+            name = name.split(&quot;-&quot;)[0]</span>
<span class="gi">+        return name.upper()</span>

<span class="w"> </span>    def get_bits(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -181,14 +335,16 @@ class PKey:</span>

<span class="w"> </span>        :return: bits in the key (as an `int`)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO 4.0: raise NotImplementedError, 0 is unlikely to ever be</span>
<span class="gi">+        # _correct_ and nothing in the critical path seems to use this.</span>
<span class="gi">+        return 0</span>

<span class="w"> </span>    def can_sign(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return ``True`` if this key has the private part necessary for signing
<span class="w"> </span>        data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def get_fingerprint(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -199,7 +355,7 @@ class PKey:</span>
<span class="w"> </span>            a 16-byte `string &lt;str&gt;` (binary) of the MD5 fingerprint, in SSH
<span class="w"> </span>            format.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return md5(self.asbytes()).digest()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def fingerprint(self):
<span class="gu">@@ -210,7 +366,11 @@ class PKey:</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hashy = sha256(bytes(self))</span>
<span class="gi">+        hash_name = hashy.name.upper()</span>
<span class="gi">+        b64ed = encodebytes(hashy.digest())</span>
<span class="gi">+        cleaned = u(b64ed).strip().rstrip(&quot;=&quot;)  # yes, OpenSSH does this too!</span>
<span class="gi">+        return f&quot;{hash_name}:{cleaned}&quot;</span>

<span class="w"> </span>    def get_base64(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -220,7 +380,7 @@ class PKey:</span>

<span class="w"> </span>        :return: a base64 `string &lt;str&gt;` containing the public part of the key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return u(encodebytes(self.asbytes())).replace(&quot;\n&quot;, &quot;&quot;)</span>

<span class="w"> </span>    def sign_ssh_data(self, data, algorithm=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -237,7 +397,7 @@ class PKey:</span>
<span class="w"> </span>        .. versionchanged:: 2.9
<span class="w"> </span>            Added the ``algorithm`` kwarg.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bytes()</span>

<span class="w"> </span>    def verify_ssh_sig(self, data, msg):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -249,7 +409,7 @@ class PKey:</span>
<span class="w"> </span>        :return:
<span class="w"> </span>            ``True`` if the signature verifies correctly; ``False`` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_private_key_file(cls, filename, password=None):
<span class="gu">@@ -272,7 +432,8 @@ class PKey:</span>
<span class="w"> </span>            encrypted, and ``password`` is ``None``
<span class="w"> </span>        :raises: `.SSHException` -- if the key file is invalid
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key = cls(filename=filename, password=password)</span>
<span class="gi">+        return key</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_private_key(cls, file_obj, password=None):
<span class="gu">@@ -292,7 +453,8 @@ class PKey:</span>
<span class="w"> </span>            if the private key file is encrypted, and ``password`` is ``None``
<span class="w"> </span>        :raises: `.SSHException` -- if the key file is invalid
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key = cls(file_obj=file_obj, password=password)</span>
<span class="gi">+        return key</span>

<span class="w"> </span>    def write_private_key_file(self, filename, password=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -306,7 +468,7 @@ class PKey:</span>
<span class="w"> </span>        :raises: ``IOError`` -- if there was an error writing the file
<span class="w"> </span>        :raises: `.SSHException` -- if the key is invalid
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise Exception(&quot;Not implemented in PKey&quot;)</span>

<span class="w"> </span>    def write_private_key(self, file_obj, password=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -319,7 +481,8 @@ class PKey:</span>
<span class="w"> </span>        :raises: ``IOError`` -- if there was an error writing to the file
<span class="w"> </span>        :raises: `.SSHException` -- if the key is invalid
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO 4.0: NotImplementedError (plus everywhere else in here)</span>
<span class="gi">+        raise Exception(&quot;Not implemented in PKey&quot;)</span>

<span class="w"> </span>    def _read_private_key_file(self, tag, filename, password=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -342,7 +505,97 @@ class PKey:</span>
<span class="w"> </span>            encrypted, and ``password`` is ``None``.
<span class="w"> </span>        :raises: `.SSHException` -- if the key file is invalid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(filename, &quot;r&quot;) as f:</span>
<span class="gi">+            data = self._read_private_key(tag, f, password)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def _read_private_key(self, tag, f, password=None):</span>
<span class="gi">+        lines = f.readlines()</span>
<span class="gi">+        if not lines:</span>
<span class="gi">+            raise SSHException(&quot;no lines in {} private key file&quot;.format(tag))</span>
<span class="gi">+</span>
<span class="gi">+        # find the BEGIN tag</span>
<span class="gi">+        start = 0</span>
<span class="gi">+        m = self.BEGIN_TAG.match(lines[start])</span>
<span class="gi">+        line_range = len(lines) - 1</span>
<span class="gi">+        while start &lt; line_range and not m:</span>
<span class="gi">+            start += 1</span>
<span class="gi">+            m = self.BEGIN_TAG.match(lines[start])</span>
<span class="gi">+        start += 1</span>
<span class="gi">+        keytype = m.group(1) if m else None</span>
<span class="gi">+        if start &gt;= len(lines) or keytype is None:</span>
<span class="gi">+            raise SSHException(&quot;not a valid {} private key file&quot;.format(tag))</span>
<span class="gi">+</span>
<span class="gi">+        # find the END tag</span>
<span class="gi">+        end = start</span>
<span class="gi">+        m = self.END_TAG.match(lines[end])</span>
<span class="gi">+        while end &lt; line_range and not m:</span>
<span class="gi">+            end += 1</span>
<span class="gi">+            m = self.END_TAG.match(lines[end])</span>
<span class="gi">+</span>
<span class="gi">+        if keytype == tag:</span>
<span class="gi">+            data = self._read_private_key_pem(lines, end, password)</span>
<span class="gi">+            pkformat = self._PRIVATE_KEY_FORMAT_ORIGINAL</span>
<span class="gi">+        elif keytype == &quot;OPENSSH&quot;:</span>
<span class="gi">+            data = self._read_private_key_openssh(lines[start:end], password)</span>
<span class="gi">+            pkformat = self._PRIVATE_KEY_FORMAT_OPENSSH</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;encountered {} key, expected {} key&quot;.format(keytype, tag)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return pkformat, data</span>
<span class="gi">+</span>
<span class="gi">+    def _got_bad_key_format_id(self, id_):</span>
<span class="gi">+        err = &quot;{}._read_private_key() spat out an unknown key format id &#39;{}&#39;&quot;</span>
<span class="gi">+        raise SSHException(err.format(self.__class__.__name__, id_))</span>
<span class="gi">+</span>
<span class="gi">+    def _read_private_key_pem(self, lines, end, password):</span>
<span class="gi">+        start = 0</span>
<span class="gi">+        # parse any headers first</span>
<span class="gi">+        headers = {}</span>
<span class="gi">+        start += 1</span>
<span class="gi">+        while start &lt; len(lines):</span>
<span class="gi">+            line = lines[start].split(&quot;: &quot;)</span>
<span class="gi">+            if len(line) == 1:</span>
<span class="gi">+                break</span>
<span class="gi">+            headers[line[0].lower()] = line[1].strip()</span>
<span class="gi">+            start += 1</span>
<span class="gi">+        # if we trudged to the end of the file, just try to cope.</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = decodebytes(b(&quot;&quot;.join(lines[start:end])))</span>
<span class="gi">+        except base64.binascii.Error as e:</span>
<span class="gi">+            raise SSHException(&quot;base64 decoding error: {}&quot;.format(e))</span>
<span class="gi">+        if &quot;proc-type&quot; not in headers:</span>
<span class="gi">+            # unencryped: done</span>
<span class="gi">+            return data</span>
<span class="gi">+        # encrypted keyfile: will need a password</span>
<span class="gi">+        proc_type = headers[&quot;proc-type&quot;]</span>
<span class="gi">+        if proc_type != &quot;4,ENCRYPTED&quot;:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &#39;Unknown private key structure &quot;{}&quot;&#39;.format(proc_type)</span>
<span class="gi">+            )</span>
<span class="gi">+        try:</span>
<span class="gi">+            encryption_type, saltstr = headers[&quot;dek-info&quot;].split(&quot;,&quot;)</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise SSHException(&quot;Can&#39;t parse DEK-info in private key file&quot;)</span>
<span class="gi">+        if encryption_type not in self._CIPHER_TABLE:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &#39;Unknown private key cipher &quot;{}&quot;&#39;.format(encryption_type)</span>
<span class="gi">+            )</span>
<span class="gi">+        # if no password was passed in,</span>
<span class="gi">+        # raise an exception pointing out that we need one</span>
<span class="gi">+        if password is None:</span>
<span class="gi">+            raise PasswordRequiredException(&quot;Private key file is encrypted&quot;)</span>
<span class="gi">+        cipher = self._CIPHER_TABLE[encryption_type][&quot;cipher&quot;]</span>
<span class="gi">+        keysize = self._CIPHER_TABLE[encryption_type][&quot;keysize&quot;]</span>
<span class="gi">+        mode = self._CIPHER_TABLE[encryption_type][&quot;mode&quot;]</span>
<span class="gi">+        salt = unhexlify(b(saltstr))</span>
<span class="gi">+        key = util.generate_key_bytes(md5, salt, password, keysize)</span>
<span class="gi">+        decryptor = Cipher(</span>
<span class="gi">+            cipher(key), mode(salt), backend=default_backend()</span>
<span class="gi">+        ).decryptor()</span>
<span class="gi">+        return decryptor.update(data) + decryptor.finalize()</span>

<span class="w"> </span>    def _read_private_key_openssh(self, lines, password):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -351,7 +604,84 @@ class PKey:</span>
<span class="w"> </span>        Reference:
<span class="w"> </span>        https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = decodebytes(b(&quot;&quot;.join(lines)))</span>
<span class="gi">+        except base64.binascii.Error as e:</span>
<span class="gi">+            raise SSHException(&quot;base64 decoding error: {}&quot;.format(e))</span>
<span class="gi">+</span>
<span class="gi">+        # read data struct</span>
<span class="gi">+        auth_magic = data[:15]</span>
<span class="gi">+        if auth_magic != OPENSSH_AUTH_MAGIC:</span>
<span class="gi">+            raise SSHException(&quot;unexpected OpenSSH key header encountered&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        cstruct = self._uint32_cstruct_unpack(data[15:], &quot;sssur&quot;)</span>
<span class="gi">+        cipher, kdfname, kdf_options, num_pubkeys, remainder = cstruct</span>
<span class="gi">+        # For now, just support 1 key.</span>
<span class="gi">+        if num_pubkeys &gt; 1:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;unsupported: private keyfile has multiple keys&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        pubkey, privkey_blob = self._uint32_cstruct_unpack(remainder, &quot;ss&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if kdfname == b(&quot;bcrypt&quot;):</span>
<span class="gi">+            if cipher == b(&quot;aes256-cbc&quot;):</span>
<span class="gi">+                mode = modes.CBC</span>
<span class="gi">+            elif cipher == b(&quot;aes256-ctr&quot;):</span>
<span class="gi">+                mode = modes.CTR</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise SSHException(</span>
<span class="gi">+                    &quot;unknown cipher `{}` used in private key file&quot;.format(</span>
<span class="gi">+                        cipher.decode(&quot;utf-8&quot;)</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            # Encrypted private key.</span>
<span class="gi">+            # If no password was passed in, raise an exception pointing</span>
<span class="gi">+            # out that we need one</span>
<span class="gi">+            if password is None:</span>
<span class="gi">+                raise PasswordRequiredException(</span>
<span class="gi">+                    &quot;private key file is encrypted&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # Unpack salt and rounds from kdfoptions</span>
<span class="gi">+            salt, rounds = self._uint32_cstruct_unpack(kdf_options, &quot;su&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            # run bcrypt kdf to derive key and iv/nonce (32 + 16 bytes)</span>
<span class="gi">+            key_iv = bcrypt.kdf(</span>
<span class="gi">+                b(password),</span>
<span class="gi">+                b(salt),</span>
<span class="gi">+                48,</span>
<span class="gi">+                rounds,</span>
<span class="gi">+                # We can&#39;t control how many rounds are on disk, so no sense</span>
<span class="gi">+                # warning about it.</span>
<span class="gi">+                ignore_few_rounds=True,</span>
<span class="gi">+            )</span>
<span class="gi">+            key = key_iv[:32]</span>
<span class="gi">+            iv = key_iv[32:]</span>
<span class="gi">+</span>
<span class="gi">+            # decrypt private key blob</span>
<span class="gi">+            decryptor = Cipher(</span>
<span class="gi">+                algorithms.AES(key), mode(iv), default_backend()</span>
<span class="gi">+            ).decryptor()</span>
<span class="gi">+            decrypted_privkey = decryptor.update(privkey_blob)</span>
<span class="gi">+            decrypted_privkey += decryptor.finalize()</span>
<span class="gi">+        elif cipher == b(&quot;none&quot;) and kdfname == b(&quot;none&quot;):</span>
<span class="gi">+            # Unencrypted private key</span>
<span class="gi">+            decrypted_privkey = privkey_blob</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;unknown cipher or kdf used in private key file&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Unpack private key and verify checkints</span>
<span class="gi">+        cstruct = self._uint32_cstruct_unpack(decrypted_privkey, &quot;uusr&quot;)</span>
<span class="gi">+        checkint1, checkint2, keytype, keydata = cstruct</span>
<span class="gi">+</span>
<span class="gi">+        if checkint1 != checkint2:</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;OpenSSH private key file checkints do not match&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return _unpad_openssh(keydata)</span>

<span class="w"> </span>    def _uint32_cstruct_unpack(self, data, strformat):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -366,7 +696,41 @@ class PKey:</span>
<span class="w"> </span>          u - denotes a 32-bit unsigned integer
<span class="w"> </span>          r - the remainder of the input string, returned as a string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        arr = []</span>
<span class="gi">+        idx = 0</span>
<span class="gi">+        try:</span>
<span class="gi">+            for f in strformat:</span>
<span class="gi">+                if f == &quot;s&quot;:</span>
<span class="gi">+                    # string</span>
<span class="gi">+                    s_size = struct.unpack(&quot;&gt;L&quot;, data[idx : idx + 4])[0]</span>
<span class="gi">+                    idx += 4</span>
<span class="gi">+                    s = data[idx : idx + s_size]</span>
<span class="gi">+                    idx += s_size</span>
<span class="gi">+                    arr.append(s)</span>
<span class="gi">+                if f == &quot;i&quot;:</span>
<span class="gi">+                    # long integer</span>
<span class="gi">+                    s_size = struct.unpack(&quot;&gt;L&quot;, data[idx : idx + 4])[0]</span>
<span class="gi">+                    idx += 4</span>
<span class="gi">+                    s = data[idx : idx + s_size]</span>
<span class="gi">+                    idx += s_size</span>
<span class="gi">+                    i = util.inflate_long(s, True)</span>
<span class="gi">+                    arr.append(i)</span>
<span class="gi">+                elif f == &quot;u&quot;:</span>
<span class="gi">+                    # 32-bit unsigned int</span>
<span class="gi">+                    u = struct.unpack(&quot;&gt;L&quot;, data[idx : idx + 4])[0]</span>
<span class="gi">+                    idx += 4</span>
<span class="gi">+                    arr.append(u)</span>
<span class="gi">+                elif f == &quot;r&quot;:</span>
<span class="gi">+                    # remainder as string</span>
<span class="gi">+                    s = data[idx:]</span>
<span class="gi">+                    arr.append(s)</span>
<span class="gi">+                    break</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            # PKey-consuming code frequently wants to save-and-skip-over issues</span>
<span class="gi">+            # with loading keys, and uses SSHException as the (really friggin</span>
<span class="gi">+            # awful) signal for this. So for now...we do this.</span>
<span class="gi">+            raise SSHException(str(e))</span>
<span class="gi">+        return tuple(arr)</span>

<span class="w"> </span>    def _write_private_key_file(self, filename, key, format, password=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -383,7 +747,36 @@ class PKey:</span>

<span class="w"> </span>        :raises: ``IOError`` -- if there was an error writing the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Ensure that we create new key files directly with a user-only mode,</span>
<span class="gi">+        # instead of opening, writing, then chmodding, which leaves us open to</span>
<span class="gi">+        # CVE-2022-24302.</span>
<span class="gi">+        with os.fdopen(</span>
<span class="gi">+            os.open(</span>
<span class="gi">+                filename,</span>
<span class="gi">+                # NOTE: O_TRUNC is a noop on new files, and O_CREAT is a noop</span>
<span class="gi">+                # on existing files, so using all 3 in both cases is fine.</span>
<span class="gi">+                flags=os.O_WRONLY | os.O_TRUNC | os.O_CREAT,</span>
<span class="gi">+                # Ditto the use of the &#39;mode&#39; argument; it should be safe to</span>
<span class="gi">+                # give even for existing files (though it will not act like a</span>
<span class="gi">+                # chmod in that case).</span>
<span class="gi">+                mode=o600,</span>
<span class="gi">+            ),</span>
<span class="gi">+            # Yea, you still gotta inform the FLO that it is in &quot;write&quot; mode.</span>
<span class="gi">+            &quot;w&quot;,</span>
<span class="gi">+        ) as f:</span>
<span class="gi">+            self._write_private_key(f, key, format, password=password)</span>
<span class="gi">+</span>
<span class="gi">+    def _write_private_key(self, f, key, format, password=None):</span>
<span class="gi">+        if password is None:</span>
<span class="gi">+            encryption = serialization.NoEncryption()</span>
<span class="gi">+        else:</span>
<span class="gi">+            encryption = serialization.BestAvailableEncryption(b(password))</span>
<span class="gi">+</span>
<span class="gi">+        f.write(</span>
<span class="gi">+            key.private_bytes(</span>
<span class="gi">+                serialization.Encoding.PEM, format, encryption</span>
<span class="gi">+            ).decode()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _check_type_and_load_cert(self, msg, key_type, cert_type):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -396,7 +789,43 @@ class PKey:</span>
<span class="w"> </span>        The obtained key type is returned for classes which need to know what
<span class="w"> </span>        it was (e.g. ECDSA.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Normalization; most classes have a single key type and give a string,</span>
<span class="gi">+        # but eg ECDSA is a 1:N mapping.</span>
<span class="gi">+        key_types = key_type</span>
<span class="gi">+        cert_types = cert_type</span>
<span class="gi">+        if isinstance(key_type, str):</span>
<span class="gi">+            key_types = [key_types]</span>
<span class="gi">+        if isinstance(cert_types, str):</span>
<span class="gi">+            cert_types = [cert_types]</span>
<span class="gi">+        # Can&#39;t do much with no message, that should&#39;ve been handled elsewhere</span>
<span class="gi">+        if msg is None:</span>
<span class="gi">+            raise SSHException(&quot;Key object may not be empty&quot;)</span>
<span class="gi">+        # First field is always key type, in either kind of object. (make sure</span>
<span class="gi">+        # we rewind before grabbing it - sometimes caller had to do their own</span>
<span class="gi">+        # introspection first!)</span>
<span class="gi">+        msg.rewind()</span>
<span class="gi">+        type_ = msg.get_text()</span>
<span class="gi">+        # Regular public key - nothing special to do besides the implicit</span>
<span class="gi">+        # type check.</span>
<span class="gi">+        if type_ in key_types:</span>
<span class="gi">+            pass</span>
<span class="gi">+        # OpenSSH-compatible certificate - store full copy as .public_blob</span>
<span class="gi">+        # (so signing works correctly) and then fast-forward past the</span>
<span class="gi">+        # nonce.</span>
<span class="gi">+        elif type_ in cert_types:</span>
<span class="gi">+            # This seems the cleanest way to &#39;clone&#39; an already-being-read</span>
<span class="gi">+            # message; they&#39;re *IO objects at heart and their .getvalue()</span>
<span class="gi">+            # always returns the full value regardless of pointer position.</span>
<span class="gi">+            self.load_certificate(Message(msg.asbytes()))</span>
<span class="gi">+            # Read out nonce as it comes before the public numbers - our caller</span>
<span class="gi">+            # is likely going to use the (only borrowed by us, not owned)</span>
<span class="gi">+            # &#39;msg&#39; object for loading those numbers right after this.</span>
<span class="gi">+            # TODO: usefully interpret it &amp; other non-public-number fields</span>
<span class="gi">+            # (requires going back into per-type subclasses.)</span>
<span class="gi">+            msg.get_string()</span>
<span class="gi">+        else:</span>
<span class="gi">+            err = &quot;Invalid key (class: {}, data type: {}&quot;</span>
<span class="gi">+            raise SSHException(err.format(self.__class__.__name__, type_))</span>

<span class="w"> </span>    def load_certificate(self, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -417,9 +846,25 @@ class PKey:</span>
<span class="w"> </span>        that is for the server to decide if it is good enough to authenticate
<span class="w"> </span>        successfully.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+        if isinstance(value, Message):</span>
<span class="gi">+            constructor = &quot;from_message&quot;</span>
<span class="gi">+        elif os.path.isfile(value):</span>
<span class="gi">+            constructor = &quot;from_file&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            constructor = &quot;from_string&quot;</span>
<span class="gi">+        blob = getattr(PublicBlob, constructor)(value)</span>
<span class="gi">+        if not blob.key_type.startswith(self.get_name()):</span>
<span class="gi">+            err = &quot;PublicBlob type {} incompatible with key type {}&quot;</span>
<span class="gi">+            raise ValueError(err.format(blob.key_type, self.get_name()))</span>
<span class="gi">+        self.public_blob = blob</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# General construct for an OpenSSH style Public Key blob</span>
<span class="gi">+# readable from a one-line file of the format:</span>
<span class="gi">+#     &lt;key-name&gt; &lt;base64-blob&gt; [&lt;comment&gt;]</span>
<span class="gi">+# Of little value in the case of standard public keys</span>
<span class="gi">+# {ssh-rsa, ssh-dss, ssh-ecdsa, ssh-ed25519}, but should</span>
<span class="gi">+# provide rudimentary support for {*-cert.v01}</span>
<span class="w"> </span>class PublicBlob:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    OpenSSH plain public key or OpenSSH signed public key (certificate).
<span class="gu">@@ -451,14 +896,36 @@ class PublicBlob:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a public blob from a ``-cert.pub``-style file on disk.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(filename) as f:</span>
<span class="gi">+            string = f.read()</span>
<span class="gi">+        return cls.from_string(string)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_string(cls, string):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a public blob from a ``-cert.pub``-style string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fields = string.split(None, 2)</span>
<span class="gi">+        if len(fields) &lt; 2:</span>
<span class="gi">+            msg = &quot;Not enough fields for public blob: {}&quot;</span>
<span class="gi">+            raise ValueError(msg.format(fields))</span>
<span class="gi">+        key_type = fields[0]</span>
<span class="gi">+        key_blob = decodebytes(b(fields[1]))</span>
<span class="gi">+        try:</span>
<span class="gi">+            comment = fields[2].strip()</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            comment = None</span>
<span class="gi">+        # Verify that the blob message first (string) field matches the</span>
<span class="gi">+        # key_type</span>
<span class="gi">+        m = Message(key_blob)</span>
<span class="gi">+        blob_type = m.get_text()</span>
<span class="gi">+        if blob_type != key_type:</span>
<span class="gi">+            deets = &quot;key type={!r}, but blob type={!r}&quot;.format(</span>
<span class="gi">+                key_type, blob_type</span>
<span class="gi">+            )</span>
<span class="gi">+            raise ValueError(&quot;Invalid PublicBlob contents: {}&quot;.format(deets))</span>
<span class="gi">+        # All good? All good.</span>
<span class="gi">+        return cls(type_=key_type, blob=key_blob, comment=comment)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_message(cls, message):
<span class="gu">@@ -468,15 +935,17 @@ class PublicBlob:</span>
<span class="w"> </span>        Specifically, a cert-bearing pubkey auth packet, because by definition
<span class="w"> </span>        OpenSSH-style certificates &#39;are&#39; their own network representation.&quot;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        type_ = message.get_text()</span>
<span class="gi">+        return cls(type_=type_, blob=message.asbytes())</span>

<span class="w"> </span>    def __str__(self):
<span class="gd">-        ret = &#39;{} public key/certificate&#39;.format(self.key_type)</span>
<span class="gi">+        ret = &quot;{} public key/certificate&quot;.format(self.key_type)</span>
<span class="w"> </span>        if self.comment:
<span class="gd">-            ret += &#39;- {}&#39;.format(self.comment)</span>
<span class="gi">+            ret += &quot;- {}&quot;.format(self.comment)</span>
<span class="w"> </span>        return ret

<span class="w"> </span>    def __eq__(self, other):
<span class="gi">+        # Just piggyback on Message/BytesIO, since both of these should be one.</span>
<span class="w"> </span>        return self and other and self.key_blob == other.key_blob

<span class="w"> </span>    def __ne__(self, other):
<span class="gh">diff --git a/paramiko/primes.py b/paramiko/primes.py</span>
<span class="gh">index c0ded8f9..663c58ed 100644</span>
<span class="gd">--- a/paramiko/primes.py</span>
<span class="gi">+++ b/paramiko/primes.py</span>
<span class="gu">@@ -1,7 +1,27 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Utility functions for dealing with primes.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.common import byte_mask
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="gu">@@ -9,7 +29,24 @@ from paramiko.ssh_exception import SSHException</span>

<span class="w"> </span>def _roll_random(n):
<span class="w"> </span>    &quot;&quot;&quot;returns a random # from 0 to N-1&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bits = util.bit_length(n - 1)</span>
<span class="gi">+    byte_count = (bits + 7) // 8</span>
<span class="gi">+    hbyte_mask = pow(2, bits % 8) - 1</span>
<span class="gi">+</span>
<span class="gi">+    # so here&#39;s the plan:</span>
<span class="gi">+    # we fetch as many random bits as we&#39;d need to fit N-1, and if the</span>
<span class="gi">+    # generated number is &gt;= N, we try again.  in the worst case (N-1 is a</span>
<span class="gi">+    # power of 2), we have slightly better than 50% odds of getting one that</span>
<span class="gi">+    # fits, so i can&#39;t guarantee that this loop will ever finish, but the odds</span>
<span class="gi">+    # of it looping forever should be infinitesimal.</span>
<span class="gi">+    while True:</span>
<span class="gi">+        x = os.urandom(byte_count)</span>
<span class="gi">+        if hbyte_mask &gt; 0:</span>
<span class="gi">+            x = byte_mask(x[0], hbyte_mask) + x[1:]</span>
<span class="gi">+        num = util.inflate_long(x, 1)</span>
<span class="gi">+        if num &lt; n:</span>
<span class="gi">+            break</span>
<span class="gi">+    return num</span>


<span class="w"> </span>class ModulusPack:
<span class="gu">@@ -19,11 +56,93 @@ class ModulusPack:</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self):
<span class="gi">+        # pack is a hash of: bits -&gt; [ (generator, modulus) ... ]</span>
<span class="w"> </span>        self.pack = {}
<span class="w"> </span>        self.discarded = []

<span class="gi">+    def _parse_modulus(self, line):</span>
<span class="gi">+        (</span>
<span class="gi">+            timestamp,</span>
<span class="gi">+            mod_type,</span>
<span class="gi">+            tests,</span>
<span class="gi">+            tries,</span>
<span class="gi">+            size,</span>
<span class="gi">+            generator,</span>
<span class="gi">+            modulus,</span>
<span class="gi">+        ) = line.split()</span>
<span class="gi">+        mod_type = int(mod_type)</span>
<span class="gi">+        tests = int(tests)</span>
<span class="gi">+        tries = int(tries)</span>
<span class="gi">+        size = int(size)</span>
<span class="gi">+        generator = int(generator)</span>
<span class="gi">+        modulus = int(modulus, 16)</span>
<span class="gi">+</span>
<span class="gi">+        # weed out primes that aren&#39;t at least:</span>
<span class="gi">+        # type 2 (meets basic structural requirements)</span>
<span class="gi">+        # test 4 (more than just a small-prime sieve)</span>
<span class="gi">+        # tries &lt; 100 if test &amp; 4 (at least 100 tries of miller-rabin)</span>
<span class="gi">+        if (</span>
<span class="gi">+            mod_type &lt; 2</span>
<span class="gi">+            or tests &lt; 4</span>
<span class="gi">+            or (tests &amp; 4 and tests &lt; 8 and tries &lt; 100)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.discarded.append(</span>
<span class="gi">+                (modulus, &quot;does not meet basic requirements&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        if generator == 0:</span>
<span class="gi">+            generator = 2</span>
<span class="gi">+</span>
<span class="gi">+        # there&#39;s a bug in the ssh &quot;moduli&quot; file (yeah, i know: shock! dismay!</span>
<span class="gi">+        # call cnn!) where it understates the bit lengths of these primes by 1.</span>
<span class="gi">+        # this is okay.</span>
<span class="gi">+        bl = util.bit_length(modulus)</span>
<span class="gi">+        if (bl != size) and (bl != size + 1):</span>
<span class="gi">+            self.discarded.append(</span>
<span class="gi">+                (modulus, &quot;incorrectly reported bit length {}&quot;.format(size))</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        if bl not in self.pack:</span>
<span class="gi">+            self.pack[bl] = []</span>
<span class="gi">+        self.pack[bl].append((generator, modulus))</span>
<span class="gi">+</span>
<span class="w"> </span>    def read_file(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :raises IOError: passed from any file operations that fail.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.pack = {}</span>
<span class="gi">+        with open(filename, &quot;r&quot;) as f:</span>
<span class="gi">+            for line in f:</span>
<span class="gi">+                line = line.strip()</span>
<span class="gi">+                if (len(line) == 0) or (line[0] == &quot;#&quot;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._parse_modulus(line)</span>
<span class="gi">+                except:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+    def get_modulus(self, min, prefer, max):</span>
<span class="gi">+        bitsizes = sorted(self.pack.keys())</span>
<span class="gi">+        if len(bitsizes) == 0:</span>
<span class="gi">+            raise SSHException(&quot;no moduli available&quot;)</span>
<span class="gi">+        good = -1</span>
<span class="gi">+        # find nearest bitsize &gt;= preferred</span>
<span class="gi">+        for b in bitsizes:</span>
<span class="gi">+            if (b &gt;= prefer) and (b &lt;= max) and (b &lt; good or good == -1):</span>
<span class="gi">+                good = b</span>
<span class="gi">+        # if that failed, find greatest bitsize &gt;= min</span>
<span class="gi">+        if good == -1:</span>
<span class="gi">+            for b in bitsizes:</span>
<span class="gi">+                if (b &gt;= min) and (b &lt;= max) and (b &gt; good):</span>
<span class="gi">+                    good = b</span>
<span class="gi">+        if good == -1:</span>
<span class="gi">+            # their entire (min, max) range has no intersection with our range.</span>
<span class="gi">+            # if their range is below ours, pick the smallest.  otherwise pick</span>
<span class="gi">+            # the largest.  it&#39;ll be out of their range requirement either way,</span>
<span class="gi">+            # but we&#39;ll be sending them the closest one we have.</span>
<span class="gi">+            good = bitsizes[0]</span>
<span class="gi">+            if min &gt; good:</span>
<span class="gi">+                good = bitsizes[-1]</span>
<span class="gi">+        # now pick a random modulus of this bitsize</span>
<span class="gi">+        n = _roll_random(len(self.pack[good]))</span>
<span class="gi">+        return self.pack[good][n]</span>
<span class="gh">diff --git a/paramiko/proxy.py b/paramiko/proxy.py</span>
<span class="gh">index 2d1ebe34..f7609c98 100644</span>
<span class="gd">--- a/paramiko/proxy.py</span>
<span class="gi">+++ b/paramiko/proxy.py</span>
<span class="gu">@@ -1,14 +1,37 @@</span>
<span class="gi">+# Copyright (C) 2012  Yipit, Inc &lt;coders@yipit.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import shlex
<span class="w"> </span>import signal
<span class="w"> </span>from select import select
<span class="w"> </span>import socket
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="gi">+# Try-and-ignore import so platforms w/o subprocess (eg Google App Engine) can</span>
<span class="gi">+# still import paramiko.</span>
<span class="w"> </span>subprocess, subprocess_import_error = None, None
<span class="w"> </span>try:
<span class="w"> </span>    import subprocess
<span class="w"> </span>except ImportError as e:
<span class="w"> </span>    subprocess_import_error = e
<span class="gi">+</span>
<span class="w"> </span>from paramiko.ssh_exception import ProxyCommandFailure
<span class="w"> </span>from paramiko.util import ClosingContextManager

<span class="gu">@@ -36,8 +59,13 @@ class ProxyCommand(ClosingContextManager):</span>
<span class="w"> </span>        if subprocess is None:
<span class="w"> </span>            raise subprocess_import_error
<span class="w"> </span>        self.cmd = shlex.split(command_line)
<span class="gd">-        self.process = subprocess.Popen(self.cmd, stdin=subprocess.PIPE,</span>
<span class="gd">-            stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=0)</span>
<span class="gi">+        self.process = subprocess.Popen(</span>
<span class="gi">+            self.cmd,</span>
<span class="gi">+            stdin=subprocess.PIPE,</span>
<span class="gi">+            stdout=subprocess.PIPE,</span>
<span class="gi">+            stderr=subprocess.PIPE,</span>
<span class="gi">+            bufsize=0,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.timeout = None

<span class="w"> </span>    def send(self, content):
<span class="gu">@@ -47,7 +75,15 @@ class ProxyCommand(ClosingContextManager):</span>

<span class="w"> </span>        :param str content: string to be sent to the forked command
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.process.stdin.write(content)</span>
<span class="gi">+        except IOError as e:</span>
<span class="gi">+            # There was a problem with the child process. It probably</span>
<span class="gi">+            # died and we can&#39;t proceed. The best option here is to</span>
<span class="gi">+            # raise an exception informing the user that the informed</span>
<span class="gi">+            # ProxyCommand is not working.</span>
<span class="gi">+            raise ProxyCommandFailure(&quot; &quot;.join(self.cmd), e.strerror)</span>
<span class="gi">+        return len(content)</span>

<span class="w"> </span>    def recv(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -57,4 +93,42 @@ class ProxyCommand(ClosingContextManager):</span>

<span class="w"> </span>        :return: the string of bytes read, which may be shorter than requested
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            buffer = b&quot;&quot;</span>
<span class="gi">+            start = time.time()</span>
<span class="gi">+            while len(buffer) &lt; size:</span>
<span class="gi">+                select_timeout = None</span>
<span class="gi">+                if self.timeout is not None:</span>
<span class="gi">+                    elapsed = time.time() - start</span>
<span class="gi">+                    if elapsed &gt;= self.timeout:</span>
<span class="gi">+                        raise socket.timeout()</span>
<span class="gi">+                    select_timeout = self.timeout - elapsed</span>
<span class="gi">+</span>
<span class="gi">+                r, w, x = select([self.process.stdout], [], [], select_timeout)</span>
<span class="gi">+                if r and r[0] == self.process.stdout:</span>
<span class="gi">+                    buffer += os.read(</span>
<span class="gi">+                        self.process.stdout.fileno(), size - len(buffer)</span>
<span class="gi">+                    )</span>
<span class="gi">+            return buffer</span>
<span class="gi">+        except socket.timeout:</span>
<span class="gi">+            if buffer:</span>
<span class="gi">+                # Don&#39;t raise socket.timeout, return partial result instead</span>
<span class="gi">+                return buffer</span>
<span class="gi">+            raise  # socket.timeout is a subclass of IOError</span>
<span class="gi">+        except IOError as e:</span>
<span class="gi">+            raise ProxyCommandFailure(&quot; &quot;.join(self.cmd), e.strerror)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        os.kill(self.process.pid, signal.SIGTERM)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def closed(self):</span>
<span class="gi">+        return self.process.returncode is not None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _closed(self):</span>
<span class="gi">+        # Concession to Python 3 socket-like API</span>
<span class="gi">+        return self.closed</span>
<span class="gi">+</span>
<span class="gi">+    def settimeout(self, timeout):</span>
<span class="gi">+        self.timeout = timeout</span>
<span class="gh">diff --git a/paramiko/rsakey.py b/paramiko/rsakey.py</span>
<span class="gh">index 5e60a19c..b7ad3ce2 100644</span>
<span class="gd">--- a/paramiko/rsakey.py</span>
<span class="gi">+++ b/paramiko/rsakey.py</span>
<span class="gu">@@ -1,10 +1,30 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>RSA keys.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives import hashes, serialization
<span class="w"> </span>from cryptography.hazmat.primitives.asymmetric import rsa, padding
<span class="gi">+</span>
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.pkey import PKey
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="gu">@@ -15,14 +35,26 @@ class RSAKey(PKey):</span>
<span class="w"> </span>    Representation of an RSA key which can be used to sign and verify SSH2
<span class="w"> </span>    data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;ssh-rsa&#39;</span>
<span class="gd">-    HASHES = {&#39;ssh-rsa&#39;: hashes.SHA1, &#39;ssh-rsa-cert-v01@openssh.com&#39;:</span>
<span class="gd">-        hashes.SHA1, &#39;rsa-sha2-256&#39;: hashes.SHA256,</span>
<span class="gd">-        &#39;rsa-sha2-256-cert-v01@openssh.com&#39;: hashes.SHA256, &#39;rsa-sha2-512&#39;:</span>
<span class="gd">-        hashes.SHA512, &#39;rsa-sha2-512-cert-v01@openssh.com&#39;: hashes.SHA512}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, msg=None, data=None, filename=None, password=None,</span>
<span class="gd">-        key=None, file_obj=None):</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;ssh-rsa&quot;</span>
<span class="gi">+    HASHES = {</span>
<span class="gi">+        &quot;ssh-rsa&quot;: hashes.SHA1,</span>
<span class="gi">+        &quot;ssh-rsa-cert-v01@openssh.com&quot;: hashes.SHA1,</span>
<span class="gi">+        &quot;rsa-sha2-256&quot;: hashes.SHA256,</span>
<span class="gi">+        &quot;rsa-sha2-256-cert-v01@openssh.com&quot;: hashes.SHA256,</span>
<span class="gi">+        &quot;rsa-sha2-512&quot;: hashes.SHA512,</span>
<span class="gi">+        &quot;rsa-sha2-512-cert-v01@openssh.com&quot;: hashes.SHA512,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg=None,</span>
<span class="gi">+        data=None,</span>
<span class="gi">+        filename=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        key=None,</span>
<span class="gi">+        file_obj=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.key = None
<span class="w"> </span>        self.public_blob = None
<span class="w"> </span>        if file_obj is not None:
<span class="gu">@@ -31,18 +63,117 @@ class RSAKey(PKey):</span>
<span class="w"> </span>        if filename is not None:
<span class="w"> </span>            self._from_private_key_file(filename, password)
<span class="w"> </span>            return
<span class="gd">-        if msg is None and data is not None:</span>
<span class="gi">+        if (msg is None) and (data is not None):</span>
<span class="w"> </span>            msg = Message(data)
<span class="w"> </span>        if key is not None:
<span class="w"> </span>            self.key = key
<span class="w"> </span>        else:
<span class="gd">-            self._check_type_and_load_cert(msg=msg, key_type=self.name,</span>
<span class="gd">-                cert_type=&#39;ssh-rsa-cert-v01@openssh.com&#39;)</span>
<span class="gd">-            self.key = rsa.RSAPublicNumbers(e=msg.get_mpint(), n=msg.</span>
<span class="gd">-                get_mpint()).public_key(default_backend())</span>
<span class="gi">+            self._check_type_and_load_cert(</span>
<span class="gi">+                msg=msg,</span>
<span class="gi">+                # NOTE: this does NOT change when using rsa2 signatures; it&#39;s</span>
<span class="gi">+                # purely about key loading, not exchange or verification</span>
<span class="gi">+                key_type=self.name,</span>
<span class="gi">+                cert_type=&quot;ssh-rsa-cert-v01@openssh.com&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.key = rsa.RSAPublicNumbers(</span>
<span class="gi">+                e=msg.get_mpint(), n=msg.get_mpint()</span>
<span class="gi">+            ).public_key(default_backend())</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def identifiers(cls):</span>
<span class="gi">+        return list(cls.HASHES.keys())</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def size(self):</span>
<span class="gi">+        return self.key.key_size</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def public_numbers(self):</span>
<span class="gi">+        if isinstance(self.key, rsa.RSAPrivateKey):</span>
<span class="gi">+            return self.key.private_numbers().public_numbers</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.key.public_numbers()</span>
<span class="gi">+</span>
<span class="gi">+    def asbytes(self):</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_string(self.name)</span>
<span class="gi">+        m.add_mpint(self.public_numbers.e)</span>
<span class="gi">+        m.add_mpint(self.public_numbers.n)</span>
<span class="gi">+        return m.asbytes()</span>

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return self.asbytes().decode(&#39;utf8&#39;, errors=&#39;ignore&#39;)</span>
<span class="gi">+        # NOTE: see #853 to explain some legacy behavior.</span>
<span class="gi">+        # TODO 4.0: replace with a nice clean fingerprint display or something</span>
<span class="gi">+        return self.asbytes().decode(&quot;utf8&quot;, errors=&quot;ignore&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _fields(self):</span>
<span class="gi">+        return (self.get_name(), self.public_numbers.e, self.public_numbers.n)</span>
<span class="gi">+</span>
<span class="gi">+    def get_name(self):</span>
<span class="gi">+        return self.name</span>
<span class="gi">+</span>
<span class="gi">+    def get_bits(self):</span>
<span class="gi">+        return self.size</span>
<span class="gi">+</span>
<span class="gi">+    def can_sign(self):</span>
<span class="gi">+        return isinstance(self.key, rsa.RSAPrivateKey)</span>
<span class="gi">+</span>
<span class="gi">+    def sign_ssh_data(self, data, algorithm=None):</span>
<span class="gi">+        if algorithm is None:</span>
<span class="gi">+            algorithm = self.name</span>
<span class="gi">+        sig = self.key.sign(</span>
<span class="gi">+            data,</span>
<span class="gi">+            padding=padding.PKCS1v15(),</span>
<span class="gi">+            # HASHES being just a map from long identifier to either SHA1 or</span>
<span class="gi">+            # SHA256 - cert&#39;ness is not truly relevant.</span>
<span class="gi">+            algorithm=self.HASHES[algorithm](),</span>
<span class="gi">+        )</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        # And here again, cert&#39;ness is irrelevant, so it is stripped out.</span>
<span class="gi">+        m.add_string(algorithm.replace(&quot;-cert-v01@openssh.com&quot;, &quot;&quot;))</span>
<span class="gi">+        m.add_string(sig)</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>
<span class="gi">+    def verify_ssh_sig(self, data, msg):</span>
<span class="gi">+        sig_algorithm = msg.get_text()</span>
<span class="gi">+        if sig_algorithm not in self.HASHES:</span>
<span class="gi">+            return False</span>
<span class="gi">+        key = self.key</span>
<span class="gi">+        if isinstance(key, rsa.RSAPrivateKey):</span>
<span class="gi">+            key = key.public_key()</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: pad received signature with leading zeros, key.verify()</span>
<span class="gi">+        # expects a signature of key size (e.g. PuTTY doesn&#39;t pad)</span>
<span class="gi">+        sign = msg.get_binary()</span>
<span class="gi">+        diff = key.key_size - len(sign) * 8</span>
<span class="gi">+        if diff &gt; 0:</span>
<span class="gi">+            sign = b&quot;\x00&quot; * ((diff + 7) // 8) + sign</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            key.verify(</span>
<span class="gi">+                sign, data, padding.PKCS1v15(), self.HASHES[sig_algorithm]()</span>
<span class="gi">+            )</span>
<span class="gi">+        except InvalidSignature:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    def write_private_key_file(self, filename, password=None):</span>
<span class="gi">+        self._write_private_key_file(</span>
<span class="gi">+            filename,</span>
<span class="gi">+            self.key,</span>
<span class="gi">+            serialization.PrivateFormat.TraditionalOpenSSL,</span>
<span class="gi">+            password=password,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def write_private_key(self, file_obj, password=None):</span>
<span class="gi">+        self._write_private_key(</span>
<span class="gi">+            file_obj,</span>
<span class="gi">+            self.key,</span>
<span class="gi">+            serialization.PrivateFormat.TraditionalOpenSSL,</span>
<span class="gi">+            password=password,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def generate(bits, progress_func=None):
<span class="gu">@@ -54,4 +185,43 @@ class RSAKey(PKey):</span>
<span class="w"> </span>        :param progress_func: Unused
<span class="w"> </span>        :return: new `.RSAKey` private key
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key = rsa.generate_private_key(</span>
<span class="gi">+            public_exponent=65537, key_size=bits, backend=default_backend()</span>
<span class="gi">+        )</span>
<span class="gi">+        return RSAKey(key=key)</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _from_private_key_file(self, filename, password):</span>
<span class="gi">+        data = self._read_private_key_file(&quot;RSA&quot;, filename, password)</span>
<span class="gi">+        self._decode_key(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _from_private_key(self, file_obj, password):</span>
<span class="gi">+        data = self._read_private_key(&quot;RSA&quot;, file_obj, password)</span>
<span class="gi">+        self._decode_key(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _decode_key(self, data):</span>
<span class="gi">+        pkformat, data = data</span>
<span class="gi">+        if pkformat == self._PRIVATE_KEY_FORMAT_ORIGINAL:</span>
<span class="gi">+            try:</span>
<span class="gi">+                key = serialization.load_der_private_key(</span>
<span class="gi">+                    data, password=None, backend=default_backend()</span>
<span class="gi">+                )</span>
<span class="gi">+            except (ValueError, TypeError, UnsupportedAlgorithm) as e:</span>
<span class="gi">+                raise SSHException(str(e))</span>
<span class="gi">+        elif pkformat == self._PRIVATE_KEY_FORMAT_OPENSSH:</span>
<span class="gi">+            n, e, d, iqmp, p, q = self._uint32_cstruct_unpack(data, &quot;iiiiii&quot;)</span>
<span class="gi">+            public_numbers = rsa.RSAPublicNumbers(e=e, n=n)</span>
<span class="gi">+            key = rsa.RSAPrivateNumbers(</span>
<span class="gi">+                p=p,</span>
<span class="gi">+                q=q,</span>
<span class="gi">+                d=d,</span>
<span class="gi">+                dmp1=d % (p - 1),</span>
<span class="gi">+                dmq1=d % (q - 1),</span>
<span class="gi">+                iqmp=iqmp,</span>
<span class="gi">+                public_numbers=public_numbers,</span>
<span class="gi">+            ).private_key(default_backend())</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._got_bad_key_format_id(pkformat)</span>
<span class="gi">+        assert isinstance(key, rsa.RSAPrivateKey)</span>
<span class="gi">+        self.key = key</span>
<span class="gh">diff --git a/paramiko/server.py b/paramiko/server.py</span>
<span class="gh">index dc283021..6923bdf5 100644</span>
<span class="gd">--- a/paramiko/server.py</span>
<span class="gi">+++ b/paramiko/server.py</span>
<span class="gu">@@ -1,9 +1,34 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>`.ServerInterface` is an interface to override for server support.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import threading
<span class="w"> </span>from paramiko import util
<span class="gd">-from paramiko.common import DEBUG, ERROR, OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED, AUTH_FAILED, AUTH_SUCCESSFUL</span>
<span class="gi">+from paramiko.common import (</span>
<span class="gi">+    DEBUG,</span>
<span class="gi">+    ERROR,</span>
<span class="gi">+    OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED,</span>
<span class="gi">+    AUTH_FAILED,</span>
<span class="gi">+    AUTH_SUCCESSFUL,</span>
<span class="gi">+)</span>


<span class="w"> </span>class ServerInterface:
<span class="gu">@@ -59,7 +84,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :param int chanid: ID of the channel
<span class="w"> </span>        :return: an `int` success or failure code (listed above)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</span>

<span class="w"> </span>    def get_allowed_auths(self, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -76,7 +101,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :param str username: the username requesting authentication.
<span class="w"> </span>        :return: a comma-separated `str` of authentication types
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;password&quot;</span>

<span class="w"> </span>    def check_auth_none(self, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -95,7 +120,7 @@ class ServerInterface:</span>
<span class="w"> </span>            it succeeds.
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_password(self, username, password):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -120,7 +145,7 @@ class ServerInterface:</span>
<span class="w"> </span>            successful, but authentication must continue.
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_publickey(self, username, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -152,7 +177,7 @@ class ServerInterface:</span>
<span class="w"> </span>            authentication
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_interactive(self, username, submethods):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -177,7 +202,7 @@ class ServerInterface:</span>
<span class="w"> </span>            object containing queries for the user
<span class="w"> </span>        :rtype: int or `.InteractiveQuery`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_interactive_response(self, responses):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -208,10 +233,11 @@ class ServerInterface:</span>
<span class="w"> </span>            object containing queries for the user
<span class="w"> </span>        :rtype: int or `.InteractiveQuery`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="gd">-    def check_auth_gssapi_with_mic(self, username, gss_authenticated=</span>
<span class="gd">-        AUTH_FAILED, cc_file=None):</span>
<span class="gi">+    def check_auth_gssapi_with_mic(</span>
<span class="gi">+        self, username, gss_authenticated=AUTH_FAILED, cc_file=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Authenticate the given user to the server if he is a valid krb5
<span class="w"> </span>        principal.
<span class="gu">@@ -235,10 +261,13 @@ class ServerInterface:</span>
<span class="w"> </span>                 log in as a user.
<span class="w"> </span>        :see: http://www.unix.com/man-page/all/3/krb5_kuserok/
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if gss_authenticated == AUTH_SUCCESSFUL:</span>
<span class="gi">+            return AUTH_SUCCESSFUL</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="gd">-    def check_auth_gssapi_keyex(self, username, gss_authenticated=</span>
<span class="gd">-        AUTH_FAILED, cc_file=None):</span>
<span class="gi">+    def check_auth_gssapi_keyex(</span>
<span class="gi">+        self, username, gss_authenticated=AUTH_FAILED, cc_file=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Authenticate the given user to the server if he is a valid krb5
<span class="w"> </span>        principal and GSS-API Key Exchange was performed.
<span class="gu">@@ -264,7 +293,9 @@ class ServerInterface:</span>
<span class="w"> </span>                 to log in as a user.
<span class="w"> </span>        :see: http://www.unix.com/man-page/all/3/krb5_kuserok/
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if gss_authenticated == AUTH_SUCCESSFUL:</span>
<span class="gi">+            return AUTH_SUCCESSFUL</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def enable_auth_gssapi(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -275,7 +306,8 @@ class ServerInterface:</span>
<span class="w"> </span>        :returns bool: Whether GSSAPI authentication is enabled.
<span class="w"> </span>        :see: `.ssh_gss`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        UseGSSAPI = False</span>
<span class="gi">+        return UseGSSAPI</span>

<span class="w"> </span>    def check_port_forward_request(self, address, port):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -296,7 +328,7 @@ class ServerInterface:</span>
<span class="w"> </span>            the port number (`int`) that was opened for listening, or ``False``
<span class="w"> </span>            to reject
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def cancel_port_forward_request(self, address, port):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -337,10 +369,13 @@ class ServerInterface:</span>
<span class="w"> </span>            ``True`` or a `tuple` of data if the request was granted; ``False``
<span class="w"> </span>            otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="gd">-    def check_channel_pty_request(self, channel, term, width, height,</span>
<span class="gd">-        pixelwidth, pixelheight, modes):</span>
<span class="gi">+    # ...Channel requests...</span>
<span class="gi">+</span>
<span class="gi">+    def check_channel_pty_request(</span>
<span class="gi">+        self, channel, term, width, height, pixelwidth, pixelheight, modes</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Determine if a pseudo-terminal of the given dimensions (usually
<span class="w"> </span>        requested for shell access) can be provided on the given channel.
<span class="gu">@@ -359,7 +394,7 @@ class ServerInterface:</span>
<span class="w"> </span>            ``True`` if the pseudo-terminal has been allocated; ``False``
<span class="w"> </span>            otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_shell_request(self, channel):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -375,7 +410,7 @@ class ServerInterface:</span>
<span class="w"> </span>            ``True`` if this channel is now hooked up to a shell; ``False`` if
<span class="w"> </span>            a shell can&#39;t or won&#39;t be provided.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_exec_request(self, channel, command):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -394,7 +429,7 @@ class ServerInterface:</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_subsystem_request(self, channel, name):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -418,10 +453,17 @@ class ServerInterface:</span>
<span class="w"> </span>            ``True`` if this channel is now hooked up to the requested
<span class="w"> </span>            subsystem; ``False`` if that subsystem can&#39;t or won&#39;t be provided.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        transport = channel.get_transport()</span>
<span class="gi">+        handler_class, args, kwargs = transport._get_subsystem_handler(name)</span>
<span class="gi">+        if handler_class is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        handler = handler_class(channel, name, self, *args, **kwargs)</span>
<span class="gi">+        handler.start()</span>
<span class="gi">+        return True</span>

<span class="gd">-    def check_channel_window_change_request(self, channel, width, height,</span>
<span class="gd">-        pixelwidth, pixelheight):</span>
<span class="gi">+    def check_channel_window_change_request(</span>
<span class="gi">+        self, channel, width, height, pixelwidth, pixelheight</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Determine if the pseudo-terminal on the given channel can be resized.
<span class="w"> </span>        This only makes sense if a pty was previously allocated on it.
<span class="gu">@@ -437,10 +479,16 @@ class ServerInterface:</span>
<span class="w"> </span>            height of screen in pixels, if known (may be ``0`` if unknown).
<span class="w"> </span>        :return: ``True`` if the terminal was resized; ``False`` if not.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="gd">-    def check_channel_x11_request(self, channel, single_connection,</span>
<span class="gd">-        auth_protocol, auth_cookie, screen_number):</span>
<span class="gi">+    def check_channel_x11_request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        channel,</span>
<span class="gi">+        single_connection,</span>
<span class="gi">+        auth_protocol,</span>
<span class="gi">+        auth_cookie,</span>
<span class="gi">+        screen_number,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Determine if the client will be provided with an X11 session.  If this
<span class="w"> </span>        method returns ``True``, X11 applications should be routed through new
<span class="gu">@@ -457,7 +505,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :param int screen_number: the number of the X11 screen to connect to
<span class="w"> </span>        :return: ``True`` if the X11 session was opened; ``False`` if not
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_forward_agent_request(self, channel):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -473,7 +521,7 @@ class ServerInterface:</span>
<span class="w"> </span>        If ``True`` is returned, the server should create an
<span class="w"> </span>        :class:`AgentServerProxy` to access the agent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_direct_tcpip_request(self, chanid, origin, destination):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -513,7 +561,7 @@ class ServerInterface:</span>
<span class="w"> </span>            (server side)
<span class="w"> </span>        :return: an `int` success or failure code (listed above)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</span>

<span class="w"> </span>    def check_channel_env_request(self, channel, name, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -531,7 +579,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :param str value: Channel value
<span class="w"> </span>        :returns: A boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def get_banner(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -545,7 +593,7 @@ class ServerInterface:</span>

<span class="w"> </span>        .. versionadded:: 2.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (None, None)</span>


<span class="w"> </span>class InteractiveQuery:
<span class="gu">@@ -553,7 +601,7 @@ class InteractiveQuery:</span>
<span class="w"> </span>    A query (set of prompts) for a user during interactive authentication.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, name=&#39;&#39;, instructions=&#39;&#39;, *prompts):</span>
<span class="gi">+    def __init__(self, name=&quot;&quot;, instructions=&quot;&quot;, *prompts):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new interactive query to send to the client.  The name and
<span class="w"> </span>        instructions are optional, but are generally displayed to the end
<span class="gu">@@ -584,7 +632,7 @@ class InteractiveQuery:</span>
<span class="w"> </span>            ``True`` (default) if the user&#39;s response should be echoed;
<span class="w"> </span>            ``False`` if not (for a password or similar)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.prompts.append((prompt, echo))</span>


<span class="w"> </span>class SubsystemHandler(threading.Thread):
<span class="gu">@@ -627,7 +675,26 @@ class SubsystemHandler(threading.Thread):</span>
<span class="w"> </span>        Return the `.ServerInterface` object associated with this channel and
<span class="w"> </span>        subsystem.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__server</span>
<span class="gi">+</span>
<span class="gi">+    def _run(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.__transport._log(</span>
<span class="gi">+                DEBUG, &quot;Starting handler for subsystem {}&quot;.format(self.__name)</span>
<span class="gi">+            )</span>
<span class="gi">+            self.start_subsystem(self.__name, self.__transport, self.__channel)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            self.__transport._log(</span>
<span class="gi">+                ERROR,</span>
<span class="gi">+                &#39;Exception in subsystem handler for &quot;{}&quot;: {}&#39;.format(</span>
<span class="gi">+                    self.__name, e</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+            self.__transport._log(ERROR, util.tb_strings())</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.finish_subsystem()</span>
<span class="gi">+        except:</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def start_subsystem(self, name, transport, channel):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -662,4 +729,4 @@ class SubsystemHandler(threading.Thread):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__channel.close()</span>
<span class="gh">diff --git a/paramiko/sftp.py b/paramiko/sftp.py</span>
<span class="gh">index 65109f59..b3528d4e 100644</span>
<span class="gd">--- a/paramiko/sftp.py</span>
<span class="gi">+++ b/paramiko/sftp.py</span>
<span class="gu">@@ -1,40 +1,127 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>import select
<span class="w"> </span>import socket
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.common import DEBUG, byte_chr, byte_ord
<span class="w"> </span>from paramiko.message import Message
<span class="gd">-(CMD_INIT, CMD_VERSION, CMD_OPEN, CMD_CLOSE, CMD_READ, CMD_WRITE, CMD_LSTAT,</span>
<span class="gd">-    CMD_FSTAT, CMD_SETSTAT, CMD_FSETSTAT, CMD_OPENDIR, CMD_READDIR,</span>
<span class="gd">-    CMD_REMOVE, CMD_MKDIR, CMD_RMDIR, CMD_REALPATH, CMD_STAT, CMD_RENAME,</span>
<span class="gd">-    CMD_READLINK, CMD_SYMLINK) = range(1, 21)</span>
<span class="gd">-CMD_STATUS, CMD_HANDLE, CMD_DATA, CMD_NAME, CMD_ATTRS = range(101, 106)</span>
<span class="gd">-CMD_EXTENDED, CMD_EXTENDED_REPLY = range(200, 202)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+(</span>
<span class="gi">+    CMD_INIT,</span>
<span class="gi">+    CMD_VERSION,</span>
<span class="gi">+    CMD_OPEN,</span>
<span class="gi">+    CMD_CLOSE,</span>
<span class="gi">+    CMD_READ,</span>
<span class="gi">+    CMD_WRITE,</span>
<span class="gi">+    CMD_LSTAT,</span>
<span class="gi">+    CMD_FSTAT,</span>
<span class="gi">+    CMD_SETSTAT,</span>
<span class="gi">+    CMD_FSETSTAT,</span>
<span class="gi">+    CMD_OPENDIR,</span>
<span class="gi">+    CMD_READDIR,</span>
<span class="gi">+    CMD_REMOVE,</span>
<span class="gi">+    CMD_MKDIR,</span>
<span class="gi">+    CMD_RMDIR,</span>
<span class="gi">+    CMD_REALPATH,</span>
<span class="gi">+    CMD_STAT,</span>
<span class="gi">+    CMD_RENAME,</span>
<span class="gi">+    CMD_READLINK,</span>
<span class="gi">+    CMD_SYMLINK,</span>
<span class="gi">+) = range(1, 21)</span>
<span class="gi">+(CMD_STATUS, CMD_HANDLE, CMD_DATA, CMD_NAME, CMD_ATTRS) = range(101, 106)</span>
<span class="gi">+(CMD_EXTENDED, CMD_EXTENDED_REPLY) = range(200, 202)</span>
<span class="gi">+</span>
<span class="w"> </span>SFTP_OK = 0
<span class="gd">-(SFTP_EOF, SFTP_NO_SUCH_FILE, SFTP_PERMISSION_DENIED, SFTP_FAILURE,</span>
<span class="gd">-    SFTP_BAD_MESSAGE, SFTP_NO_CONNECTION, SFTP_CONNECTION_LOST,</span>
<span class="gd">-    SFTP_OP_UNSUPPORTED) = range(1, 9)</span>
<span class="gd">-SFTP_DESC = [&#39;Success&#39;, &#39;End of file&#39;, &#39;No such file&#39;, &#39;Permission denied&#39;,</span>
<span class="gd">-    &#39;Failure&#39;, &#39;Bad message&#39;, &#39;No connection&#39;, &#39;Connection lost&#39;,</span>
<span class="gd">-    &#39;Operation unsupported&#39;]</span>
<span class="gd">-SFTP_FLAG_READ = 1</span>
<span class="gd">-SFTP_FLAG_WRITE = 2</span>
<span class="gd">-SFTP_FLAG_APPEND = 4</span>
<span class="gd">-SFTP_FLAG_CREATE = 8</span>
<span class="gd">-SFTP_FLAG_TRUNC = 16</span>
<span class="gd">-SFTP_FLAG_EXCL = 32</span>
<span class="gi">+(</span>
<span class="gi">+    SFTP_EOF,</span>
<span class="gi">+    SFTP_NO_SUCH_FILE,</span>
<span class="gi">+    SFTP_PERMISSION_DENIED,</span>
<span class="gi">+    SFTP_FAILURE,</span>
<span class="gi">+    SFTP_BAD_MESSAGE,</span>
<span class="gi">+    SFTP_NO_CONNECTION,</span>
<span class="gi">+    SFTP_CONNECTION_LOST,</span>
<span class="gi">+    SFTP_OP_UNSUPPORTED,</span>
<span class="gi">+) = range(1, 9)</span>
<span class="gi">+</span>
<span class="gi">+SFTP_DESC = [</span>
<span class="gi">+    &quot;Success&quot;,</span>
<span class="gi">+    &quot;End of file&quot;,</span>
<span class="gi">+    &quot;No such file&quot;,</span>
<span class="gi">+    &quot;Permission denied&quot;,</span>
<span class="gi">+    &quot;Failure&quot;,</span>
<span class="gi">+    &quot;Bad message&quot;,</span>
<span class="gi">+    &quot;No connection&quot;,</span>
<span class="gi">+    &quot;Connection lost&quot;,</span>
<span class="gi">+    &quot;Operation unsupported&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+SFTP_FLAG_READ = 0x1</span>
<span class="gi">+SFTP_FLAG_WRITE = 0x2</span>
<span class="gi">+SFTP_FLAG_APPEND = 0x4</span>
<span class="gi">+SFTP_FLAG_CREATE = 0x8</span>
<span class="gi">+SFTP_FLAG_TRUNC = 0x10</span>
<span class="gi">+SFTP_FLAG_EXCL = 0x20</span>
<span class="gi">+</span>
<span class="w"> </span>_VERSION = 3
<span class="gd">-CMD_NAMES = {CMD_INIT: &#39;init&#39;, CMD_VERSION: &#39;version&#39;, CMD_OPEN: &#39;open&#39;,</span>
<span class="gd">-    CMD_CLOSE: &#39;close&#39;, CMD_READ: &#39;read&#39;, CMD_WRITE: &#39;write&#39;, CMD_LSTAT:</span>
<span class="gd">-    &#39;lstat&#39;, CMD_FSTAT: &#39;fstat&#39;, CMD_SETSTAT: &#39;setstat&#39;, CMD_FSETSTAT:</span>
<span class="gd">-    &#39;fsetstat&#39;, CMD_OPENDIR: &#39;opendir&#39;, CMD_READDIR: &#39;readdir&#39;, CMD_REMOVE:</span>
<span class="gd">-    &#39;remove&#39;, CMD_MKDIR: &#39;mkdir&#39;, CMD_RMDIR: &#39;rmdir&#39;, CMD_REALPATH:</span>
<span class="gd">-    &#39;realpath&#39;, CMD_STAT: &#39;stat&#39;, CMD_RENAME: &#39;rename&#39;, CMD_READLINK:</span>
<span class="gd">-    &#39;readlink&#39;, CMD_SYMLINK: &#39;symlink&#39;, CMD_STATUS: &#39;status&#39;, CMD_HANDLE:</span>
<span class="gd">-    &#39;handle&#39;, CMD_DATA: &#39;data&#39;, CMD_NAME: &#39;name&#39;, CMD_ATTRS: &#39;attrs&#39;,</span>
<span class="gd">-    CMD_EXTENDED: &#39;extended&#39;, CMD_EXTENDED_REPLY: &#39;extended_reply&#39;}</span>


<span class="gi">+# for debugging</span>
<span class="gi">+CMD_NAMES = {</span>
<span class="gi">+    CMD_INIT: &quot;init&quot;,</span>
<span class="gi">+    CMD_VERSION: &quot;version&quot;,</span>
<span class="gi">+    CMD_OPEN: &quot;open&quot;,</span>
<span class="gi">+    CMD_CLOSE: &quot;close&quot;,</span>
<span class="gi">+    CMD_READ: &quot;read&quot;,</span>
<span class="gi">+    CMD_WRITE: &quot;write&quot;,</span>
<span class="gi">+    CMD_LSTAT: &quot;lstat&quot;,</span>
<span class="gi">+    CMD_FSTAT: &quot;fstat&quot;,</span>
<span class="gi">+    CMD_SETSTAT: &quot;setstat&quot;,</span>
<span class="gi">+    CMD_FSETSTAT: &quot;fsetstat&quot;,</span>
<span class="gi">+    CMD_OPENDIR: &quot;opendir&quot;,</span>
<span class="gi">+    CMD_READDIR: &quot;readdir&quot;,</span>
<span class="gi">+    CMD_REMOVE: &quot;remove&quot;,</span>
<span class="gi">+    CMD_MKDIR: &quot;mkdir&quot;,</span>
<span class="gi">+    CMD_RMDIR: &quot;rmdir&quot;,</span>
<span class="gi">+    CMD_REALPATH: &quot;realpath&quot;,</span>
<span class="gi">+    CMD_STAT: &quot;stat&quot;,</span>
<span class="gi">+    CMD_RENAME: &quot;rename&quot;,</span>
<span class="gi">+    CMD_READLINK: &quot;readlink&quot;,</span>
<span class="gi">+    CMD_SYMLINK: &quot;symlink&quot;,</span>
<span class="gi">+    CMD_STATUS: &quot;status&quot;,</span>
<span class="gi">+    CMD_HANDLE: &quot;handle&quot;,</span>
<span class="gi">+    CMD_DATA: &quot;data&quot;,</span>
<span class="gi">+    CMD_NAME: &quot;name&quot;,</span>
<span class="gi">+    CMD_ATTRS: &quot;attrs&quot;,</span>
<span class="gi">+    CMD_EXTENDED: &quot;extended&quot;,</span>
<span class="gi">+    CMD_EXTENDED_REPLY: &quot;extended_reply&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO: rewrite SFTP file/server modules&#39; overly-flexible &quot;make a request with</span>
<span class="gi">+# xyz components&quot; so we don&#39;t need this very silly method of signaling whether</span>
<span class="gi">+# a given Python integer should be 32- or 64-bit.</span>
<span class="gi">+# NOTE: this only became an issue when dropping Python 2 support; prior to</span>
<span class="gi">+# doing so, we had to support actual-longs, which served as that signal. This</span>
<span class="gi">+# is simply recreating that structure in a more tightly scoped fashion.</span>
<span class="w"> </span>class int64(int):
<span class="w"> </span>    pass

<span class="gu">@@ -44,8 +131,94 @@ class SFTPError(Exception):</span>


<span class="w"> </span>class BaseSFTP:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="gd">-        self.logger = util.get_logger(&#39;paramiko.sftp&#39;)</span>
<span class="gi">+        self.logger = util.get_logger(&quot;paramiko.sftp&quot;)</span>
<span class="w"> </span>        self.sock = None
<span class="w"> </span>        self.ultra_debug = False
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _send_version(self):</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_int(_VERSION)</span>
<span class="gi">+        self._send_packet(CMD_INIT, m)</span>
<span class="gi">+        t, data = self._read_packet()</span>
<span class="gi">+        if t != CMD_VERSION:</span>
<span class="gi">+            raise SFTPError(&quot;Incompatible sftp protocol&quot;)</span>
<span class="gi">+        version = struct.unpack(&quot;&gt;I&quot;, data[:4])[0]</span>
<span class="gi">+        #        if version != _VERSION:</span>
<span class="gi">+        #            raise SFTPError(&#39;Incompatible sftp protocol&#39;)</span>
<span class="gi">+        return version</span>
<span class="gi">+</span>
<span class="gi">+    def _send_server_version(self):</span>
<span class="gi">+        # winscp will freak out if the server sends version info before the</span>
<span class="gi">+        # client finishes sending INIT.</span>
<span class="gi">+        t, data = self._read_packet()</span>
<span class="gi">+        if t != CMD_INIT:</span>
<span class="gi">+            raise SFTPError(&quot;Incompatible sftp protocol&quot;)</span>
<span class="gi">+        version = struct.unpack(&quot;&gt;I&quot;, data[:4])[0]</span>
<span class="gi">+        # advertise that we support &quot;check-file&quot;</span>
<span class="gi">+        extension_pairs = [&quot;check-file&quot;, &quot;md5,sha1&quot;]</span>
<span class="gi">+        msg = Message()</span>
<span class="gi">+        msg.add_int(_VERSION)</span>
<span class="gi">+        msg.add(*extension_pairs)</span>
<span class="gi">+        self._send_packet(CMD_VERSION, msg)</span>
<span class="gi">+        return version</span>
<span class="gi">+</span>
<span class="gi">+    def _log(self, level, msg, *args):</span>
<span class="gi">+        self.logger.log(level, msg, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def _write_all(self, out):</span>
<span class="gi">+        while len(out) &gt; 0:</span>
<span class="gi">+            n = self.sock.send(out)</span>
<span class="gi">+            if n &lt;= 0:</span>
<span class="gi">+                raise EOFError()</span>
<span class="gi">+            if n == len(out):</span>
<span class="gi">+                return</span>
<span class="gi">+            out = out[n:]</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def _read_all(self, n):</span>
<span class="gi">+        out = bytes()</span>
<span class="gi">+        while n &gt; 0:</span>
<span class="gi">+            if isinstance(self.sock, socket.socket):</span>
<span class="gi">+                # sometimes sftp is used directly over a socket instead of</span>
<span class="gi">+                # through a paramiko channel.  in this case, check periodically</span>
<span class="gi">+                # if the socket is closed.  (for some reason, recv() won&#39;t ever</span>
<span class="gi">+                # return or raise an exception, but calling select on a closed</span>
<span class="gi">+                # socket will.)</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    read, write, err = select.select([self.sock], [], [], 0.1)</span>
<span class="gi">+                    if len(read) &gt; 0:</span>
<span class="gi">+                        x = self.sock.recv(n)</span>
<span class="gi">+                        break</span>
<span class="gi">+            else:</span>
<span class="gi">+                x = self.sock.recv(n)</span>
<span class="gi">+</span>
<span class="gi">+            if len(x) == 0:</span>
<span class="gi">+                raise EOFError()</span>
<span class="gi">+            out += x</span>
<span class="gi">+            n -= len(x)</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def _send_packet(self, t, packet):</span>
<span class="gi">+        packet = packet.asbytes()</span>
<span class="gi">+        out = struct.pack(&quot;&gt;I&quot;, len(packet) + 1) + byte_chr(t) + packet</span>
<span class="gi">+        if self.ultra_debug:</span>
<span class="gi">+            self._log(DEBUG, util.format_binary(out, &quot;OUT: &quot;))</span>
<span class="gi">+        self._write_all(out)</span>
<span class="gi">+</span>
<span class="gi">+    def _read_packet(self):</span>
<span class="gi">+        x = self._read_all(4)</span>
<span class="gi">+        # most sftp servers won&#39;t accept packets larger than about 32k, so</span>
<span class="gi">+        # anything with the high byte set (&gt; 16MB) is just garbage.</span>
<span class="gi">+        if byte_ord(x[0]):</span>
<span class="gi">+            raise SFTPError(&quot;Garbage packet received&quot;)</span>
<span class="gi">+        size = struct.unpack(&quot;&gt;I&quot;, x)[0]</span>
<span class="gi">+        data = self._read_all(size)</span>
<span class="gi">+        if self.ultra_debug:</span>
<span class="gi">+            self._log(DEBUG, util.format_binary(data, &quot;IN: &quot;))</span>
<span class="gi">+        if size &gt; 0:</span>
<span class="gi">+            t = byte_ord(data[0])</span>
<span class="gi">+            return t, data[1:]</span>
<span class="gi">+        return 0, bytes()</span>
<span class="gh">diff --git a/paramiko/sftp_attr.py b/paramiko/sftp_attr.py</span>
<span class="gh">index 0745a134..18ffbf86 100644</span>
<span class="gd">--- a/paramiko/sftp_attr.py</span>
<span class="gi">+++ b/paramiko/sftp_attr.py</span>
<span class="gu">@@ -1,3 +1,21 @@</span>
<span class="gi">+# Copyright (C) 2003-2006 Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>import stat
<span class="w"> </span>import time
<span class="w"> </span>from paramiko.common import x80000000, o700, o70, xffffffff
<span class="gu">@@ -21,6 +39,7 @@ class SFTPAttributes:</span>
<span class="w"> </span>    are stored in a dict named ``attr``.  Occasionally, the filename is also
<span class="w"> </span>    stored, in ``filename``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    FLAG_SIZE = 1
<span class="w"> </span>    FLAG_UIDGID = 2
<span class="w"> </span>    FLAG_PERMISSIONS = 4
<span class="gu">@@ -50,48 +69,150 @@ class SFTPAttributes:</span>
<span class="w"> </span>        :param str filename: the filename associated with this file.
<span class="w"> </span>        :return: new `.SFTPAttributes` object with the same attribute fields.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attr = cls()</span>
<span class="gi">+        attr.st_size = obj.st_size</span>
<span class="gi">+        attr.st_uid = obj.st_uid</span>
<span class="gi">+        attr.st_gid = obj.st_gid</span>
<span class="gi">+        attr.st_mode = obj.st_mode</span>
<span class="gi">+        attr.st_atime = obj.st_atime</span>
<span class="gi">+        attr.st_mtime = obj.st_mtime</span>
<span class="gi">+        if filename is not None:</span>
<span class="gi">+            attr.filename = filename</span>
<span class="gi">+        return attr</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;SFTPAttributes: {}&gt;&#39;.format(self._debug_str())</span>
<span class="gi">+        return &quot;&lt;SFTPAttributes: {}&gt;&quot;.format(self._debug_str())</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_msg(cls, msg, filename=None, longname=None):</span>
<span class="gi">+        attr = cls()</span>
<span class="gi">+        attr._unpack(msg)</span>
<span class="gi">+        if filename is not None:</span>
<span class="gi">+            attr.filename = filename</span>
<span class="gi">+        if longname is not None:</span>
<span class="gi">+            attr.longname = longname</span>
<span class="gi">+        return attr</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack(self, msg):</span>
<span class="gi">+        self._flags = msg.get_int()</span>
<span class="gi">+        if self._flags &amp; self.FLAG_SIZE:</span>
<span class="gi">+            self.st_size = msg.get_int64()</span>
<span class="gi">+        if self._flags &amp; self.FLAG_UIDGID:</span>
<span class="gi">+            self.st_uid = msg.get_int()</span>
<span class="gi">+            self.st_gid = msg.get_int()</span>
<span class="gi">+        if self._flags &amp; self.FLAG_PERMISSIONS:</span>
<span class="gi">+            self.st_mode = msg.get_int()</span>
<span class="gi">+        if self._flags &amp; self.FLAG_AMTIME:</span>
<span class="gi">+            self.st_atime = msg.get_int()</span>
<span class="gi">+            self.st_mtime = msg.get_int()</span>
<span class="gi">+        if self._flags &amp; self.FLAG_EXTENDED:</span>
<span class="gi">+            count = msg.get_int()</span>
<span class="gi">+            for i in range(count):</span>
<span class="gi">+                self.attr[msg.get_string()] = msg.get_string()</span>
<span class="gi">+</span>
<span class="gi">+    def _pack(self, msg):</span>
<span class="gi">+        self._flags = 0</span>
<span class="gi">+        if self.st_size is not None:</span>
<span class="gi">+            self._flags |= self.FLAG_SIZE</span>
<span class="gi">+        if (self.st_uid is not None) and (self.st_gid is not None):</span>
<span class="gi">+            self._flags |= self.FLAG_UIDGID</span>
<span class="gi">+        if self.st_mode is not None:</span>
<span class="gi">+            self._flags |= self.FLAG_PERMISSIONS</span>
<span class="gi">+        if (self.st_atime is not None) and (self.st_mtime is not None):</span>
<span class="gi">+            self._flags |= self.FLAG_AMTIME</span>
<span class="gi">+        if len(self.attr) &gt; 0:</span>
<span class="gi">+            self._flags |= self.FLAG_EXTENDED</span>
<span class="gi">+        msg.add_int(self._flags)</span>
<span class="gi">+        if self._flags &amp; self.FLAG_SIZE:</span>
<span class="gi">+            msg.add_int64(self.st_size)</span>
<span class="gi">+        if self._flags &amp; self.FLAG_UIDGID:</span>
<span class="gi">+            msg.add_int(self.st_uid)</span>
<span class="gi">+            msg.add_int(self.st_gid)</span>
<span class="gi">+        if self._flags &amp; self.FLAG_PERMISSIONS:</span>
<span class="gi">+            msg.add_int(self.st_mode)</span>
<span class="gi">+        if self._flags &amp; self.FLAG_AMTIME:</span>
<span class="gi">+            # throw away any fractional seconds</span>
<span class="gi">+            msg.add_int(int(self.st_atime))</span>
<span class="gi">+            msg.add_int(int(self.st_mtime))</span>
<span class="gi">+        if self._flags &amp; self.FLAG_EXTENDED:</span>
<span class="gi">+            msg.add_int(len(self.attr))</span>
<span class="gi">+            for key, val in self.attr.items():</span>
<span class="gi">+                msg.add_string(key)</span>
<span class="gi">+                msg.add_string(val)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def _debug_str(self):</span>
<span class="gi">+        out = &quot;[ &quot;</span>
<span class="gi">+        if self.st_size is not None:</span>
<span class="gi">+            out += &quot;size={} &quot;.format(self.st_size)</span>
<span class="gi">+        if (self.st_uid is not None) and (self.st_gid is not None):</span>
<span class="gi">+            out += &quot;uid={} gid={} &quot;.format(self.st_uid, self.st_gid)</span>
<span class="gi">+        if self.st_mode is not None:</span>
<span class="gi">+            out += &quot;mode=&quot; + oct(self.st_mode) + &quot; &quot;</span>
<span class="gi">+        if (self.st_atime is not None) and (self.st_mtime is not None):</span>
<span class="gi">+            out += &quot;atime={} mtime={} &quot;.format(self.st_atime, self.st_mtime)</span>
<span class="gi">+        for k, v in self.attr.items():</span>
<span class="gi">+            out += &#39;&quot;{}&quot;={!r} &#39;.format(str(k), v)</span>
<span class="gi">+        out += &quot;]&quot;</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _rwx(n, suid, sticky=False):</span>
<span class="gi">+        if suid:</span>
<span class="gi">+            suid = 2</span>
<span class="gi">+        out = &quot;-r&quot;[n &gt;&gt; 2] + &quot;-w&quot;[(n &gt;&gt; 1) &amp; 1]</span>
<span class="gi">+        if sticky:</span>
<span class="gi">+            out += &quot;-xTt&quot;[suid + (n &amp; 1)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            out += &quot;-xSs&quot;[suid + (n &amp; 1)]</span>
<span class="gi">+        return out</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        &quot;&quot;&quot;create a unix-style long description of the file (like ls -l)&quot;&quot;&quot;
<span class="w"> </span>        if self.st_mode is not None:
<span class="w"> </span>            kind = stat.S_IFMT(self.st_mode)
<span class="w"> </span>            if kind == stat.S_IFIFO:
<span class="gd">-                ks = &#39;p&#39;</span>
<span class="gi">+                ks = &quot;p&quot;</span>
<span class="w"> </span>            elif kind == stat.S_IFCHR:
<span class="gd">-                ks = &#39;c&#39;</span>
<span class="gi">+                ks = &quot;c&quot;</span>
<span class="w"> </span>            elif kind == stat.S_IFDIR:
<span class="gd">-                ks = &#39;d&#39;</span>
<span class="gi">+                ks = &quot;d&quot;</span>
<span class="w"> </span>            elif kind == stat.S_IFBLK:
<span class="gd">-                ks = &#39;b&#39;</span>
<span class="gi">+                ks = &quot;b&quot;</span>
<span class="w"> </span>            elif kind == stat.S_IFREG:
<span class="gd">-                ks = &#39;-&#39;</span>
<span class="gi">+                ks = &quot;-&quot;</span>
<span class="w"> </span>            elif kind == stat.S_IFLNK:
<span class="gd">-                ks = &#39;l&#39;</span>
<span class="gi">+                ks = &quot;l&quot;</span>
<span class="w"> </span>            elif kind == stat.S_IFSOCK:
<span class="gd">-                ks = &#39;s&#39;</span>
<span class="gi">+                ks = &quot;s&quot;</span>
<span class="w"> </span>            else:
<span class="gd">-                ks = &#39;?&#39;</span>
<span class="gd">-            ks += self._rwx((self.st_mode &amp; o700) &gt;&gt; 6, self.st_mode &amp; stat</span>
<span class="gd">-                .S_ISUID)</span>
<span class="gd">-            ks += self._rwx((self.st_mode &amp; o70) &gt;&gt; 3, self.st_mode &amp; stat.</span>
<span class="gd">-                S_ISGID)</span>
<span class="gd">-            ks += self._rwx(self.st_mode &amp; 7, self.st_mode &amp; stat.S_ISVTX, True</span>
<span class="gd">-                )</span>
<span class="gi">+                ks = &quot;?&quot;</span>
<span class="gi">+            ks += self._rwx(</span>
<span class="gi">+                (self.st_mode &amp; o700) &gt;&gt; 6, self.st_mode &amp; stat.S_ISUID</span>
<span class="gi">+            )</span>
<span class="gi">+            ks += self._rwx(</span>
<span class="gi">+                (self.st_mode &amp; o70) &gt;&gt; 3, self.st_mode &amp; stat.S_ISGID</span>
<span class="gi">+            )</span>
<span class="gi">+            ks += self._rwx(</span>
<span class="gi">+                self.st_mode &amp; 7, self.st_mode &amp; stat.S_ISVTX, True</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            ks = &#39;?---------&#39;</span>
<span class="gd">-        if self.st_mtime is None or self.st_mtime == xffffffff:</span>
<span class="gd">-            datestr = &#39;(unknown date)&#39;</span>
<span class="gi">+            ks = &quot;?---------&quot;</span>
<span class="gi">+        # compute display date</span>
<span class="gi">+        if (self.st_mtime is None) or (self.st_mtime == xffffffff):</span>
<span class="gi">+            # shouldn&#39;t really happen</span>
<span class="gi">+            datestr = &quot;(unknown date)&quot;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            time_tuple = time.localtime(self.st_mtime)
<span class="gd">-            if abs(time.time() - self.st_mtime) &gt; 15552000:</span>
<span class="gd">-                datestr = time.strftime(&#39;%d %b %Y&#39;, time_tuple)</span>
<span class="gi">+            if abs(time.time() - self.st_mtime) &gt; 15_552_000:</span>
<span class="gi">+                # (15,552,000s = 6 months)</span>
<span class="gi">+                datestr = time.strftime(&quot;%d %b %Y&quot;, time_tuple)</span>
<span class="w"> </span>            else:
<span class="gd">-                datestr = time.strftime(&#39;%d %b %H:%M&#39;, time_tuple)</span>
<span class="gd">-        filename = getattr(self, &#39;filename&#39;, &#39;?&#39;)</span>
<span class="gi">+                datestr = time.strftime(&quot;%d %b %H:%M&quot;, time_tuple)</span>
<span class="gi">+        filename = getattr(self, &quot;filename&quot;, &quot;?&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # not all servers support uid/gid</span>
<span class="w"> </span>        uid = self.st_uid
<span class="w"> </span>        gid = self.st_gid
<span class="w"> </span>        size = self.st_size
<span class="gu">@@ -101,5 +222,18 @@ class SFTPAttributes:</span>
<span class="w"> </span>            gid = 0
<span class="w"> </span>        if size is None:
<span class="w"> </span>            size = 0
<span class="gd">-        return &#39;%s   1 %-8d %-8d %8d %-12s %s&#39; % (ks, uid, gid, size,</span>
<span class="gd">-            datestr, filename)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO: not sure this actually worked as expected beforehand, leaving</span>
<span class="gi">+        # it untouched for the time being, re: .format() upgrade, until someone</span>
<span class="gi">+        # has time to doublecheck</span>
<span class="gi">+        return &quot;%s   1 %-8d %-8d %8d %-12s %s&quot; % (</span>
<span class="gi">+            ks,</span>
<span class="gi">+            uid,</span>
<span class="gi">+            gid,</span>
<span class="gi">+            size,</span>
<span class="gi">+            datestr,</span>
<span class="gi">+            filename,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def asbytes(self):</span>
<span class="gi">+        return str(self).encode()</span>
<span class="gh">diff --git a/paramiko/sftp_client.py b/paramiko/sftp_client.py</span>
<span class="gh">index 24ff487a..066cd83f 100644</span>
<span class="gd">--- a/paramiko/sftp_client.py</span>
<span class="gi">+++ b/paramiko/sftp_client.py</span>
<span class="gu">@@ -1,3 +1,22 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of Paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from binascii import hexlify
<span class="w"> </span>import errno
<span class="w"> </span>import os
<span class="gu">@@ -9,7 +28,41 @@ from paramiko import util</span>
<span class="w"> </span>from paramiko.channel import Channel
<span class="w"> </span>from paramiko.message import Message
<span class="w"> </span>from paramiko.common import INFO, DEBUG, o777
<span class="gd">-from paramiko.sftp import BaseSFTP, CMD_OPENDIR, CMD_HANDLE, SFTPError, CMD_READDIR, CMD_NAME, CMD_CLOSE, SFTP_FLAG_READ, SFTP_FLAG_WRITE, SFTP_FLAG_CREATE, SFTP_FLAG_TRUNC, SFTP_FLAG_APPEND, SFTP_FLAG_EXCL, CMD_OPEN, CMD_REMOVE, CMD_RENAME, CMD_MKDIR, CMD_RMDIR, CMD_STAT, CMD_ATTRS, CMD_LSTAT, CMD_SYMLINK, CMD_SETSTAT, CMD_READLINK, CMD_REALPATH, CMD_STATUS, CMD_EXTENDED, SFTP_OK, SFTP_EOF, SFTP_NO_SUCH_FILE, SFTP_PERMISSION_DENIED, int64</span>
<span class="gi">+from paramiko.sftp import (</span>
<span class="gi">+    BaseSFTP,</span>
<span class="gi">+    CMD_OPENDIR,</span>
<span class="gi">+    CMD_HANDLE,</span>
<span class="gi">+    SFTPError,</span>
<span class="gi">+    CMD_READDIR,</span>
<span class="gi">+    CMD_NAME,</span>
<span class="gi">+    CMD_CLOSE,</span>
<span class="gi">+    SFTP_FLAG_READ,</span>
<span class="gi">+    SFTP_FLAG_WRITE,</span>
<span class="gi">+    SFTP_FLAG_CREATE,</span>
<span class="gi">+    SFTP_FLAG_TRUNC,</span>
<span class="gi">+    SFTP_FLAG_APPEND,</span>
<span class="gi">+    SFTP_FLAG_EXCL,</span>
<span class="gi">+    CMD_OPEN,</span>
<span class="gi">+    CMD_REMOVE,</span>
<span class="gi">+    CMD_RENAME,</span>
<span class="gi">+    CMD_MKDIR,</span>
<span class="gi">+    CMD_RMDIR,</span>
<span class="gi">+    CMD_STAT,</span>
<span class="gi">+    CMD_ATTRS,</span>
<span class="gi">+    CMD_LSTAT,</span>
<span class="gi">+    CMD_SYMLINK,</span>
<span class="gi">+    CMD_SETSTAT,</span>
<span class="gi">+    CMD_READLINK,</span>
<span class="gi">+    CMD_REALPATH,</span>
<span class="gi">+    CMD_STATUS,</span>
<span class="gi">+    CMD_EXTENDED,</span>
<span class="gi">+    SFTP_OK,</span>
<span class="gi">+    SFTP_EOF,</span>
<span class="gi">+    SFTP_NO_SUCH_FILE,</span>
<span class="gi">+    SFTP_PERMISSION_DENIED,</span>
<span class="gi">+    int64,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from paramiko.sftp_attr import SFTPAttributes
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="w"> </span>from paramiko.sftp_file import SFTPFile
<span class="gu">@@ -22,10 +75,16 @@ def _to_unicode(s):</span>
<span class="w"> </span>    protocol).  if neither works, just return a byte string because the server
<span class="w"> </span>    probably doesn&#39;t know the filename&#39;s encoding.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return s.encode(&quot;ascii&quot;)</span>
<span class="gi">+    except (UnicodeError, AttributeError):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return s.decode(&quot;utf-8&quot;)</span>
<span class="gi">+        except UnicodeError:</span>
<span class="gi">+            return s</span>


<span class="gd">-b_slash = b&#39;/&#39;</span>
<span class="gi">+b_slash = b&quot;/&quot;</span>


<span class="w"> </span>class SFTPClient(BaseSFTP, ClosingContextManager):
<span class="gu">@@ -55,20 +114,28 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        self.sock = sock
<span class="w"> </span>        self.ultra_debug = False
<span class="w"> </span>        self.request_number = 1
<span class="gi">+        # lock for request_number</span>
<span class="w"> </span>        self._lock = threading.Lock()
<span class="w"> </span>        self._cwd = None
<span class="gi">+        # request # -&gt; SFTPFile</span>
<span class="w"> </span>        self._expecting = weakref.WeakValueDictionary()
<span class="w"> </span>        if type(sock) is Channel:
<span class="gi">+            # override default logger</span>
<span class="w"> </span>            transport = self.sock.get_transport()
<span class="gd">-            self.logger = util.get_logger(transport.get_log_channel() + &#39;.sftp&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            self.logger = util.get_logger(</span>
<span class="gi">+                transport.get_log_channel() + &quot;.sftp&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>            self.ultra_debug = transport.get_hexdump()
<span class="w"> </span>        try:
<span class="w"> </span>            server_version = self._send_version()
<span class="w"> </span>        except EOFError:
<span class="gd">-            raise SSHException(&#39;EOF during negotiation&#39;)</span>
<span class="gd">-        self._log(INFO, &#39;Opened sftp connection (server version {})&#39;.format</span>
<span class="gd">-            (server_version))</span>
<span class="gi">+            raise SSHException(&quot;EOF during negotiation&quot;)</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            INFO,</span>
<span class="gi">+            &quot;Opened sftp connection (server version {})&quot;.format(</span>
<span class="gi">+                server_version</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_transport(cls, t, window_size=None, max_packet_size=None):
<span class="gu">@@ -94,7 +161,29 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 1.15
<span class="w"> </span>            Added the ``window_size`` and ``max_packet_size`` arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        chan = t.open_session(</span>
<span class="gi">+            window_size=window_size, max_packet_size=max_packet_size</span>
<span class="gi">+        )</span>
<span class="gi">+        if chan is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        chan.invoke_subsystem(&quot;sftp&quot;)</span>
<span class="gi">+        return cls(chan)</span>
<span class="gi">+</span>
<span class="gi">+    def _log(self, level, msg, *args):</span>
<span class="gi">+        if isinstance(msg, list):</span>
<span class="gi">+            for m in msg:</span>
<span class="gi">+                self._log(level, m, *args)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # NOTE: these bits MUST continue using %-style format junk because</span>
<span class="gi">+            # logging.Logger.log() explicitly requires it. Grump.</span>
<span class="gi">+            # escape &#39;%&#39; in msg (they could come from file or directory names)</span>
<span class="gi">+            # before logging</span>
<span class="gi">+            msg = msg.replace(&quot;%&quot;, &quot;%%&quot;)</span>
<span class="gi">+            super()._log(</span>
<span class="gi">+                level,</span>
<span class="gi">+                &quot;[chan %s] &quot; + msg,</span>
<span class="gi">+                *([self.sock.get_name()] + list(args))</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -102,7 +191,8 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._log(INFO, &quot;sftp session closed.&quot;)</span>
<span class="gi">+        self.sock.close()</span>

<span class="w"> </span>    def get_channel(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -111,9 +201,9 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.7.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sock</span>

<span class="gd">-    def listdir(self, path=&#39;.&#39;):</span>
<span class="gi">+    def listdir(self, path=&quot;.&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list containing the names of the entries in the given
<span class="w"> </span>        ``path``.
<span class="gu">@@ -125,9 +215,9 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        :param str path: path to list (defaults to ``&#39;.&#39;``)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [f.filename for f in self.listdir_attr(path)]</span>

<span class="gd">-    def listdir_attr(self, path=&#39;.&#39;):</span>
<span class="gi">+    def listdir_attr(self, path=&quot;.&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list containing `.SFTPAttributes` objects corresponding to
<span class="w"> </span>        files in the given ``path``.  The list is in arbitrary order.  It does
<span class="gu">@@ -144,9 +234,32 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def listdir_iter(self, path=&#39;.&#39;, read_aheads=50):</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;listdir({!r})&quot;.format(path))</span>
<span class="gi">+        t, msg = self._request(CMD_OPENDIR, path)</span>
<span class="gi">+        if t != CMD_HANDLE:</span>
<span class="gi">+            raise SFTPError(&quot;Expected handle&quot;)</span>
<span class="gi">+        handle = msg.get_binary()</span>
<span class="gi">+        filelist = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                t, msg = self._request(CMD_READDIR, handle)</span>
<span class="gi">+            except EOFError:</span>
<span class="gi">+                # done with handle</span>
<span class="gi">+                break</span>
<span class="gi">+            if t != CMD_NAME:</span>
<span class="gi">+                raise SFTPError(&quot;Expected name response&quot;)</span>
<span class="gi">+            count = msg.get_int()</span>
<span class="gi">+            for i in range(count):</span>
<span class="gi">+                filename = msg.get_text()</span>
<span class="gi">+                longname = msg.get_text()</span>
<span class="gi">+                attr = SFTPAttributes._from_msg(msg, filename, longname)</span>
<span class="gi">+                if (filename != &quot;.&quot;) and (filename != &quot;..&quot;):</span>
<span class="gi">+                    filelist.append(attr)</span>
<span class="gi">+        self._request(CMD_CLOSE, handle)</span>
<span class="gi">+        return filelist</span>
<span class="gi">+</span>
<span class="gi">+    def listdir_iter(self, path=&quot;.&quot;, read_aheads=50):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generator version of `.listdir_attr`.

<span class="gu">@@ -160,9 +273,57 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.15
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def open(self, filename, mode=&#39;r&#39;, bufsize=-1):</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;listdir({!r})&quot;.format(path))</span>
<span class="gi">+        t, msg = self._request(CMD_OPENDIR, path)</span>
<span class="gi">+</span>
<span class="gi">+        if t != CMD_HANDLE:</span>
<span class="gi">+            raise SFTPError(&quot;Expected handle&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        handle = msg.get_string()</span>
<span class="gi">+</span>
<span class="gi">+        nums = list()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Send out a bunch of readdir requests so that we can read the</span>
<span class="gi">+                # responses later on Section 6.7 of the SSH file transfer RFC</span>
<span class="gi">+                # explains this</span>
<span class="gi">+                # http://filezilla-project.org/specs/draft-ietf-secsh-filexfer-02.txt</span>
<span class="gi">+                for i in range(read_aheads):</span>
<span class="gi">+                    num = self._async_request(type(None), CMD_READDIR, handle)</span>
<span class="gi">+                    nums.append(num)</span>
<span class="gi">+</span>
<span class="gi">+                # For each of our sent requests</span>
<span class="gi">+                # Read and parse the corresponding packets</span>
<span class="gi">+                # If we&#39;re at the end of our queued requests, then fire off</span>
<span class="gi">+                # some more requests</span>
<span class="gi">+                # Exit the loop when we&#39;ve reached the end of the directory</span>
<span class="gi">+                # handle</span>
<span class="gi">+                for num in nums:</span>
<span class="gi">+                    t, pkt_data = self._read_packet()</span>
<span class="gi">+                    msg = Message(pkt_data)</span>
<span class="gi">+                    new_num = msg.get_int()</span>
<span class="gi">+                    if num == new_num:</span>
<span class="gi">+                        if t == CMD_STATUS:</span>
<span class="gi">+                            self._convert_status(msg)</span>
<span class="gi">+                    count = msg.get_int()</span>
<span class="gi">+                    for i in range(count):</span>
<span class="gi">+                        filename = msg.get_text()</span>
<span class="gi">+                        longname = msg.get_text()</span>
<span class="gi">+                        attr = SFTPAttributes._from_msg(</span>
<span class="gi">+                            msg, filename, longname</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if (filename != &quot;.&quot;) and (filename != &quot;..&quot;):</span>
<span class="gi">+                            yield attr</span>
<span class="gi">+</span>
<span class="gi">+                # If we&#39;ve hit the end of our queued requests, reset nums.</span>
<span class="gi">+                nums = list()</span>
<span class="gi">+</span>
<span class="gi">+            except EOFError:</span>
<span class="gi">+                self._request(CMD_CLOSE, handle)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+    def open(self, filename, mode=&quot;r&quot;, bufsize=-1):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Open a file on the remote server.  The arguments are the same as for
<span class="w"> </span>        Python&#39;s built-in `python:file` (aka `python:open`).  A file-like
<span class="gu">@@ -194,7 +355,33 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the file could not be opened.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        filename = self._adjust_cwd(filename)</span>
<span class="gi">+        self._log(DEBUG, &quot;open({!r}, {!r})&quot;.format(filename, mode))</span>
<span class="gi">+        imode = 0</span>
<span class="gi">+        if (&quot;r&quot; in mode) or (&quot;+&quot; in mode):</span>
<span class="gi">+            imode |= SFTP_FLAG_READ</span>
<span class="gi">+        if (&quot;w&quot; in mode) or (&quot;+&quot; in mode) or (&quot;a&quot; in mode):</span>
<span class="gi">+            imode |= SFTP_FLAG_WRITE</span>
<span class="gi">+        if &quot;w&quot; in mode:</span>
<span class="gi">+            imode |= SFTP_FLAG_CREATE | SFTP_FLAG_TRUNC</span>
<span class="gi">+        if &quot;a&quot; in mode:</span>
<span class="gi">+            imode |= SFTP_FLAG_CREATE | SFTP_FLAG_APPEND</span>
<span class="gi">+        if &quot;x&quot; in mode:</span>
<span class="gi">+            imode |= SFTP_FLAG_CREATE | SFTP_FLAG_EXCL</span>
<span class="gi">+        attrblock = SFTPAttributes()</span>
<span class="gi">+        t, msg = self._request(CMD_OPEN, filename, imode, attrblock)</span>
<span class="gi">+        if t != CMD_HANDLE:</span>
<span class="gi">+            raise SFTPError(&quot;Expected handle&quot;)</span>
<span class="gi">+        handle = msg.get_binary()</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            DEBUG,</span>
<span class="gi">+            &quot;open({!r}, {!r}) -&gt; {}&quot;.format(</span>
<span class="gi">+                filename, mode, u(hexlify(handle))</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        return SFTPFile(self, handle, mode, bufsize)</span>
<span class="gi">+</span>
<span class="gi">+    # Python continues to vacillate about &quot;open&quot; vs &quot;file&quot;...</span>
<span class="w"> </span>    file = open

<span class="w"> </span>    def remove(self, path):
<span class="gu">@@ -206,7 +393,10 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the path refers to a folder (directory)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;remove({!r})&quot;.format(path))</span>
<span class="gi">+        self._request(CMD_REMOVE, path)</span>
<span class="gi">+</span>
<span class="w"> </span>    unlink = remove

<span class="w"> </span>    def rename(self, oldpath, newpath):
<span class="gu">@@ -227,7 +417,10 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>            ``IOError`` -- if ``newpath`` is a folder, or something else goes
<span class="w"> </span>            wrong
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        oldpath = self._adjust_cwd(oldpath)</span>
<span class="gi">+        newpath = self._adjust_cwd(newpath)</span>
<span class="gi">+        self._log(DEBUG, &quot;rename({!r}, {!r})&quot;.format(oldpath, newpath))</span>
<span class="gi">+        self._request(CMD_RENAME, oldpath, newpath)</span>

<span class="w"> </span>    def posix_rename(self, oldpath, newpath):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -244,7 +437,12 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        :versionadded: 2.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        oldpath = self._adjust_cwd(oldpath)</span>
<span class="gi">+        newpath = self._adjust_cwd(newpath)</span>
<span class="gi">+        self._log(DEBUG, &quot;posix_rename({!r}, {!r})&quot;.format(oldpath, newpath))</span>
<span class="gi">+        self._request(</span>
<span class="gi">+            CMD_EXTENDED, &quot;posix-rename@openssh.com&quot;, oldpath, newpath</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def mkdir(self, path, mode=o777):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -255,7 +453,11 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        :param str path: name of the folder to create
<span class="w"> </span>        :param int mode: permissions (posix-style) for the newly-created folder
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;mkdir({!r}, {!r})&quot;.format(path, mode))</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_mode = mode</span>
<span class="gi">+        self._request(CMD_MKDIR, path, attr)</span>

<span class="w"> </span>    def rmdir(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -263,7 +465,9 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        :param str path: name of the folder to remove
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;rmdir({!r})&quot;.format(path))</span>
<span class="gi">+        self._request(CMD_RMDIR, path)</span>

<span class="w"> </span>    def stat(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -284,7 +488,12 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>            an `.SFTPAttributes` object containing attributes about the given
<span class="w"> </span>            file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;stat({!r})&quot;.format(path))</span>
<span class="gi">+        t, msg = self._request(CMD_STAT, path)</span>
<span class="gi">+        if t != CMD_ATTRS:</span>
<span class="gi">+            raise SFTPError(&quot;Expected attributes&quot;)</span>
<span class="gi">+        return SFTPAttributes._from_msg(msg)</span>

<span class="w"> </span>    def lstat(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -297,7 +506,12 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>            an `.SFTPAttributes` object containing attributes about the given
<span class="w"> </span>            file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;lstat({!r})&quot;.format(path))</span>
<span class="gi">+        t, msg = self._request(CMD_LSTAT, path)</span>
<span class="gi">+        if t != CMD_ATTRS:</span>
<span class="gi">+            raise SFTPError(&quot;Expected attributes&quot;)</span>
<span class="gi">+        return SFTPAttributes._from_msg(msg)</span>

<span class="w"> </span>    def symlink(self, source, dest):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -306,7 +520,10 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        :param str source: path of the original file
<span class="w"> </span>        :param str dest: path of the newly created symlink
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dest = self._adjust_cwd(dest)</span>
<span class="gi">+        self._log(DEBUG, &quot;symlink({!r}, {!r})&quot;.format(source, dest))</span>
<span class="gi">+        source = b(source)</span>
<span class="gi">+        self._request(CMD_SYMLINK, source, dest)</span>

<span class="w"> </span>    def chmod(self, path, mode):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -317,7 +534,11 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        :param str path: path of the file to change the permissions of
<span class="w"> </span>        :param int mode: new permissions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;chmod({!r}, {!r})&quot;.format(path, mode))</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_mode = mode</span>
<span class="gi">+        self._request(CMD_SETSTAT, path, attr)</span>

<span class="w"> </span>    def chown(self, path, uid, gid):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -330,7 +551,11 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        :param int uid: new owner&#39;s uid
<span class="w"> </span>        :param int gid: new group id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;chown({!r}, {!r}, {!r})&quot;.format(path, uid, gid))</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_uid, attr.st_gid = uid, gid</span>
<span class="gi">+        self._request(CMD_SETSTAT, path, attr)</span>

<span class="w"> </span>    def utime(self, path, times):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -346,7 +571,13 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>            ``None`` or a tuple of (access time, modified time) in standard
<span class="w"> </span>            internet epoch time (seconds since 01 January 1970 GMT)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        if times is None:</span>
<span class="gi">+            times = (time.time(), time.time())</span>
<span class="gi">+        self._log(DEBUG, &quot;utime({!r}, {!r})&quot;.format(path, times))</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_atime, attr.st_mtime = times</span>
<span class="gi">+        self._request(CMD_SETSTAT, path, attr)</span>

<span class="w"> </span>    def truncate(self, path, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -357,7 +588,11 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        :param str path: path of the file to modify
<span class="w"> </span>        :param int size: the new size of the file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;truncate({!r}, {!r})&quot;.format(path, size))</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_size = size</span>
<span class="gi">+        self._request(CMD_SETSTAT, path, attr)</span>

<span class="w"> </span>    def readlink(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -368,7 +603,17 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        :param str path: path of the symbolic link file
<span class="w"> </span>        :return: target path, as a `str`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;readlink({!r})&quot;.format(path))</span>
<span class="gi">+        t, msg = self._request(CMD_READLINK, path)</span>
<span class="gi">+        if t != CMD_NAME:</span>
<span class="gi">+            raise SFTPError(&quot;Expected name response&quot;)</span>
<span class="gi">+        count = msg.get_int()</span>
<span class="gi">+        if count == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if count != 1:</span>
<span class="gi">+            raise SFTPError(&quot;Readlink returned {} results&quot;.format(count))</span>
<span class="gi">+        return _to_unicode(msg.get_string())</span>

<span class="w"> </span>    def normalize(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -382,7 +627,15 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the path can&#39;t be resolved on the server
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._adjust_cwd(path)</span>
<span class="gi">+        self._log(DEBUG, &quot;normalize({!r})&quot;.format(path))</span>
<span class="gi">+        t, msg = self._request(CMD_REALPATH, path)</span>
<span class="gi">+        if t != CMD_NAME:</span>
<span class="gi">+            raise SFTPError(&quot;Expected name response&quot;)</span>
<span class="gi">+        count = msg.get_int()</span>
<span class="gi">+        if count != 1:</span>
<span class="gi">+            raise SFTPError(&quot;Realpath returned {} results&quot;.format(count))</span>
<span class="gi">+        return msg.get_text()</span>

<span class="w"> </span>    def chdir(self, path=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -400,7 +653,13 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if path is None:</span>
<span class="gi">+            self._cwd = None</span>
<span class="gi">+            return</span>
<span class="gi">+        if not stat.S_ISDIR(self.stat(path).st_mode):</span>
<span class="gi">+            code = errno.ENOTDIR</span>
<span class="gi">+            raise SFTPError(code, &quot;{}: {}&quot;.format(os.strerror(code), path))</span>
<span class="gi">+        self._cwd = b(self.normalize(path))</span>

<span class="w"> </span>    def getcwd(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -410,7 +669,20 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: make class initialize with self._cwd set to self.normalize(&#39;.&#39;)</span>
<span class="gi">+        return self._cwd and u(self._cwd)</span>
<span class="gi">+</span>
<span class="gi">+    def _transfer_with_callback(self, reader, writer, file_size, callback):</span>
<span class="gi">+        size = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            data = reader.read(32768)</span>
<span class="gi">+            writer.write(data)</span>
<span class="gi">+            size += len(data)</span>
<span class="gi">+            if len(data) == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+            if callback is not None:</span>
<span class="gi">+                callback(size, file_size)</span>
<span class="gi">+        return size</span>

<span class="w"> </span>    def putfo(self, fl, remotepath, file_size=0, callback=None, confirm=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -439,7 +711,20 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.10
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.file(remotepath, &quot;wb&quot;) as fr:</span>
<span class="gi">+            fr.set_pipelined(True)</span>
<span class="gi">+            size = self._transfer_with_callback(</span>
<span class="gi">+                reader=fl, writer=fr, file_size=file_size, callback=callback</span>
<span class="gi">+            )</span>
<span class="gi">+        if confirm:</span>
<span class="gi">+            s = self.stat(remotepath)</span>
<span class="gi">+            if s.st_size != size:</span>
<span class="gi">+                raise IOError(</span>
<span class="gi">+                    &quot;size mismatch in put!  {} != {}&quot;.format(s.st_size, size)</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            s = SFTPAttributes()</span>
<span class="gi">+        return s</span>

<span class="w"> </span>    def put(self, localpath, remotepath, callback=None, confirm=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -469,10 +754,18 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 1.7.7
<span class="w"> </span>            ``confirm`` param added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        file_size = os.stat(localpath).st_size</span>
<span class="gi">+        with open(localpath, &quot;rb&quot;) as fl:</span>
<span class="gi">+            return self.putfo(fl, remotepath, file_size, callback, confirm)</span>

<span class="gd">-    def getfo(self, remotepath, fl, callback=None, prefetch=True,</span>
<span class="gd">-        max_concurrent_prefetch_requests=None):</span>
<span class="gi">+    def getfo(</span>
<span class="gi">+        self,</span>
<span class="gi">+        remotepath,</span>
<span class="gi">+        fl,</span>
<span class="gi">+        callback=None,</span>
<span class="gi">+        prefetch=True,</span>
<span class="gi">+        max_concurrent_prefetch_requests=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy a remote file (``remotepath``) from the SFTP server and write to
<span class="w"> </span>        an open file or file-like object, ``fl``.  Any exception raised by
<span class="gu">@@ -499,10 +792,22 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 3.3
<span class="w"> </span>            Added ``max_concurrent_prefetch_requests``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get(self, remotepath, localpath, callback=None, prefetch=True,</span>
<span class="gd">-        max_concurrent_prefetch_requests=None):</span>
<span class="gi">+        file_size = self.stat(remotepath).st_size</span>
<span class="gi">+        with self.open(remotepath, &quot;rb&quot;) as fr:</span>
<span class="gi">+            if prefetch:</span>
<span class="gi">+                fr.prefetch(file_size, max_concurrent_prefetch_requests)</span>
<span class="gi">+            return self._transfer_with_callback(</span>
<span class="gi">+                reader=fr, writer=fl, file_size=file_size, callback=callback</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def get(</span>
<span class="gi">+        self,</span>
<span class="gi">+        remotepath,</span>
<span class="gi">+        localpath,</span>
<span class="gi">+        callback=None,</span>
<span class="gi">+        prefetch=True,</span>
<span class="gi">+        max_concurrent_prefetch_requests=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy a remote file (``remotepath``) from the SFTP server to the local
<span class="w"> </span>        host as ``localpath``.  Any exception raised by operations will be
<span class="gu">@@ -531,24 +836,130 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 3.3
<span class="w"> </span>            Added ``max_concurrent_prefetch_requests``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(localpath, &quot;wb&quot;) as fl:</span>
<span class="gi">+            size = self.getfo(</span>
<span class="gi">+                remotepath,</span>
<span class="gi">+                fl,</span>
<span class="gi">+                callback,</span>
<span class="gi">+                prefetch,</span>
<span class="gi">+                max_concurrent_prefetch_requests,</span>
<span class="gi">+            )</span>
<span class="gi">+        s = os.stat(localpath)</span>
<span class="gi">+        if s.st_size != size:</span>
<span class="gi">+            raise IOError(</span>
<span class="gi">+                &quot;size mismatch in get!  {} != {}&quot;.format(s.st_size, size)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _request(self, t, *args):</span>
<span class="gi">+        num = self._async_request(type(None), t, *args)</span>
<span class="gi">+        return self._read_response(num)</span>
<span class="gi">+</span>
<span class="gi">+    def _async_request(self, fileobj, t, *args):</span>
<span class="gi">+        # this method may be called from other threads (prefetch)</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            msg = Message()</span>
<span class="gi">+            msg.add_int(self.request_number)</span>
<span class="gi">+            for item in args:</span>
<span class="gi">+                if isinstance(item, int64):</span>
<span class="gi">+                    msg.add_int64(item)</span>
<span class="gi">+                elif isinstance(item, int):</span>
<span class="gi">+                    msg.add_int(item)</span>
<span class="gi">+                elif isinstance(item, SFTPAttributes):</span>
<span class="gi">+                    item._pack(msg)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # For all other types, rely on as_string() to either coerce</span>
<span class="gi">+                    # to bytes before writing or raise a suitable exception.</span>
<span class="gi">+                    msg.add_string(item)</span>
<span class="gi">+            num = self.request_number</span>
<span class="gi">+            self._expecting[num] = fileobj</span>
<span class="gi">+            self.request_number += 1</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>
<span class="gi">+        self._send_packet(t, msg)</span>
<span class="gi">+        return num</span>
<span class="gi">+</span>
<span class="gi">+    def _read_response(self, waitfor=None):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                t, data = self._read_packet()</span>
<span class="gi">+            except EOFError as e:</span>
<span class="gi">+                raise SSHException(&quot;Server connection dropped: {}&quot;.format(e))</span>
<span class="gi">+            msg = Message(data)</span>
<span class="gi">+            num = msg.get_int()</span>
<span class="gi">+            self._lock.acquire()</span>
<span class="gi">+            try:</span>
<span class="gi">+                if num not in self._expecting:</span>
<span class="gi">+                    # might be response for a file that was closed before</span>
<span class="gi">+                    # responses came back</span>
<span class="gi">+                    self._log(DEBUG, &quot;Unexpected response #{}&quot;.format(num))</span>
<span class="gi">+                    if waitfor is None:</span>
<span class="gi">+                        # just doing a single check</span>
<span class="gi">+                        break</span>
<span class="gi">+                    continue</span>
<span class="gi">+                fileobj = self._expecting[num]</span>
<span class="gi">+                del self._expecting[num]</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self._lock.release()</span>
<span class="gi">+            if num == waitfor:</span>
<span class="gi">+                # synchronous</span>
<span class="gi">+                if t == CMD_STATUS:</span>
<span class="gi">+                    self._convert_status(msg)</span>
<span class="gi">+                return t, msg</span>
<span class="gi">+</span>
<span class="gi">+            # can not rewrite this to deal with E721, either as a None check</span>
<span class="gi">+            # nor as not an instance of None or NoneType</span>
<span class="gi">+            if fileobj is not type(None):  # noqa</span>
<span class="gi">+                fileobj._async_response(t, msg, num)</span>
<span class="gi">+            if waitfor is None:</span>
<span class="gi">+                # just doing a single check</span>
<span class="gi">+                break</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    def _finish_responses(self, fileobj):</span>
<span class="gi">+        while fileobj in self._expecting.values():</span>
<span class="gi">+            self._read_response()</span>
<span class="gi">+            fileobj._check_exception()</span>

<span class="w"> </span>    def _convert_status(self, msg):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Raises EOFError or IOError on error status; otherwise does nothing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        code = msg.get_int()</span>
<span class="gi">+        text = msg.get_text()</span>
<span class="gi">+        if code == SFTP_OK:</span>
<span class="gi">+            return</span>
<span class="gi">+        elif code == SFTP_EOF:</span>
<span class="gi">+            raise EOFError(text)</span>
<span class="gi">+        elif code == SFTP_NO_SUCH_FILE:</span>
<span class="gi">+            # clever idea from john a. meinel: map the error codes to errno</span>
<span class="gi">+            raise IOError(errno.ENOENT, text)</span>
<span class="gi">+        elif code == SFTP_PERMISSION_DENIED:</span>
<span class="gi">+            raise IOError(errno.EACCES, text)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise IOError(text)</span>

<span class="w"> </span>    def _adjust_cwd(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return an adjusted path if we&#39;re emulating a &quot;current working
<span class="w"> </span>        directory&quot; for the server.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = b(path)</span>
<span class="gi">+        if self._cwd is None:</span>
<span class="gi">+            return path</span>
<span class="gi">+        if len(path) and path[0:1] == b_slash:</span>
<span class="gi">+            # absolute path</span>
<span class="gi">+            return path</span>
<span class="gi">+        if self._cwd == b_slash:</span>
<span class="gi">+            return self._cwd + path</span>
<span class="gi">+        return self._cwd + b_slash + path</span>


<span class="w"> </span>class SFTP(SFTPClient):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    An alias for `.SFTPClient` for backwards compatibility.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass
<span class="gh">diff --git a/paramiko/sftp_file.py b/paramiko/sftp_file.py</span>
<span class="gh">index e4ca900d..c74695e0 100644</span>
<span class="gd">--- a/paramiko/sftp_file.py</span>
<span class="gi">+++ b/paramiko/sftp_file.py</span>
<span class="gu">@@ -1,15 +1,48 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>SFTP file object
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from binascii import hexlify
<span class="w"> </span>from collections import deque
<span class="w"> </span>import socket
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="w"> </span>from paramiko.common import DEBUG, io_sleep
<span class="gi">+</span>
<span class="w"> </span>from paramiko.file import BufferedFile
<span class="w"> </span>from paramiko.util import u
<span class="gd">-from paramiko.sftp import CMD_CLOSE, CMD_READ, CMD_DATA, SFTPError, CMD_WRITE, CMD_STATUS, CMD_FSTAT, CMD_ATTRS, CMD_FSETSTAT, CMD_EXTENDED, int64</span>
<span class="gi">+from paramiko.sftp import (</span>
<span class="gi">+    CMD_CLOSE,</span>
<span class="gi">+    CMD_READ,</span>
<span class="gi">+    CMD_DATA,</span>
<span class="gi">+    SFTPError,</span>
<span class="gi">+    CMD_WRITE,</span>
<span class="gi">+    CMD_STATUS,</span>
<span class="gi">+    CMD_FSTAT,</span>
<span class="gi">+    CMD_ATTRS,</span>
<span class="gi">+    CMD_FSETSTAT,</span>
<span class="gi">+    CMD_EXTENDED,</span>
<span class="gi">+    int64,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.sftp_attr import SFTPAttributes


<span class="gu">@@ -20,9 +53,12 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>    Instances of this class may be used as context managers in the same way
<span class="w"> </span>    that built-in Python file objects are.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Some sftp servers will choke if you send read/write requests larger than</span>
<span class="gi">+    # this size.</span>
<span class="w"> </span>    MAX_REQUEST_SIZE = 32768

<span class="gd">-    def __init__(self, sftp, handle, mode=&#39;r&#39;, bufsize=-1):</span>
<span class="gi">+    def __init__(self, sftp, handle, mode=&quot;r&quot;, bufsize=-1):</span>
<span class="w"> </span>        BufferedFile.__init__(self)
<span class="w"> </span>        self.sftp = sftp
<span class="w"> </span>        self.handle = handle
<span class="gu">@@ -43,7 +79,55 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._close(async_=False)</span>
<span class="gi">+</span>
<span class="gi">+    def _close(self, async_=False):</span>
<span class="gi">+        # We allow double-close without signaling an error, because real</span>
<span class="gi">+        # Python file objects do.  However, we must protect against actually</span>
<span class="gi">+        # sending multiple CMD_CLOSE packets, because after we close our</span>
<span class="gi">+        # handle, the same handle may be re-allocated by the server, and we</span>
<span class="gi">+        # may end up mysteriously closing some random other file.  (This is</span>
<span class="gi">+        # especially important because we unconditionally call close() from</span>
<span class="gi">+        # __del__.)</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.sftp._log(DEBUG, &quot;close({})&quot;.format(u(hexlify(self.handle))))</span>
<span class="gi">+        if self.pipelined:</span>
<span class="gi">+            self.sftp._finish_responses(self)</span>
<span class="gi">+        BufferedFile.close(self)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if async_:</span>
<span class="gi">+                # GC&#39;d file handle could be called from an arbitrary thread</span>
<span class="gi">+                # -- don&#39;t wait for a response</span>
<span class="gi">+                self.sftp._async_request(type(None), CMD_CLOSE, self.handle)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.sftp._request(CMD_CLOSE, self.handle)</span>
<span class="gi">+        except EOFError:</span>
<span class="gi">+            # may have outlived the Transport connection</span>
<span class="gi">+            pass</span>
<span class="gi">+        except (IOError, socket.error):</span>
<span class="gi">+            # may have outlived the Transport connection</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def _data_in_prefetch_requests(self, offset, size):</span>
<span class="gi">+        k = [</span>
<span class="gi">+            x for x in list(self._prefetch_extents.values()) if x[0] &lt;= offset</span>
<span class="gi">+        ]</span>
<span class="gi">+        if len(k) == 0:</span>
<span class="gi">+            return False</span>
<span class="gi">+        k.sort(key=lambda x: x[0])</span>
<span class="gi">+        buf_offset, buf_size = k[-1]</span>
<span class="gi">+        if buf_offset + buf_size &lt;= offset:</span>
<span class="gi">+            # prefetch request ends before this one begins</span>
<span class="gi">+            return False</span>
<span class="gi">+        if buf_offset + buf_size &gt;= offset + size:</span>
<span class="gi">+            # inclusive</span>
<span class="gi">+            return True</span>
<span class="gi">+        # well, we have part of the request.  see if another chunk has</span>
<span class="gi">+        # the rest.</span>
<span class="gi">+        return self._data_in_prefetch_requests(</span>
<span class="gi">+            buf_offset + buf_size, offset + size - buf_offset - buf_size</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _data_in_prefetch_buffers(self, offset):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -52,14 +136,80 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        return None.  this guarantees nothing about the number of bytes
<span class="w"> </span>        collected in the prefetch buffer so far.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        k = [i for i in self._prefetch_data.keys() if i &lt;= offset]</span>
<span class="gi">+        if len(k) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        index = max(k)</span>
<span class="gi">+        buf_offset = offset - index</span>
<span class="gi">+        if buf_offset &gt;= len(self._prefetch_data[index]):</span>
<span class="gi">+            # it&#39;s not here</span>
<span class="gi">+            return None</span>
<span class="gi">+        return index</span>

<span class="w"> </span>    def _read_prefetch(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        read data out of the prefetch buffer, if possible.  if the data isn&#39;t
<span class="w"> </span>        in the buffer, return None.  otherwise, behaves like a normal read.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # while not closed, and haven&#39;t fetched past the current position,</span>
<span class="gi">+        # and haven&#39;t reached EOF...</span>
<span class="gi">+        while True:</span>
<span class="gi">+            offset = self._data_in_prefetch_buffers(self._realpos)</span>
<span class="gi">+            if offset is not None:</span>
<span class="gi">+                break</span>
<span class="gi">+            if self._prefetch_done or self._closed:</span>
<span class="gi">+                break</span>
<span class="gi">+            self.sftp._read_response()</span>
<span class="gi">+            self._check_exception()</span>
<span class="gi">+        if offset is None:</span>
<span class="gi">+            self._prefetching = False</span>
<span class="gi">+            return None</span>
<span class="gi">+        prefetch = self._prefetch_data[offset]</span>
<span class="gi">+        del self._prefetch_data[offset]</span>
<span class="gi">+</span>
<span class="gi">+        buf_offset = self._realpos - offset</span>
<span class="gi">+        if buf_offset &gt; 0:</span>
<span class="gi">+            self._prefetch_data[offset] = prefetch[:buf_offset]</span>
<span class="gi">+            prefetch = prefetch[buf_offset:]</span>
<span class="gi">+        if size &lt; len(prefetch):</span>
<span class="gi">+            self._prefetch_data[self._realpos + size] = prefetch[size:]</span>
<span class="gi">+            prefetch = prefetch[:size]</span>
<span class="gi">+        return prefetch</span>
<span class="gi">+</span>
<span class="gi">+    def _read(self, size):</span>
<span class="gi">+        size = min(size, self.MAX_REQUEST_SIZE)</span>
<span class="gi">+        if self._prefetching:</span>
<span class="gi">+            data = self._read_prefetch(size)</span>
<span class="gi">+            if data is not None:</span>
<span class="gi">+                return data</span>
<span class="gi">+        t, msg = self.sftp._request(</span>
<span class="gi">+            CMD_READ, self.handle, int64(self._realpos), int(size)</span>
<span class="gi">+        )</span>
<span class="gi">+        if t != CMD_DATA:</span>
<span class="gi">+            raise SFTPError(&quot;Expected data&quot;)</span>
<span class="gi">+        return msg.get_string()</span>
<span class="gi">+</span>
<span class="gi">+    def _write(self, data):</span>
<span class="gi">+        # may write less than requested if it would exceed max packet size</span>
<span class="gi">+        chunk = min(len(data), self.MAX_REQUEST_SIZE)</span>
<span class="gi">+        sftp_async_request = self.sftp._async_request(</span>
<span class="gi">+            type(None),</span>
<span class="gi">+            CMD_WRITE,</span>
<span class="gi">+            self.handle,</span>
<span class="gi">+            int64(self._realpos),</span>
<span class="gi">+            data[:chunk],</span>
<span class="gi">+        )</span>
<span class="gi">+        self._reqs.append(sftp_async_request)</span>
<span class="gi">+        if not self.pipelined or (</span>
<span class="gi">+            len(self._reqs) &gt; 100 and self.sftp.sock.recv_ready()</span>
<span class="gi">+        ):</span>
<span class="gi">+            while len(self._reqs):</span>
<span class="gi">+                req = self._reqs.popleft()</span>
<span class="gi">+                t, msg = self.sftp._read_response(req)</span>
<span class="gi">+                if t != CMD_STATUS:</span>
<span class="gi">+                    raise SFTPError(&quot;Expected status&quot;)</span>
<span class="gi">+                # convert_status already called</span>
<span class="gi">+        return chunk</span>

<span class="w"> </span>    def settimeout(self, timeout):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -72,7 +222,7 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. seealso:: `.Channel.settimeout`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sftp.sock.settimeout(timeout)</span>

<span class="w"> </span>    def gettimeout(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -81,7 +231,7 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. seealso:: `.Channel.gettimeout`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sftp.sock.gettimeout()</span>

<span class="w"> </span>    def setblocking(self, blocking):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -93,7 +243,7 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. seealso:: `.Channel.setblocking`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sftp.sock.setblocking(blocking)</span>

<span class="w"> </span>    def seekable(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -103,7 +253,7 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>            `True` if the file supports random access. If `False`,
<span class="w"> </span>            :meth:`seek` will raise an exception
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def seek(self, offset, whence=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -111,7 +261,15 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        See `file.seek` for details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        if whence == self.SEEK_SET:</span>
<span class="gi">+            self._realpos = self._pos = offset</span>
<span class="gi">+        elif whence == self.SEEK_CUR:</span>
<span class="gi">+            self._pos += offset</span>
<span class="gi">+            self._realpos = self._pos</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._realpos = self._pos = self._get_size() + offset</span>
<span class="gi">+        self._rbuffer = bytes()</span>

<span class="w"> </span>    def stat(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -122,7 +280,10 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        :returns:
<span class="w"> </span>            an `.SFTPAttributes` object containing attributes about this file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        t, msg = self.sftp._request(CMD_FSTAT, self.handle)</span>
<span class="gi">+        if t != CMD_ATTRS:</span>
<span class="gi">+            raise SFTPError(&quot;Expected attributes&quot;)</span>
<span class="gi">+        return SFTPAttributes._from_msg(msg)</span>

<span class="w"> </span>    def chmod(self, mode):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -132,7 +293,12 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        :param int mode: new permissions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sftp._log(</span>
<span class="gi">+            DEBUG, &quot;chmod({}, {!r})&quot;.format(hexlify(self.handle), mode)</span>
<span class="gi">+        )</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_mode = mode</span>
<span class="gi">+        self.sftp._request(CMD_FSETSTAT, self.handle, attr)</span>

<span class="w"> </span>    def chown(self, uid, gid):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -144,7 +310,13 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        :param int uid: new owner&#39;s uid
<span class="w"> </span>        :param int gid: new group id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sftp._log(</span>
<span class="gi">+            DEBUG,</span>
<span class="gi">+            &quot;chown({}, {!r}, {!r})&quot;.format(hexlify(self.handle), uid, gid),</span>
<span class="gi">+        )</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_uid, attr.st_gid = uid, gid</span>
<span class="gi">+        self.sftp._request(CMD_FSETSTAT, self.handle, attr)</span>

<span class="w"> </span>    def utime(self, times):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -159,7 +331,14 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>            ``None`` or a tuple of (access time, modified time) in standard
<span class="w"> </span>            internet epoch time (seconds since 01 January 1970 GMT)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if times is None:</span>
<span class="gi">+            times = (time.time(), time.time())</span>
<span class="gi">+        self.sftp._log(</span>
<span class="gi">+            DEBUG, &quot;utime({}, {!r})&quot;.format(hexlify(self.handle), times)</span>
<span class="gi">+        )</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_atime, attr.st_mtime = times</span>
<span class="gi">+        self.sftp._request(CMD_FSETSTAT, self.handle, attr)</span>

<span class="w"> </span>    def truncate(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -169,7 +348,12 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        :param size: the new size of the file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sftp._log(</span>
<span class="gi">+            DEBUG, &quot;truncate({}, {!r})&quot;.format(hexlify(self.handle), size)</span>
<span class="gi">+        )</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_size = size</span>
<span class="gi">+        self.sftp._request(CMD_FSETSTAT, self.handle, attr)</span>

<span class="w"> </span>    def check(self, hash_algorithm, offset=0, length=0, block_size=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -217,7 +401,19 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. versionadded:: 1.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        t, msg = self.sftp._request(</span>
<span class="gi">+            CMD_EXTENDED,</span>
<span class="gi">+            &quot;check-file&quot;,</span>
<span class="gi">+            self.handle,</span>
<span class="gi">+            hash_algorithm,</span>
<span class="gi">+            int64(offset),</span>
<span class="gi">+            int64(length),</span>
<span class="gi">+            block_size,</span>
<span class="gi">+        )</span>
<span class="gi">+        msg.get_text()  # ext</span>
<span class="gi">+        msg.get_text()  # alg</span>
<span class="gi">+        data = msg.get_remainder()</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def set_pipelined(self, pipelined=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -237,7 +433,7 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. versionadded:: 1.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.pipelined = pipelined</span>

<span class="w"> </span>    def prefetch(self, file_size=None, max_concurrent_requests=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -272,7 +468,18 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        .. versionchanged:: 3.3
<span class="w"> </span>            Added ``max_concurrent_requests``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if file_size is None:</span>
<span class="gi">+            file_size = self.stat().st_size</span>
<span class="gi">+</span>
<span class="gi">+        # queue up async reads for the rest of the file</span>
<span class="gi">+        chunks = []</span>
<span class="gi">+        n = self._realpos</span>
<span class="gi">+        while n &lt; file_size:</span>
<span class="gi">+            chunk = min(self.MAX_REQUEST_SIZE, file_size - n)</span>
<span class="gi">+            chunks.append((n, chunk))</span>
<span class="gi">+            n += chunk</span>
<span class="gi">+        if len(chunks) &gt; 0:</span>
<span class="gi">+            self._start_prefetch(chunks, max_concurrent_requests)</span>

<span class="w"> </span>    def readv(self, chunks, max_concurrent_prefetch_requests=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -294,8 +501,94 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        .. versionchanged:: 3.3
<span class="w"> </span>            Added ``max_concurrent_prefetch_requests``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sftp._log(</span>
<span class="gi">+            DEBUG, &quot;readv({}, {!r})&quot;.format(hexlify(self.handle), chunks)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        read_chunks = []</span>
<span class="gi">+        for offset, size in chunks:</span>
<span class="gi">+            # don&#39;t fetch data that&#39;s already in the prefetch buffer</span>
<span class="gi">+            if self._data_in_prefetch_buffers(</span>
<span class="gi">+                offset</span>
<span class="gi">+            ) or self._data_in_prefetch_requests(offset, size):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # break up anything larger than the max read size</span>
<span class="gi">+            while size &gt; 0:</span>
<span class="gi">+                chunk_size = min(size, self.MAX_REQUEST_SIZE)</span>
<span class="gi">+                read_chunks.append((offset, chunk_size))</span>
<span class="gi">+                offset += chunk_size</span>
<span class="gi">+                size -= chunk_size</span>
<span class="gi">+</span>
<span class="gi">+        self._start_prefetch(read_chunks, max_concurrent_prefetch_requests)</span>
<span class="gi">+        # now we can just devolve to a bunch of read()s :)</span>
<span class="gi">+        for x in chunks:</span>
<span class="gi">+            self.seek(x[0])</span>
<span class="gi">+            yield self.read(x[1])</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _get_size(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.stat().st_size</span>
<span class="gi">+        except:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+    def _start_prefetch(self, chunks, max_concurrent_requests=None):</span>
<span class="gi">+        self._prefetching = True</span>
<span class="gi">+        self._prefetch_done = False</span>
<span class="gi">+</span>
<span class="gi">+        t = threading.Thread(</span>
<span class="gi">+            target=self._prefetch_thread,</span>
<span class="gi">+            args=(chunks, max_concurrent_requests),</span>
<span class="gi">+        )</span>
<span class="gi">+        t.daemon = True</span>
<span class="gi">+        t.start()</span>
<span class="gi">+</span>
<span class="gi">+    def _prefetch_thread(self, chunks, max_concurrent_requests):</span>
<span class="gi">+        # do these read requests in a temporary thread because there may be</span>
<span class="gi">+        # a lot of them, so it may block.</span>
<span class="gi">+        for offset, length in chunks:</span>
<span class="gi">+            # Limit the number of concurrent requests in a busy-loop</span>
<span class="gi">+            if max_concurrent_requests is not None:</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    with self._prefetch_lock:</span>
<span class="gi">+                        pf_len = len(self._prefetch_extents)</span>
<span class="gi">+                        if pf_len &lt; max_concurrent_requests:</span>
<span class="gi">+                            break</span>
<span class="gi">+                    time.sleep(io_sleep)</span>
<span class="gi">+</span>
<span class="gi">+            num = self.sftp._async_request(</span>
<span class="gi">+                self, CMD_READ, self.handle, int64(offset), int(length)</span>
<span class="gi">+            )</span>
<span class="gi">+            with self._prefetch_lock:</span>
<span class="gi">+                self._prefetch_extents[num] = (offset, length)</span>
<span class="gi">+</span>
<span class="gi">+    def _async_response(self, t, msg, num):</span>
<span class="gi">+        if t == CMD_STATUS:</span>
<span class="gi">+            # save exception and re-raise it on next file operation</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.sftp._convert_status(msg)</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self._saved_exception = e</span>
<span class="gi">+            return</span>
<span class="gi">+        if t != CMD_DATA:</span>
<span class="gi">+            raise SFTPError(&quot;Expected data&quot;)</span>
<span class="gi">+        data = msg.get_string()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            with self._prefetch_lock:</span>
<span class="gi">+                # spin if in race with _prefetch_thread</span>
<span class="gi">+                if num in self._prefetch_extents:</span>
<span class="gi">+                    offset, length = self._prefetch_extents[num]</span>
<span class="gi">+                    self._prefetch_data[offset] = data</span>
<span class="gi">+                    del self._prefetch_extents[num]</span>
<span class="gi">+                    if len(self._prefetch_extents) == 0:</span>
<span class="gi">+                        self._prefetch_done = True</span>
<span class="gi">+                    break</span>

<span class="w"> </span>    def _check_exception(self):
<span class="w"> </span>        &quot;&quot;&quot;if there&#39;s a saved exception, raise &amp; clear it&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._saved_exception is not None:</span>
<span class="gi">+            x = self._saved_exception</span>
<span class="gi">+            self._saved_exception = None</span>
<span class="gi">+            raise x</span>
<span class="gh">diff --git a/paramiko/sftp_handle.py b/paramiko/sftp_handle.py</span>
<span class="gh">index 5b9d4a8b..b2046526 100644</span>
<span class="gd">--- a/paramiko/sftp_handle.py</span>
<span class="gi">+++ b/paramiko/sftp_handle.py</span>
<span class="gu">@@ -1,6 +1,25 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Abstraction of an SFTP file handle (for server mode).
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from paramiko.sftp import SFTP_OP_UNSUPPORTED, SFTP_OK
<span class="w"> </span>from paramiko.util import ClosingContextManager
<span class="gu">@@ -29,6 +48,7 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.__flags = flags
<span class="w"> </span>        self.__name = None
<span class="gi">+        # only for handles to folders:</span>
<span class="w"> </span>        self.__files = {}
<span class="w"> </span>        self.__tell = None

<span class="gu">@@ -44,7 +64,12 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        using the default implementations of `read` and `write`, this
<span class="w"> </span>        method&#39;s default implementation should be fine also.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        readfile = getattr(self, &quot;readfile&quot;, None)</span>
<span class="gi">+        if readfile is not None:</span>
<span class="gi">+            readfile.close()</span>
<span class="gi">+        writefile = getattr(self, &quot;writefile&quot;, None)</span>
<span class="gi">+        if writefile is not None:</span>
<span class="gi">+            writefile.close()</span>

<span class="w"> </span>    def read(self, offset, length):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -64,7 +89,21 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        :param int length: number of bytes to attempt to read.
<span class="w"> </span>        :return: the `bytes` read, or an error code `int`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        readfile = getattr(self, &quot;readfile&quot;, None)</span>
<span class="gi">+        if readfile is None:</span>
<span class="gi">+            return SFTP_OP_UNSUPPORTED</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.__tell is None:</span>
<span class="gi">+                self.__tell = readfile.tell()</span>
<span class="gi">+            if offset != self.__tell:</span>
<span class="gi">+                readfile.seek(offset)</span>
<span class="gi">+                self.__tell = offset</span>
<span class="gi">+            data = readfile.read(length)</span>
<span class="gi">+        except IOError as e:</span>
<span class="gi">+            self.__tell = None</span>
<span class="gi">+            return SFTPServer.convert_errno(e.errno)</span>
<span class="gi">+        self.__tell += len(data)</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def write(self, offset, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -84,7 +123,25 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        :param bytes data: data to write into the file.
<span class="w"> </span>        :return: an SFTP error code like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writefile = getattr(self, &quot;writefile&quot;, None)</span>
<span class="gi">+        if writefile is None:</span>
<span class="gi">+            return SFTP_OP_UNSUPPORTED</span>
<span class="gi">+        try:</span>
<span class="gi">+            # in append mode, don&#39;t care about seeking</span>
<span class="gi">+            if (self.__flags &amp; os.O_APPEND) == 0:</span>
<span class="gi">+                if self.__tell is None:</span>
<span class="gi">+                    self.__tell = writefile.tell()</span>
<span class="gi">+                if offset != self.__tell:</span>
<span class="gi">+                    writefile.seek(offset)</span>
<span class="gi">+                    self.__tell = offset</span>
<span class="gi">+            writefile.write(data)</span>
<span class="gi">+            writefile.flush()</span>
<span class="gi">+        except IOError as e:</span>
<span class="gi">+            self.__tell = None</span>
<span class="gi">+            return SFTPServer.convert_errno(e.errno)</span>
<span class="gi">+        if self.__tell is not None:</span>
<span class="gi">+            self.__tell += len(data)</span>
<span class="gi">+        return SFTP_OK</span>

<span class="w"> </span>    def stat(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -97,7 +154,7 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>            (like ``SFTP_PERMISSION_DENIED``).
<span class="w"> </span>        :rtype: `.SFTPAttributes` or error code
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def chattr(self, attr):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -108,7 +165,9 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        :param .SFTPAttributes attr: the attributes to change on this file.
<span class="w"> </span>        :return: an `int` error code like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>

<span class="w"> </span>    def _set_files(self, files):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -116,14 +175,22 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        the SFTP protocol, listing a directory is a multi-stage process
<span class="w"> </span>        requiring a temporary handle.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__files = files</span>

<span class="w"> </span>    def _get_next_files(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used by the SFTP server code to retrieve a cached directory
<span class="w"> </span>        listing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fnlist = self.__files[:16]</span>
<span class="gi">+        self.__files = self.__files[16:]</span>
<span class="gi">+        return fnlist</span>
<span class="gi">+</span>
<span class="gi">+    def _get_name(self):</span>
<span class="gi">+        return self.__name</span>
<span class="gi">+</span>
<span class="gi">+    def _set_name(self, name):</span>
<span class="gi">+        self.__name = name</span>


<span class="w"> </span>from paramiko.sftp_server import SFTPServer
<span class="gh">diff --git a/paramiko/sftp_server.py b/paramiko/sftp_server.py</span>
<span class="gh">index 2ffa92dd..cd3910dc 100644</span>
<span class="gd">--- a/paramiko/sftp_server.py</span>
<span class="gi">+++ b/paramiko/sftp_server.py</span>
<span class="gu">@@ -1,19 +1,88 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Server-mode SFTP support.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import errno
<span class="w"> </span>import sys
<span class="w"> </span>from hashlib import md5, sha1
<span class="gi">+</span>
<span class="w"> </span>from paramiko import util
<span class="gd">-from paramiko.sftp import BaseSFTP, Message, SFTP_FAILURE, SFTP_PERMISSION_DENIED, SFTP_NO_SUCH_FILE, int64</span>
<span class="gi">+from paramiko.sftp import (</span>
<span class="gi">+    BaseSFTP,</span>
<span class="gi">+    Message,</span>
<span class="gi">+    SFTP_FAILURE,</span>
<span class="gi">+    SFTP_PERMISSION_DENIED,</span>
<span class="gi">+    SFTP_NO_SUCH_FILE,</span>
<span class="gi">+    int64,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.sftp_si import SFTPServerInterface
<span class="w"> </span>from paramiko.sftp_attr import SFTPAttributes
<span class="w"> </span>from paramiko.common import DEBUG
<span class="w"> </span>from paramiko.server import SubsystemHandler
<span class="w"> </span>from paramiko.util import b
<span class="gd">-from paramiko.sftp import CMD_HANDLE, SFTP_DESC, CMD_STATUS, SFTP_EOF, CMD_NAME, SFTP_BAD_MESSAGE, CMD_EXTENDED_REPLY, SFTP_FLAG_READ, SFTP_FLAG_WRITE, SFTP_FLAG_APPEND, SFTP_FLAG_CREATE, SFTP_FLAG_TRUNC, SFTP_FLAG_EXCL, CMD_NAMES, CMD_OPEN, CMD_CLOSE, SFTP_OK, CMD_READ, CMD_DATA, CMD_WRITE, CMD_REMOVE, CMD_RENAME, CMD_MKDIR, CMD_RMDIR, CMD_OPENDIR, CMD_READDIR, CMD_STAT, CMD_ATTRS, CMD_LSTAT, CMD_FSTAT, CMD_SETSTAT, CMD_FSETSTAT, CMD_READLINK, CMD_SYMLINK, CMD_REALPATH, CMD_EXTENDED, SFTP_OP_UNSUPPORTED</span>
<span class="gd">-_hash_class = {&#39;sha1&#39;: sha1, &#39;md5&#39;: md5}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# known hash algorithms for the &quot;check-file&quot; extension</span>
<span class="gi">+from paramiko.sftp import (</span>
<span class="gi">+    CMD_HANDLE,</span>
<span class="gi">+    SFTP_DESC,</span>
<span class="gi">+    CMD_STATUS,</span>
<span class="gi">+    SFTP_EOF,</span>
<span class="gi">+    CMD_NAME,</span>
<span class="gi">+    SFTP_BAD_MESSAGE,</span>
<span class="gi">+    CMD_EXTENDED_REPLY,</span>
<span class="gi">+    SFTP_FLAG_READ,</span>
<span class="gi">+    SFTP_FLAG_WRITE,</span>
<span class="gi">+    SFTP_FLAG_APPEND,</span>
<span class="gi">+    SFTP_FLAG_CREATE,</span>
<span class="gi">+    SFTP_FLAG_TRUNC,</span>
<span class="gi">+    SFTP_FLAG_EXCL,</span>
<span class="gi">+    CMD_NAMES,</span>
<span class="gi">+    CMD_OPEN,</span>
<span class="gi">+    CMD_CLOSE,</span>
<span class="gi">+    SFTP_OK,</span>
<span class="gi">+    CMD_READ,</span>
<span class="gi">+    CMD_DATA,</span>
<span class="gi">+    CMD_WRITE,</span>
<span class="gi">+    CMD_REMOVE,</span>
<span class="gi">+    CMD_RENAME,</span>
<span class="gi">+    CMD_MKDIR,</span>
<span class="gi">+    CMD_RMDIR,</span>
<span class="gi">+    CMD_OPENDIR,</span>
<span class="gi">+    CMD_READDIR,</span>
<span class="gi">+    CMD_STAT,</span>
<span class="gi">+    CMD_ATTRS,</span>
<span class="gi">+    CMD_LSTAT,</span>
<span class="gi">+    CMD_FSTAT,</span>
<span class="gi">+    CMD_SETSTAT,</span>
<span class="gi">+    CMD_FSETSTAT,</span>
<span class="gi">+    CMD_READLINK,</span>
<span class="gi">+    CMD_SYMLINK,</span>
<span class="gi">+    CMD_REALPATH,</span>
<span class="gi">+    CMD_EXTENDED,</span>
<span class="gi">+    SFTP_OP_UNSUPPORTED,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+_hash_class = {&quot;sha1&quot;: sha1, &quot;md5&quot;: md5}</span>


<span class="w"> </span>class SFTPServer(BaseSFTP, SubsystemHandler):
<span class="gu">@@ -23,8 +92,15 @@ class SFTPServer(BaseSFTP, SubsystemHandler):</span>
<span class="w"> </span>    Use `.Transport.set_subsystem_handler` to activate this class.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, channel, name, server, sftp_si=SFTPServerInterface,</span>
<span class="gd">-        *args, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        channel,</span>
<span class="gi">+        name,</span>
<span class="gi">+        server,</span>
<span class="gi">+        sftp_si=SFTPServerInterface,</span>
<span class="gi">+        *args,</span>
<span class="gi">+        **kwargs</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The constructor for SFTPServer is meant to be called from within the
<span class="w"> </span>        `.Transport` as a subsystem handler.  ``server`` and any additional
<span class="gu">@@ -42,13 +118,61 @@ class SFTPServer(BaseSFTP, SubsystemHandler):</span>
<span class="w"> </span>        BaseSFTP.__init__(self)
<span class="w"> </span>        SubsystemHandler.__init__(self, channel, name, server)
<span class="w"> </span>        transport = channel.get_transport()
<span class="gd">-        self.logger = util.get_logger(transport.get_log_channel() + &#39;.sftp&#39;)</span>
<span class="gi">+        self.logger = util.get_logger(transport.get_log_channel() + &quot;.sftp&quot;)</span>
<span class="w"> </span>        self.ultra_debug = transport.get_hexdump()
<span class="w"> </span>        self.next_handle = 1
<span class="gi">+        # map of handle-string to SFTPHandle for files &amp; folders:</span>
<span class="w"> </span>        self.file_table = {}
<span class="w"> </span>        self.folder_table = {}
<span class="w"> </span>        self.server = sftp_si(server, *args, **kwargs)

<span class="gi">+    def _log(self, level, msg):</span>
<span class="gi">+        if issubclass(type(msg), list):</span>
<span class="gi">+            for m in msg:</span>
<span class="gi">+                super()._log(level, &quot;[chan &quot; + self.sock.get_name() + &quot;] &quot; + m)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super()._log(level, &quot;[chan &quot; + self.sock.get_name() + &quot;] &quot; + msg)</span>
<span class="gi">+</span>
<span class="gi">+    def start_subsystem(self, name, transport, channel):</span>
<span class="gi">+        self.sock = channel</span>
<span class="gi">+        self._log(DEBUG, &quot;Started sftp server on channel {!r}&quot;.format(channel))</span>
<span class="gi">+        self._send_server_version()</span>
<span class="gi">+        self.server.session_started()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                t, data = self._read_packet()</span>
<span class="gi">+            except EOFError:</span>
<span class="gi">+                self._log(DEBUG, &quot;EOF -- end of session&quot;)</span>
<span class="gi">+                return</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self._log(DEBUG, &quot;Exception on channel: &quot; + str(e))</span>
<span class="gi">+                self._log(DEBUG, util.tb_strings())</span>
<span class="gi">+                return</span>
<span class="gi">+            msg = Message(data)</span>
<span class="gi">+            request_number = msg.get_int()</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._process(t, request_number, msg)</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self._log(DEBUG, &quot;Exception in server processing: &quot; + str(e))</span>
<span class="gi">+                self._log(DEBUG, util.tb_strings())</span>
<span class="gi">+                # send some kind of failure message, at least</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._send_status(request_number, SFTP_FAILURE)</span>
<span class="gi">+                except:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+    def finish_subsystem(self):</span>
<span class="gi">+        self.server.session_ended()</span>
<span class="gi">+        super().finish_subsystem()</span>
<span class="gi">+        # close any file handles that were left open</span>
<span class="gi">+        # (so we can return them to the OS quickly)</span>
<span class="gi">+        for f in self.file_table.values():</span>
<span class="gi">+            f.close()</span>
<span class="gi">+        for f in self.folder_table.values():</span>
<span class="gi">+            f.close()</span>
<span class="gi">+        self.file_table = {}</span>
<span class="gi">+        self.folder_table = {}</span>
<span class="gi">+</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def convert_errno(e):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -59,7 +183,14 @@ class SFTPServer(BaseSFTP, SubsystemHandler):</span>
<span class="w"> </span>        :param int e: an errno code, as from ``OSError.errno``.
<span class="w"> </span>        :return: an `int` SFTP error code like ``SFTP_NO_SUCH_FILE``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if e == errno.EACCES:</span>
<span class="gi">+            # permission denied</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        elif (e == errno.ENOENT) or (e == errno.ENOTDIR):</span>
<span class="gi">+            # no such file</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def set_file_attr(filename, attr):
<span class="gu">@@ -76,11 +207,331 @@ class SFTPServer(BaseSFTP, SubsystemHandler):</span>
<span class="w"> </span>            name of the file to alter (should usually be an absolute path).
<span class="w"> </span>        :param .SFTPAttributes attr: attributes to change.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if sys.platform != &quot;win32&quot;:</span>
<span class="gi">+            # mode operations are meaningless on win32</span>
<span class="gi">+            if attr._flags &amp; attr.FLAG_PERMISSIONS:</span>
<span class="gi">+                os.chmod(filename, attr.st_mode)</span>
<span class="gi">+            if attr._flags &amp; attr.FLAG_UIDGID:</span>
<span class="gi">+                os.chown(filename, attr.st_uid, attr.st_gid)</span>
<span class="gi">+        if attr._flags &amp; attr.FLAG_AMTIME:</span>
<span class="gi">+            os.utime(filename, (attr.st_atime, attr.st_mtime))</span>
<span class="gi">+        if attr._flags &amp; attr.FLAG_SIZE:</span>
<span class="gi">+            with open(filename, &quot;w+&quot;) as f:</span>
<span class="gi">+                f.truncate(attr.st_size)</span>
<span class="gi">+</span>
<span class="gi">+    # ...internals...</span>
<span class="gi">+</span>
<span class="gi">+    def _response(self, request_number, t, *args):</span>
<span class="gi">+        msg = Message()</span>
<span class="gi">+        msg.add_int(request_number)</span>
<span class="gi">+        for item in args:</span>
<span class="gi">+            # NOTE: this is a very silly tiny class used for SFTPFile mostly</span>
<span class="gi">+            if isinstance(item, int64):</span>
<span class="gi">+                msg.add_int64(item)</span>
<span class="gi">+            elif isinstance(item, int):</span>
<span class="gi">+                msg.add_int(item)</span>
<span class="gi">+            elif isinstance(item, (str, bytes)):</span>
<span class="gi">+                msg.add_string(item)</span>
<span class="gi">+            elif type(item) is SFTPAttributes:</span>
<span class="gi">+                item._pack(msg)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise Exception(</span>
<span class="gi">+                    &quot;unknown type for {!r} type {!r}&quot;.format(item, type(item))</span>
<span class="gi">+                )</span>
<span class="gi">+        self._send_packet(t, msg)</span>
<span class="gi">+</span>
<span class="gi">+    def _send_handle_response(self, request_number, handle, folder=False):</span>
<span class="gi">+        if not issubclass(type(handle), SFTPHandle):</span>
<span class="gi">+            # must be error code</span>
<span class="gi">+            self._send_status(request_number, handle)</span>
<span class="gi">+            return</span>
<span class="gi">+        handle._set_name(b(&quot;hx{:d}&quot;.format(self.next_handle)))</span>
<span class="gi">+        self.next_handle += 1</span>
<span class="gi">+        if folder:</span>
<span class="gi">+            self.folder_table[handle._get_name()] = handle</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.file_table[handle._get_name()] = handle</span>
<span class="gi">+        self._response(request_number, CMD_HANDLE, handle._get_name())</span>
<span class="gi">+</span>
<span class="gi">+    def _send_status(self, request_number, code, desc=None):</span>
<span class="gi">+        if desc is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                desc = SFTP_DESC[code]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                desc = &quot;Unknown&quot;</span>
<span class="gi">+        # some clients expect a &quot;language&quot; tag at the end</span>
<span class="gi">+        # (but don&#39;t mind it being blank)</span>
<span class="gi">+        self._response(request_number, CMD_STATUS, code, desc, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _open_folder(self, request_number, path):</span>
<span class="gi">+        resp = self.server.list_folder(path)</span>
<span class="gi">+        if issubclass(type(resp), list):</span>
<span class="gi">+            # got an actual list of filenames in the folder</span>
<span class="gi">+            folder = SFTPHandle()</span>
<span class="gi">+            folder._set_files(resp)</span>
<span class="gi">+            self._send_handle_response(request_number, folder, True)</span>
<span class="gi">+            return</span>
<span class="gi">+        # must be an error code</span>
<span class="gi">+        self._send_status(request_number, resp)</span>
<span class="gi">+</span>
<span class="gi">+    def _read_folder(self, request_number, folder):</span>
<span class="gi">+        flist = folder._get_next_files()</span>
<span class="gi">+        if len(flist) == 0:</span>
<span class="gi">+            self._send_status(request_number, SFTP_EOF)</span>
<span class="gi">+            return</span>
<span class="gi">+        msg = Message()</span>
<span class="gi">+        msg.add_int(request_number)</span>
<span class="gi">+        msg.add_int(len(flist))</span>
<span class="gi">+        for attr in flist:</span>
<span class="gi">+            msg.add_string(attr.filename)</span>
<span class="gi">+            msg.add_string(attr)</span>
<span class="gi">+            attr._pack(msg)</span>
<span class="gi">+        self._send_packet(CMD_NAME, msg)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_file(self, request_number, msg):</span>
<span class="gi">+        # this extension actually comes from v6 protocol, but since it&#39;s an</span>
<span class="gi">+        # extension, i feel like we can reasonably support it backported.</span>
<span class="gi">+        # it&#39;s very useful for verifying uploaded files or checking for</span>
<span class="gi">+        # rsync-like differences between local and remote files.</span>
<span class="gi">+        handle = msg.get_binary()</span>
<span class="gi">+        alg_list = msg.get_list()</span>
<span class="gi">+        start = msg.get_int64()</span>
<span class="gi">+        length = msg.get_int64()</span>
<span class="gi">+        block_size = msg.get_int()</span>
<span class="gi">+        if handle not in self.file_table:</span>
<span class="gi">+            self._send_status(</span>
<span class="gi">+                request_number, SFTP_BAD_MESSAGE, &quot;Invalid handle&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        f = self.file_table[handle]</span>
<span class="gi">+        for x in alg_list:</span>
<span class="gi">+            if x in _hash_class:</span>
<span class="gi">+                algname = x</span>
<span class="gi">+                alg = _hash_class[x]</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._send_status(</span>
<span class="gi">+                request_number, SFTP_FAILURE, &quot;No supported hash types found&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        if length == 0:</span>
<span class="gi">+            st = f.stat()</span>
<span class="gi">+            if not issubclass(type(st), SFTPAttributes):</span>
<span class="gi">+                self._send_status(request_number, st, &quot;Unable to stat file&quot;)</span>
<span class="gi">+                return</span>
<span class="gi">+            length = st.st_size - start</span>
<span class="gi">+        if block_size == 0:</span>
<span class="gi">+            block_size = length</span>
<span class="gi">+        if block_size &lt; 256:</span>
<span class="gi">+            self._send_status(</span>
<span class="gi">+                request_number, SFTP_FAILURE, &quot;Block size too small&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        sum_out = bytes()</span>
<span class="gi">+        offset = start</span>
<span class="gi">+        while offset &lt; start + length:</span>
<span class="gi">+            blocklen = min(block_size, start + length - offset)</span>
<span class="gi">+            # don&#39;t try to read more than about 64KB at a time</span>
<span class="gi">+            chunklen = min(blocklen, 65536)</span>
<span class="gi">+            count = 0</span>
<span class="gi">+            hash_obj = alg()</span>
<span class="gi">+            while count &lt; blocklen:</span>
<span class="gi">+                data = f.read(offset, chunklen)</span>
<span class="gi">+                if not isinstance(data, bytes):</span>
<span class="gi">+                    self._send_status(</span>
<span class="gi">+                        request_number, data, &quot;Unable to hash file&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                    return</span>
<span class="gi">+                hash_obj.update(data)</span>
<span class="gi">+                count += len(data)</span>
<span class="gi">+                offset += count</span>
<span class="gi">+            sum_out += hash_obj.digest()</span>
<span class="gi">+</span>
<span class="gi">+        msg = Message()</span>
<span class="gi">+        msg.add_int(request_number)</span>
<span class="gi">+        msg.add_string(&quot;check-file&quot;)</span>
<span class="gi">+        msg.add_string(algname)</span>
<span class="gi">+        msg.add_bytes(sum_out)</span>
<span class="gi">+        self._send_packet(CMD_EXTENDED_REPLY, msg)</span>

<span class="w"> </span>    def _convert_pflags(self, pflags):
<span class="w"> </span>        &quot;&quot;&quot;convert SFTP-style open() flags to Python&#39;s os.open() flags&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (pflags &amp; SFTP_FLAG_READ) and (pflags &amp; SFTP_FLAG_WRITE):</span>
<span class="gi">+            flags = os.O_RDWR</span>
<span class="gi">+        elif pflags &amp; SFTP_FLAG_WRITE:</span>
<span class="gi">+            flags = os.O_WRONLY</span>
<span class="gi">+        else:</span>
<span class="gi">+            flags = os.O_RDONLY</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_APPEND:</span>
<span class="gi">+            flags |= os.O_APPEND</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_CREATE:</span>
<span class="gi">+            flags |= os.O_CREAT</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_TRUNC:</span>
<span class="gi">+            flags |= os.O_TRUNC</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_EXCL:</span>
<span class="gi">+            flags |= os.O_EXCL</span>
<span class="gi">+        return flags</span>
<span class="gi">+</span>
<span class="gi">+    def _process(self, t, request_number, msg):</span>
<span class="gi">+        self._log(DEBUG, &quot;Request: {}&quot;.format(CMD_NAMES[t]))</span>
<span class="gi">+        if t == CMD_OPEN:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            flags = self._convert_pflags(msg.get_int())</span>
<span class="gi">+            attr = SFTPAttributes._from_msg(msg)</span>
<span class="gi">+            self._send_handle_response(</span>
<span class="gi">+                request_number, self.server.open(path, flags, attr)</span>
<span class="gi">+            )</span>
<span class="gi">+        elif t == CMD_CLOSE:</span>
<span class="gi">+            handle = msg.get_binary()</span>
<span class="gi">+            if handle in self.folder_table:</span>
<span class="gi">+                del self.folder_table[handle]</span>
<span class="gi">+                self._send_status(request_number, SFTP_OK)</span>
<span class="gi">+                return</span>
<span class="gi">+            if handle in self.file_table:</span>
<span class="gi">+                self.file_table[handle].close()</span>
<span class="gi">+                del self.file_table[handle]</span>
<span class="gi">+                self._send_status(request_number, SFTP_OK)</span>
<span class="gi">+                return</span>
<span class="gi">+            self._send_status(</span>
<span class="gi">+                request_number, SFTP_BAD_MESSAGE, &quot;Invalid handle&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        elif t == CMD_READ:</span>
<span class="gi">+            handle = msg.get_binary()</span>
<span class="gi">+            offset = msg.get_int64()</span>
<span class="gi">+            length = msg.get_int()</span>
<span class="gi">+            if handle not in self.file_table:</span>
<span class="gi">+                self._send_status(</span>
<span class="gi">+                    request_number, SFTP_BAD_MESSAGE, &quot;Invalid handle&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                return</span>
<span class="gi">+            data = self.file_table[handle].read(offset, length)</span>
<span class="gi">+            if isinstance(data, (bytes, str)):</span>
<span class="gi">+                if len(data) == 0:</span>
<span class="gi">+                    self._send_status(request_number, SFTP_EOF)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._response(request_number, CMD_DATA, data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._send_status(request_number, data)</span>
<span class="gi">+        elif t == CMD_WRITE:</span>
<span class="gi">+            handle = msg.get_binary()</span>
<span class="gi">+            offset = msg.get_int64()</span>
<span class="gi">+            data = msg.get_binary()</span>
<span class="gi">+            if handle not in self.file_table:</span>
<span class="gi">+                self._send_status(</span>
<span class="gi">+                    request_number, SFTP_BAD_MESSAGE, &quot;Invalid handle&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                return</span>
<span class="gi">+            self._send_status(</span>
<span class="gi">+                request_number, self.file_table[handle].write(offset, data)</span>
<span class="gi">+            )</span>
<span class="gi">+        elif t == CMD_REMOVE:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            self._send_status(request_number, self.server.remove(path))</span>
<span class="gi">+        elif t == CMD_RENAME:</span>
<span class="gi">+            oldpath = msg.get_text()</span>
<span class="gi">+            newpath = msg.get_text()</span>
<span class="gi">+            self._send_status(</span>
<span class="gi">+                request_number, self.server.rename(oldpath, newpath)</span>
<span class="gi">+            )</span>
<span class="gi">+        elif t == CMD_MKDIR:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            attr = SFTPAttributes._from_msg(msg)</span>
<span class="gi">+            self._send_status(request_number, self.server.mkdir(path, attr))</span>
<span class="gi">+        elif t == CMD_RMDIR:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            self._send_status(request_number, self.server.rmdir(path))</span>
<span class="gi">+        elif t == CMD_OPENDIR:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            self._open_folder(request_number, path)</span>
<span class="gi">+            return</span>
<span class="gi">+        elif t == CMD_READDIR:</span>
<span class="gi">+            handle = msg.get_binary()</span>
<span class="gi">+            if handle not in self.folder_table:</span>
<span class="gi">+                self._send_status(</span>
<span class="gi">+                    request_number, SFTP_BAD_MESSAGE, &quot;Invalid handle&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                return</span>
<span class="gi">+            folder = self.folder_table[handle]</span>
<span class="gi">+            self._read_folder(request_number, folder)</span>
<span class="gi">+        elif t == CMD_STAT:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            resp = self.server.stat(path)</span>
<span class="gi">+            if issubclass(type(resp), SFTPAttributes):</span>
<span class="gi">+                self._response(request_number, CMD_ATTRS, resp)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._send_status(request_number, resp)</span>
<span class="gi">+        elif t == CMD_LSTAT:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            resp = self.server.lstat(path)</span>
<span class="gi">+            if issubclass(type(resp), SFTPAttributes):</span>
<span class="gi">+                self._response(request_number, CMD_ATTRS, resp)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._send_status(request_number, resp)</span>
<span class="gi">+        elif t == CMD_FSTAT:</span>
<span class="gi">+            handle = msg.get_binary()</span>
<span class="gi">+            if handle not in self.file_table:</span>
<span class="gi">+                self._send_status(</span>
<span class="gi">+                    request_number, SFTP_BAD_MESSAGE, &quot;Invalid handle&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                return</span>
<span class="gi">+            resp = self.file_table[handle].stat()</span>
<span class="gi">+            if issubclass(type(resp), SFTPAttributes):</span>
<span class="gi">+                self._response(request_number, CMD_ATTRS, resp)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._send_status(request_number, resp)</span>
<span class="gi">+        elif t == CMD_SETSTAT:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            attr = SFTPAttributes._from_msg(msg)</span>
<span class="gi">+            self._send_status(request_number, self.server.chattr(path, attr))</span>
<span class="gi">+        elif t == CMD_FSETSTAT:</span>
<span class="gi">+            handle = msg.get_binary()</span>
<span class="gi">+            attr = SFTPAttributes._from_msg(msg)</span>
<span class="gi">+            if handle not in self.file_table:</span>
<span class="gi">+                self._response(</span>
<span class="gi">+                    request_number, SFTP_BAD_MESSAGE, &quot;Invalid handle&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                return</span>
<span class="gi">+            self._send_status(</span>
<span class="gi">+                request_number, self.file_table[handle].chattr(attr)</span>
<span class="gi">+            )</span>
<span class="gi">+        elif t == CMD_READLINK:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            resp = self.server.readlink(path)</span>
<span class="gi">+            if isinstance(resp, (bytes, str)):</span>
<span class="gi">+                self._response(</span>
<span class="gi">+                    request_number, CMD_NAME, 1, resp, &quot;&quot;, SFTPAttributes()</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._send_status(request_number, resp)</span>
<span class="gi">+        elif t == CMD_SYMLINK:</span>
<span class="gi">+            # the sftp 2 draft is incorrect here!</span>
<span class="gi">+            # path always follows target_path</span>
<span class="gi">+            target_path = msg.get_text()</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            self._send_status(</span>
<span class="gi">+                request_number, self.server.symlink(target_path, path)</span>
<span class="gi">+            )</span>
<span class="gi">+        elif t == CMD_REALPATH:</span>
<span class="gi">+            path = msg.get_text()</span>
<span class="gi">+            rpath = self.server.canonicalize(path)</span>
<span class="gi">+            self._response(</span>
<span class="gi">+                request_number, CMD_NAME, 1, rpath, &quot;&quot;, SFTPAttributes()</span>
<span class="gi">+            )</span>
<span class="gi">+        elif t == CMD_EXTENDED:</span>
<span class="gi">+            tag = msg.get_text()</span>
<span class="gi">+            if tag == &quot;check-file&quot;:</span>
<span class="gi">+                self._check_file(request_number, msg)</span>
<span class="gi">+            elif tag == &quot;posix-rename@openssh.com&quot;:</span>
<span class="gi">+                oldpath = msg.get_text()</span>
<span class="gi">+                newpath = msg.get_text()</span>
<span class="gi">+                self._send_status(</span>
<span class="gi">+                    request_number, self.server.posix_rename(oldpath, newpath)</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._send_status(request_number, SFTP_OP_UNSUPPORTED)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._send_status(request_number, SFTP_OP_UNSUPPORTED)</span>


<span class="w"> </span>from paramiko.sftp_handle import SFTPHandle
<span class="gh">diff --git a/paramiko/sftp_si.py b/paramiko/sftp_si.py</span>
<span class="gh">index e0b4e643..72b5db94 100644</span>
<span class="gd">--- a/paramiko/sftp_si.py</span>
<span class="gi">+++ b/paramiko/sftp_si.py</span>
<span class="gu">@@ -1,6 +1,25 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>An interface to override for SFTP server support.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from paramiko.sftp import SFTP_OP_UNSUPPORTED
<span class="gu">@@ -86,7 +105,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            requested attributes of the file if it is newly created.
<span class="w"> </span>        :return: a new `.SFTPHandle` or error code.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def list_folder(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -118,7 +137,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            direct translation from the SFTP server path to your local
<span class="w"> </span>            filesystem.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def stat(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -134,7 +153,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            an `.SFTPAttributes` object for the given file, or an SFTP error
<span class="w"> </span>            code (like ``SFTP_PERMISSION_DENIED``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def lstat(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -152,7 +171,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            an `.SFTPAttributes` object for the given file, or an SFTP error
<span class="w"> </span>            code (like ``SFTP_PERMISSION_DENIED``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def remove(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -162,7 +181,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            the requested path (relative or absolute) of the file to delete.
<span class="w"> </span>        :return: an SFTP error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def rename(self, oldpath, newpath):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -186,7 +205,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>        :param str newpath: the requested new path of the file.
<span class="w"> </span>        :return: an SFTP error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def posix_rename(self, oldpath, newpath):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -200,7 +219,7 @@ class SFTPServerInterface:</span>

<span class="w"> </span>        :versionadded: 2.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def mkdir(self, path, attr):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -217,7 +236,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>        :param .SFTPAttributes attr: requested attributes of the new folder.
<span class="w"> </span>        :return: an SFTP error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def rmdir(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -229,7 +248,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            requested path (relative or absolute) of the folder to remove.
<span class="w"> </span>        :return: an SFTP error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def chattr(self, path, attr):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -244,7 +263,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            object)
<span class="w"> </span>        :return: an error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def canonicalize(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -260,7 +279,14 @@ class SFTPServerInterface:</span>

<span class="w"> </span>        The default implementation returns ``os.path.normpath(&#39;/&#39; + path)``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if os.path.isabs(path):</span>
<span class="gi">+            out = os.path.normpath(path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            out = os.path.normpath(&quot;/&quot; + path)</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            # on windows, normalize backslashes to sftp/posix format</span>
<span class="gi">+            out = out.replace(&quot;\\&quot;, &quot;/&quot;)</span>
<span class="gi">+        return out</span>

<span class="w"> </span>    def readlink(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -273,7 +299,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            the target `str` path of the symbolic link, or an error code like
<span class="w"> </span>            ``SFTP_NO_SUCH_FILE``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def symlink(self, target_path, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -287,4 +313,4 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            path (relative or absolute) of the symbolic link to create.
<span class="w"> </span>        :return: an error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>
<span class="gh">diff --git a/paramiko/ssh_exception.py b/paramiko/ssh_exception.py</span>
<span class="gh">index f09c6eb0..2b68ebe8 100644</span>
<span class="gd">--- a/paramiko/ssh_exception.py</span>
<span class="gi">+++ b/paramiko/ssh_exception.py</span>
<span class="gu">@@ -1,3 +1,21 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>import socket


<span class="gu">@@ -5,6 +23,7 @@ class SSHException(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Exception raised by failures in SSH2 protocol negotiation or logic errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -16,6 +35,7 @@ class AuthenticationException(SSHException):</span>

<span class="w"> </span>    .. versionadded:: 1.6
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -23,6 +43,7 @@ class PasswordRequiredException(AuthenticationException):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Exception raised when a password is needed to unlock a private key file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -34,22 +55,28 @@ class BadAuthenticationType(AuthenticationException):</span>

<span class="w"> </span>    .. versionadded:: 1.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    allowed_types = []

<span class="gi">+    # TODO 4.0: remove explanation kwarg</span>
<span class="w"> </span>    def __init__(self, explanation, types):
<span class="gi">+        # TODO 4.0: remove this supercall unless it&#39;s actually required for</span>
<span class="gi">+        # pickling (after fixing pickling)</span>
<span class="w"> </span>        AuthenticationException.__init__(self, explanation, types)
<span class="w"> </span>        self.explanation = explanation
<span class="w"> </span>        self.allowed_types = types

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;{}; allowed types: {!r}&#39;.format(self.explanation, self.</span>
<span class="gd">-            allowed_types)</span>
<span class="gi">+        return &quot;{}; allowed types: {!r}&quot;.format(</span>
<span class="gi">+            self.explanation, self.allowed_types</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PartialAuthentication(AuthenticationException):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    An internal exception thrown in the case of partial authentication.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    allowed_types = []

<span class="w"> </span>    def __init__(self, types):
<span class="gu">@@ -57,10 +84,12 @@ class PartialAuthentication(AuthenticationException):</span>
<span class="w"> </span>        self.allowed_types = types

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;Partial authentication; allowed types: {!r}&#39;.format(self.</span>
<span class="gd">-            allowed_types)</span>
<span class="gi">+        return &quot;Partial authentication; allowed types: {!r}&quot;.format(</span>
<span class="gi">+            self.allowed_types</span>
<span class="gi">+        )</span>


<span class="gi">+# TODO 4.0: stop inheriting from SSHException, move to auth.py</span>
<span class="w"> </span>class UnableToAuthenticate(AuthenticationException):
<span class="w"> </span>    pass

<span class="gu">@@ -80,7 +109,7 @@ class ChannelException(SSHException):</span>
<span class="w"> </span>        self.text = text

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;ChannelException({!r}, {!r})&#39;.format(self.code, self.text)</span>
<span class="gi">+        return &quot;ChannelException({!r}, {!r})&quot;.format(self.code, self.text)</span>


<span class="w"> </span>class BadHostKeyException(SSHException):
<span class="gu">@@ -101,10 +130,12 @@ class BadHostKeyException(SSHException):</span>
<span class="w"> </span>        self.expected_key = expected_key

<span class="w"> </span>    def __str__(self):
<span class="gd">-        msg = (</span>
<span class="gd">-            &quot;Host key for server &#39;{}&#39; does not match: got &#39;{}&#39;, expected &#39;{}&#39;&quot;)</span>
<span class="gd">-        return msg.format(self.hostname, self.key.get_base64(), self.</span>
<span class="gd">-            expected_key.get_base64())</span>
<span class="gi">+        msg = &quot;Host key for server &#39;{}&#39; does not match: got &#39;{}&#39;, expected &#39;{}&#39;&quot;  # noqa</span>
<span class="gi">+        return msg.format(</span>
<span class="gi">+            self.hostname,</span>
<span class="gi">+            self.key.get_base64(),</span>
<span class="gi">+            self.expected_key.get_base64(),</span>
<span class="gi">+        )</span>


<span class="w"> </span>class IncompatiblePeer(SSHException):
<span class="gu">@@ -113,6 +144,12 @@ class IncompatiblePeer(SSHException):</span>

<span class="w"> </span>    .. versionadded:: 2.9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # TODO 4.0: consider making this annotate w/ 1..N &#39;missing&#39; algorithms,</span>
<span class="gi">+    # either just the first one that would halt kex, or even updating the</span>
<span class="gi">+    # Transport logic so we record /all/ that /could/ halt kex.</span>
<span class="gi">+    # TODO: update docstrings where this may end up raised so they are more</span>
<span class="gi">+    # specific.</span>
<span class="w"> </span>    pass


<span class="gu">@@ -131,7 +168,8 @@ class ProxyCommandFailure(SSHException):</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return &#39;ProxyCommand(&quot;{}&quot;) returned nonzero exit status: {}&#39;.format(
<span class="gd">-            self.command, self.error)</span>
<span class="gi">+            self.command, self.error</span>
<span class="gi">+        )</span>


<span class="w"> </span>class NoValidConnectionsError(socket.error):
<span class="gu">@@ -163,17 +201,19 @@ class NoValidConnectionsError(socket.error):</span>
<span class="w"> </span>            The errors dict to store, as described by class docstring.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        addrs = sorted(errors.keys())
<span class="gd">-        body = &#39;, &#39;.join([x[0] for x in addrs[:-1]])</span>
<span class="gi">+        body = &quot;, &quot;.join([x[0] for x in addrs[:-1]])</span>
<span class="w"> </span>        tail = addrs[-1][0]
<span class="w"> </span>        if body:
<span class="gd">-            msg = &#39;Unable to connect to port {0} on {1} or {2}&#39;</span>
<span class="gi">+            msg = &quot;Unable to connect to port {0} on {1} or {2}&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            msg = &#39;Unable to connect to port {0} on {2}&#39;</span>
<span class="gd">-        super().__init__(None, msg.format(addrs[0][1], body, tail))</span>
<span class="gi">+            msg = &quot;Unable to connect to port {0} on {2}&quot;</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            None, msg.format(addrs[0][1], body, tail)  # stand-in for errno</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.errors = errors

<span class="w"> </span>    def __reduce__(self):
<span class="gd">-        return self.__class__, (self.errors,)</span>
<span class="gi">+        return (self.__class__, (self.errors,))</span>


<span class="w"> </span>class CouldNotCanonicalize(SSHException):
<span class="gu">@@ -182,6 +222,7 @@ class CouldNotCanonicalize(SSHException):</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -195,6 +236,7 @@ class ConfigParseError(SSHException):</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -204,4 +246,5 @@ class MessageOrderError(SSHException):</span>

<span class="w"> </span>    .. versionadded:: 3.4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass
<span class="gh">diff --git a/paramiko/ssh_gss.py b/paramiko/ssh_gss.py</span>
<span class="gh">index 5956a062..ee49c34d 100644</span>
<span class="gd">--- a/paramiko/ssh_gss.py</span>
<span class="gi">+++ b/paramiko/ssh_gss.py</span>
<span class="gu">@@ -1,3 +1,24 @@</span>
<span class="gi">+# Copyright (C) 2013-2014 science + computing ag</span>
<span class="gi">+# Author: Sebastian Deiss &lt;sebastian.deiss@t-online.de&gt;</span>
<span class="gi">+#</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>This module provides GSS-API / SSPI  authentication as defined in :rfc:`4462`.

<span class="gu">@@ -7,31 +28,48 @@ This module provides GSS-API / SSPI  authentication as defined in :rfc:`4462`.</span>

<span class="w"> </span>.. versionadded:: 1.15
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: A boolean constraint that indicates if GSS-API / SSPI is available.</span>
<span class="w"> </span>GSS_AUTH_AVAILABLE = True
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: A tuple of the exception types used by the underlying GSSAPI implementation.</span>
<span class="w"> </span>GSS_EXCEPTIONS = ()
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: :var str _API: Constraint for the used API</span>
<span class="w"> </span>_API = None
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import gssapi
<span class="gd">-    if hasattr(gssapi, &#39;__title__&#39;) and gssapi.__title__ == &#39;python-gssapi&#39;:</span>
<span class="gd">-        _API = &#39;MIT&#39;</span>
<span class="gd">-        GSS_EXCEPTIONS = gssapi.GSSException,</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(gssapi, &quot;__title__&quot;) and gssapi.__title__ == &quot;python-gssapi&quot;:</span>
<span class="gi">+        # old, unmaintained python-gssapi package</span>
<span class="gi">+        _API = &quot;MIT&quot;  # keep this for compatibility</span>
<span class="gi">+        GSS_EXCEPTIONS = (gssapi.GSSException,)</span>
<span class="w"> </span>    else:
<span class="gd">-        _API = &#39;PYTHON-GSSAPI-NEW&#39;</span>
<span class="gd">-        GSS_EXCEPTIONS = (gssapi.exceptions.GeneralError, gssapi.raw.misc.</span>
<span class="gd">-            GSSError)</span>
<span class="gi">+        _API = &quot;PYTHON-GSSAPI-NEW&quot;</span>
<span class="gi">+        GSS_EXCEPTIONS = (</span>
<span class="gi">+            gssapi.exceptions.GeneralError,</span>
<span class="gi">+            gssapi.raw.misc.GSSError,</span>
<span class="gi">+        )</span>
<span class="w"> </span>except (ImportError, OSError):
<span class="w"> </span>    try:
<span class="w"> </span>        import pywintypes
<span class="w"> </span>        import sspicon
<span class="w"> </span>        import sspi
<span class="gd">-        _API = &#39;SSPI&#39;</span>
<span class="gd">-        GSS_EXCEPTIONS = pywintypes.error,</span>
<span class="gi">+</span>
<span class="gi">+        _API = &quot;SSPI&quot;</span>
<span class="gi">+        GSS_EXCEPTIONS = (pywintypes.error,)</span>
<span class="w"> </span>    except ImportError:
<span class="w"> </span>        GSS_AUTH_AVAILABLE = False
<span class="w"> </span>        _API = None
<span class="gi">+</span>
<span class="w"> </span>from paramiko.common import MSG_USERAUTH_REQUEST
<span class="w"> </span>from paramiko.ssh_exception import SSHException
<span class="w"> </span>from paramiko._version import __version_info__
<span class="gu">@@ -59,7 +97,14 @@ def GSSAuth(auth_method, gss_deleg_creds=True):</span>
<span class="w"> </span>           If there is no supported API available,
<span class="w"> </span>           ``None`` will be returned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _API == &quot;MIT&quot;:</span>
<span class="gi">+        return _SSH_GSSAPI_OLD(auth_method, gss_deleg_creds)</span>
<span class="gi">+    elif _API == &quot;PYTHON-GSSAPI-NEW&quot;:</span>
<span class="gi">+        return _SSH_GSSAPI_NEW(auth_method, gss_deleg_creds)</span>
<span class="gi">+    elif _API == &quot;SSPI&quot; and os.name == &quot;nt&quot;:</span>
<span class="gi">+        return _SSH_SSPI(auth_method, gss_deleg_creds)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ImportError(&quot;Unable to import a GSS-API / SSPI module!&quot;)</span>


<span class="w"> </span>class _SSH_GSSAuth:
<span class="gu">@@ -79,14 +124,18 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>        self._gss_host = None
<span class="w"> </span>        self._username = None
<span class="w"> </span>        self._session_id = None
<span class="gd">-        self._service = &#39;ssh-connection&#39;</span>
<span class="gi">+        self._service = &quot;ssh-connection&quot;</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        OpenSSH supports Kerberos V5 mechanism only for GSS-API authentication,
<span class="w"> </span>        so we also support the krb5 mechanism only.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self._krb5_mech = &#39;1.2.840.113554.1.2.2&#39;</span>
<span class="gi">+        self._krb5_mech = &quot;1.2.840.113554.1.2.2&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # client mode</span>
<span class="w"> </span>        self._gss_ctxt = None
<span class="w"> </span>        self._gss_ctxt_status = False
<span class="gi">+</span>
<span class="gi">+        # server mode</span>
<span class="w"> </span>        self._gss_srv_ctxt = None
<span class="w"> </span>        self._gss_srv_ctxt_status = False
<span class="w"> </span>        self.cc_file = None
<span class="gu">@@ -99,7 +148,8 @@ class _SSH_GSSAuth:</span>

<span class="w"> </span>        :param str service: The desired SSH service
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if service.find(&quot;ssh-&quot;):</span>
<span class="gi">+            self._service = service</span>

<span class="w"> </span>    def set_username(self, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -108,9 +158,9 @@ class _SSH_GSSAuth:</span>

<span class="w"> </span>        :param str username: The name of the user who attempts to login
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._username = username</span>

<span class="gd">-    def ssh_gss_oids(self, mode=&#39;client&#39;):</span>
<span class="gi">+    def ssh_gss_oids(self, mode=&quot;client&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This method returns a single OID, because we only support the
<span class="w"> </span>        Kerberos V5 mechanism.
<span class="gu">@@ -122,7 +172,15 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>        :note: In server mode we just return the OID length and the DER encoded
<span class="w"> </span>               OID.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pyasn1.type.univ import ObjectIdentifier</span>
<span class="gi">+        from pyasn1.codec.der import encoder</span>
<span class="gi">+</span>
<span class="gi">+        OIDs = self._make_uint32(1)</span>
<span class="gi">+        krb5_OID = encoder.encode(ObjectIdentifier(self._krb5_mech))</span>
<span class="gi">+        OID_len = self._make_uint32(len(krb5_OID))</span>
<span class="gi">+        if mode == &quot;server&quot;:</span>
<span class="gi">+            return OID_len + krb5_OID</span>
<span class="gi">+        return OIDs + OID_len + krb5_OID</span>

<span class="w"> </span>    def ssh_check_mech(self, desired_mech):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -131,8 +189,15 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>        :param str desired_mech: The desired GSS-API mechanism of the client
<span class="w"> </span>        :return: ``True`` if the given OID is supported, otherwise C{False}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pyasn1.codec.der import decoder</span>

<span class="gi">+        mech, __ = decoder.decode(desired_mech)</span>
<span class="gi">+        if mech.__str__() != self._krb5_mech:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Internals</span>
<span class="gi">+    # -------------------------------------------------------------------------</span>
<span class="w"> </span>    def _make_uint32(self, integer):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a 32 bit unsigned integer (The byte sequence of an integer).
<span class="gu">@@ -140,7 +205,7 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>        :param int integer: The integer value to convert
<span class="w"> </span>        :return: The byte sequence of an 32 bit integer
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return struct.pack(&quot;!I&quot;, integer)</span>

<span class="w"> </span>    def _ssh_build_mic(self, session_id, username, service, auth_method):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -159,7 +224,16 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>                 string    authentication-method
<span class="w"> </span>                           (gssapi-with-mic or gssapi-keyex)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mic = self._make_uint32(len(session_id))</span>
<span class="gi">+        mic += session_id</span>
<span class="gi">+        mic += struct.pack(&quot;B&quot;, MSG_USERAUTH_REQUEST)</span>
<span class="gi">+        mic += self._make_uint32(len(username))</span>
<span class="gi">+        mic += username.encode()</span>
<span class="gi">+        mic += self._make_uint32(len(service))</span>
<span class="gi">+        mic += service.encode()</span>
<span class="gi">+        mic += self._make_uint32(len(auth_method))</span>
<span class="gi">+        mic += auth_method.encode()</span>
<span class="gi">+        return mic</span>


<span class="w"> </span>class _SSH_GSSAPI_OLD(_SSH_GSSAuth):
<span class="gu">@@ -177,15 +251,24 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>        :param bool gss_deleg_creds: Delegate client credentials or not
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        _SSH_GSSAuth.__init__(self, auth_method, gss_deleg_creds)
<span class="gi">+</span>
<span class="w"> </span>        if self._gss_deleg_creds:
<span class="gd">-            self._gss_flags = (gssapi.C_PROT_READY_FLAG, gssapi.</span>
<span class="gd">-                C_INTEG_FLAG, gssapi.C_MUTUAL_FLAG, gssapi.C_DELEG_FLAG)</span>
<span class="gi">+            self._gss_flags = (</span>
<span class="gi">+                gssapi.C_PROT_READY_FLAG,</span>
<span class="gi">+                gssapi.C_INTEG_FLAG,</span>
<span class="gi">+                gssapi.C_MUTUAL_FLAG,</span>
<span class="gi">+                gssapi.C_DELEG_FLAG,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            self._gss_flags = (gssapi.C_PROT_READY_FLAG, gssapi.</span>
<span class="gd">-                C_INTEG_FLAG, gssapi.C_MUTUAL_FLAG)</span>
<span class="gi">+            self._gss_flags = (</span>
<span class="gi">+                gssapi.C_PROT_READY_FLAG,</span>
<span class="gi">+                gssapi.C_INTEG_FLAG,</span>
<span class="gi">+                gssapi.C_MUTUAL_FLAG,</span>
<span class="gi">+            )</span>

<span class="gd">-    def ssh_init_sec_context(self, target, desired_mech=None, username=None,</span>
<span class="gd">-        recv_token=None):</span>
<span class="gi">+    def ssh_init_sec_context(</span>
<span class="gi">+        self, target, desired_mech=None, username=None, recv_token=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Initialize a GSS-API context.

<span class="gu">@@ -201,7 +284,39 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: A ``String`` if the GSS-API has returned a token or
<span class="w"> </span>            ``None`` if no token was returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pyasn1.codec.der import decoder</span>
<span class="gi">+</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        self._gss_host = target</span>
<span class="gi">+        targ_name = gssapi.Name(</span>
<span class="gi">+            &quot;host@&quot; + self._gss_host, gssapi.C_NT_HOSTBASED_SERVICE</span>
<span class="gi">+        )</span>
<span class="gi">+        ctx = gssapi.Context()</span>
<span class="gi">+        ctx.flags = self._gss_flags</span>
<span class="gi">+        if desired_mech is None:</span>
<span class="gi">+            krb5_mech = gssapi.OID.mech_from_string(self._krb5_mech)</span>
<span class="gi">+        else:</span>
<span class="gi">+            mech, __ = decoder.decode(desired_mech)</span>
<span class="gi">+            if mech.__str__() != self._krb5_mech:</span>
<span class="gi">+                raise SSHException(&quot;Unsupported mechanism OID.&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                krb5_mech = gssapi.OID.mech_from_string(self._krb5_mech)</span>
<span class="gi">+        token = None</span>
<span class="gi">+        try:</span>
<span class="gi">+            if recv_token is None:</span>
<span class="gi">+                self._gss_ctxt = gssapi.InitContext(</span>
<span class="gi">+                    peer_name=targ_name,</span>
<span class="gi">+                    mech_type=krb5_mech,</span>
<span class="gi">+                    req_flags=ctx.flags,</span>
<span class="gi">+                )</span>
<span class="gi">+                token = self._gss_ctxt.step(token)</span>
<span class="gi">+            else:</span>
<span class="gi">+                token = self._gss_ctxt.step(recv_token)</span>
<span class="gi">+        except gssapi.GSSException:</span>
<span class="gi">+            message = &quot;{} Target: {}&quot;.format(sys.exc_info()[1], self._gss_host)</span>
<span class="gi">+            raise gssapi.GSSException(message)</span>
<span class="gi">+        self._gss_ctxt_status = self._gss_ctxt.established</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def ssh_get_mic(self, session_id, gss_kex=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -216,7 +331,19 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>                 Returns the MIC token from GSS-API with the SSH session ID as
<span class="w"> </span>                 message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._session_id = session_id</span>
<span class="gi">+        if not gss_kex:</span>
<span class="gi">+            mic_field = self._ssh_build_mic(</span>
<span class="gi">+                self._session_id,</span>
<span class="gi">+                self._username,</span>
<span class="gi">+                self._service,</span>
<span class="gi">+                self._auth_method,</span>
<span class="gi">+            )</span>
<span class="gi">+            mic_token = self._gss_ctxt.get_mic(mic_field)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # for key exchange with gssapi-keyex</span>
<span class="gi">+            mic_token = self._gss_srv_ctxt.get_mic(self._session_id)</span>
<span class="gi">+        return mic_token</span>

<span class="w"> </span>    def ssh_accept_sec_context(self, hostname, recv_token, username=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -229,7 +356,14 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: A ``String`` if the GSS-API has returned a token or ``None``
<span class="w"> </span>                if no token was returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # hostname and username are not required for GSSAPI, but for SSPI</span>
<span class="gi">+        self._gss_host = hostname</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        if self._gss_srv_ctxt is None:</span>
<span class="gi">+            self._gss_srv_ctxt = gssapi.AcceptContext()</span>
<span class="gi">+        token = self._gss_srv_ctxt.step(recv_token)</span>
<span class="gi">+        self._gss_srv_ctxt_status = self._gss_srv_ctxt.established</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def ssh_check_mic(self, mic_token, session_id, username=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -241,7 +375,21 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: None if the MIC check was successful
<span class="w"> </span>        :raises: ``gssapi.GSSException`` -- if the MIC check failed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._session_id = session_id</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        if self._username is not None:</span>
<span class="gi">+            # server mode</span>
<span class="gi">+            mic_field = self._ssh_build_mic(</span>
<span class="gi">+                self._session_id,</span>
<span class="gi">+                self._username,</span>
<span class="gi">+                self._service,</span>
<span class="gi">+                self._auth_method,</span>
<span class="gi">+            )</span>
<span class="gi">+            self._gss_srv_ctxt.verify_mic(mic_field, mic_token)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # for key exchange with gssapi-keyex</span>
<span class="gi">+            # client mode</span>
<span class="gi">+            self._gss_ctxt.verify_mic(self._session_id, mic_token)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def credentials_delegated(self):
<span class="gu">@@ -250,7 +398,9 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>

<span class="w"> </span>        :return: ``True`` if credentials are delegated, otherwise ``False``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._gss_srv_ctxt.delegated_cred is not None:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def save_client_creds(self, client_token):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -263,10 +413,11 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>            ``NotImplementedError`` -- Credential delegation is currently not
<span class="w"> </span>            supported in server mode
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>if __version_info__ &lt; (2, 5):
<span class="gi">+    # provide the old name for strict backward compatibility</span>
<span class="w"> </span>    _SSH_GSSAPI = _SSH_GSSAPI_OLD


<span class="gu">@@ -285,17 +436,24 @@ class _SSH_GSSAPI_NEW(_SSH_GSSAuth):</span>
<span class="w"> </span>        :param bool gss_deleg_creds: Delegate client credentials or not
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        _SSH_GSSAuth.__init__(self, auth_method, gss_deleg_creds)
<span class="gi">+</span>
<span class="w"> </span>        if self._gss_deleg_creds:
<span class="gd">-            self._gss_flags = (gssapi.RequirementFlag.protection_ready,</span>
<span class="gd">-                gssapi.RequirementFlag.integrity, gssapi.RequirementFlag.</span>
<span class="gd">-                mutual_authentication, gssapi.RequirementFlag.delegate_to_peer)</span>
<span class="gi">+            self._gss_flags = (</span>
<span class="gi">+                gssapi.RequirementFlag.protection_ready,</span>
<span class="gi">+                gssapi.RequirementFlag.integrity,</span>
<span class="gi">+                gssapi.RequirementFlag.mutual_authentication,</span>
<span class="gi">+                gssapi.RequirementFlag.delegate_to_peer,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            self._gss_flags = (gssapi.RequirementFlag.protection_ready,</span>
<span class="gd">-                gssapi.RequirementFlag.integrity, gssapi.RequirementFlag.</span>
<span class="gd">-                mutual_authentication)</span>
<span class="gi">+            self._gss_flags = (</span>
<span class="gi">+                gssapi.RequirementFlag.protection_ready,</span>
<span class="gi">+                gssapi.RequirementFlag.integrity,</span>
<span class="gi">+                gssapi.RequirementFlag.mutual_authentication,</span>
<span class="gi">+            )</span>

<span class="gd">-    def ssh_init_sec_context(self, target, desired_mech=None, username=None,</span>
<span class="gd">-        recv_token=None):</span>
<span class="gi">+    def ssh_init_sec_context(</span>
<span class="gi">+        self, target, desired_mech=None, username=None, recv_token=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Initialize a GSS-API context.

<span class="gu">@@ -312,7 +470,32 @@ class _SSH_GSSAPI_NEW(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: A ``String`` if the GSS-API has returned a token or ``None``
<span class="w"> </span>                 if no token was returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pyasn1.codec.der import decoder</span>
<span class="gi">+</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        self._gss_host = target</span>
<span class="gi">+        targ_name = gssapi.Name(</span>
<span class="gi">+            &quot;host@&quot; + self._gss_host,</span>
<span class="gi">+            name_type=gssapi.NameType.hostbased_service,</span>
<span class="gi">+        )</span>
<span class="gi">+        if desired_mech is not None:</span>
<span class="gi">+            mech, __ = decoder.decode(desired_mech)</span>
<span class="gi">+            if mech.__str__() != self._krb5_mech:</span>
<span class="gi">+                raise SSHException(&quot;Unsupported mechanism OID.&quot;)</span>
<span class="gi">+        krb5_mech = gssapi.MechType.kerberos</span>
<span class="gi">+        token = None</span>
<span class="gi">+        if recv_token is None:</span>
<span class="gi">+            self._gss_ctxt = gssapi.SecurityContext(</span>
<span class="gi">+                name=targ_name,</span>
<span class="gi">+                flags=self._gss_flags,</span>
<span class="gi">+                mech=krb5_mech,</span>
<span class="gi">+                usage=&quot;initiate&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+            token = self._gss_ctxt.step(token)</span>
<span class="gi">+        else:</span>
<span class="gi">+            token = self._gss_ctxt.step(recv_token)</span>
<span class="gi">+        self._gss_ctxt_status = self._gss_ctxt.complete</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def ssh_get_mic(self, session_id, gss_kex=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -328,7 +511,19 @@ class _SSH_GSSAPI_NEW(_SSH_GSSAuth):</span>
<span class="w"> </span>                 message.
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._session_id = session_id</span>
<span class="gi">+        if not gss_kex:</span>
<span class="gi">+            mic_field = self._ssh_build_mic(</span>
<span class="gi">+                self._session_id,</span>
<span class="gi">+                self._username,</span>
<span class="gi">+                self._service,</span>
<span class="gi">+                self._auth_method,</span>
<span class="gi">+            )</span>
<span class="gi">+            mic_token = self._gss_ctxt.get_signature(mic_field)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # for key exchange with gssapi-keyex</span>
<span class="gi">+            mic_token = self._gss_srv_ctxt.get_signature(self._session_id)</span>
<span class="gi">+        return mic_token</span>

<span class="w"> </span>    def ssh_accept_sec_context(self, hostname, recv_token, username=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -341,7 +536,14 @@ class _SSH_GSSAPI_NEW(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: A ``String`` if the GSS-API has returned a token or ``None``
<span class="w"> </span>                if no token was returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # hostname and username are not required for GSSAPI, but for SSPI</span>
<span class="gi">+        self._gss_host = hostname</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        if self._gss_srv_ctxt is None:</span>
<span class="gi">+            self._gss_srv_ctxt = gssapi.SecurityContext(usage=&quot;accept&quot;)</span>
<span class="gi">+        token = self._gss_srv_ctxt.step(recv_token)</span>
<span class="gi">+        self._gss_srv_ctxt_status = self._gss_srv_ctxt.complete</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def ssh_check_mic(self, mic_token, session_id, username=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -353,7 +555,21 @@ class _SSH_GSSAPI_NEW(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: None if the MIC check was successful
<span class="w"> </span>        :raises: ``gssapi.exceptions.GSSError`` -- if the MIC check failed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._session_id = session_id</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        if self._username is not None:</span>
<span class="gi">+            # server mode</span>
<span class="gi">+            mic_field = self._ssh_build_mic(</span>
<span class="gi">+                self._session_id,</span>
<span class="gi">+                self._username,</span>
<span class="gi">+                self._service,</span>
<span class="gi">+                self._auth_method,</span>
<span class="gi">+            )</span>
<span class="gi">+            self._gss_srv_ctxt.verify_signature(mic_field, mic_token)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # for key exchange with gssapi-keyex</span>
<span class="gi">+            # client mode</span>
<span class="gi">+            self._gss_ctxt.verify_signature(self._session_id, mic_token)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def credentials_delegated(self):
<span class="gu">@@ -363,7 +579,9 @@ class _SSH_GSSAPI_NEW(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: ``True`` if credentials are delegated, otherwise ``False``
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._gss_srv_ctxt.delegated_creds is not None:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def save_client_creds(self, client_token):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -375,7 +593,7 @@ class _SSH_GSSAPI_NEW(_SSH_GSSAuth):</span>
<span class="w"> </span>        :raises: ``NotImplementedError`` -- Credential delegation is currently
<span class="w"> </span>                 not supported in server mode
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class _SSH_SSPI(_SSH_GSSAuth):
<span class="gu">@@ -392,15 +610,21 @@ class _SSH_SSPI(_SSH_GSSAuth):</span>
<span class="w"> </span>        :param bool gss_deleg_creds: Delegate client credentials or not
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        _SSH_GSSAuth.__init__(self, auth_method, gss_deleg_creds)
<span class="gi">+</span>
<span class="w"> </span>        if self._gss_deleg_creds:
<span class="gd">-            self._gss_flags = (sspicon.ISC_REQ_INTEGRITY | sspicon.</span>
<span class="gd">-                ISC_REQ_MUTUAL_AUTH | sspicon.ISC_REQ_DELEGATE)</span>
<span class="gi">+            self._gss_flags = (</span>
<span class="gi">+                sspicon.ISC_REQ_INTEGRITY</span>
<span class="gi">+                | sspicon.ISC_REQ_MUTUAL_AUTH</span>
<span class="gi">+                | sspicon.ISC_REQ_DELEGATE</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            self._gss_flags = (sspicon.ISC_REQ_INTEGRITY | sspicon.</span>
<span class="gd">-                ISC_REQ_MUTUAL_AUTH)</span>
<span class="gi">+            self._gss_flags = (</span>
<span class="gi">+                sspicon.ISC_REQ_INTEGRITY | sspicon.ISC_REQ_MUTUAL_AUTH</span>
<span class="gi">+            )</span>

<span class="gd">-    def ssh_init_sec_context(self, target, desired_mech=None, username=None,</span>
<span class="gd">-        recv_token=None):</span>
<span class="gi">+    def ssh_init_sec_context(</span>
<span class="gi">+        self, target, desired_mech=None, username=None, recv_token=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Initialize a SSPI context.

<span class="gu">@@ -416,7 +640,39 @@ class _SSH_SSPI(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: A ``String`` if the SSPI has returned a token or ``None`` if
<span class="w"> </span>                 no token was returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pyasn1.codec.der import decoder</span>
<span class="gi">+</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        self._gss_host = target</span>
<span class="gi">+        error = 0</span>
<span class="gi">+        targ_name = &quot;host/&quot; + self._gss_host</span>
<span class="gi">+        if desired_mech is not None:</span>
<span class="gi">+            mech, __ = decoder.decode(desired_mech)</span>
<span class="gi">+            if mech.__str__() != self._krb5_mech:</span>
<span class="gi">+                raise SSHException(&quot;Unsupported mechanism OID.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if recv_token is None:</span>
<span class="gi">+                self._gss_ctxt = sspi.ClientAuth(</span>
<span class="gi">+                    &quot;Kerberos&quot;, scflags=self._gss_flags, targetspn=targ_name</span>
<span class="gi">+                )</span>
<span class="gi">+            error, token = self._gss_ctxt.authorize(recv_token)</span>
<span class="gi">+            token = token[0].Buffer</span>
<span class="gi">+        except pywintypes.error as e:</span>
<span class="gi">+            e.strerror += &quot;, Target: {}&quot;.format(self._gss_host)</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+        if error == 0:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            if the status is GSS_COMPLETE (error = 0) the context is fully</span>
<span class="gi">+            established an we can set _gss_ctxt_status to True.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            self._gss_ctxt_status = True</span>
<span class="gi">+            token = None</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            You won&#39;t get another token if the context is fully established,</span>
<span class="gi">+            so i set token to None instead of &quot;&quot;</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def ssh_get_mic(self, session_id, gss_kex=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -431,7 +687,19 @@ class _SSH_SSPI(_SSH_GSSAuth):</span>
<span class="w"> </span>                 Returns the MIC token from SSPI with the SSH session ID as
<span class="w"> </span>                 message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._session_id = session_id</span>
<span class="gi">+        if not gss_kex:</span>
<span class="gi">+            mic_field = self._ssh_build_mic(</span>
<span class="gi">+                self._session_id,</span>
<span class="gi">+                self._username,</span>
<span class="gi">+                self._service,</span>
<span class="gi">+                self._auth_method,</span>
<span class="gi">+            )</span>
<span class="gi">+            mic_token = self._gss_ctxt.sign(mic_field)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # for key exchange with gssapi-keyex</span>
<span class="gi">+            mic_token = self._gss_srv_ctxt.sign(self._session_id)</span>
<span class="gi">+        return mic_token</span>

<span class="w"> </span>    def ssh_accept_sec_context(self, hostname, username, recv_token):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -444,7 +712,16 @@ class _SSH_SSPI(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: A ``String`` if the SSPI has returned a token or ``None`` if
<span class="w"> </span>                 no token was returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._gss_host = hostname</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        targ_name = &quot;host/&quot; + self._gss_host</span>
<span class="gi">+        self._gss_srv_ctxt = sspi.ServerAuth(&quot;Kerberos&quot;, spn=targ_name)</span>
<span class="gi">+        error, token = self._gss_srv_ctxt.authorize(recv_token)</span>
<span class="gi">+        token = token[0].Buffer</span>
<span class="gi">+        if error == 0:</span>
<span class="gi">+            self._gss_srv_ctxt_status = True</span>
<span class="gi">+            token = None</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def ssh_check_mic(self, mic_token, session_id, username=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -456,7 +733,25 @@ class _SSH_SSPI(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: None if the MIC check was successful
<span class="w"> </span>        :raises: ``sspi.error`` -- if the MIC check failed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._session_id = session_id</span>
<span class="gi">+        self._username = username</span>
<span class="gi">+        if username is not None:</span>
<span class="gi">+            # server mode</span>
<span class="gi">+            mic_field = self._ssh_build_mic(</span>
<span class="gi">+                self._session_id,</span>
<span class="gi">+                self._username,</span>
<span class="gi">+                self._service,</span>
<span class="gi">+                self._auth_method,</span>
<span class="gi">+            )</span>
<span class="gi">+            # Verifies data and its signature.  If verification fails, an</span>
<span class="gi">+            # sspi.error will be raised.</span>
<span class="gi">+            self._gss_srv_ctxt.verify(mic_field, mic_token)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # for key exchange with gssapi-keyex</span>
<span class="gi">+            # client mode</span>
<span class="gi">+            # Verifies data and its signature.  If verification fails, an</span>
<span class="gi">+            # sspi.error will be raised.</span>
<span class="gi">+            self._gss_ctxt.verify(self._session_id, mic_token)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def credentials_delegated(self):
<span class="gu">@@ -465,7 +760,9 @@ class _SSH_SSPI(_SSH_GSSAuth):</span>

<span class="w"> </span>        :return: ``True`` if credentials are delegated, otherwise ``False``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._gss_flags &amp; sspicon.ISC_REQ_DELEGATE and (</span>
<span class="gi">+            self._gss_srv_ctxt_status or self._gss_flags</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def save_client_creds(self, client_token):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -478,4 +775,4 @@ class _SSH_SSPI(_SSH_GSSAuth):</span>
<span class="w"> </span>            ``NotImplementedError`` -- Credential delegation is currently not
<span class="w"> </span>            supported in server mode
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gh">diff --git a/paramiko/transport.py b/paramiko/transport.py</span>
<span class="gh">index a4f0e92e..ecd8c7bc 100644</span>
<span class="gd">--- a/paramiko/transport.py</span>
<span class="gi">+++ b/paramiko/transport.py</span>
<span class="gu">@@ -1,6 +1,26 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Core protocol implementation
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import socket
<span class="w"> </span>import sys
<span class="gu">@@ -8,14 +28,67 @@ import threading</span>
<span class="w"> </span>import time
<span class="w"> </span>import weakref
<span class="w"> </span>from hashlib import md5, sha1, sha256, sha512
<span class="gi">+</span>
<span class="w"> </span>from cryptography.hazmat.backends import default_backend
<span class="w"> </span>from cryptography.hazmat.primitives.ciphers import algorithms, Cipher, modes
<span class="gi">+</span>
<span class="w"> </span>import paramiko
<span class="w"> </span>from paramiko import util
<span class="w"> </span>from paramiko.auth_handler import AuthHandler, AuthOnlyHandler
<span class="w"> </span>from paramiko.ssh_gss import GSSAuth
<span class="w"> </span>from paramiko.channel import Channel
<span class="gd">-from paramiko.common import xffffffff, cMSG_CHANNEL_OPEN, cMSG_IGNORE, cMSG_GLOBAL_REQUEST, DEBUG, MSG_KEXINIT, MSG_IGNORE, MSG_DISCONNECT, MSG_DEBUG, ERROR, WARNING, cMSG_UNIMPLEMENTED, INFO, cMSG_KEXINIT, cMSG_NEWKEYS, MSG_NEWKEYS, cMSG_REQUEST_SUCCESS, cMSG_REQUEST_FAILURE, CONNECTION_FAILED_CODE, OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED, OPEN_SUCCEEDED, cMSG_CHANNEL_OPEN_FAILURE, cMSG_CHANNEL_OPEN_SUCCESS, MSG_GLOBAL_REQUEST, MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE, cMSG_SERVICE_REQUEST, MSG_SERVICE_ACCEPT, MSG_CHANNEL_OPEN_SUCCESS, MSG_CHANNEL_OPEN_FAILURE, MSG_CHANNEL_OPEN, MSG_CHANNEL_SUCCESS, MSG_CHANNEL_FAILURE, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA, MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_REQUEST, MSG_CHANNEL_EOF, MSG_CHANNEL_CLOSE, MIN_WINDOW_SIZE, MIN_PACKET_SIZE, MAX_WINDOW_SIZE, DEFAULT_WINDOW_SIZE, DEFAULT_MAX_PACKET_SIZE, HIGHEST_USERAUTH_MESSAGE_ID, MSG_UNIMPLEMENTED, MSG_NAMES, MSG_EXT_INFO, cMSG_EXT_INFO, byte_ord</span>
<span class="gi">+from paramiko.common import (</span>
<span class="gi">+    xffffffff,</span>
<span class="gi">+    cMSG_CHANNEL_OPEN,</span>
<span class="gi">+    cMSG_IGNORE,</span>
<span class="gi">+    cMSG_GLOBAL_REQUEST,</span>
<span class="gi">+    DEBUG,</span>
<span class="gi">+    MSG_KEXINIT,</span>
<span class="gi">+    MSG_IGNORE,</span>
<span class="gi">+    MSG_DISCONNECT,</span>
<span class="gi">+    MSG_DEBUG,</span>
<span class="gi">+    ERROR,</span>
<span class="gi">+    WARNING,</span>
<span class="gi">+    cMSG_UNIMPLEMENTED,</span>
<span class="gi">+    INFO,</span>
<span class="gi">+    cMSG_KEXINIT,</span>
<span class="gi">+    cMSG_NEWKEYS,</span>
<span class="gi">+    MSG_NEWKEYS,</span>
<span class="gi">+    cMSG_REQUEST_SUCCESS,</span>
<span class="gi">+    cMSG_REQUEST_FAILURE,</span>
<span class="gi">+    CONNECTION_FAILED_CODE,</span>
<span class="gi">+    OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED,</span>
<span class="gi">+    OPEN_SUCCEEDED,</span>
<span class="gi">+    cMSG_CHANNEL_OPEN_FAILURE,</span>
<span class="gi">+    cMSG_CHANNEL_OPEN_SUCCESS,</span>
<span class="gi">+    MSG_GLOBAL_REQUEST,</span>
<span class="gi">+    MSG_REQUEST_SUCCESS,</span>
<span class="gi">+    MSG_REQUEST_FAILURE,</span>
<span class="gi">+    cMSG_SERVICE_REQUEST,</span>
<span class="gi">+    MSG_SERVICE_ACCEPT,</span>
<span class="gi">+    MSG_CHANNEL_OPEN_SUCCESS,</span>
<span class="gi">+    MSG_CHANNEL_OPEN_FAILURE,</span>
<span class="gi">+    MSG_CHANNEL_OPEN,</span>
<span class="gi">+    MSG_CHANNEL_SUCCESS,</span>
<span class="gi">+    MSG_CHANNEL_FAILURE,</span>
<span class="gi">+    MSG_CHANNEL_DATA,</span>
<span class="gi">+    MSG_CHANNEL_EXTENDED_DATA,</span>
<span class="gi">+    MSG_CHANNEL_WINDOW_ADJUST,</span>
<span class="gi">+    MSG_CHANNEL_REQUEST,</span>
<span class="gi">+    MSG_CHANNEL_EOF,</span>
<span class="gi">+    MSG_CHANNEL_CLOSE,</span>
<span class="gi">+    MIN_WINDOW_SIZE,</span>
<span class="gi">+    MIN_PACKET_SIZE,</span>
<span class="gi">+    MAX_WINDOW_SIZE,</span>
<span class="gi">+    DEFAULT_WINDOW_SIZE,</span>
<span class="gi">+    DEFAULT_MAX_PACKET_SIZE,</span>
<span class="gi">+    HIGHEST_USERAUTH_MESSAGE_ID,</span>
<span class="gi">+    MSG_UNIMPLEMENTED,</span>
<span class="gi">+    MSG_NAMES,</span>
<span class="gi">+    MSG_EXT_INFO,</span>
<span class="gi">+    cMSG_EXT_INFO,</span>
<span class="gi">+    byte_ord,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.compress import ZlibCompressor, ZlibDecompressor
<span class="w"> </span>from paramiko.dsskey import DSSKey
<span class="w"> </span>from paramiko.ed25519key import Ed25519Key
<span class="gu">@@ -33,14 +106,46 @@ from paramiko.rsakey import RSAKey</span>
<span class="w"> </span>from paramiko.ecdsakey import ECDSAKey
<span class="w"> </span>from paramiko.server import ServerInterface
<span class="w"> </span>from paramiko.sftp_client import SFTPClient
<span class="gd">-from paramiko.ssh_exception import BadAuthenticationType, ChannelException, IncompatiblePeer, MessageOrderError, ProxyCommandFailure, SSHException</span>
<span class="gd">-from paramiko.util import ClosingContextManager, clamp_value, b</span>
<span class="gi">+from paramiko.ssh_exception import (</span>
<span class="gi">+    BadAuthenticationType,</span>
<span class="gi">+    ChannelException,</span>
<span class="gi">+    IncompatiblePeer,</span>
<span class="gi">+    MessageOrderError,</span>
<span class="gi">+    ProxyCommandFailure,</span>
<span class="gi">+    SSHException,</span>
<span class="gi">+)</span>
<span class="gi">+from paramiko.util import (</span>
<span class="gi">+    ClosingContextManager,</span>
<span class="gi">+    clamp_value,</span>
<span class="gi">+    b,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TripleDES is moving from `cryptography.hazmat.primitives.ciphers.algorithms`</span>
<span class="gi">+# in cryptography&gt;=43.0.0 to `cryptography.hazmat.decrepit.ciphers.algorithms`</span>
<span class="gi">+# It will be removed from `cryptography.hazmat.primitives.ciphers.algorithms`</span>
<span class="gi">+# in cryptography==48.0.0.</span>
<span class="gi">+#</span>
<span class="gi">+# Source References:</span>
<span class="gi">+# - https://github.com/pyca/cryptography/commit/722a6393e61b3ac</span>
<span class="gi">+# - https://github.com/pyca/cryptography/pull/11407/files</span>
<span class="w"> </span>try:
<span class="w"> </span>    from cryptography.hazmat.decrepit.ciphers.algorithms import TripleDES
<span class="w"> </span>except ImportError:
<span class="w"> </span>    from cryptography.hazmat.primitives.ciphers.algorithms import TripleDES
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# for thread cleanup</span>
<span class="w"> </span>_active_threads = []
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _join_lingering_threads():</span>
<span class="gi">+    for thr in _active_threads:</span>
<span class="gi">+        thr.stop_thread()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import atexit
<span class="gi">+</span>
<span class="w"> </span>atexit.register(_join_lingering_threads)


<span class="gu">@@ -54,85 +159,199 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>    Instances of this class may be used as context managers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _ENCRYPT = object()
<span class="w"> </span>    _DECRYPT = object()
<span class="gd">-    _PROTO_ID = &#39;2.0&#39;</span>
<span class="gd">-    _CLIENT_ID = &#39;paramiko_{}&#39;.format(paramiko.__version__)</span>
<span class="gd">-    _preferred_ciphers = (&#39;aes128-ctr&#39;, &#39;aes192-ctr&#39;, &#39;aes256-ctr&#39;,</span>
<span class="gd">-        &#39;aes128-cbc&#39;, &#39;aes192-cbc&#39;, &#39;aes256-cbc&#39;, &#39;3des-cbc&#39;)</span>
<span class="gd">-    _preferred_macs = (&#39;hmac-sha2-256&#39;, &#39;hmac-sha2-512&#39;,</span>
<span class="gd">-        &#39;hmac-sha2-256-etm@openssh.com&#39;, &#39;hmac-sha2-512-etm@openssh.com&#39;,</span>
<span class="gd">-        &#39;hmac-sha1&#39;, &#39;hmac-md5&#39;, &#39;hmac-sha1-96&#39;, &#39;hmac-md5-96&#39;)</span>
<span class="gd">-    _preferred_keys = (&#39;ssh-ed25519&#39;, &#39;ecdsa-sha2-nistp256&#39;,</span>
<span class="gd">-        &#39;ecdsa-sha2-nistp384&#39;, &#39;ecdsa-sha2-nistp521&#39;, &#39;rsa-sha2-512&#39;,</span>
<span class="gd">-        &#39;rsa-sha2-256&#39;, &#39;ssh-rsa&#39;, &#39;ssh-dss&#39;)</span>
<span class="gd">-    _preferred_pubkeys = (&#39;ssh-ed25519&#39;, &#39;ecdsa-sha2-nistp256&#39;,</span>
<span class="gd">-        &#39;ecdsa-sha2-nistp384&#39;, &#39;ecdsa-sha2-nistp521&#39;, &#39;rsa-sha2-512&#39;,</span>
<span class="gd">-        &#39;rsa-sha2-256&#39;, &#39;ssh-rsa&#39;, &#39;ssh-dss&#39;)</span>
<span class="gd">-    _preferred_kex = (&#39;ecdh-sha2-nistp256&#39;, &#39;ecdh-sha2-nistp384&#39;,</span>
<span class="gd">-        &#39;ecdh-sha2-nistp521&#39;, &#39;diffie-hellman-group16-sha512&#39;,</span>
<span class="gd">-        &#39;diffie-hellman-group-exchange-sha256&#39;,</span>
<span class="gd">-        &#39;diffie-hellman-group14-sha256&#39;,</span>
<span class="gd">-        &#39;diffie-hellman-group-exchange-sha1&#39;, &#39;diffie-hellman-group14-sha1&#39;,</span>
<span class="gd">-        &#39;diffie-hellman-group1-sha1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    _PROTO_ID = &quot;2.0&quot;</span>
<span class="gi">+    _CLIENT_ID = &quot;paramiko_{}&quot;.format(paramiko.__version__)</span>
<span class="gi">+</span>
<span class="gi">+    # These tuples of algorithm identifiers are in preference order; do not</span>
<span class="gi">+    # reorder without reason!</span>
<span class="gi">+    # NOTE: if you need to modify these, we suggest leveraging the</span>
<span class="gi">+    # `disabled_algorithms` constructor argument (also available in SSHClient)</span>
<span class="gi">+    # instead of monkeypatching or subclassing.</span>
<span class="gi">+    _preferred_ciphers = (</span>
<span class="gi">+        &quot;aes128-ctr&quot;,</span>
<span class="gi">+        &quot;aes192-ctr&quot;,</span>
<span class="gi">+        &quot;aes256-ctr&quot;,</span>
<span class="gi">+        &quot;aes128-cbc&quot;,</span>
<span class="gi">+        &quot;aes192-cbc&quot;,</span>
<span class="gi">+        &quot;aes256-cbc&quot;,</span>
<span class="gi">+        &quot;3des-cbc&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    _preferred_macs = (</span>
<span class="gi">+        &quot;hmac-sha2-256&quot;,</span>
<span class="gi">+        &quot;hmac-sha2-512&quot;,</span>
<span class="gi">+        &quot;hmac-sha2-256-etm@openssh.com&quot;,</span>
<span class="gi">+        &quot;hmac-sha2-512-etm@openssh.com&quot;,</span>
<span class="gi">+        &quot;hmac-sha1&quot;,</span>
<span class="gi">+        &quot;hmac-md5&quot;,</span>
<span class="gi">+        &quot;hmac-sha1-96&quot;,</span>
<span class="gi">+        &quot;hmac-md5-96&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    # ~= HostKeyAlgorithms in OpenSSH land</span>
<span class="gi">+    _preferred_keys = (</span>
<span class="gi">+        &quot;ssh-ed25519&quot;,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp256&quot;,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp384&quot;,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp521&quot;,</span>
<span class="gi">+        &quot;rsa-sha2-512&quot;,</span>
<span class="gi">+        &quot;rsa-sha2-256&quot;,</span>
<span class="gi">+        &quot;ssh-rsa&quot;,</span>
<span class="gi">+        &quot;ssh-dss&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    # ~= PubKeyAcceptedAlgorithms</span>
<span class="gi">+    _preferred_pubkeys = (</span>
<span class="gi">+        &quot;ssh-ed25519&quot;,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp256&quot;,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp384&quot;,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp521&quot;,</span>
<span class="gi">+        &quot;rsa-sha2-512&quot;,</span>
<span class="gi">+        &quot;rsa-sha2-256&quot;,</span>
<span class="gi">+        &quot;ssh-rsa&quot;,</span>
<span class="gi">+        &quot;ssh-dss&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    _preferred_kex = (</span>
<span class="gi">+        &quot;ecdh-sha2-nistp256&quot;,</span>
<span class="gi">+        &quot;ecdh-sha2-nistp384&quot;,</span>
<span class="gi">+        &quot;ecdh-sha2-nistp521&quot;,</span>
<span class="gi">+        &quot;diffie-hellman-group16-sha512&quot;,</span>
<span class="gi">+        &quot;diffie-hellman-group-exchange-sha256&quot;,</span>
<span class="gi">+        &quot;diffie-hellman-group14-sha256&quot;,</span>
<span class="gi">+        &quot;diffie-hellman-group-exchange-sha1&quot;,</span>
<span class="gi">+        &quot;diffie-hellman-group14-sha1&quot;,</span>
<span class="gi">+        &quot;diffie-hellman-group1-sha1&quot;,</span>
<span class="gi">+    )</span>
<span class="w"> </span>    if KexCurve25519.is_available():
<span class="gd">-        _preferred_kex = (&#39;curve25519-sha256@libssh.org&#39;,) + _preferred_kex</span>
<span class="gd">-    _preferred_gsskex = (&#39;gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;,</span>
<span class="gd">-        &#39;gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;,</span>
<span class="gd">-        &#39;gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;)</span>
<span class="gd">-    _preferred_compression = &#39;none&#39;,</span>
<span class="gd">-    _cipher_info = {&#39;aes128-ctr&#39;: {&#39;class&#39;: algorithms.AES, &#39;mode&#39;: modes.</span>
<span class="gd">-        CTR, &#39;block-size&#39;: 16, &#39;key-size&#39;: 16}, &#39;aes192-ctr&#39;: {&#39;class&#39;:</span>
<span class="gd">-        algorithms.AES, &#39;mode&#39;: modes.CTR, &#39;block-size&#39;: 16, &#39;key-size&#39;: 24</span>
<span class="gd">-        }, &#39;aes256-ctr&#39;: {&#39;class&#39;: algorithms.AES, &#39;mode&#39;: modes.CTR,</span>
<span class="gd">-        &#39;block-size&#39;: 16, &#39;key-size&#39;: 32}, &#39;aes128-cbc&#39;: {&#39;class&#39;:</span>
<span class="gd">-        algorithms.AES, &#39;mode&#39;: modes.CBC, &#39;block-size&#39;: 16, &#39;key-size&#39;: 16</span>
<span class="gd">-        }, &#39;aes192-cbc&#39;: {&#39;class&#39;: algorithms.AES, &#39;mode&#39;: modes.CBC,</span>
<span class="gd">-        &#39;block-size&#39;: 16, &#39;key-size&#39;: 24}, &#39;aes256-cbc&#39;: {&#39;class&#39;:</span>
<span class="gd">-        algorithms.AES, &#39;mode&#39;: modes.CBC, &#39;block-size&#39;: 16, &#39;key-size&#39;: 32</span>
<span class="gd">-        }, &#39;3des-cbc&#39;: {&#39;class&#39;: TripleDES, &#39;mode&#39;: modes.CBC, &#39;block-size&#39;:</span>
<span class="gd">-        8, &#39;key-size&#39;: 24}}</span>
<span class="gd">-    _mac_info = {&#39;hmac-sha1&#39;: {&#39;class&#39;: sha1, &#39;size&#39;: 20}, &#39;hmac-sha1-96&#39;:</span>
<span class="gd">-        {&#39;class&#39;: sha1, &#39;size&#39;: 12}, &#39;hmac-sha2-256&#39;: {&#39;class&#39;: sha256,</span>
<span class="gd">-        &#39;size&#39;: 32}, &#39;hmac-sha2-256-etm@openssh.com&#39;: {&#39;class&#39;: sha256,</span>
<span class="gd">-        &#39;size&#39;: 32}, &#39;hmac-sha2-512&#39;: {&#39;class&#39;: sha512, &#39;size&#39;: 64},</span>
<span class="gd">-        &#39;hmac-sha2-512-etm@openssh.com&#39;: {&#39;class&#39;: sha512, &#39;size&#39;: 64},</span>
<span class="gd">-        &#39;hmac-md5&#39;: {&#39;class&#39;: md5, &#39;size&#39;: 16}, &#39;hmac-md5-96&#39;: {&#39;class&#39;:</span>
<span class="gd">-        md5, &#39;size&#39;: 12}}</span>
<span class="gd">-    _key_info = {&#39;ssh-rsa&#39;: RSAKey, &#39;ssh-rsa-cert-v01@openssh.com&#39;: RSAKey,</span>
<span class="gd">-        &#39;rsa-sha2-256&#39;: RSAKey, &#39;rsa-sha2-256-cert-v01@openssh.com&#39;: RSAKey,</span>
<span class="gd">-        &#39;rsa-sha2-512&#39;: RSAKey, &#39;rsa-sha2-512-cert-v01@openssh.com&#39;: RSAKey,</span>
<span class="gd">-        &#39;ssh-dss&#39;: DSSKey, &#39;ssh-dss-cert-v01@openssh.com&#39;: DSSKey,</span>
<span class="gd">-        &#39;ecdsa-sha2-nistp256&#39;: ECDSAKey,</span>
<span class="gd">-        &#39;ecdsa-sha2-nistp256-cert-v01@openssh.com&#39;: ECDSAKey,</span>
<span class="gd">-        &#39;ecdsa-sha2-nistp384&#39;: ECDSAKey,</span>
<span class="gd">-        &#39;ecdsa-sha2-nistp384-cert-v01@openssh.com&#39;: ECDSAKey,</span>
<span class="gd">-        &#39;ecdsa-sha2-nistp521&#39;: ECDSAKey,</span>
<span class="gd">-        &#39;ecdsa-sha2-nistp521-cert-v01@openssh.com&#39;: ECDSAKey, &#39;ssh-ed25519&#39;:</span>
<span class="gd">-        Ed25519Key, &#39;ssh-ed25519-cert-v01@openssh.com&#39;: Ed25519Key}</span>
<span class="gd">-    _kex_info = {&#39;diffie-hellman-group1-sha1&#39;: KexGroup1,</span>
<span class="gd">-        &#39;diffie-hellman-group14-sha1&#39;: KexGroup14,</span>
<span class="gd">-        &#39;diffie-hellman-group-exchange-sha1&#39;: KexGex,</span>
<span class="gd">-        &#39;diffie-hellman-group-exchange-sha256&#39;: KexGexSHA256,</span>
<span class="gd">-        &#39;diffie-hellman-group14-sha256&#39;: KexGroup14SHA256,</span>
<span class="gd">-        &#39;diffie-hellman-group16-sha512&#39;: KexGroup16SHA512,</span>
<span class="gd">-        &#39;gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;: KexGSSGroup1,</span>
<span class="gd">-        &#39;gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;: KexGSSGroup14,</span>
<span class="gd">-        &#39;gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==&#39;: KexGSSGex,</span>
<span class="gd">-        &#39;ecdh-sha2-nistp256&#39;: KexNistp256, &#39;ecdh-sha2-nistp384&#39;:</span>
<span class="gd">-        KexNistp384, &#39;ecdh-sha2-nistp521&#39;: KexNistp521}</span>
<span class="gi">+        _preferred_kex = (&quot;curve25519-sha256@libssh.org&quot;,) + _preferred_kex</span>
<span class="gi">+    _preferred_gsskex = (</span>
<span class="gi">+        &quot;gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;,</span>
<span class="gi">+        &quot;gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;,</span>
<span class="gi">+        &quot;gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    _preferred_compression = (&quot;none&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+    _cipher_info = {</span>
<span class="gi">+        &quot;aes128-ctr&quot;: {</span>
<span class="gi">+            &quot;class&quot;: algorithms.AES,</span>
<span class="gi">+            &quot;mode&quot;: modes.CTR,</span>
<span class="gi">+            &quot;block-size&quot;: 16,</span>
<span class="gi">+            &quot;key-size&quot;: 16,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;aes192-ctr&quot;: {</span>
<span class="gi">+            &quot;class&quot;: algorithms.AES,</span>
<span class="gi">+            &quot;mode&quot;: modes.CTR,</span>
<span class="gi">+            &quot;block-size&quot;: 16,</span>
<span class="gi">+            &quot;key-size&quot;: 24,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;aes256-ctr&quot;: {</span>
<span class="gi">+            &quot;class&quot;: algorithms.AES,</span>
<span class="gi">+            &quot;mode&quot;: modes.CTR,</span>
<span class="gi">+            &quot;block-size&quot;: 16,</span>
<span class="gi">+            &quot;key-size&quot;: 32,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;aes128-cbc&quot;: {</span>
<span class="gi">+            &quot;class&quot;: algorithms.AES,</span>
<span class="gi">+            &quot;mode&quot;: modes.CBC,</span>
<span class="gi">+            &quot;block-size&quot;: 16,</span>
<span class="gi">+            &quot;key-size&quot;: 16,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;aes192-cbc&quot;: {</span>
<span class="gi">+            &quot;class&quot;: algorithms.AES,</span>
<span class="gi">+            &quot;mode&quot;: modes.CBC,</span>
<span class="gi">+            &quot;block-size&quot;: 16,</span>
<span class="gi">+            &quot;key-size&quot;: 24,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;aes256-cbc&quot;: {</span>
<span class="gi">+            &quot;class&quot;: algorithms.AES,</span>
<span class="gi">+            &quot;mode&quot;: modes.CBC,</span>
<span class="gi">+            &quot;block-size&quot;: 16,</span>
<span class="gi">+            &quot;key-size&quot;: 32,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;3des-cbc&quot;: {</span>
<span class="gi">+            &quot;class&quot;: TripleDES,</span>
<span class="gi">+            &quot;mode&quot;: modes.CBC,</span>
<span class="gi">+            &quot;block-size&quot;: 8,</span>
<span class="gi">+            &quot;key-size&quot;: 24,</span>
<span class="gi">+        },</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    _mac_info = {</span>
<span class="gi">+        &quot;hmac-sha1&quot;: {&quot;class&quot;: sha1, &quot;size&quot;: 20},</span>
<span class="gi">+        &quot;hmac-sha1-96&quot;: {&quot;class&quot;: sha1, &quot;size&quot;: 12},</span>
<span class="gi">+        &quot;hmac-sha2-256&quot;: {&quot;class&quot;: sha256, &quot;size&quot;: 32},</span>
<span class="gi">+        &quot;hmac-sha2-256-etm@openssh.com&quot;: {&quot;class&quot;: sha256, &quot;size&quot;: 32},</span>
<span class="gi">+        &quot;hmac-sha2-512&quot;: {&quot;class&quot;: sha512, &quot;size&quot;: 64},</span>
<span class="gi">+        &quot;hmac-sha2-512-etm@openssh.com&quot;: {&quot;class&quot;: sha512, &quot;size&quot;: 64},</span>
<span class="gi">+        &quot;hmac-md5&quot;: {&quot;class&quot;: md5, &quot;size&quot;: 16},</span>
<span class="gi">+        &quot;hmac-md5-96&quot;: {&quot;class&quot;: md5, &quot;size&quot;: 12},</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    _key_info = {</span>
<span class="gi">+        # TODO: at some point we will want to drop this as it&#39;s no longer</span>
<span class="gi">+        # considered secure due to using SHA-1 for signatures. OpenSSH 8.8 no</span>
<span class="gi">+        # longer supports it. Question becomes at what point do we want to</span>
<span class="gi">+        # prevent users with older setups from using this?</span>
<span class="gi">+        &quot;ssh-rsa&quot;: RSAKey,</span>
<span class="gi">+        &quot;ssh-rsa-cert-v01@openssh.com&quot;: RSAKey,</span>
<span class="gi">+        &quot;rsa-sha2-256&quot;: RSAKey,</span>
<span class="gi">+        &quot;rsa-sha2-256-cert-v01@openssh.com&quot;: RSAKey,</span>
<span class="gi">+        &quot;rsa-sha2-512&quot;: RSAKey,</span>
<span class="gi">+        &quot;rsa-sha2-512-cert-v01@openssh.com&quot;: RSAKey,</span>
<span class="gi">+        &quot;ssh-dss&quot;: DSSKey,</span>
<span class="gi">+        &quot;ssh-dss-cert-v01@openssh.com&quot;: DSSKey,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp256&quot;: ECDSAKey,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp256-cert-v01@openssh.com&quot;: ECDSAKey,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp384&quot;: ECDSAKey,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp384-cert-v01@openssh.com&quot;: ECDSAKey,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp521&quot;: ECDSAKey,</span>
<span class="gi">+        &quot;ecdsa-sha2-nistp521-cert-v01@openssh.com&quot;: ECDSAKey,</span>
<span class="gi">+        &quot;ssh-ed25519&quot;: Ed25519Key,</span>
<span class="gi">+        &quot;ssh-ed25519-cert-v01@openssh.com&quot;: Ed25519Key,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    _kex_info = {</span>
<span class="gi">+        &quot;diffie-hellman-group1-sha1&quot;: KexGroup1,</span>
<span class="gi">+        &quot;diffie-hellman-group14-sha1&quot;: KexGroup14,</span>
<span class="gi">+        &quot;diffie-hellman-group-exchange-sha1&quot;: KexGex,</span>
<span class="gi">+        &quot;diffie-hellman-group-exchange-sha256&quot;: KexGexSHA256,</span>
<span class="gi">+        &quot;diffie-hellman-group14-sha256&quot;: KexGroup14SHA256,</span>
<span class="gi">+        &quot;diffie-hellman-group16-sha512&quot;: KexGroup16SHA512,</span>
<span class="gi">+        &quot;gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;: KexGSSGroup1,</span>
<span class="gi">+        &quot;gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;: KexGSSGroup14,</span>
<span class="gi">+        &quot;gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==&quot;: KexGSSGex,</span>
<span class="gi">+        &quot;ecdh-sha2-nistp256&quot;: KexNistp256,</span>
<span class="gi">+        &quot;ecdh-sha2-nistp384&quot;: KexNistp384,</span>
<span class="gi">+        &quot;ecdh-sha2-nistp521&quot;: KexNistp521,</span>
<span class="gi">+    }</span>
<span class="w"> </span>    if KexCurve25519.is_available():
<span class="gd">-        _kex_info[&#39;curve25519-sha256@libssh.org&#39;] = KexCurve25519</span>
<span class="gd">-    _compression_info = {&#39;zlib@openssh.com&#39;: (ZlibCompressor,</span>
<span class="gd">-        ZlibDecompressor), &#39;zlib&#39;: (ZlibCompressor, ZlibDecompressor),</span>
<span class="gd">-        &#39;none&#39;: (None, None)}</span>
<span class="gi">+        _kex_info[&quot;curve25519-sha256@libssh.org&quot;] = KexCurve25519</span>
<span class="gi">+</span>
<span class="gi">+    _compression_info = {</span>
<span class="gi">+        # zlib@openssh.com is just zlib, but only turned on after a successful</span>
<span class="gi">+        # authentication.  openssh servers may only offer this type because</span>
<span class="gi">+        # they&#39;ve had troubles with security holes in zlib in the past.</span>
<span class="gi">+        &quot;zlib@openssh.com&quot;: (ZlibCompressor, ZlibDecompressor),</span>
<span class="gi">+        &quot;zlib&quot;: (ZlibCompressor, ZlibDecompressor),</span>
<span class="gi">+        &quot;none&quot;: (None, None),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    _modulus_pack = None
<span class="w"> </span>    _active_check_timeout = 0.1

<span class="gd">-    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE,</span>
<span class="gd">-        default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False,</span>
<span class="gd">-        gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=</span>
<span class="gd">-        True, strict_kex=True, packetizer_class=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        sock,</span>
<span class="gi">+        default_window_size=DEFAULT_WINDOW_SIZE,</span>
<span class="gi">+        default_max_packet_size=DEFAULT_MAX_PACKET_SIZE,</span>
<span class="gi">+        gss_kex=False,</span>
<span class="gi">+        gss_deleg_creds=True,</span>
<span class="gi">+        disabled_algorithms=None,</span>
<span class="gi">+        server_sig_algs=True,</span>
<span class="gi">+        strict_kex=True,</span>
<span class="gi">+        packetizer_class=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new SSH session over an existing socket, or socket-like
<span class="w"> </span>        object.  This only creates the `.Transport` object; it doesn&#39;t begin
<span class="gu">@@ -225,22 +444,29 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        self.server_extensions = {}
<span class="w"> </span>        self.advertise_strict_kex = strict_kex
<span class="w"> </span>        self.agreed_on_strict_kex = False
<span class="gi">+</span>
<span class="gi">+        # TODO: these two overrides on sock&#39;s type should go away sometime, too</span>
<span class="gi">+        # many ways to do it!</span>
<span class="w"> </span>        if isinstance(sock, str):
<span class="gd">-            hl = sock.split(&#39;:&#39;, 1)</span>
<span class="gi">+            # convert &quot;host:port&quot; into (host, port)</span>
<span class="gi">+            hl = sock.split(&quot;:&quot;, 1)</span>
<span class="w"> </span>            self.hostname = hl[0]
<span class="w"> </span>            if len(hl) == 1:
<span class="gd">-                sock = hl[0], 22</span>
<span class="gi">+                sock = (hl[0], 22)</span>
<span class="w"> </span>            else:
<span class="gd">-                sock = hl[0], int(hl[1])</span>
<span class="gi">+                sock = (hl[0], int(hl[1]))</span>
<span class="w"> </span>        if type(sock) is tuple:
<span class="gi">+            # connect to the given (host, port)</span>
<span class="w"> </span>            hostname, port = sock
<span class="w"> </span>            self.hostname = hostname
<span class="gd">-            reason = &#39;No suitable address family&#39;</span>
<span class="gd">-            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC,</span>
<span class="gd">-                socket.SOCK_STREAM)</span>
<span class="gi">+            reason = &quot;No suitable address family&quot;</span>
<span class="gi">+            addrinfos = socket.getaddrinfo(</span>
<span class="gi">+                hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM</span>
<span class="gi">+            )</span>
<span class="w"> </span>            for family, socktype, proto, canonname, sockaddr in addrinfos:
<span class="w"> </span>                if socktype == socket.SOCK_STREAM:
<span class="w"> </span>                    af = family
<span class="gi">+                    # addr = sockaddr</span>
<span class="w"> </span>                    sock = socket.socket(af, socket.SOCK_STREAM)
<span class="w"> </span>                    try:
<span class="w"> </span>                        sock.connect((hostname, port))
<span class="gu">@@ -249,97 +475,171 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>                    else:
<span class="w"> </span>                        break
<span class="w"> </span>            else:
<span class="gd">-                raise SSHException(&#39;Unable to connect to {}: {}&#39;.format(</span>
<span class="gd">-                    hostname, reason))</span>
<span class="gi">+                raise SSHException(</span>
<span class="gi">+                    &quot;Unable to connect to {}: {}&quot;.format(hostname, reason)</span>
<span class="gi">+                )</span>
<span class="gi">+        # okay, normal socket-ish flow here...</span>
<span class="w"> </span>        threading.Thread.__init__(self)
<span class="w"> </span>        self.daemon = True
<span class="w"> </span>        self.sock = sock
<span class="gi">+        # we set the timeout so we can check self.active periodically to</span>
<span class="gi">+        # see if we should bail. socket.timeout exception is never propagated.</span>
<span class="w"> </span>        self.sock.settimeout(self._active_check_timeout)
<span class="gi">+</span>
<span class="gi">+        # negotiated crypto parameters</span>
<span class="w"> </span>        self.packetizer = (packetizer_class or Packetizer)(sock)
<span class="gd">-        self.local_version = &#39;SSH-&#39; + self._PROTO_ID + &#39;-&#39; + self._CLIENT_ID</span>
<span class="gd">-        self.remote_version = &#39;&#39;</span>
<span class="gd">-        self.local_cipher = self.remote_cipher = &#39;&#39;</span>
<span class="gi">+        self.local_version = &quot;SSH-&quot; + self._PROTO_ID + &quot;-&quot; + self._CLIENT_ID</span>
<span class="gi">+        self.remote_version = &quot;&quot;</span>
<span class="gi">+        self.local_cipher = self.remote_cipher = &quot;&quot;</span>
<span class="w"> </span>        self.local_kex_init = self.remote_kex_init = None
<span class="w"> </span>        self.local_mac = self.remote_mac = None
<span class="w"> </span>        self.local_compression = self.remote_compression = None
<span class="w"> </span>        self.session_id = None
<span class="w"> </span>        self.host_key_type = None
<span class="w"> </span>        self.host_key = None
<span class="gi">+</span>
<span class="gi">+        # GSS-API / SSPI Key Exchange</span>
<span class="w"> </span>        self.use_gss_kex = gss_kex
<span class="gi">+        # This will be set to True if GSS-API Key Exchange was performed</span>
<span class="w"> </span>        self.gss_kex_used = False
<span class="w"> </span>        self.kexgss_ctxt = None
<span class="w"> </span>        self.gss_host = None
<span class="w"> </span>        if self.use_gss_kex:
<span class="gd">-            self.kexgss_ctxt = GSSAuth(&#39;gssapi-keyex&#39;, gss_deleg_creds)</span>
<span class="gi">+            self.kexgss_ctxt = GSSAuth(&quot;gssapi-keyex&quot;, gss_deleg_creds)</span>
<span class="w"> </span>            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
<span class="gi">+</span>
<span class="gi">+        # state used during negotiation</span>
<span class="w"> </span>        self.kex_engine = None
<span class="w"> </span>        self.H = None
<span class="w"> </span>        self.K = None
<span class="gi">+</span>
<span class="w"> </span>        self.initial_kex_done = False
<span class="w"> </span>        self.in_kex = False
<span class="w"> </span>        self.authenticated = False
<span class="w"> </span>        self._expected_packet = tuple()
<span class="gi">+        # synchronization (always higher level than write_lock)</span>
<span class="w"> </span>        self.lock = threading.Lock()
<span class="gi">+</span>
<span class="gi">+        # tracking open channels</span>
<span class="w"> </span>        self._channels = ChannelMap()
<span class="gd">-        self.channel_events = {}</span>
<span class="gd">-        self.channels_seen = {}</span>
<span class="gi">+        self.channel_events = {}  # (id -&gt; Event)</span>
<span class="gi">+        self.channels_seen = {}  # (id -&gt; True)</span>
<span class="w"> </span>        self._channel_counter = 0
<span class="w"> </span>        self.default_max_packet_size = default_max_packet_size
<span class="w"> </span>        self.default_window_size = default_window_size
<span class="w"> </span>        self._forward_agent_handler = None
<span class="w"> </span>        self._x11_handler = None
<span class="w"> </span>        self._tcp_handler = None
<span class="gi">+</span>
<span class="w"> </span>        self.saved_exception = None
<span class="w"> </span>        self.clear_to_send = threading.Event()
<span class="w"> </span>        self.clear_to_send_lock = threading.Lock()
<span class="w"> </span>        self.clear_to_send_timeout = 30.0
<span class="gd">-        self.log_name = &#39;paramiko.transport&#39;</span>
<span class="gi">+        self.log_name = &quot;paramiko.transport&quot;</span>
<span class="w"> </span>        self.logger = util.get_logger(self.log_name)
<span class="w"> </span>        self.packetizer.set_log(self.logger)
<span class="w"> </span>        self.auth_handler = None
<span class="gi">+        # response Message from an arbitrary global request</span>
<span class="w"> </span>        self.global_response = None
<span class="gi">+        # user-defined event callbacks</span>
<span class="w"> </span>        self.completion_event = None
<span class="gi">+        # how long (seconds) to wait for the SSH banner</span>
<span class="w"> </span>        self.banner_timeout = 15
<span class="gi">+        # how long (seconds) to wait for the handshake to finish after SSH</span>
<span class="gi">+        # banner sent.</span>
<span class="w"> </span>        self.handshake_timeout = 15
<span class="gi">+        # how long (seconds) to wait for the auth response.</span>
<span class="w"> </span>        self.auth_timeout = 30
<span class="gi">+        # how long (seconds) to wait for opening a channel</span>
<span class="w"> </span>        self.channel_timeout = 60 * 60
<span class="w"> </span>        self.disabled_algorithms = disabled_algorithms or {}
<span class="w"> </span>        self.server_sig_algs = server_sig_algs
<span class="gi">+</span>
<span class="gi">+        # server mode:</span>
<span class="w"> </span>        self.server_mode = False
<span class="w"> </span>        self.server_object = None
<span class="w"> </span>        self.server_key_dict = {}
<span class="w"> </span>        self.server_accepts = []
<span class="w"> </span>        self.server_accept_cv = threading.Condition(self.lock)
<span class="w"> </span>        self.subsystem_table = {}
<span class="gd">-        self._handler_table = {MSG_EXT_INFO: self._parse_ext_info,</span>
<span class="gd">-            MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self.</span>
<span class="gd">-            _parse_global_request, MSG_REQUEST_SUCCESS: self.</span>
<span class="gd">-            _parse_request_success, MSG_REQUEST_FAILURE: self.</span>
<span class="gd">-            _parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self.</span>
<span class="gd">-            _parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self.</span>
<span class="gd">-            _parse_channel_open_failure, MSG_CHANNEL_OPEN: self.</span>
<span class="gd">-            _parse_channel_open, MSG_KEXINIT: self._negotiate_keys}</span>
<span class="gi">+</span>
<span class="gi">+        # Handler table, now set at init time for easier per-instance</span>
<span class="gi">+        # manipulation and subclass twiddling.</span>
<span class="gi">+        self._handler_table = {</span>
<span class="gi">+            MSG_EXT_INFO: self._parse_ext_info,</span>
<span class="gi">+            MSG_NEWKEYS: self._parse_newkeys,</span>
<span class="gi">+            MSG_GLOBAL_REQUEST: self._parse_global_request,</span>
<span class="gi">+            MSG_REQUEST_SUCCESS: self._parse_request_success,</span>
<span class="gi">+            MSG_REQUEST_FAILURE: self._parse_request_failure,</span>
<span class="gi">+            MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success,</span>
<span class="gi">+            MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure,</span>
<span class="gi">+            MSG_CHANNEL_OPEN: self._parse_channel_open,</span>
<span class="gi">+            MSG_KEXINIT: self._negotiate_keys,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def _filter_algorithm(self, type_):</span>
<span class="gi">+        default = getattr(self, &quot;_preferred_{}&quot;.format(type_))</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            x</span>
<span class="gi">+            for x in default</span>
<span class="gi">+            if x not in self.disabled_algorithms.get(type_, [])</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def preferred_ciphers(self):</span>
<span class="gi">+        return self._filter_algorithm(&quot;ciphers&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def preferred_macs(self):</span>
<span class="gi">+        return self._filter_algorithm(&quot;macs&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def preferred_keys(self):</span>
<span class="gi">+        # Interleave cert variants here; resistant to various background</span>
<span class="gi">+        # overwriting of _preferred_keys, and necessary as hostkeys can&#39;t use</span>
<span class="gi">+        # the logic pubkey auth does re: injecting/checking for certs at</span>
<span class="gi">+        # runtime</span>
<span class="gi">+        filtered = self._filter_algorithm(&quot;keys&quot;)</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            filtered</span>
<span class="gi">+            + tuple(&quot;{}-cert-v01@openssh.com&quot;.format(x) for x in filtered)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def preferred_pubkeys(self):</span>
<span class="gi">+        return self._filter_algorithm(&quot;pubkeys&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def preferred_kex(self):</span>
<span class="gi">+        return self._filter_algorithm(&quot;kex&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def preferred_compression(self):</span>
<span class="gi">+        return self._filter_algorithm(&quot;compression&quot;)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a string representation of this object, for debugging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        id_ = hex(id(self) &amp; xffffffff)
<span class="gd">-        out = &#39;&lt;paramiko.Transport at {}&#39;.format(id_)</span>
<span class="gi">+        out = &quot;&lt;paramiko.Transport at {}&quot;.format(id_)</span>
<span class="w"> </span>        if not self.active:
<span class="gd">-            out += &#39; (unconnected)&#39;</span>
<span class="gi">+            out += &quot; (unconnected)&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            if self.local_cipher != &#39;&#39;:</span>
<span class="gd">-                out += &#39; (cipher {}, {:d} bits)&#39;.format(self.local_cipher, </span>
<span class="gd">-                    self._cipher_info[self.local_cipher][&#39;key-size&#39;] * 8)</span>
<span class="gi">+            if self.local_cipher != &quot;&quot;:</span>
<span class="gi">+                out += &quot; (cipher {}, {:d} bits)&quot;.format(</span>
<span class="gi">+                    self.local_cipher,</span>
<span class="gi">+                    self._cipher_info[self.local_cipher][&quot;key-size&quot;] * 8,</span>
<span class="gi">+                )</span>
<span class="w"> </span>            if self.is_authenticated():
<span class="gd">-                out += &#39; (active; {} open channel(s))&#39;.format(len(self.</span>
<span class="gd">-                    _channels))</span>
<span class="gi">+                out += &quot; (active; {} open channel(s))&quot;.format(</span>
<span class="gi">+                    len(self._channels)</span>
<span class="gi">+                )</span>
<span class="w"> </span>            elif self.initial_kex_done:
<span class="gd">-                out += &#39; (connected; awaiting auth)&#39;</span>
<span class="gi">+                out += &quot; (connected; awaiting auth)&quot;</span>
<span class="w"> </span>            else:
<span class="gd">-                out += &#39; (connecting)&#39;</span>
<span class="gd">-        out += &#39;&gt;&#39;</span>
<span class="gi">+                out += &quot; (connecting)&quot;</span>
<span class="gi">+        out += &quot;&gt;&quot;</span>
<span class="w"> </span>        return out

<span class="w"> </span>    def atfork(self):
<span class="gu">@@ -352,7 +652,8 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.5.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sock.close()</span>
<span class="gi">+        self.close()</span>

<span class="w"> </span>    def get_security_options(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -361,7 +662,7 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        digest/hash operations, public keys, and key exchanges) and the order
<span class="w"> </span>        of preference for them.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SecurityOptions(self)</span>

<span class="w"> </span>    def set_gss_host(self, gss_host, trust_dns=True, gssapi_requested=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -384,7 +685,18 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            (Defaults to True due to backwards compatibility.)
<span class="w"> </span>        :returns: ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # No GSSAPI in play == nothing to do</span>
<span class="gi">+        if not gssapi_requested:</span>
<span class="gi">+            return</span>
<span class="gi">+        # Obtain the correct host first - did user request a GSS-specific name</span>
<span class="gi">+        # to use that is distinct from the actual SSH target hostname?</span>
<span class="gi">+        if gss_host is None:</span>
<span class="gi">+            gss_host = self.hostname</span>
<span class="gi">+        # Finally, canonicalize via DNS if DNS is trusted.</span>
<span class="gi">+        if trust_dns and gss_host is not None:</span>
<span class="gi">+            gss_host = socket.getfqdn(gss_host)</span>
<span class="gi">+        # And set attribute for reference later.</span>
<span class="gi">+        self.gss_host = gss_host</span>

<span class="w"> </span>    def start_client(self, event=None, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -421,7 +733,28 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if negotiation fails (and no ``event`` was
<span class="w"> </span>            passed in)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.active = True</span>
<span class="gi">+        if event is not None:</span>
<span class="gi">+            # async, return immediately and let the app poll for completion</span>
<span class="gi">+            self.completion_event = event</span>
<span class="gi">+            self.start()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # synchronous, wait for a result</span>
<span class="gi">+        self.completion_event = event = threading.Event()</span>
<span class="gi">+        self.start()</span>
<span class="gi">+        max_time = time.time() + timeout if timeout is not None else None</span>
<span class="gi">+        while True:</span>
<span class="gi">+            event.wait(0.1)</span>
<span class="gi">+            if not self.active:</span>
<span class="gi">+                e = self.get_exception()</span>
<span class="gi">+                if e is not None:</span>
<span class="gi">+                    raise e</span>
<span class="gi">+                raise SSHException(&quot;Negotiation failed.&quot;)</span>
<span class="gi">+            if event.is_set() or (</span>
<span class="gi">+                timeout is not None and time.time() &gt;= max_time</span>
<span class="gi">+            ):</span>
<span class="gi">+                break</span>

<span class="w"> </span>    def start_server(self, event=None, server=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -465,7 +798,29 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if negotiation fails (and no ``event`` was
<span class="w"> </span>            passed in)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if server is None:</span>
<span class="gi">+            server = ServerInterface()</span>
<span class="gi">+        self.server_mode = True</span>
<span class="gi">+        self.server_object = server</span>
<span class="gi">+        self.active = True</span>
<span class="gi">+        if event is not None:</span>
<span class="gi">+            # async, return immediately and let the app poll for completion</span>
<span class="gi">+            self.completion_event = event</span>
<span class="gi">+            self.start()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # synchronous, wait for a result</span>
<span class="gi">+        self.completion_event = event = threading.Event()</span>
<span class="gi">+        self.start()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            event.wait(0.1)</span>
<span class="gi">+            if not self.active:</span>
<span class="gi">+                e = self.get_exception()</span>
<span class="gi">+                if e is not None:</span>
<span class="gi">+                    raise e</span>
<span class="gi">+                raise SSHException(&quot;Negotiation failed.&quot;)</span>
<span class="gi">+            if event.is_set():</span>
<span class="gi">+                break</span>

<span class="w"> </span>    def add_server_key(self, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -479,7 +834,13 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        :param .PKey key:
<span class="w"> </span>            the host key to add, usually an `.RSAKey` or `.DSSKey`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.server_key_dict[key.get_name()] = key</span>
<span class="gi">+        # Handle SHA-2 extensions for RSA by ensuring that lookups into</span>
<span class="gi">+        # self.server_key_dict will yield this key for any of the algorithm</span>
<span class="gi">+        # names.</span>
<span class="gi">+        if isinstance(key, RSAKey):</span>
<span class="gi">+            self.server_key_dict[&quot;rsa-sha2-256&quot;] = key</span>
<span class="gi">+            self.server_key_dict[&quot;rsa-sha2-512&quot;] = key</span>

<span class="w"> </span>    def get_server_key(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -496,7 +857,11 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            host key (`.PKey`) of the type negotiated by the client, or
<span class="w"> </span>            ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.server_key_dict[self.host_key_type]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def load_server_moduli(filename=None):
<span class="gu">@@ -524,13 +889,31 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. note:: This has no effect when used in client mode.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        Transport._modulus_pack = ModulusPack()</span>
<span class="gi">+        # places to look for the openssh &quot;moduli&quot; file</span>
<span class="gi">+        file_list = [&quot;/etc/ssh/moduli&quot;, &quot;/usr/local/etc/moduli&quot;]</span>
<span class="gi">+        if filename is not None:</span>
<span class="gi">+            file_list.insert(0, filename)</span>
<span class="gi">+        for fn in file_list:</span>
<span class="gi">+            try:</span>
<span class="gi">+                Transport._modulus_pack.read_file(fn)</span>
<span class="gi">+                return True</span>
<span class="gi">+            except IOError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        # none succeeded</span>
<span class="gi">+        Transport._modulus_pack = None</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close this session, and any open channels that are tied to it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.active:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.stop_thread()</span>
<span class="gi">+        for chan in list(self._channels.values()):</span>
<span class="gi">+            chan._unlink()</span>
<span class="gi">+        self.sock.close()</span>

<span class="w"> </span>    def get_remote_server_key(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -545,7 +928,9 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        :return: public key (`.PKey`) of the remote server
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (not self.active) or (not self.initial_kex_done):</span>
<span class="gi">+            raise SSHException(&quot;No existing session&quot;)</span>
<span class="gi">+        return self.host_key</span>

<span class="w"> </span>    def is_active(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -555,10 +940,11 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            True if the session is still active (open); False if the session is
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.active</span>

<span class="gd">-    def open_session(self, window_size=None, max_packet_size=None, timeout=None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def open_session(</span>
<span class="gi">+        self, window_size=None, max_packet_size=None, timeout=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Request a new channel to the server, of type ``&quot;session&quot;``.  This is
<span class="w"> </span>        just an alias for calling `open_channel` with an argument of
<span class="gu">@@ -584,7 +970,12 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 1.15
<span class="w"> </span>            Added the ``window_size`` and ``max_packet_size`` arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.open_channel(</span>
<span class="gi">+            &quot;session&quot;,</span>
<span class="gi">+            window_size=window_size,</span>
<span class="gi">+            max_packet_size=max_packet_size,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def open_x11_channel(self, src_addr=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -600,7 +991,7 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request is rejected or the session ends
<span class="w"> </span>            prematurely
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.open_channel(&quot;x11&quot;, src_addr=src_addr)</span>

<span class="w"> </span>    def open_forward_agent_channel(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -614,7 +1005,7 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        :raises: `.SSHException` --
<span class="w"> </span>            if the request is rejected or the session ends prematurely
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.open_channel(&quot;auth-agent@openssh.com&quot;)</span>

<span class="w"> </span>    def open_forwarded_tcpip_channel(self, src_addr, dest_addr):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -626,10 +1017,17 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        :param src_addr: originator&#39;s address
<span class="w"> </span>        :param dest_addr: local (server) connected address
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.open_channel(&quot;forwarded-tcpip&quot;, dest_addr, src_addr)</span>

<span class="gd">-    def open_channel(self, kind, dest_addr=None, src_addr=None, window_size</span>
<span class="gd">-        =None, max_packet_size=None, timeout=None):</span>
<span class="gi">+    def open_channel(</span>
<span class="gi">+        self,</span>
<span class="gi">+        kind,</span>
<span class="gi">+        dest_addr=None,</span>
<span class="gi">+        src_addr=None,</span>
<span class="gi">+        window_size=None,</span>
<span class="gi">+        max_packet_size=None,</span>
<span class="gi">+        timeout=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Request a new channel to the server. `Channels &lt;.Channel&gt;` are
<span class="w"> </span>        socket-like objects used for the actual transfer of data across the
<span class="gu">@@ -665,7 +1063,56 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 1.15
<span class="w"> </span>            Added the ``window_size`` and ``max_packet_size`` arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.active:</span>
<span class="gi">+            raise SSHException(&quot;SSH session not active&quot;)</span>
<span class="gi">+        timeout = self.channel_timeout if timeout is None else timeout</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            window_size = self._sanitize_window_size(window_size)</span>
<span class="gi">+            max_packet_size = self._sanitize_packet_size(max_packet_size)</span>
<span class="gi">+            chanid = self._next_channel()</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_CHANNEL_OPEN)</span>
<span class="gi">+            m.add_string(kind)</span>
<span class="gi">+            m.add_int(chanid)</span>
<span class="gi">+            m.add_int(window_size)</span>
<span class="gi">+            m.add_int(max_packet_size)</span>
<span class="gi">+            if (kind == &quot;forwarded-tcpip&quot;) or (kind == &quot;direct-tcpip&quot;):</span>
<span class="gi">+                m.add_string(dest_addr[0])</span>
<span class="gi">+                m.add_int(dest_addr[1])</span>
<span class="gi">+                m.add_string(src_addr[0])</span>
<span class="gi">+                m.add_int(src_addr[1])</span>
<span class="gi">+            elif kind == &quot;x11&quot;:</span>
<span class="gi">+                m.add_string(src_addr[0])</span>
<span class="gi">+                m.add_int(src_addr[1])</span>
<span class="gi">+            chan = Channel(chanid)</span>
<span class="gi">+            self._channels.put(chanid, chan)</span>
<span class="gi">+            self.channel_events[chanid] = event = threading.Event()</span>
<span class="gi">+            self.channels_seen[chanid] = True</span>
<span class="gi">+            chan._set_transport(self)</span>
<span class="gi">+            chan._set_window(window_size, max_packet_size)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        self._send_user_message(m)</span>
<span class="gi">+        start_ts = time.time()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            event.wait(0.1)</span>
<span class="gi">+            if not self.active:</span>
<span class="gi">+                e = self.get_exception()</span>
<span class="gi">+                if e is None:</span>
<span class="gi">+                    e = SSHException(&quot;Unable to open channel.&quot;)</span>
<span class="gi">+                raise e</span>
<span class="gi">+            if event.is_set():</span>
<span class="gi">+                break</span>
<span class="gi">+            elif start_ts + timeout &lt; time.time():</span>
<span class="gi">+                raise SSHException(&quot;Timeout opening channel.&quot;)</span>
<span class="gi">+        chan = self._channels.get(chanid)</span>
<span class="gi">+        if chan is not None:</span>
<span class="gi">+            return chan</span>
<span class="gi">+        e = self.get_exception()</span>
<span class="gi">+        if e is None:</span>
<span class="gi">+            e = SSHException(&quot;Unable to open channel.&quot;)</span>
<span class="gi">+        raise e</span>

<span class="w"> </span>    def request_port_forward(self, address, port, handler=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -700,7 +1147,26 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        :raises:
<span class="w"> </span>            `.SSHException` -- if the server refused the TCP forward request
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.active:</span>
<span class="gi">+            raise SSHException(&quot;SSH session not active&quot;)</span>
<span class="gi">+        port = int(port)</span>
<span class="gi">+        response = self.global_request(</span>
<span class="gi">+            &quot;tcpip-forward&quot;, (address, port), wait=True</span>
<span class="gi">+        )</span>
<span class="gi">+        if response is None:</span>
<span class="gi">+            raise SSHException(&quot;TCP forwarding request denied&quot;)</span>
<span class="gi">+        if port == 0:</span>
<span class="gi">+            port = response.get_int()</span>
<span class="gi">+        if handler is None:</span>
<span class="gi">+</span>
<span class="gi">+            def default_handler(channel, src_addr, dest_addr_port):</span>
<span class="gi">+                # src_addr, src_port = src_addr_port</span>
<span class="gi">+                # dest_addr, dest_port = dest_addr_port</span>
<span class="gi">+                self._queue_incoming_channel(channel)</span>
<span class="gi">+</span>
<span class="gi">+            handler = default_handler</span>
<span class="gi">+        self._tcp_handler = handler</span>
<span class="gi">+        return port</span>

<span class="w"> </span>    def cancel_port_forward(self, address, port):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -711,7 +1177,10 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        :param str address: the address to stop forwarding
<span class="w"> </span>        :param int port: the port to stop forwarding
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.active:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._tcp_handler = None</span>
<span class="gi">+        self.global_request(&quot;cancel-tcpip-forward&quot;, (address, port), wait=True)</span>

<span class="w"> </span>    def open_sftp_client(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -723,7 +1192,7 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            a new `.SFTPClient` referring to an sftp session (channel) across
<span class="w"> </span>            this transport
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SFTPClient.from_transport(self)</span>

<span class="w"> </span>    def send_ignore(self, byte_count=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -736,7 +1205,12 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            the number of random bytes to send in the payload of the ignored
<span class="w"> </span>            packet -- defaults to a random number from 10 to 41.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_IGNORE)</span>
<span class="gi">+        if byte_count is None:</span>
<span class="gi">+            byte_count = (byte_ord(os.urandom(1)) % 32) + 10</span>
<span class="gi">+        m.add_bytes(os.urandom(byte_count))</span>
<span class="gi">+        self._send_user_message(m)</span>

<span class="w"> </span>    def renegotiate_keys(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -751,7 +1225,18 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the key renegotiation failed (which causes
<span class="w"> </span>            the session to end)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.completion_event = threading.Event()</span>
<span class="gi">+        self._send_kex_init()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.completion_event.wait(0.1)</span>
<span class="gi">+            if not self.active:</span>
<span class="gi">+                e = self.get_exception()</span>
<span class="gi">+                if e is not None:</span>
<span class="gi">+                    raise e</span>
<span class="gi">+                raise SSHException(&quot;Negotiation failed.&quot;)</span>
<span class="gi">+            if self.completion_event.is_set():</span>
<span class="gi">+                break</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def set_keepalive(self, interval):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -764,7 +1249,11 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            seconds to wait before sending a keepalive packet (or
<span class="w"> </span>            0 to disable keepalives).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def _request(x=weakref.proxy(self)):</span>
<span class="gi">+            return x.global_request(&quot;keepalive@lag.net&quot;, wait=False)</span>
<span class="gi">+</span>
<span class="gi">+        self.packetizer.set_keepalive(interval, _request)</span>

<span class="w"> </span>    def global_request(self, kind, data=None, wait=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -783,7 +1272,25 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            successful (or an empty `.Message` if ``wait`` was ``False``);
<span class="w"> </span>            ``None`` if the request was denied.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if wait:</span>
<span class="gi">+            self.completion_event = threading.Event()</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_GLOBAL_REQUEST)</span>
<span class="gi">+        m.add_string(kind)</span>
<span class="gi">+        m.add_boolean(wait)</span>
<span class="gi">+        if data is not None:</span>
<span class="gi">+            m.add(*data)</span>
<span class="gi">+        self._log(DEBUG, &#39;Sending global request &quot;{}&quot;&#39;.format(kind))</span>
<span class="gi">+        self._send_user_message(m)</span>
<span class="gi">+        if not wait:</span>
<span class="gi">+            return None</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.completion_event.wait(0.1)</span>
<span class="gi">+            if not self.active:</span>
<span class="gi">+                return None</span>
<span class="gi">+            if self.completion_event.is_set():</span>
<span class="gi">+                break</span>
<span class="gi">+        return self.global_response</span>

<span class="w"> </span>    def accept(self, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -795,11 +1302,33 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            seconds to wait for a channel, or ``None`` to wait forever
<span class="w"> </span>        :return: a new `.Channel` opened by the client
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def connect(self, hostkey=None, username=&#39;&#39;, password=None, pkey=None,</span>
<span class="gd">-        gss_host=None, gss_auth=False, gss_kex=False, gss_deleg_creds=True,</span>
<span class="gd">-        gss_trust_dns=True):</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if len(self.server_accepts) &gt; 0:</span>
<span class="gi">+                chan = self.server_accepts.pop(0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.server_accept_cv.wait(timeout)</span>
<span class="gi">+                if len(self.server_accepts) &gt; 0:</span>
<span class="gi">+                    chan = self.server_accepts.pop(0)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # timeout</span>
<span class="gi">+                    chan = None</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        return chan</span>
<span class="gi">+</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        hostkey=None,</span>
<span class="gi">+        username=&quot;&quot;,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        pkey=None,</span>
<span class="gi">+        gss_host=None,</span>
<span class="gi">+        gss_auth=False,</span>
<span class="gi">+        gss_kex=False,</span>
<span class="gi">+        gss_deleg_creds=True,</span>
<span class="gi">+        gss_trust_dns=True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Negotiate an SSH2 session, and optionally verify the server&#39;s host key
<span class="w"> </span>        and authenticate using a password or private key.  This is a shortcut
<span class="gu">@@ -848,7 +1377,73 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 2.3
<span class="w"> </span>            Added the ``gss_trust_dns`` argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hostkey is not None:</span>
<span class="gi">+            # TODO: a more robust implementation would be to ask each key class</span>
<span class="gi">+            # for its nameS plural, and just use that.</span>
<span class="gi">+            # TODO: that could be used in a bunch of other spots too</span>
<span class="gi">+            if isinstance(hostkey, RSAKey):</span>
<span class="gi">+                self._preferred_keys = [</span>
<span class="gi">+                    &quot;rsa-sha2-512&quot;,</span>
<span class="gi">+                    &quot;rsa-sha2-256&quot;,</span>
<span class="gi">+                    &quot;ssh-rsa&quot;,</span>
<span class="gi">+                ]</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._preferred_keys = [hostkey.get_name()]</span>
<span class="gi">+</span>
<span class="gi">+        self.set_gss_host(</span>
<span class="gi">+            gss_host=gss_host,</span>
<span class="gi">+            trust_dns=gss_trust_dns,</span>
<span class="gi">+            gssapi_requested=gss_kex or gss_auth,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.start_client()</span>
<span class="gi">+</span>
<span class="gi">+        # check host key if we were given one</span>
<span class="gi">+        # If GSS-API Key Exchange was performed, we are not required to check</span>
<span class="gi">+        # the host key.</span>
<span class="gi">+        if (hostkey is not None) and not gss_kex:</span>
<span class="gi">+            key = self.get_remote_server_key()</span>
<span class="gi">+            if (</span>
<span class="gi">+                key.get_name() != hostkey.get_name()</span>
<span class="gi">+                or key.asbytes() != hostkey.asbytes()</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._log(DEBUG, &quot;Bad host key from server&quot;)</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG,</span>
<span class="gi">+                    &quot;Expected: {}: {}&quot;.format(</span>
<span class="gi">+                        hostkey.get_name(), repr(hostkey.asbytes())</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG,</span>
<span class="gi">+                    &quot;Got     : {}: {}&quot;.format(</span>
<span class="gi">+                        key.get_name(), repr(key.asbytes())</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+                raise SSHException(&quot;Bad host key from server&quot;)</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG, &quot;Host key verified ({})&quot;.format(hostkey.get_name())</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if (pkey is not None) or (password is not None) or gss_auth or gss_kex:</span>
<span class="gi">+            if gss_auth:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG, &quot;Attempting GSS-API auth... (gssapi-with-mic)&quot;</span>
<span class="gi">+                )  # noqa</span>
<span class="gi">+                self.auth_gssapi_with_mic(</span>
<span class="gi">+                    username, self.gss_host, gss_deleg_creds</span>
<span class="gi">+                )</span>
<span class="gi">+            elif gss_kex:</span>
<span class="gi">+                self._log(DEBUG, &quot;Attempting GSS-API auth... (gssapi-keyex)&quot;)</span>
<span class="gi">+                self.auth_gssapi_keyex(username)</span>
<span class="gi">+            elif pkey is not None:</span>
<span class="gi">+                self._log(DEBUG, &quot;Attempting public-key auth...&quot;)</span>
<span class="gi">+                self.auth_publickey(username, pkey)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._log(DEBUG, &quot;Attempting password auth...&quot;)</span>
<span class="gi">+                self.auth_password(username, password)</span>
<span class="gi">+</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def get_exception(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -862,7 +1457,13 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            e = self.saved_exception</span>
<span class="gi">+            self.saved_exception = None</span>
<span class="gi">+            return e</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>

<span class="w"> </span>    def set_subsystem_handler(self, name, handler, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -878,7 +1479,11 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        :param handler:
<span class="w"> </span>            subclass of `.SubsystemHandler` that handles this subsystem.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.lock.acquire()</span>
<span class="gi">+            self.subsystem_table[name] = (handler, args, kwargs)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>

<span class="w"> </span>    def is_authenticated(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -889,7 +1494,11 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            successfully; False if authentication failed and/or the session is
<span class="w"> </span>            closed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.active</span>
<span class="gi">+            and self.auth_handler is not None</span>
<span class="gi">+            and self.auth_handler.is_authenticated()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def get_username(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -899,7 +1508,9 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        :return: username that was authenticated (a `str`), or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.active or (self.auth_handler is None):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self.auth_handler.get_username()</span>

<span class="w"> </span>    def get_banner(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -910,7 +1521,9 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.13
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.active or (self.auth_handler is None):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self.auth_handler.banner</span>

<span class="w"> </span>    def auth_none(self, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -933,7 +1546,12 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (not self.active) or (not self.initial_kex_done):</span>
<span class="gi">+            raise SSHException(&quot;No existing session&quot;)</span>
<span class="gi">+        my_event = threading.Event()</span>
<span class="gi">+        self.auth_handler = AuthHandler(self)</span>
<span class="gi">+        self.auth_handler.auth_none(username, my_event)</span>
<span class="gi">+        return self.auth_handler.wait_for_response(my_event)</span>

<span class="w"> </span>    def auth_password(self, username, password, event=None, fallback=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -982,7 +1600,43 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            event was passed in)
<span class="w"> </span>        :raises: `.SSHException` -- if there was a network error
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (not self.active) or (not self.initial_kex_done):</span>
<span class="gi">+            # we should never try to send the password unless we&#39;re on a secure</span>
<span class="gi">+            # link</span>
<span class="gi">+            raise SSHException(&quot;No existing session&quot;)</span>
<span class="gi">+        if event is None:</span>
<span class="gi">+            my_event = threading.Event()</span>
<span class="gi">+        else:</span>
<span class="gi">+            my_event = event</span>
<span class="gi">+        self.auth_handler = AuthHandler(self)</span>
<span class="gi">+        self.auth_handler.auth_password(username, password, my_event)</span>
<span class="gi">+        if event is not None:</span>
<span class="gi">+            # caller wants to wait for event themselves</span>
<span class="gi">+            return []</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.auth_handler.wait_for_response(my_event)</span>
<span class="gi">+        except BadAuthenticationType as e:</span>
<span class="gi">+            # if password auth isn&#39;t allowed, but keyboard-interactive *is*,</span>
<span class="gi">+            # try to fudge it</span>
<span class="gi">+            if not fallback or (&quot;keyboard-interactive&quot; not in e.allowed_types):</span>
<span class="gi">+                raise</span>
<span class="gi">+            try:</span>
<span class="gi">+</span>
<span class="gi">+                def handler(title, instructions, fields):</span>
<span class="gi">+                    if len(fields) &gt; 1:</span>
<span class="gi">+                        raise SSHException(&quot;Fallback authentication failed.&quot;)</span>
<span class="gi">+                    if len(fields) == 0:</span>
<span class="gi">+                        # for some reason, at least on os x, a 2nd request will</span>
<span class="gi">+                        # be made with zero fields requested.  maybe it&#39;s just</span>
<span class="gi">+                        # to try to fake out automated scripting of the exact</span>
<span class="gi">+                        # type we&#39;re doing here.  *shrug* :)</span>
<span class="gi">+                        return []</span>
<span class="gi">+                    return [password]</span>
<span class="gi">+</span>
<span class="gi">+                return self.auth_interactive(username, handler)</span>
<span class="gi">+            except SSHException:</span>
<span class="gi">+                # attempt failed; just raise the original exception</span>
<span class="gi">+                raise e</span>

<span class="w"> </span>    def auth_publickey(self, username, key, event=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1019,9 +1673,21 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            event was passed in)
<span class="w"> </span>        :raises: `.SSHException` -- if there was a network error
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (not self.active) or (not self.initial_kex_done):</span>
<span class="gi">+            # we should never try to authenticate unless we&#39;re on a secure link</span>
<span class="gi">+            raise SSHException(&quot;No existing session&quot;)</span>
<span class="gi">+        if event is None:</span>
<span class="gi">+            my_event = threading.Event()</span>
<span class="gi">+        else:</span>
<span class="gi">+            my_event = event</span>
<span class="gi">+        self.auth_handler = AuthHandler(self)</span>
<span class="gi">+        self.auth_handler.auth_publickey(username, key, my_event)</span>
<span class="gi">+        if event is not None:</span>
<span class="gi">+            # caller wants to wait for event themselves</span>
<span class="gi">+            return []</span>
<span class="gi">+        return self.auth_handler.wait_for_response(my_event)</span>

<span class="gd">-    def auth_interactive(self, username, handler, submethods=&#39;&#39;):</span>
<span class="gi">+    def auth_interactive(self, username, handler, submethods=&quot;&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Authenticate to the server interactively.  A handler is used to answer
<span class="w"> </span>        arbitrary questions from the server.  On many servers, this is just a
<span class="gu">@@ -1064,16 +1730,38 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (not self.active) or (not self.initial_kex_done):</span>
<span class="gi">+            # we should never try to authenticate unless we&#39;re on a secure link</span>
<span class="gi">+            raise SSHException(&quot;No existing session&quot;)</span>
<span class="gi">+        my_event = threading.Event()</span>
<span class="gi">+        self.auth_handler = AuthHandler(self)</span>
<span class="gi">+        self.auth_handler.auth_interactive(</span>
<span class="gi">+            username, handler, my_event, submethods</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.auth_handler.wait_for_response(my_event)</span>

<span class="gd">-    def auth_interactive_dumb(self, username, handler=None, submethods=&#39;&#39;):</span>
<span class="gi">+    def auth_interactive_dumb(self, username, handler=None, submethods=&quot;&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Authenticate to the server interactively but dumber.
<span class="w"> </span>        Just print the prompt and / or instructions to stdout and send back
<span class="w"> </span>        the response. This is good for situations where partial auth is
<span class="w"> </span>        achieved by key and then the user has to enter a 2fac token.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not handler:</span>
<span class="gi">+</span>
<span class="gi">+            def handler(title, instructions, prompt_list):</span>
<span class="gi">+                answers = []</span>
<span class="gi">+                if title:</span>
<span class="gi">+                    print(title.strip())</span>
<span class="gi">+                if instructions:</span>
<span class="gi">+                    print(instructions.strip())</span>
<span class="gi">+                for prompt, show_input in prompt_list:</span>
<span class="gi">+                    print(prompt.strip(), end=&quot; &quot;)</span>
<span class="gi">+                    answers.append(input())</span>
<span class="gi">+                return answers</span>
<span class="gi">+</span>
<span class="gi">+        return self.auth_interactive(username, handler, submethods)</span>

<span class="w"> </span>    def auth_gssapi_with_mic(self, username, gss_host, gss_deleg_creds):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1091,7 +1779,15 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            event was passed in)
<span class="w"> </span>        :raises: `.SSHException` -- if there was a network error
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (not self.active) or (not self.initial_kex_done):</span>
<span class="gi">+            # we should never try to authenticate unless we&#39;re on a secure link</span>
<span class="gi">+            raise SSHException(&quot;No existing session&quot;)</span>
<span class="gi">+        my_event = threading.Event()</span>
<span class="gi">+        self.auth_handler = AuthHandler(self)</span>
<span class="gi">+        self.auth_handler.auth_gssapi_with_mic(</span>
<span class="gi">+            username, gss_host, gss_deleg_creds, my_event</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.auth_handler.wait_for_response(my_event)</span>

<span class="w"> </span>    def auth_gssapi_keyex(self, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1108,7 +1804,13 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            if the authentication failed (and no event was passed in)
<span class="w"> </span>        :raises: `.SSHException` -- if there was a network error
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (not self.active) or (not self.initial_kex_done):</span>
<span class="gi">+            # we should never try to authenticate unless we&#39;re on a secure link</span>
<span class="gi">+            raise SSHException(&quot;No existing session&quot;)</span>
<span class="gi">+        my_event = threading.Event()</span>
<span class="gi">+        self.auth_handler = AuthHandler(self)</span>
<span class="gi">+        self.auth_handler.auth_gssapi_keyex(username, my_event)</span>
<span class="gi">+        return self.auth_handler.wait_for_response(my_event)</span>

<span class="w"> </span>    def set_log_channel(self, name):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1121,7 +1823,9 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.log_name = name</span>
<span class="gi">+        self.logger = util.get_logger(name)</span>
<span class="gi">+        self.packetizer.set_log(self.logger)</span>

<span class="w"> </span>    def get_log_channel(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1131,7 +1835,7 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.log_name</span>

<span class="w"> </span>    def set_hexdump(self, hexdump):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1143,7 +1847,7 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            ``True`` to log protocol traffix (in hex) to the log; ``False``
<span class="w"> </span>            otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packetizer.set_hexdump(hexdump)</span>

<span class="w"> </span>    def get_hexdump(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1154,7 +1858,7 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.packetizer.get_hexdump()</span>

<span class="w"> </span>    def use_compression(self, compress=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1168,7 +1872,10 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.5.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if compress:</span>
<span class="gi">+            self._preferred_compression = (&quot;zlib@openssh.com&quot;, &quot;zlib&quot;, &quot;none&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._preferred_compression = (&quot;none&quot;,)</span>

<span class="w"> </span>    def getpeername(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1182,42 +1889,194 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            the address of the remote host, if known, as a ``(str, int)``
<span class="w"> </span>            tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        gp = getattr(self.sock, &quot;getpeername&quot;, None)</span>
<span class="gi">+        if gp is None:</span>
<span class="gi">+            return &quot;unknown&quot;, 0</span>
<span class="gi">+        return gp()</span>
<span class="gi">+</span>
<span class="gi">+    def stop_thread(self):</span>
<span class="gi">+        self.active = False</span>
<span class="gi">+        self.packetizer.close()</span>
<span class="gi">+        # Keep trying to join() our main thread, quickly, until:</span>
<span class="gi">+        # * We join()ed successfully (self.is_alive() == False)</span>
<span class="gi">+        # * Or it looks like we&#39;ve hit issue #520 (socket.recv hitting some</span>
<span class="gi">+        # race condition preventing it from timing out correctly), wherein</span>
<span class="gi">+        # our socket and packetizer are both closed (but where we&#39;d</span>
<span class="gi">+        # otherwise be sitting forever on that recv()).</span>
<span class="gi">+        while (</span>
<span class="gi">+            self.is_alive()</span>
<span class="gi">+            and self is not threading.current_thread()</span>
<span class="gi">+            and not self.sock._closed</span>
<span class="gi">+            and not self.packetizer.closed</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.join(0.1)</span>
<span class="gi">+</span>
<span class="gi">+    # internals...</span>
<span class="gi">+</span>
<span class="gi">+    # TODO 4.0: make a public alias for this because multiple other classes</span>
<span class="gi">+    # already explicitly rely on it...or just rewrite logging :D</span>
<span class="gi">+    def _log(self, level, msg, *args):</span>
<span class="gi">+        if issubclass(type(msg), list):</span>
<span class="gi">+            for m in msg:</span>
<span class="gi">+                self.logger.log(level, m)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.logger.log(level, msg, *args)</span>

<span class="w"> </span>    def _get_modulus_pack(self):
<span class="w"> </span>        &quot;&quot;&quot;used by KexGex to find primes for group exchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._modulus_pack</span>

<span class="w"> </span>    def _next_channel(self):
<span class="w"> </span>        &quot;&quot;&quot;you are holding the lock&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        chanid = self._channel_counter</span>
<span class="gi">+        while self._channels.get(chanid) is not None:</span>
<span class="gi">+            self._channel_counter = (self._channel_counter + 1) &amp; 0xFFFFFF</span>
<span class="gi">+            chanid = self._channel_counter</span>
<span class="gi">+        self._channel_counter = (self._channel_counter + 1) &amp; 0xFFFFFF</span>
<span class="gi">+        return chanid</span>

<span class="w"> </span>    def _unlink_channel(self, chanid):
<span class="w"> </span>        &quot;&quot;&quot;used by a Channel to remove itself from the active channel list&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._channels.delete(chanid)</span>
<span class="gi">+</span>
<span class="gi">+    def _send_message(self, data):</span>
<span class="gi">+        self.packetizer.send_message(data)</span>

<span class="w"> </span>    def _send_user_message(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        send a message, but block if we&#39;re in key negotiation.  this is used
<span class="w"> </span>        for user-initiated requests.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start = time.time()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.clear_to_send.wait(0.1)</span>
<span class="gi">+            if not self.active:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG, &quot;Dropping user packet because connection is dead.&quot;</span>
<span class="gi">+                )  # noqa</span>
<span class="gi">+                return</span>
<span class="gi">+            self.clear_to_send_lock.acquire()</span>
<span class="gi">+            if self.clear_to_send.is_set():</span>
<span class="gi">+                break</span>
<span class="gi">+            self.clear_to_send_lock.release()</span>
<span class="gi">+            if time.time() &gt; start + self.clear_to_send_timeout:</span>
<span class="gi">+                raise SSHException(</span>
<span class="gi">+                    &quot;Key-exchange timed out waiting for key negotiation&quot;</span>
<span class="gi">+                )  # noqa</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._send_message(data)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.clear_to_send_lock.release()</span>

<span class="w"> </span>    def _set_K_H(self, k, h):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used by a kex obj to set the K (root key) and H (exchange hash).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.K = k</span>
<span class="gi">+        self.H = h</span>
<span class="gi">+        if self.session_id is None:</span>
<span class="gi">+            self.session_id = h</span>

<span class="w"> </span>    def _expect_packet(self, *ptypes):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used by a kex obj to register the next packet type it expects to see.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._expected_packet = tuple(ptypes)</span>
<span class="gi">+</span>
<span class="gi">+    def _verify_key(self, host_key, sig):</span>
<span class="gi">+        key = self._key_info[self.host_key_type](Message(host_key))</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            raise SSHException(&quot;Unknown host key type&quot;)</span>
<span class="gi">+        if not key.verify_ssh_sig(self.H, Message(sig)):</span>
<span class="gi">+            raise SSHException(</span>
<span class="gi">+                &quot;Signature verification ({}) failed.&quot;.format(</span>
<span class="gi">+                    self.host_key_type</span>
<span class="gi">+                )</span>
<span class="gi">+            )  # noqa</span>
<span class="gi">+        self.host_key = key</span>

<span class="w"> </span>    def _compute_key(self, id, nbytes):
<span class="w"> </span>        &quot;&quot;&quot;id is &#39;A&#39; - &#39;F&#39; for the various keys used by ssh&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_mpint(self.K)</span>
<span class="gi">+        m.add_bytes(self.H)</span>
<span class="gi">+        m.add_byte(b(id))</span>
<span class="gi">+        m.add_bytes(self.session_id)</span>
<span class="gi">+        # Fallback to SHA1 for kex engines that fail to specify a hex</span>
<span class="gi">+        # algorithm, or for e.g. transport tests that don&#39;t run kexinit.</span>
<span class="gi">+        hash_algo = getattr(self.kex_engine, &quot;hash_algo&quot;, None)</span>
<span class="gi">+        hash_select_msg = &quot;kex engine {} specified hash_algo {!r}&quot;.format(</span>
<span class="gi">+            self.kex_engine.__class__.__name__, hash_algo</span>
<span class="gi">+        )</span>
<span class="gi">+        if hash_algo is None:</span>
<span class="gi">+            hash_algo = sha1</span>
<span class="gi">+            hash_select_msg += &quot;, falling back to sha1&quot;</span>
<span class="gi">+        if not hasattr(self, &quot;_logged_hash_selection&quot;):</span>
<span class="gi">+            self._log(DEBUG, hash_select_msg)</span>
<span class="gi">+            setattr(self, &quot;_logged_hash_selection&quot;, True)</span>
<span class="gi">+        out = sofar = hash_algo(m.asbytes()).digest()</span>
<span class="gi">+        while len(out) &lt; nbytes:</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_mpint(self.K)</span>
<span class="gi">+            m.add_bytes(self.H)</span>
<span class="gi">+            m.add_bytes(sofar)</span>
<span class="gi">+            digest = hash_algo(m.asbytes()).digest()</span>
<span class="gi">+            out += digest</span>
<span class="gi">+            sofar += digest</span>
<span class="gi">+        return out[:nbytes]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_cipher(self, name, key, iv, operation):</span>
<span class="gi">+        if name not in self._cipher_info:</span>
<span class="gi">+            raise SSHException(&quot;Unknown client cipher &quot; + name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cipher = Cipher(</span>
<span class="gi">+                self._cipher_info[name][&quot;class&quot;](key),</span>
<span class="gi">+                self._cipher_info[name][&quot;mode&quot;](iv),</span>
<span class="gi">+                backend=default_backend(),</span>
<span class="gi">+            )</span>
<span class="gi">+            if operation is self._ENCRYPT:</span>
<span class="gi">+                return cipher.encryptor()</span>
<span class="gi">+            else:</span>
<span class="gi">+                return cipher.decryptor()</span>
<span class="gi">+</span>
<span class="gi">+    def _set_forward_agent_handler(self, handler):</span>
<span class="gi">+        if handler is None:</span>
<span class="gi">+</span>
<span class="gi">+            def default_handler(channel):</span>
<span class="gi">+                self._queue_incoming_channel(channel)</span>
<span class="gi">+</span>
<span class="gi">+            self._forward_agent_handler = default_handler</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._forward_agent_handler = handler</span>
<span class="gi">+</span>
<span class="gi">+    def _set_x11_handler(self, handler):</span>
<span class="gi">+        # only called if a channel has turned on x11 forwarding</span>
<span class="gi">+        if handler is None:</span>
<span class="gi">+            # by default, use the same mechanism as accept()</span>
<span class="gi">+            def default_handler(channel, src_addr_port):</span>
<span class="gi">+                self._queue_incoming_channel(channel)</span>
<span class="gi">+</span>
<span class="gi">+            self._x11_handler = default_handler</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._x11_handler = handler</span>
<span class="gi">+</span>
<span class="gi">+    def _queue_incoming_channel(self, channel):</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.server_accepts.append(channel)</span>
<span class="gi">+            self.server_accept_cv.notify()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def _sanitize_window_size(self, window_size):</span>
<span class="gi">+        if window_size is None:</span>
<span class="gi">+            window_size = self.default_window_size</span>
<span class="gi">+        return clamp_value(MIN_WINDOW_SIZE, window_size, MAX_WINDOW_SIZE)</span>
<span class="gi">+</span>
<span class="gi">+    def _sanitize_packet_size(self, max_packet_size):</span>
<span class="gi">+        if max_packet_size is None:</span>
<span class="gi">+            max_packet_size = self.default_max_packet_size</span>
<span class="gi">+        return clamp_value(MIN_PACKET_SIZE, max_packet_size, MAX_WINDOW_SIZE)</span>

<span class="w"> </span>    def _ensure_authed(self, ptype, message):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1229,7 +2088,33 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        Otherwise (client mode, authed, or pre-auth message) returns None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            not self.server_mode</span>
<span class="gi">+            or ptype &lt;= HIGHEST_USERAUTH_MESSAGE_ID</span>
<span class="gi">+            or self.is_authenticated()</span>
<span class="gi">+        ):</span>
<span class="gi">+            return None</span>
<span class="gi">+        # WELP. We must be dealing with someone trying to do non-auth things</span>
<span class="gi">+        # without being authed. Tell them off, based on message class.</span>
<span class="gi">+        reply = Message()</span>
<span class="gi">+        # Global requests have no details, just failure.</span>
<span class="gi">+        if ptype == MSG_GLOBAL_REQUEST:</span>
<span class="gi">+            reply.add_byte(cMSG_REQUEST_FAILURE)</span>
<span class="gi">+        # Channel opens let us reject w/ a specific type + message.</span>
<span class="gi">+        elif ptype == MSG_CHANNEL_OPEN:</span>
<span class="gi">+            kind = message.get_text()  # noqa</span>
<span class="gi">+            chanid = message.get_int()</span>
<span class="gi">+            reply.add_byte(cMSG_CHANNEL_OPEN_FAILURE)</span>
<span class="gi">+            reply.add_int(chanid)</span>
<span class="gi">+            reply.add_int(OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED)</span>
<span class="gi">+            reply.add_string(&quot;&quot;)</span>
<span class="gi">+            reply.add_string(&quot;en&quot;)</span>
<span class="gi">+        # NOTE: Post-open channel messages do not need checking; the above will</span>
<span class="gi">+        # reject attempts to open channels, meaning that even if a malicious</span>
<span class="gi">+        # user tries to send a MSG_CHANNEL_REQUEST, it will simply fall under</span>
<span class="gi">+        # the logic that handles unknown channel IDs (as the channel list will</span>
<span class="gi">+        # be empty.)</span>
<span class="gi">+        return reply</span>

<span class="w"> </span>    def _enforce_strict_kex(self, ptype):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1239,32 +2124,1001 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        messages; it does not interrogate ``ptype`` besides using it to log
<span class="w"> </span>        more accurately.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.agreed_on_strict_kex and not self.initial_kex_done:</span>
<span class="gi">+            name = MSG_NAMES.get(ptype, f&quot;msg {ptype}&quot;)</span>
<span class="gi">+            raise MessageOrderError(</span>
<span class="gi">+                f&quot;In strict-kex mode, but was sent {name!r}!&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        # (use the exposed &quot;run&quot; method, because if we specify a thread target</span>
<span class="gi">+        # of a private method, threading.Thread will keep a reference to it</span>
<span class="gi">+        # indefinitely, creating a GC cycle and not letting Transport ever be</span>
<span class="gi">+        # GC&#39;d. it&#39;s a bug in Thread.)</span>
<span class="gi">+</span>
<span class="gi">+        # Hold reference to &#39;sys&#39; so we can test sys.modules to detect</span>
<span class="gi">+        # interpreter shutdown.</span>
<span class="gi">+        self.sys = sys</span>
<span class="gi">+</span>
<span class="gi">+        # active=True occurs before the thread is launched, to avoid a race</span>
<span class="gi">+        _active_threads.append(self)</span>
<span class="gi">+        tid = hex(id(self) &amp; xffffffff)</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            self._log(DEBUG, &quot;starting thread (server mode): {}&quot;.format(tid))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._log(DEBUG, &quot;starting thread (client mode): {}&quot;.format(tid))</span>
<span class="gi">+        try:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.packetizer.write_all(b(self.local_version + &quot;\r\n&quot;))</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG,</span>
<span class="gi">+                    &quot;Local version/idstring: {}&quot;.format(self.local_version),</span>
<span class="gi">+                )  # noqa</span>
<span class="gi">+                self._check_banner()</span>
<span class="gi">+                # The above is actually very much part of the handshake, but</span>
<span class="gi">+                # sometimes the banner can be read but the machine is not</span>
<span class="gi">+                # responding, for example when the remote ssh daemon is loaded</span>
<span class="gi">+                # in to memory but we can not read from the disk/spawn a new</span>
<span class="gi">+                # shell.</span>
<span class="gi">+                # Make sure we can specify a timeout for the initial handshake.</span>
<span class="gi">+                # Re-use the banner timeout for now.</span>
<span class="gi">+                self.packetizer.start_handshake(self.handshake_timeout)</span>
<span class="gi">+                self._send_kex_init()</span>
<span class="gi">+                self._expect_packet(MSG_KEXINIT)</span>
<span class="gi">+</span>
<span class="gi">+                while self.active:</span>
<span class="gi">+                    if self.packetizer.need_rekey() and not self.in_kex:</span>
<span class="gi">+                        self._send_kex_init()</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        ptype, m = self.packetizer.read_message()</span>
<span class="gi">+                    except NeedRekeyException:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if ptype == MSG_IGNORE:</span>
<span class="gi">+                        self._enforce_strict_kex(ptype)</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    elif ptype == MSG_DISCONNECT:</span>
<span class="gi">+                        self._parse_disconnect(m)</span>
<span class="gi">+                        break</span>
<span class="gi">+                    elif ptype == MSG_DEBUG:</span>
<span class="gi">+                        self._enforce_strict_kex(ptype)</span>
<span class="gi">+                        self._parse_debug(m)</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if len(self._expected_packet) &gt; 0:</span>
<span class="gi">+                        if ptype not in self._expected_packet:</span>
<span class="gi">+                            exc_class = SSHException</span>
<span class="gi">+                            if self.agreed_on_strict_kex:</span>
<span class="gi">+                                exc_class = MessageOrderError</span>
<span class="gi">+                            raise exc_class(</span>
<span class="gi">+                                &quot;Expecting packet from {!r}, got {:d}&quot;.format(</span>
<span class="gi">+                                    self._expected_packet, ptype</span>
<span class="gi">+                                )</span>
<span class="gi">+                            )  # noqa</span>
<span class="gi">+                        self._expected_packet = tuple()</span>
<span class="gi">+                        # These message IDs indicate key exchange &amp; will differ</span>
<span class="gi">+                        # depending on exact exchange algorithm</span>
<span class="gi">+                        if (ptype &gt;= 30) and (ptype &lt;= 41):</span>
<span class="gi">+                            self.kex_engine.parse_next(ptype, m)</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                    if ptype in self._handler_table:</span>
<span class="gi">+                        error_msg = self._ensure_authed(ptype, m)</span>
<span class="gi">+                        if error_msg:</span>
<span class="gi">+                            self._send_message(error_msg)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            self._handler_table[ptype](m)</span>
<span class="gi">+                    elif ptype in self._channel_handler_table:</span>
<span class="gi">+                        chanid = m.get_int()</span>
<span class="gi">+                        chan = self._channels.get(chanid)</span>
<span class="gi">+                        if chan is not None:</span>
<span class="gi">+                            self._channel_handler_table[ptype](chan, m)</span>
<span class="gi">+                        elif chanid in self.channels_seen:</span>
<span class="gi">+                            self._log(</span>
<span class="gi">+                                DEBUG,</span>
<span class="gi">+                                &quot;Ignoring message for dead channel {:d}&quot;.format(  # noqa</span>
<span class="gi">+                                    chanid</span>
<span class="gi">+                                ),</span>
<span class="gi">+                            )</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            self._log(</span>
<span class="gi">+                                ERROR,</span>
<span class="gi">+                                &quot;Channel request for unknown channel {:d}&quot;.format(  # noqa</span>
<span class="gi">+                                    chanid</span>
<span class="gi">+                                ),</span>
<span class="gi">+                            )</span>
<span class="gi">+                            break</span>
<span class="gi">+                    elif (</span>
<span class="gi">+                        self.auth_handler is not None</span>
<span class="gi">+                        and ptype in self.auth_handler._handler_table</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        handler = self.auth_handler._handler_table[ptype]</span>
<span class="gi">+                        handler(m)</span>
<span class="gi">+                        if len(self._expected_packet) &gt; 0:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # Respond with &quot;I don&#39;t implement this particular</span>
<span class="gi">+                        # message type&quot; message (unless the message type was</span>
<span class="gi">+                        # itself literally MSG_UNIMPLEMENTED, in which case, we</span>
<span class="gi">+                        # just shut up to avoid causing a useless loop).</span>
<span class="gi">+                        name = MSG_NAMES[ptype]</span>
<span class="gi">+                        warning = &quot;Oops, unhandled type {} ({!r})&quot;.format(</span>
<span class="gi">+                            ptype, name</span>
<span class="gi">+                        )</span>
<span class="gi">+                        self._log(WARNING, warning)</span>
<span class="gi">+                        if ptype != MSG_UNIMPLEMENTED:</span>
<span class="gi">+                            msg = Message()</span>
<span class="gi">+                            msg.add_byte(cMSG_UNIMPLEMENTED)</span>
<span class="gi">+                            msg.add_int(m.seqno)</span>
<span class="gi">+                            self._send_message(msg)</span>
<span class="gi">+                    self.packetizer.complete_handshake()</span>
<span class="gi">+            except SSHException as e:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    ERROR,</span>
<span class="gi">+                    &quot;Exception ({}): {}&quot;.format(</span>
<span class="gi">+                        &quot;server&quot; if self.server_mode else &quot;client&quot;, e</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+                self._log(ERROR, util.tb_strings())</span>
<span class="gi">+                self.saved_exception = e</span>
<span class="gi">+            except EOFError as e:</span>
<span class="gi">+                self._log(DEBUG, &quot;EOF in transport thread&quot;)</span>
<span class="gi">+                self.saved_exception = e</span>
<span class="gi">+            except socket.error as e:</span>
<span class="gi">+                if type(e.args) is tuple:</span>
<span class="gi">+                    if e.args:</span>
<span class="gi">+                        emsg = &quot;{} ({:d})&quot;.format(e.args[1], e.args[0])</span>
<span class="gi">+                    else:  # empty tuple, e.g. socket.timeout</span>
<span class="gi">+                        emsg = str(e) or repr(e)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    emsg = e.args</span>
<span class="gi">+                self._log(ERROR, &quot;Socket exception: &quot; + emsg)</span>
<span class="gi">+                self.saved_exception = e</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self._log(ERROR, &quot;Unknown exception: &quot; + str(e))</span>
<span class="gi">+                self._log(ERROR, util.tb_strings())</span>
<span class="gi">+                self.saved_exception = e</span>
<span class="gi">+            _active_threads.remove(self)</span>
<span class="gi">+            for chan in list(self._channels.values()):</span>
<span class="gi">+                chan._unlink()</span>
<span class="gi">+            if self.active:</span>
<span class="gi">+                self.active = False</span>
<span class="gi">+                self.packetizer.close()</span>
<span class="gi">+                if self.completion_event is not None:</span>
<span class="gi">+                    self.completion_event.set()</span>
<span class="gi">+                if self.auth_handler is not None:</span>
<span class="gi">+                    self.auth_handler.abort()</span>
<span class="gi">+                for event in self.channel_events.values():</span>
<span class="gi">+                    event.set()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self.lock.acquire()</span>
<span class="gi">+                    self.server_accept_cv.notify()</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    self.lock.release()</span>
<span class="gi">+            self.sock.close()</span>
<span class="gi">+        except:</span>
<span class="gi">+            # Don&#39;t raise spurious &#39;NoneType has no attribute X&#39; errors when we</span>
<span class="gi">+            # wake up during interpreter shutdown. Or rather -- raise</span>
<span class="gi">+            # everything *if* sys.modules (used as a convenient sentinel)</span>
<span class="gi">+            # appears to still exist.</span>
<span class="gi">+            if self.sys.modules is not None:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+    def _log_agreement(self, which, local, remote):</span>
<span class="gi">+        # Log useful, non-duplicative line re: an agreed-upon algorithm.</span>
<span class="gi">+        # Old code implied algorithms could be asymmetrical (different for</span>
<span class="gi">+        # inbound vs outbound) so we preserve that possibility.</span>
<span class="gi">+        msg = &quot;{}: &quot;.format(which)</span>
<span class="gi">+        if local == remote:</span>
<span class="gi">+            msg += local</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg += &quot;local={}, remote={}&quot;.format(local, remote)</span>
<span class="gi">+        self._log(DEBUG, msg)</span>
<span class="gi">+</span>
<span class="gi">+    # protocol stages</span>
<span class="gi">+</span>
<span class="gi">+    def _negotiate_keys(self, m):</span>
<span class="gi">+        # throws SSHException on anything unusual</span>
<span class="gi">+        self.clear_to_send_lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.clear_to_send.clear()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.clear_to_send_lock.release()</span>
<span class="gi">+        if self.local_kex_init is None:</span>
<span class="gi">+            # remote side wants to renegotiate</span>
<span class="gi">+            self._send_kex_init()</span>
<span class="gi">+        self._parse_kex_init(m)</span>
<span class="gi">+        self.kex_engine.start_kex()</span>
<span class="gi">+</span>
<span class="gi">+    def _check_banner(self):</span>
<span class="gi">+        # this is slow, but we only have to do it once</span>
<span class="gi">+        for i in range(100):</span>
<span class="gi">+            # give them 15 seconds for the first line, then just 2 seconds</span>
<span class="gi">+            # each additional line.  (some sites have very high latency.)</span>
<span class="gi">+            if i == 0:</span>
<span class="gi">+                timeout = self.banner_timeout</span>
<span class="gi">+            else:</span>
<span class="gi">+                timeout = 2</span>
<span class="gi">+            try:</span>
<span class="gi">+                buf = self.packetizer.readline(timeout)</span>
<span class="gi">+            except ProxyCommandFailure:</span>
<span class="gi">+                raise</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                raise SSHException(</span>
<span class="gi">+                    &quot;Error reading SSH protocol banner&quot; + str(e)</span>
<span class="gi">+                )</span>
<span class="gi">+            if buf[:4] == &quot;SSH-&quot;:</span>
<span class="gi">+                break</span>
<span class="gi">+            self._log(DEBUG, &quot;Banner: &quot; + buf)</span>
<span class="gi">+        if buf[:4] != &quot;SSH-&quot;:</span>
<span class="gi">+            raise SSHException(&#39;Indecipherable protocol version &quot;&#39; + buf + &#39;&quot;&#39;)</span>
<span class="gi">+        # save this server version string for later</span>
<span class="gi">+        self.remote_version = buf</span>
<span class="gi">+        self._log(DEBUG, &quot;Remote version/idstring: {}&quot;.format(buf))</span>
<span class="gi">+        # pull off any attached comment</span>
<span class="gi">+        # NOTE: comment used to be stored in a variable and then...never used.</span>
<span class="gi">+        # since 2003. ca 877cd974b8182d26fa76d566072917ea67b64e67</span>
<span class="gi">+        i = buf.find(&quot; &quot;)</span>
<span class="gi">+        if i &gt;= 0:</span>
<span class="gi">+            buf = buf[:i]</span>
<span class="gi">+        # parse out version string and make sure it matches</span>
<span class="gi">+        segs = buf.split(&quot;-&quot;, 2)</span>
<span class="gi">+        if len(segs) &lt; 3:</span>
<span class="gi">+            raise SSHException(&quot;Invalid SSH banner&quot;)</span>
<span class="gi">+        version = segs[1]</span>
<span class="gi">+        client = segs[2]</span>
<span class="gi">+        if version != &quot;1.99&quot; and version != &quot;2.0&quot;:</span>
<span class="gi">+            msg = &quot;Incompatible version ({} instead of 2.0)&quot;</span>
<span class="gi">+            raise IncompatiblePeer(msg.format(version))</span>
<span class="gi">+        msg = &quot;Connected (version {}, client {})&quot;.format(version, client)</span>
<span class="gi">+        self._log(INFO, msg)</span>

<span class="w"> </span>    def _send_kex_init(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        announce to the other side that we&#39;d like to negotiate keys, and what
<span class="w"> </span>        kind of key negotiation we support.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.clear_to_send_lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.clear_to_send.clear()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.clear_to_send_lock.release()</span>
<span class="gi">+        self.gss_kex_used = False</span>
<span class="gi">+        self.in_kex = True</span>
<span class="gi">+        kex_algos = list(self.preferred_kex)</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            mp_required_prefix = &quot;diffie-hellman-group-exchange-sha&quot;</span>
<span class="gi">+            kex_mp = [k for k in kex_algos if k.startswith(mp_required_prefix)]</span>
<span class="gi">+            if (self._modulus_pack is None) and (len(kex_mp) &gt; 0):</span>
<span class="gi">+                # can&#39;t do group-exchange if we don&#39;t have a pack of potential</span>
<span class="gi">+                # primes</span>
<span class="gi">+                pkex = [</span>
<span class="gi">+                    k</span>
<span class="gi">+                    for k in self.get_security_options().kex</span>
<span class="gi">+                    if not k.startswith(mp_required_prefix)</span>
<span class="gi">+                ]</span>
<span class="gi">+                self.get_security_options().kex = pkex</span>
<span class="gi">+            available_server_keys = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    list(self.server_key_dict.keys()).__contains__,</span>
<span class="gi">+                    # TODO: ensure tests will catch if somebody streamlines</span>
<span class="gi">+                    # this by mistake - case is the admittedly silly one where</span>
<span class="gi">+                    # the only calls to add_server_key() contain keys which</span>
<span class="gi">+                    # were filtered out of the below via disabled_algorithms.</span>
<span class="gi">+                    # If this is streamlined, we would then be allowing the</span>
<span class="gi">+                    # disabled algorithm(s) for hostkey use</span>
<span class="gi">+                    # TODO: honestly this prob just wants to get thrown out</span>
<span class="gi">+                    # when we make kex configuration more straightforward</span>
<span class="gi">+                    self.preferred_keys,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            available_server_keys = self.preferred_keys</span>
<span class="gi">+            # Signal support for MSG_EXT_INFO so server will send it to us.</span>
<span class="gi">+            # NOTE: doing this here handily means we don&#39;t even consider this</span>
<span class="gi">+            # value when agreeing on real kex algo to use (which is a common</span>
<span class="gi">+            # pitfall when adding this apparently).</span>
<span class="gi">+            kex_algos.append(&quot;ext-info-c&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Similar to ext-info, but used in both server modes, so done outside</span>
<span class="gi">+        # of above if/else.</span>
<span class="gi">+        if self.advertise_strict_kex:</span>
<span class="gi">+            which = &quot;s&quot; if self.server_mode else &quot;c&quot;</span>
<span class="gi">+            kex_algos.append(f&quot;kex-strict-{which}-v00@openssh.com&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_KEXINIT)</span>
<span class="gi">+        m.add_bytes(os.urandom(16))</span>
<span class="gi">+        m.add_list(kex_algos)</span>
<span class="gi">+        m.add_list(available_server_keys)</span>
<span class="gi">+        m.add_list(self.preferred_ciphers)</span>
<span class="gi">+        m.add_list(self.preferred_ciphers)</span>
<span class="gi">+        m.add_list(self.preferred_macs)</span>
<span class="gi">+        m.add_list(self.preferred_macs)</span>
<span class="gi">+        m.add_list(self.preferred_compression)</span>
<span class="gi">+        m.add_list(self.preferred_compression)</span>
<span class="gi">+        m.add_string(bytes())</span>
<span class="gi">+        m.add_string(bytes())</span>
<span class="gi">+        m.add_boolean(False)</span>
<span class="gi">+        m.add_int(0)</span>
<span class="gi">+        # save a copy for later (needed to compute a hash)</span>
<span class="gi">+        self.local_kex_init = self._latest_kex_init = m.asbytes()</span>
<span class="gi">+        self._send_message(m)</span>
<span class="gi">+</span>
<span class="gi">+    def _really_parse_kex_init(self, m, ignore_first_byte=False):</span>
<span class="gi">+        parsed = {}</span>
<span class="gi">+        if ignore_first_byte:</span>
<span class="gi">+            m.get_byte()</span>
<span class="gi">+        m.get_bytes(16)  # cookie, discarded</span>
<span class="gi">+        parsed[&quot;kex_algo_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;server_key_algo_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;client_encrypt_algo_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;server_encrypt_algo_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;client_mac_algo_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;server_mac_algo_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;client_compress_algo_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;server_compress_algo_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;client_lang_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;server_lang_list&quot;] = m.get_list()</span>
<span class="gi">+        parsed[&quot;kex_follows&quot;] = m.get_boolean()</span>
<span class="gi">+        m.get_int()  # unused</span>
<span class="gi">+        return parsed</span>
<span class="gi">+</span>
<span class="gi">+    def _get_latest_kex_init(self):</span>
<span class="gi">+        return self._really_parse_kex_init(</span>
<span class="gi">+            Message(self._latest_kex_init),</span>
<span class="gi">+            ignore_first_byte=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_kex_init(self, m):</span>
<span class="gi">+        parsed = self._really_parse_kex_init(m)</span>
<span class="gi">+        kex_algo_list = parsed[&quot;kex_algo_list&quot;]</span>
<span class="gi">+        server_key_algo_list = parsed[&quot;server_key_algo_list&quot;]</span>
<span class="gi">+        client_encrypt_algo_list = parsed[&quot;client_encrypt_algo_list&quot;]</span>
<span class="gi">+        server_encrypt_algo_list = parsed[&quot;server_encrypt_algo_list&quot;]</span>
<span class="gi">+        client_mac_algo_list = parsed[&quot;client_mac_algo_list&quot;]</span>
<span class="gi">+        server_mac_algo_list = parsed[&quot;server_mac_algo_list&quot;]</span>
<span class="gi">+        client_compress_algo_list = parsed[&quot;client_compress_algo_list&quot;]</span>
<span class="gi">+        server_compress_algo_list = parsed[&quot;server_compress_algo_list&quot;]</span>
<span class="gi">+        client_lang_list = parsed[&quot;client_lang_list&quot;]</span>
<span class="gi">+        server_lang_list = parsed[&quot;server_lang_list&quot;]</span>
<span class="gi">+        kex_follows = parsed[&quot;kex_follows&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        self._log(DEBUG, &quot;=== Key exchange possibilities ===&quot;)</span>
<span class="gi">+        for prefix, value in (</span>
<span class="gi">+            (&quot;kex algos&quot;, kex_algo_list),</span>
<span class="gi">+            (&quot;server key&quot;, server_key_algo_list),</span>
<span class="gi">+            # TODO: shouldn&#39;t these two lines say &quot;cipher&quot; to match usual</span>
<span class="gi">+            # terminology (including elsewhere in paramiko!)?</span>
<span class="gi">+            (&quot;client encrypt&quot;, client_encrypt_algo_list),</span>
<span class="gi">+            (&quot;server encrypt&quot;, server_encrypt_algo_list),</span>
<span class="gi">+            (&quot;client mac&quot;, client_mac_algo_list),</span>
<span class="gi">+            (&quot;server mac&quot;, server_mac_algo_list),</span>
<span class="gi">+            (&quot;client compress&quot;, client_compress_algo_list),</span>
<span class="gi">+            (&quot;server compress&quot;, server_compress_algo_list),</span>
<span class="gi">+            (&quot;client lang&quot;, client_lang_list),</span>
<span class="gi">+            (&quot;server lang&quot;, server_lang_list),</span>
<span class="gi">+        ):</span>
<span class="gi">+            if value == [&quot;&quot;]:</span>
<span class="gi">+                value = [&quot;&lt;none&gt;&quot;]</span>
<span class="gi">+            value = &quot;, &quot;.join(value)</span>
<span class="gi">+            self._log(DEBUG, &quot;{}: {}&quot;.format(prefix, value))</span>
<span class="gi">+        self._log(DEBUG, &quot;kex follows: {}&quot;.format(kex_follows))</span>
<span class="gi">+        self._log(DEBUG, &quot;=== Key exchange agreements ===&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Record, and strip out, ext-info and/or strict-kex non-algorithms</span>
<span class="gi">+        self._remote_ext_info = None</span>
<span class="gi">+        self._remote_strict_kex = None</span>
<span class="gi">+        to_pop = []</span>
<span class="gi">+        for i, algo in enumerate(kex_algo_list):</span>
<span class="gi">+            if algo.startswith(&quot;ext-info-&quot;):</span>
<span class="gi">+                self._remote_ext_info = algo</span>
<span class="gi">+                to_pop.insert(0, i)</span>
<span class="gi">+            elif algo.startswith(&quot;kex-strict-&quot;):</span>
<span class="gi">+                # NOTE: this is what we are expecting from the /remote/ end.</span>
<span class="gi">+                which = &quot;c&quot; if self.server_mode else &quot;s&quot;</span>
<span class="gi">+                expected = f&quot;kex-strict-{which}-v00@openssh.com&quot;</span>
<span class="gi">+                # Set strict mode if agreed.</span>
<span class="gi">+                self.agreed_on_strict_kex = (</span>
<span class="gi">+                    algo == expected and self.advertise_strict_kex</span>
<span class="gi">+                )</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG, f&quot;Strict kex mode: {self.agreed_on_strict_kex}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                to_pop.insert(0, i)</span>
<span class="gi">+        for i in to_pop:</span>
<span class="gi">+            kex_algo_list.pop(i)</span>
<span class="gi">+</span>
<span class="gi">+        # CVE mitigation: expect zeroed-out seqno anytime we are performing kex</span>
<span class="gi">+        # init phase, if strict mode was negotiated.</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.agreed_on_strict_kex</span>
<span class="gi">+            and not self.initial_kex_done</span>
<span class="gi">+            and m.seqno != 0</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise MessageOrderError(</span>
<span class="gi">+                &quot;In strict-kex mode, but KEXINIT was not the first packet!&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # as a server, we pick the first item in the client&#39;s list that we</span>
<span class="gi">+        # support.</span>
<span class="gi">+        # as a client, we pick the first item in our list that the server</span>
<span class="gi">+        # supports.</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            agreed_kex = list(</span>
<span class="gi">+                filter(self.preferred_kex.__contains__, kex_algo_list)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            agreed_kex = list(</span>
<span class="gi">+                filter(kex_algo_list.__contains__, self.preferred_kex)</span>
<span class="gi">+            )</span>
<span class="gi">+        if len(agreed_kex) == 0:</span>
<span class="gi">+            # TODO: do an auth-overhaul style aggregate exception here?</span>
<span class="gi">+            # TODO: would let us streamline log output &amp; show all failures up</span>
<span class="gi">+            # front</span>
<span class="gi">+            raise IncompatiblePeer(</span>
<span class="gi">+                &quot;Incompatible ssh peer (no acceptable kex algorithm)&quot;</span>
<span class="gi">+            )  # noqa</span>
<span class="gi">+        self.kex_engine = self._kex_info[agreed_kex[0]](self)</span>
<span class="gi">+        self._log(DEBUG, &quot;Kex: {}&quot;.format(agreed_kex[0]))</span>
<span class="gi">+</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            available_server_keys = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    list(self.server_key_dict.keys()).__contains__,</span>
<span class="gi">+                    self.preferred_keys,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            agreed_keys = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    available_server_keys.__contains__, server_key_algo_list</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            agreed_keys = list(</span>
<span class="gi">+                filter(server_key_algo_list.__contains__, self.preferred_keys)</span>
<span class="gi">+            )</span>
<span class="gi">+        if len(agreed_keys) == 0:</span>
<span class="gi">+            raise IncompatiblePeer(</span>
<span class="gi">+                &quot;Incompatible ssh peer (no acceptable host key)&quot;</span>
<span class="gi">+            )  # noqa</span>
<span class="gi">+        self.host_key_type = agreed_keys[0]</span>
<span class="gi">+        if self.server_mode and (self.get_server_key() is None):</span>
<span class="gi">+            raise IncompatiblePeer(</span>
<span class="gi">+                &quot;Incompatible ssh peer (can&#39;t match requested host key type)&quot;</span>
<span class="gi">+            )  # noqa</span>
<span class="gi">+        self._log_agreement(&quot;HostKey&quot;, agreed_keys[0], agreed_keys[0])</span>
<span class="gi">+</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            agreed_local_ciphers = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    self.preferred_ciphers.__contains__,</span>
<span class="gi">+                    server_encrypt_algo_list,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            agreed_remote_ciphers = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    self.preferred_ciphers.__contains__,</span>
<span class="gi">+                    client_encrypt_algo_list,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            agreed_local_ciphers = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    client_encrypt_algo_list.__contains__,</span>
<span class="gi">+                    self.preferred_ciphers,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            agreed_remote_ciphers = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    server_encrypt_algo_list.__contains__,</span>
<span class="gi">+                    self.preferred_ciphers,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        if len(agreed_local_ciphers) == 0 or len(agreed_remote_ciphers) == 0:</span>
<span class="gi">+            raise IncompatiblePeer(</span>
<span class="gi">+                &quot;Incompatible ssh server (no acceptable ciphers)&quot;</span>
<span class="gi">+            )  # noqa</span>
<span class="gi">+        self.local_cipher = agreed_local_ciphers[0]</span>
<span class="gi">+        self.remote_cipher = agreed_remote_ciphers[0]</span>
<span class="gi">+        self._log_agreement(</span>
<span class="gi">+            &quot;Cipher&quot;, local=self.local_cipher, remote=self.remote_cipher</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            agreed_remote_macs = list(</span>
<span class="gi">+                filter(self.preferred_macs.__contains__, client_mac_algo_list)</span>
<span class="gi">+            )</span>
<span class="gi">+            agreed_local_macs = list(</span>
<span class="gi">+                filter(self.preferred_macs.__contains__, server_mac_algo_list)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            agreed_local_macs = list(</span>
<span class="gi">+                filter(client_mac_algo_list.__contains__, self.preferred_macs)</span>
<span class="gi">+            )</span>
<span class="gi">+            agreed_remote_macs = list(</span>
<span class="gi">+                filter(server_mac_algo_list.__contains__, self.preferred_macs)</span>
<span class="gi">+            )</span>
<span class="gi">+        if (len(agreed_local_macs) == 0) or (len(agreed_remote_macs) == 0):</span>
<span class="gi">+            raise IncompatiblePeer(</span>
<span class="gi">+                &quot;Incompatible ssh server (no acceptable macs)&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        self.local_mac = agreed_local_macs[0]</span>
<span class="gi">+        self.remote_mac = agreed_remote_macs[0]</span>
<span class="gi">+        self._log_agreement(</span>
<span class="gi">+            &quot;MAC&quot;, local=self.local_mac, remote=self.remote_mac</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            agreed_remote_compression = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    self.preferred_compression.__contains__,</span>
<span class="gi">+                    client_compress_algo_list,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            agreed_local_compression = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    self.preferred_compression.__contains__,</span>
<span class="gi">+                    server_compress_algo_list,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            agreed_local_compression = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    client_compress_algo_list.__contains__,</span>
<span class="gi">+                    self.preferred_compression,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            agreed_remote_compression = list(</span>
<span class="gi">+                filter(</span>
<span class="gi">+                    server_compress_algo_list.__contains__,</span>
<span class="gi">+                    self.preferred_compression,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        if (</span>
<span class="gi">+            len(agreed_local_compression) == 0</span>
<span class="gi">+            or len(agreed_remote_compression) == 0</span>
<span class="gi">+        ):</span>
<span class="gi">+            msg = &quot;Incompatible ssh server (no acceptable compression)&quot;</span>
<span class="gi">+            msg += &quot; {!r} {!r} {!r}&quot;</span>
<span class="gi">+            raise IncompatiblePeer(</span>
<span class="gi">+                msg.format(</span>
<span class="gi">+                    agreed_local_compression,</span>
<span class="gi">+                    agreed_remote_compression,</span>
<span class="gi">+                    self.preferred_compression,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        self.local_compression = agreed_local_compression[0]</span>
<span class="gi">+        self.remote_compression = agreed_remote_compression[0]</span>
<span class="gi">+        self._log_agreement(</span>
<span class="gi">+            &quot;Compression&quot;,</span>
<span class="gi">+            local=self.local_compression,</span>
<span class="gi">+            remote=self.remote_compression,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._log(DEBUG, &quot;=== End of kex handshake ===&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # save for computing hash later...</span>
<span class="gi">+        # now wait!  openssh has a bug (and others might too) where there are</span>
<span class="gi">+        # actually some extra bytes (one NUL byte in openssh&#39;s case) added to</span>
<span class="gi">+        # the end of the packet but not parsed.  turns out we need to throw</span>
<span class="gi">+        # away those bytes because they aren&#39;t part of the hash.</span>
<span class="gi">+        self.remote_kex_init = cMSG_KEXINIT + m.get_so_far()</span>

<span class="w"> </span>    def _activate_inbound(self):
<span class="w"> </span>        &quot;&quot;&quot;switch on newly negotiated encryption parameters for
<span class="w"> </span>        inbound traffic&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        block_size = self._cipher_info[self.remote_cipher][&quot;block-size&quot;]</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            IV_in = self._compute_key(&quot;A&quot;, block_size)</span>
<span class="gi">+            key_in = self._compute_key(</span>
<span class="gi">+                &quot;C&quot;, self._cipher_info[self.remote_cipher][&quot;key-size&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            IV_in = self._compute_key(&quot;B&quot;, block_size)</span>
<span class="gi">+            key_in = self._compute_key(</span>
<span class="gi">+                &quot;D&quot;, self._cipher_info[self.remote_cipher][&quot;key-size&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+        engine = self._get_cipher(</span>
<span class="gi">+            self.remote_cipher, key_in, IV_in, self._DECRYPT</span>
<span class="gi">+        )</span>
<span class="gi">+        etm = &quot;etm@openssh.com&quot; in self.remote_mac</span>
<span class="gi">+        mac_size = self._mac_info[self.remote_mac][&quot;size&quot;]</span>
<span class="gi">+        mac_engine = self._mac_info[self.remote_mac][&quot;class&quot;]</span>
<span class="gi">+        # initial mac keys are done in the hash&#39;s natural size (not the</span>
<span class="gi">+        # potentially truncated transmission size)</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            mac_key = self._compute_key(&quot;E&quot;, mac_engine().digest_size)</span>
<span class="gi">+        else:</span>
<span class="gi">+            mac_key = self._compute_key(&quot;F&quot;, mac_engine().digest_size)</span>
<span class="gi">+        self.packetizer.set_inbound_cipher(</span>
<span class="gi">+            engine, block_size, mac_engine, mac_size, mac_key, etm=etm</span>
<span class="gi">+        )</span>
<span class="gi">+        compress_in = self._compression_info[self.remote_compression][1]</span>
<span class="gi">+        if compress_in is not None and (</span>
<span class="gi">+            self.remote_compression != &quot;zlib@openssh.com&quot; or self.authenticated</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._log(DEBUG, &quot;Switching on inbound compression ...&quot;)</span>
<span class="gi">+            self.packetizer.set_inbound_compressor(compress_in())</span>
<span class="gi">+        # Reset inbound sequence number if strict mode.</span>
<span class="gi">+        if self.agreed_on_strict_kex:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                &quot;Resetting inbound seqno after NEWKEYS due to strict mode&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.packetizer.reset_seqno_in()</span>

<span class="w"> </span>    def _activate_outbound(self):
<span class="w"> </span>        &quot;&quot;&quot;switch on newly negotiated encryption parameters for
<span class="w"> </span>        outbound traffic&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    _channel_handler_table = {MSG_CHANNEL_SUCCESS: Channel._request_success,</span>
<span class="gd">-        MSG_CHANNEL_FAILURE: Channel._request_failed, MSG_CHANNEL_DATA:</span>
<span class="gd">-        Channel._feed, MSG_CHANNEL_EXTENDED_DATA: Channel._feed_extended,</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_NEWKEYS)</span>
<span class="gi">+        self._send_message(m)</span>
<span class="gi">+        # Reset outbound sequence number if strict mode.</span>
<span class="gi">+        if self.agreed_on_strict_kex:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                &quot;Resetting outbound seqno after NEWKEYS due to strict mode&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.packetizer.reset_seqno_out()</span>
<span class="gi">+        block_size = self._cipher_info[self.local_cipher][&quot;block-size&quot;]</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            IV_out = self._compute_key(&quot;B&quot;, block_size)</span>
<span class="gi">+            key_out = self._compute_key(</span>
<span class="gi">+                &quot;D&quot;, self._cipher_info[self.local_cipher][&quot;key-size&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            IV_out = self._compute_key(&quot;A&quot;, block_size)</span>
<span class="gi">+            key_out = self._compute_key(</span>
<span class="gi">+                &quot;C&quot;, self._cipher_info[self.local_cipher][&quot;key-size&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+        engine = self._get_cipher(</span>
<span class="gi">+            self.local_cipher, key_out, IV_out, self._ENCRYPT</span>
<span class="gi">+        )</span>
<span class="gi">+        etm = &quot;etm@openssh.com&quot; in self.local_mac</span>
<span class="gi">+        mac_size = self._mac_info[self.local_mac][&quot;size&quot;]</span>
<span class="gi">+        mac_engine = self._mac_info[self.local_mac][&quot;class&quot;]</span>
<span class="gi">+        # initial mac keys are done in the hash&#39;s natural size (not the</span>
<span class="gi">+        # potentially truncated transmission size)</span>
<span class="gi">+        if self.server_mode:</span>
<span class="gi">+            mac_key = self._compute_key(&quot;F&quot;, mac_engine().digest_size)</span>
<span class="gi">+        else:</span>
<span class="gi">+            mac_key = self._compute_key(&quot;E&quot;, mac_engine().digest_size)</span>
<span class="gi">+        sdctr = self.local_cipher.endswith(&quot;-ctr&quot;)</span>
<span class="gi">+        self.packetizer.set_outbound_cipher(</span>
<span class="gi">+            engine, block_size, mac_engine, mac_size, mac_key, sdctr, etm=etm</span>
<span class="gi">+        )</span>
<span class="gi">+        compress_out = self._compression_info[self.local_compression][0]</span>
<span class="gi">+        if compress_out is not None and (</span>
<span class="gi">+            self.local_compression != &quot;zlib@openssh.com&quot; or self.authenticated</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._log(DEBUG, &quot;Switching on outbound compression ...&quot;)</span>
<span class="gi">+            self.packetizer.set_outbound_compressor(compress_out())</span>
<span class="gi">+        if not self.packetizer.need_rekey():</span>
<span class="gi">+            self.in_kex = False</span>
<span class="gi">+        # If client indicated extension support, send that packet immediately</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.server_mode</span>
<span class="gi">+            and self.server_sig_algs</span>
<span class="gi">+            and self._remote_ext_info == &quot;ext-info-c&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            extensions = {&quot;server-sig-algs&quot;: &quot;,&quot;.join(self.preferred_pubkeys)}</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_EXT_INFO)</span>
<span class="gi">+            m.add_int(len(extensions))</span>
<span class="gi">+            for name, value in sorted(extensions.items()):</span>
<span class="gi">+                m.add_string(name)</span>
<span class="gi">+                m.add_string(value)</span>
<span class="gi">+            self._send_message(m)</span>
<span class="gi">+        # we always expect to receive NEWKEYS now</span>
<span class="gi">+        self._expect_packet(MSG_NEWKEYS)</span>
<span class="gi">+</span>
<span class="gi">+    def _auth_trigger(self):</span>
<span class="gi">+        self.authenticated = True</span>
<span class="gi">+        # delayed initiation of compression</span>
<span class="gi">+        if self.local_compression == &quot;zlib@openssh.com&quot;:</span>
<span class="gi">+            compress_out = self._compression_info[self.local_compression][0]</span>
<span class="gi">+            self._log(DEBUG, &quot;Switching on outbound compression ...&quot;)</span>
<span class="gi">+            self.packetizer.set_outbound_compressor(compress_out())</span>
<span class="gi">+        if self.remote_compression == &quot;zlib@openssh.com&quot;:</span>
<span class="gi">+            compress_in = self._compression_info[self.remote_compression][1]</span>
<span class="gi">+            self._log(DEBUG, &quot;Switching on inbound compression ...&quot;)</span>
<span class="gi">+            self.packetizer.set_inbound_compressor(compress_in())</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_ext_info(self, msg):</span>
<span class="gi">+        # Packet is a count followed by that many key-string to possibly-bytes</span>
<span class="gi">+        # pairs.</span>
<span class="gi">+        extensions = {}</span>
<span class="gi">+        for _ in range(msg.get_int()):</span>
<span class="gi">+            name = msg.get_text()</span>
<span class="gi">+            value = msg.get_string()</span>
<span class="gi">+            extensions[name] = value</span>
<span class="gi">+        self._log(DEBUG, &quot;Got EXT_INFO: {}&quot;.format(extensions))</span>
<span class="gi">+        # NOTE: this should work ok in cases where a server sends /two/ such</span>
<span class="gi">+        # messages; the RFC explicitly states a 2nd one should overwrite the</span>
<span class="gi">+        # 1st.</span>
<span class="gi">+        self.server_extensions = extensions</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_newkeys(self, m):</span>
<span class="gi">+        self._log(DEBUG, &quot;Switch to new keys ...&quot;)</span>
<span class="gi">+        self._activate_inbound()</span>
<span class="gi">+        # can also free a bunch of stuff here</span>
<span class="gi">+        self.local_kex_init = self.remote_kex_init = None</span>
<span class="gi">+        self.K = None</span>
<span class="gi">+        self.kex_engine = None</span>
<span class="gi">+        if self.server_mode and (self.auth_handler is None):</span>
<span class="gi">+            # create auth handler for server mode</span>
<span class="gi">+            self.auth_handler = AuthHandler(self)</span>
<span class="gi">+        if not self.initial_kex_done:</span>
<span class="gi">+            # this was the first key exchange</span>
<span class="gi">+            # (also signal to packetizer as it sometimes wants to know this</span>
<span class="gi">+            # status as well, eg when seqnos rollover)</span>
<span class="gi">+            self.initial_kex_done = self.packetizer._initial_kex_done = True</span>
<span class="gi">+        # send an event?</span>
<span class="gi">+        if self.completion_event is not None:</span>
<span class="gi">+            self.completion_event.set()</span>
<span class="gi">+        # it&#39;s now okay to send data again (if this was a re-key)</span>
<span class="gi">+        if not self.packetizer.need_rekey():</span>
<span class="gi">+            self.in_kex = False</span>
<span class="gi">+        self.clear_to_send_lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.clear_to_send.set()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.clear_to_send_lock.release()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_disconnect(self, m):</span>
<span class="gi">+        code = m.get_int()</span>
<span class="gi">+        desc = m.get_text()</span>
<span class="gi">+        self._log(INFO, &quot;Disconnect (code {:d}): {}&quot;.format(code, desc))</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_global_request(self, m):</span>
<span class="gi">+        kind = m.get_text()</span>
<span class="gi">+        self._log(DEBUG, &#39;Received global request &quot;{}&quot;&#39;.format(kind))</span>
<span class="gi">+        want_reply = m.get_boolean()</span>
<span class="gi">+        if not self.server_mode:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                &#39;Rejecting &quot;{}&quot; global request from server.&#39;.format(kind),</span>
<span class="gi">+            )</span>
<span class="gi">+            ok = False</span>
<span class="gi">+        elif kind == &quot;tcpip-forward&quot;:</span>
<span class="gi">+            address = m.get_text()</span>
<span class="gi">+            port = m.get_int()</span>
<span class="gi">+            ok = self.server_object.check_port_forward_request(address, port)</span>
<span class="gi">+            if ok:</span>
<span class="gi">+                ok = (ok,)</span>
<span class="gi">+        elif kind == &quot;cancel-tcpip-forward&quot;:</span>
<span class="gi">+            address = m.get_text()</span>
<span class="gi">+            port = m.get_int()</span>
<span class="gi">+            self.server_object.cancel_port_forward_request(address, port)</span>
<span class="gi">+            ok = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            ok = self.server_object.check_global_request(kind, m)</span>
<span class="gi">+        extra = ()</span>
<span class="gi">+        if type(ok) is tuple:</span>
<span class="gi">+            extra = ok</span>
<span class="gi">+            ok = True</span>
<span class="gi">+        if want_reply:</span>
<span class="gi">+            msg = Message()</span>
<span class="gi">+            if ok:</span>
<span class="gi">+                msg.add_byte(cMSG_REQUEST_SUCCESS)</span>
<span class="gi">+                msg.add(*extra)</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg.add_byte(cMSG_REQUEST_FAILURE)</span>
<span class="gi">+            self._send_message(msg)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_request_success(self, m):</span>
<span class="gi">+        self._log(DEBUG, &quot;Global request successful.&quot;)</span>
<span class="gi">+        self.global_response = m</span>
<span class="gi">+        if self.completion_event is not None:</span>
<span class="gi">+            self.completion_event.set()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_request_failure(self, m):</span>
<span class="gi">+        self._log(DEBUG, &quot;Global request denied.&quot;)</span>
<span class="gi">+        self.global_response = None</span>
<span class="gi">+        if self.completion_event is not None:</span>
<span class="gi">+            self.completion_event.set()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_channel_open_success(self, m):</span>
<span class="gi">+        chanid = m.get_int()</span>
<span class="gi">+        server_chanid = m.get_int()</span>
<span class="gi">+        server_window_size = m.get_int()</span>
<span class="gi">+        server_max_packet_size = m.get_int()</span>
<span class="gi">+        chan = self._channels.get(chanid)</span>
<span class="gi">+        if chan is None:</span>
<span class="gi">+            self._log(WARNING, &quot;Success for unrequested channel! [??]&quot;)</span>
<span class="gi">+            return</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            chan._set_remote_channel(</span>
<span class="gi">+                server_chanid, server_window_size, server_max_packet_size</span>
<span class="gi">+            )</span>
<span class="gi">+            self._log(DEBUG, &quot;Secsh channel {:d} opened.&quot;.format(chanid))</span>
<span class="gi">+            if chanid in self.channel_events:</span>
<span class="gi">+                self.channel_events[chanid].set()</span>
<span class="gi">+                del self.channel_events[chanid]</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_channel_open_failure(self, m):</span>
<span class="gi">+        chanid = m.get_int()</span>
<span class="gi">+        reason = m.get_int()</span>
<span class="gi">+        reason_str = m.get_text()</span>
<span class="gi">+        m.get_text()  # ignored language</span>
<span class="gi">+        reason_text = CONNECTION_FAILED_CODE.get(reason, &quot;(unknown code)&quot;)</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            ERROR,</span>
<span class="gi">+            &quot;Secsh channel {:d} open FAILED: {}: {}&quot;.format(</span>
<span class="gi">+                chanid, reason_str, reason_text</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.saved_exception = ChannelException(reason, reason_text)</span>
<span class="gi">+            if chanid in self.channel_events:</span>
<span class="gi">+                self._channels.delete(chanid)</span>
<span class="gi">+                if chanid in self.channel_events:</span>
<span class="gi">+                    self.channel_events[chanid].set()</span>
<span class="gi">+                    del self.channel_events[chanid]</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_channel_open(self, m):</span>
<span class="gi">+        kind = m.get_text()</span>
<span class="gi">+        chanid = m.get_int()</span>
<span class="gi">+        initial_window_size = m.get_int()</span>
<span class="gi">+        max_packet_size = m.get_int()</span>
<span class="gi">+        reject = False</span>
<span class="gi">+        if (</span>
<span class="gi">+            kind == &quot;auth-agent@openssh.com&quot;</span>
<span class="gi">+            and self._forward_agent_handler is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._log(DEBUG, &quot;Incoming forward agent connection&quot;)</span>
<span class="gi">+            self.lock.acquire()</span>
<span class="gi">+            try:</span>
<span class="gi">+                my_chanid = self._next_channel()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self.lock.release()</span>
<span class="gi">+        elif (kind == &quot;x11&quot;) and (self._x11_handler is not None):</span>
<span class="gi">+            origin_addr = m.get_text()</span>
<span class="gi">+            origin_port = m.get_int()</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                &quot;Incoming x11 connection from {}:{:d}&quot;.format(</span>
<span class="gi">+                    origin_addr, origin_port</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+            self.lock.acquire()</span>
<span class="gi">+            try:</span>
<span class="gi">+                my_chanid = self._next_channel()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self.lock.release()</span>
<span class="gi">+        elif (kind == &quot;forwarded-tcpip&quot;) and (self._tcp_handler is not None):</span>
<span class="gi">+            server_addr = m.get_text()</span>
<span class="gi">+            server_port = m.get_int()</span>
<span class="gi">+            origin_addr = m.get_text()</span>
<span class="gi">+            origin_port = m.get_int()</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                &quot;Incoming tcp forwarded connection from {}:{:d}&quot;.format(</span>
<span class="gi">+                    origin_addr, origin_port</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+            self.lock.acquire()</span>
<span class="gi">+            try:</span>
<span class="gi">+                my_chanid = self._next_channel()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self.lock.release()</span>
<span class="gi">+        elif not self.server_mode:</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG,</span>
<span class="gi">+                &#39;Rejecting &quot;{}&quot; channel request from server.&#39;.format(kind),</span>
<span class="gi">+            )</span>
<span class="gi">+            reject = True</span>
<span class="gi">+            reason = OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.lock.acquire()</span>
<span class="gi">+            try:</span>
<span class="gi">+                my_chanid = self._next_channel()</span>
<span class="gi">+            finally:</span>
<span class="gi">+                self.lock.release()</span>
<span class="gi">+            if kind == &quot;direct-tcpip&quot;:</span>
<span class="gi">+                # handle direct-tcpip requests coming from the client</span>
<span class="gi">+                dest_addr = m.get_text()</span>
<span class="gi">+                dest_port = m.get_int()</span>
<span class="gi">+                origin_addr = m.get_text()</span>
<span class="gi">+                origin_port = m.get_int()</span>
<span class="gi">+                reason = self.server_object.check_channel_direct_tcpip_request(</span>
<span class="gi">+                    my_chanid,</span>
<span class="gi">+                    (origin_addr, origin_port),</span>
<span class="gi">+                    (dest_addr, dest_port),</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                reason = self.server_object.check_channel_request(</span>
<span class="gi">+                    kind, my_chanid</span>
<span class="gi">+                )</span>
<span class="gi">+            if reason != OPEN_SUCCEEDED:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    DEBUG,</span>
<span class="gi">+                    &#39;Rejecting &quot;{}&quot; channel request from client.&#39;.format(kind),</span>
<span class="gi">+                )</span>
<span class="gi">+                reject = True</span>
<span class="gi">+        if reject:</span>
<span class="gi">+            msg = Message()</span>
<span class="gi">+            msg.add_byte(cMSG_CHANNEL_OPEN_FAILURE)</span>
<span class="gi">+            msg.add_int(chanid)</span>
<span class="gi">+            msg.add_int(reason)</span>
<span class="gi">+            msg.add_string(&quot;&quot;)</span>
<span class="gi">+            msg.add_string(&quot;en&quot;)</span>
<span class="gi">+            self._send_message(msg)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        chan = Channel(my_chanid)</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._channels.put(my_chanid, chan)</span>
<span class="gi">+            self.channels_seen[my_chanid] = True</span>
<span class="gi">+            chan._set_transport(self)</span>
<span class="gi">+            chan._set_window(</span>
<span class="gi">+                self.default_window_size, self.default_max_packet_size</span>
<span class="gi">+            )</span>
<span class="gi">+            chan._set_remote_channel(</span>
<span class="gi">+                chanid, initial_window_size, max_packet_size</span>
<span class="gi">+            )</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_OPEN_SUCCESS)</span>
<span class="gi">+        m.add_int(chanid)</span>
<span class="gi">+        m.add_int(my_chanid)</span>
<span class="gi">+        m.add_int(self.default_window_size)</span>
<span class="gi">+        m.add_int(self.default_max_packet_size)</span>
<span class="gi">+        self._send_message(m)</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            DEBUG, &quot;Secsh channel {:d} ({}) opened.&quot;.format(my_chanid, kind)</span>
<span class="gi">+        )</span>
<span class="gi">+        if kind == &quot;auth-agent@openssh.com&quot;:</span>
<span class="gi">+            self._forward_agent_handler(chan)</span>
<span class="gi">+        elif kind == &quot;x11&quot;:</span>
<span class="gi">+            self._x11_handler(chan, (origin_addr, origin_port))</span>
<span class="gi">+        elif kind == &quot;forwarded-tcpip&quot;:</span>
<span class="gi">+            chan.origin_addr = (origin_addr, origin_port)</span>
<span class="gi">+            self._tcp_handler(</span>
<span class="gi">+                chan, (origin_addr, origin_port), (server_addr, server_port)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._queue_incoming_channel(chan)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_debug(self, m):</span>
<span class="gi">+        m.get_boolean()  # always_display</span>
<span class="gi">+        msg = m.get_string()</span>
<span class="gi">+        m.get_string()  # language</span>
<span class="gi">+        self._log(DEBUG, &quot;Debug msg: {}&quot;.format(util.safe_string(msg)))</span>
<span class="gi">+</span>
<span class="gi">+    def _get_subsystem_handler(self, name):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.lock.acquire()</span>
<span class="gi">+            if name not in self.subsystem_table:</span>
<span class="gi">+                return None, [], {}</span>
<span class="gi">+            return self.subsystem_table[name]</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    _channel_handler_table = {</span>
<span class="gi">+        MSG_CHANNEL_SUCCESS: Channel._request_success,</span>
<span class="gi">+        MSG_CHANNEL_FAILURE: Channel._request_failed,</span>
<span class="gi">+        MSG_CHANNEL_DATA: Channel._feed,</span>
<span class="gi">+        MSG_CHANNEL_EXTENDED_DATA: Channel._feed_extended,</span>
<span class="w"> </span>        MSG_CHANNEL_WINDOW_ADJUST: Channel._window_adjust,
<span class="gd">-        MSG_CHANNEL_REQUEST: Channel._handle_request, MSG_CHANNEL_EOF:</span>
<span class="gd">-        Channel._handle_eof, MSG_CHANNEL_CLOSE: Channel._handle_close}</span>
<span class="gi">+        MSG_CHANNEL_REQUEST: Channel._handle_request,</span>
<span class="gi">+        MSG_CHANNEL_EOF: Channel._handle_eof,</span>
<span class="gi">+        MSG_CHANNEL_CLOSE: Channel._handle_close,</span>
<span class="gi">+    }</span>


<span class="gi">+# TODO 4.0: drop this, we barely use it ourselves, it badly replicates the</span>
<span class="gi">+# Transport-internal algorithm management, AND does so in a way which doesn&#39;t</span>
<span class="gi">+# honor newer things like disabled_algorithms!</span>
<span class="w"> </span>class SecurityOptions:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Simple object containing the security preferences of an ssh transport.
<span class="gu">@@ -1277,7 +3131,8 @@ class SecurityOptions:</span>
<span class="w"> </span>    ``ValueError`` will be raised.  If you try to assign something besides a
<span class="w"> </span>    tuple to one of the fields, ``TypeError`` will be raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_transport&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = &quot;_transport&quot;</span>

<span class="w"> </span>    def __init__(self, transport):
<span class="w"> </span>        self._transport = transport
<span class="gu">@@ -1286,40 +3141,102 @@ class SecurityOptions:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a string representation of this object, for debugging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;&lt;paramiko.SecurityOptions for {!r}&gt;&#39;.format(self._transport)</span>
<span class="gi">+        return &quot;&lt;paramiko.SecurityOptions for {!r}&gt;&quot;.format(self._transport)</span>
<span class="gi">+</span>
<span class="gi">+    def _set(self, name, orig, x):</span>
<span class="gi">+        if type(x) is list:</span>
<span class="gi">+            x = tuple(x)</span>
<span class="gi">+        if type(x) is not tuple:</span>
<span class="gi">+            raise TypeError(&quot;expected tuple or list&quot;)</span>
<span class="gi">+        possible = list(getattr(self._transport, orig).keys())</span>
<span class="gi">+        forbidden = [n for n in x if n not in possible]</span>
<span class="gi">+        if len(forbidden) &gt; 0:</span>
<span class="gi">+            raise ValueError(&quot;unknown cipher&quot;)</span>
<span class="gi">+        setattr(self._transport, name, x)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def ciphers(self):
<span class="w"> </span>        &quot;&quot;&quot;Symmetric encryption ciphers&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._transport._preferred_ciphers</span>
<span class="gi">+</span>
<span class="gi">+    @ciphers.setter</span>
<span class="gi">+    def ciphers(self, x):</span>
<span class="gi">+        self._set(&quot;_preferred_ciphers&quot;, &quot;_cipher_info&quot;, x)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def digests(self):
<span class="w"> </span>        &quot;&quot;&quot;Digest (one-way hash) algorithms&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._transport._preferred_macs</span>
<span class="gi">+</span>
<span class="gi">+    @digests.setter</span>
<span class="gi">+    def digests(self, x):</span>
<span class="gi">+        self._set(&quot;_preferred_macs&quot;, &quot;_mac_info&quot;, x)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def key_types(self):
<span class="w"> </span>        &quot;&quot;&quot;Public-key algorithms&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._transport._preferred_keys</span>
<span class="gi">+</span>
<span class="gi">+    @key_types.setter</span>
<span class="gi">+    def key_types(self, x):</span>
<span class="gi">+        self._set(&quot;_preferred_keys&quot;, &quot;_key_info&quot;, x)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def kex(self):
<span class="w"> </span>        &quot;&quot;&quot;Key exchange algorithms&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._transport._preferred_kex</span>
<span class="gi">+</span>
<span class="gi">+    @kex.setter</span>
<span class="gi">+    def kex(self, x):</span>
<span class="gi">+        self._set(&quot;_preferred_kex&quot;, &quot;_kex_info&quot;, x)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def compression(self):
<span class="w"> </span>        &quot;&quot;&quot;Compression algorithms&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._transport._preferred_compression</span>

<span class="gi">+    @compression.setter</span>
<span class="gi">+    def compression(self, x):</span>
<span class="gi">+        self._set(&quot;_preferred_compression&quot;, &quot;_compression_info&quot;, x)</span>

<span class="gd">-class ChannelMap:</span>

<span class="gi">+class ChannelMap:</span>
<span class="w"> </span>    def __init__(self):
<span class="gi">+        # (id -&gt; Channel)</span>
<span class="w"> </span>        self._map = weakref.WeakValueDictionary()
<span class="w"> </span>        self._lock = threading.Lock()

<span class="gi">+    def put(self, chanid, chan):</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._map[chanid] = chan</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, chanid):</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._map.get(chanid, None)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def delete(self, chanid):</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            try:</span>
<span class="gi">+                del self._map[chanid]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        self._lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return list(self._map.values())</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock.release()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        self._lock.acquire()
<span class="w"> </span>        try:
<span class="gu">@@ -1335,7 +3252,152 @@ class ServiceRequestingTransport(Transport):</span>
<span class="w"> </span>    .. versionadded:: 3.2
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    # NOTE: this purposefully duplicates some of the parent class in order to</span>
<span class="gi">+    # modernize, refactor, etc. The intent is that eventually we will collapse</span>
<span class="gi">+    # this one onto the parent in a backwards incompatible release.</span>
<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self._service_userauth_accepted = False
<span class="w"> </span>        self._handler_table[MSG_SERVICE_ACCEPT] = self._parse_service_accept
<span class="gi">+</span>
<span class="gi">+    def _parse_service_accept(self, m):</span>
<span class="gi">+        service = m.get_text()</span>
<span class="gi">+        # Short-circuit for any service name not ssh-userauth.</span>
<span class="gi">+        # NOTE: it&#39;s technically possible for &#39;service name&#39; in</span>
<span class="gi">+        # SERVICE_REQUEST/ACCEPT messages to be &quot;ssh-connection&quot; --</span>
<span class="gi">+        # but I don&#39;t see evidence of Paramiko ever initiating or expecting to</span>
<span class="gi">+        # receive one of these. We /do/ see the &#39;service name&#39; field in</span>
<span class="gi">+        # MSG_USERAUTH_REQUEST/ACCEPT/FAILURE set to this string, but that is a</span>
<span class="gi">+        # different set of handlers, so...!</span>
<span class="gi">+        if service != &quot;ssh-userauth&quot;:</span>
<span class="gi">+            # TODO 4.0: consider erroring here (with an ability to opt out?)</span>
<span class="gi">+            # instead as it probably means something went Very Wrong.</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                DEBUG, &#39;Service request &quot;{}&quot; accepted (?)&#39;.format(service)</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        # Record that we saw a service-userauth acceptance, meaning we are free</span>
<span class="gi">+        # to submit auth requests.</span>
<span class="gi">+        self._service_userauth_accepted = True</span>
<span class="gi">+        self._log(DEBUG, &quot;MSG_SERVICE_ACCEPT received; auth may begin&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def ensure_session(self):</span>
<span class="gi">+        # Make sure we&#39;re not trying to auth on a not-yet-open or</span>
<span class="gi">+        # already-closed transport session; that&#39;s our responsibility, not that</span>
<span class="gi">+        # of AuthHandler.</span>
<span class="gi">+        if (not self.active) or (not self.initial_kex_done):</span>
<span class="gi">+            # TODO: better error message? this can happen in many places, eg</span>
<span class="gi">+            # user error (authing before connecting) or developer error (some</span>
<span class="gi">+            # improperly handled pre/mid auth shutdown didn&#39;t become fatal</span>
<span class="gi">+            # enough). The latter is much more common &amp; should ideally be fixed</span>
<span class="gi">+            # by terminating things harder?</span>
<span class="gi">+            raise SSHException(&quot;No existing session&quot;)</span>
<span class="gi">+        # Also make sure we&#39;ve actually been told we are allowed to auth.</span>
<span class="gi">+        if self._service_userauth_accepted:</span>
<span class="gi">+            return</span>
<span class="gi">+        # Or request to do so, otherwise.</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_SERVICE_REQUEST)</span>
<span class="gi">+        m.add_string(&quot;ssh-userauth&quot;)</span>
<span class="gi">+        self._log(DEBUG, &quot;Sending MSG_SERVICE_REQUEST: ssh-userauth&quot;)</span>
<span class="gi">+        self._send_message(m)</span>
<span class="gi">+        # Now we wait to hear back; the user is expecting a blocking-style auth</span>
<span class="gi">+        # request so there&#39;s no point giving control back anywhere.</span>
<span class="gi">+        while not self._service_userauth_accepted:</span>
<span class="gi">+            # TODO: feels like we&#39;re missing an AuthHandler Event like</span>
<span class="gi">+            # &#39;self.auth_event&#39; which is set when AuthHandler shuts down in</span>
<span class="gi">+            # ways good AND bad. Transport only seems to have completion_event</span>
<span class="gi">+            # which is unclear re: intent, eg it&#39;s set by newkeys which always</span>
<span class="gi">+            # happens on connection, so it&#39;ll always be set by the time we get</span>
<span class="gi">+            # here.</span>
<span class="gi">+            # NOTE: this copies the timing of event.wait() in</span>
<span class="gi">+            # AuthHandler.wait_for_response, re: 1/10 of a second. Could</span>
<span class="gi">+            # presumably be smaller, but seems unlikely this period is going to</span>
<span class="gi">+            # be &quot;too long&quot; for any code doing ssh networking...</span>
<span class="gi">+            time.sleep(0.1)</span>
<span class="gi">+        self.auth_handler = self.get_auth_handler()</span>
<span class="gi">+</span>
<span class="gi">+    def get_auth_handler(self):</span>
<span class="gi">+        # NOTE: using new sibling subclass instead of classic AuthHandler</span>
<span class="gi">+        return AuthOnlyHandler(self)</span>
<span class="gi">+</span>
<span class="gi">+    def auth_none(self, username):</span>
<span class="gi">+        # TODO 4.0: merge to parent, preserving (most of) docstring</span>
<span class="gi">+        self.ensure_session()</span>
<span class="gi">+        return self.auth_handler.auth_none(username)</span>
<span class="gi">+</span>
<span class="gi">+    def auth_password(self, username, password, fallback=True):</span>
<span class="gi">+        # TODO 4.0: merge to parent, preserving (most of) docstring</span>
<span class="gi">+        self.ensure_session()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.auth_handler.auth_password(username, password)</span>
<span class="gi">+        except BadAuthenticationType as e:</span>
<span class="gi">+            # if password auth isn&#39;t allowed, but keyboard-interactive *is*,</span>
<span class="gi">+            # try to fudge it</span>
<span class="gi">+            if not fallback or (&quot;keyboard-interactive&quot; not in e.allowed_types):</span>
<span class="gi">+                raise</span>
<span class="gi">+            try:</span>
<span class="gi">+</span>
<span class="gi">+                def handler(title, instructions, fields):</span>
<span class="gi">+                    if len(fields) &gt; 1:</span>
<span class="gi">+                        raise SSHException(&quot;Fallback authentication failed.&quot;)</span>
<span class="gi">+                    if len(fields) == 0:</span>
<span class="gi">+                        # for some reason, at least on os x, a 2nd request will</span>
<span class="gi">+                        # be made with zero fields requested.  maybe it&#39;s just</span>
<span class="gi">+                        # to try to fake out automated scripting of the exact</span>
<span class="gi">+                        # type we&#39;re doing here.  *shrug* :)</span>
<span class="gi">+                        return []</span>
<span class="gi">+                    return [password]</span>
<span class="gi">+</span>
<span class="gi">+                return self.auth_interactive(username, handler)</span>
<span class="gi">+            except SSHException:</span>
<span class="gi">+                # attempt to fudge failed; just raise the original exception</span>
<span class="gi">+                raise e</span>
<span class="gi">+</span>
<span class="gi">+    def auth_publickey(self, username, key):</span>
<span class="gi">+        # TODO 4.0: merge to parent, preserving (most of) docstring</span>
<span class="gi">+        self.ensure_session()</span>
<span class="gi">+        return self.auth_handler.auth_publickey(username, key)</span>
<span class="gi">+</span>
<span class="gi">+    def auth_interactive(self, username, handler, submethods=&quot;&quot;):</span>
<span class="gi">+        # TODO 4.0: merge to parent, preserving (most of) docstring</span>
<span class="gi">+        self.ensure_session()</span>
<span class="gi">+        return self.auth_handler.auth_interactive(</span>
<span class="gi">+            username, handler, submethods</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def auth_interactive_dumb(self, username, handler=None, submethods=&quot;&quot;):</span>
<span class="gi">+        # TODO 4.0: merge to parent, preserving (most of) docstring</span>
<span class="gi">+        # NOTE: legacy impl omitted equiv of ensure_session since it just wraps</span>
<span class="gi">+        # another call to an auth method. however we reinstate it for</span>
<span class="gi">+        # consistency reasons.</span>
<span class="gi">+        self.ensure_session()</span>
<span class="gi">+        if not handler:</span>
<span class="gi">+</span>
<span class="gi">+            def handler(title, instructions, prompt_list):</span>
<span class="gi">+                answers = []</span>
<span class="gi">+                if title:</span>
<span class="gi">+                    print(title.strip())</span>
<span class="gi">+                if instructions:</span>
<span class="gi">+                    print(instructions.strip())</span>
<span class="gi">+                for prompt, show_input in prompt_list:</span>
<span class="gi">+                    print(prompt.strip(), end=&quot; &quot;)</span>
<span class="gi">+                    answers.append(input())</span>
<span class="gi">+                return answers</span>
<span class="gi">+</span>
<span class="gi">+        return self.auth_interactive(username, handler, submethods)</span>
<span class="gi">+</span>
<span class="gi">+    def auth_gssapi_with_mic(self, username, gss_host, gss_deleg_creds):</span>
<span class="gi">+        # TODO 4.0: merge to parent, preserving (most of) docstring</span>
<span class="gi">+        self.ensure_session()</span>
<span class="gi">+        self.auth_handler = self.get_auth_handler()</span>
<span class="gi">+        return self.auth_handler.auth_gssapi_with_mic(</span>
<span class="gi">+            username, gss_host, gss_deleg_creds</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def auth_gssapi_keyex(self, username):</span>
<span class="gi">+        # TODO 4.0: merge to parent, preserving (most of) docstring</span>
<span class="gi">+        self.ensure_session()</span>
<span class="gi">+        self.auth_handler = self.get_auth_handler()</span>
<span class="gi">+        return self.auth_handler.auth_gssapi_keyex(username)</span>
<span class="gh">diff --git a/paramiko/util.py b/paramiko/util.py</span>
<span class="gh">index d9df7198..f1e33a50 100644</span>
<span class="gd">--- a/paramiko/util.py</span>
<span class="gi">+++ b/paramiko/util.py</span>
<span class="gu">@@ -1,25 +1,142 @@</span>
<span class="gi">+# Copyright (C) 2003-2007  Robey Pointer &lt;robeypointer@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Useful functions used by the rest of paramiko.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import struct
<span class="w"> </span>import traceback
<span class="w"> </span>import threading
<span class="w"> </span>import logging
<span class="gd">-from paramiko.common import DEBUG, zero_byte, xffffffff, max_byte, byte_ord, byte_chr</span>
<span class="gi">+</span>
<span class="gi">+from paramiko.common import (</span>
<span class="gi">+    DEBUG,</span>
<span class="gi">+    zero_byte,</span>
<span class="gi">+    xffffffff,</span>
<span class="gi">+    max_byte,</span>
<span class="gi">+    byte_ord,</span>
<span class="gi">+    byte_chr,</span>
<span class="gi">+)</span>
<span class="w"> </span>from paramiko.config import SSHConfig


<span class="w"> </span>def inflate_long(s, always_positive=False):
<span class="w"> </span>    &quot;&quot;&quot;turns a normalized byte string into a long-int
<span class="w"> </span>    (adapted from Crypto.Util.number)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    out = 0</span>
<span class="gi">+    negative = 0</span>
<span class="gi">+    if not always_positive and (len(s) &gt; 0) and (byte_ord(s[0]) &gt;= 0x80):</span>
<span class="gi">+        negative = 1</span>
<span class="gi">+    if len(s) % 4:</span>
<span class="gi">+        filler = zero_byte</span>
<span class="gi">+        if negative:</span>
<span class="gi">+            filler = max_byte</span>
<span class="gi">+        # never convert this to ``s +=`` because this is a string, not a number</span>
<span class="gi">+        # noinspection PyAugmentAssignment</span>
<span class="gi">+        s = filler * (4 - len(s) % 4) + s</span>
<span class="gi">+    for i in range(0, len(s), 4):</span>
<span class="gi">+        out = (out &lt;&lt; 32) + struct.unpack(&quot;&gt;I&quot;, s[i : i + 4])[0]</span>
<span class="gi">+    if negative:</span>
<span class="gi">+        out -= 1 &lt;&lt; (8 * len(s))</span>
<span class="gi">+    return out</span>


<span class="w"> </span>def deflate_long(n, add_sign_padding=True):
<span class="w"> </span>    &quot;&quot;&quot;turns a long-int into a normalized byte string
<span class="w"> </span>    (adapted from Crypto.Util.number)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # after much testing, this algorithm was deemed to be the fastest</span>
<span class="gi">+    s = bytes()</span>
<span class="gi">+    n = int(n)</span>
<span class="gi">+    while (n != 0) and (n != -1):</span>
<span class="gi">+        s = struct.pack(&quot;&gt;I&quot;, n &amp; xffffffff) + s</span>
<span class="gi">+        n &gt;&gt;= 32</span>
<span class="gi">+    # strip off leading zeros, FFs</span>
<span class="gi">+    for i in enumerate(s):</span>
<span class="gi">+        if (n == 0) and (i[1] != 0):</span>
<span class="gi">+            break</span>
<span class="gi">+        if (n == -1) and (i[1] != 0xFF):</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        # degenerate case, n was either 0 or -1</span>
<span class="gi">+        i = (0,)</span>
<span class="gi">+        if n == 0:</span>
<span class="gi">+            s = zero_byte</span>
<span class="gi">+        else:</span>
<span class="gi">+            s = max_byte</span>
<span class="gi">+    s = s[i[0] :]</span>
<span class="gi">+    if add_sign_padding:</span>
<span class="gi">+        if (n == 0) and (byte_ord(s[0]) &gt;= 0x80):</span>
<span class="gi">+            s = zero_byte + s</span>
<span class="gi">+        if (n == -1) and (byte_ord(s[0]) &lt; 0x80):</span>
<span class="gi">+            s = max_byte + s</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_binary(data, prefix=&quot;&quot;):</span>
<span class="gi">+    x = 0</span>
<span class="gi">+    out = []</span>
<span class="gi">+    while len(data) &gt; x + 16:</span>
<span class="gi">+        out.append(format_binary_line(data[x : x + 16]))</span>
<span class="gi">+        x += 16</span>
<span class="gi">+    if x &lt; len(data):</span>
<span class="gi">+        out.append(format_binary_line(data[x:]))</span>
<span class="gi">+    return [prefix + line for line in out]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_binary_line(data):</span>
<span class="gi">+    left = &quot; &quot;.join([&quot;{:02X}&quot;.format(byte_ord(c)) for c in data])</span>
<span class="gi">+    right = &quot;&quot;.join(</span>
<span class="gi">+        [&quot;.{:c}..&quot;.format(byte_ord(c))[(byte_ord(c) + 63) // 95] for c in data]</span>
<span class="gi">+    )</span>
<span class="gi">+    return &quot;{:50s} {}&quot;.format(left, right)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def safe_string(s):</span>
<span class="gi">+    out = b&quot;&quot;</span>
<span class="gi">+    for c in s:</span>
<span class="gi">+        i = byte_ord(c)</span>
<span class="gi">+        if 32 &lt;= i &lt;= 127:</span>
<span class="gi">+            out += byte_chr(i)</span>
<span class="gi">+        else:</span>
<span class="gi">+            out += b(&quot;%{:02X}&quot;.format(i))</span>
<span class="gi">+    return out</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def bit_length(n):</span>
<span class="gi">+    try:</span>
<span class="gi">+        return n.bit_length()</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        norm = deflate_long(n, False)</span>
<span class="gi">+        hbyte = byte_ord(norm[0])</span>
<span class="gi">+        if hbyte == 0:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        bitlen = len(norm) * 8</span>
<span class="gi">+        while not (hbyte &amp; 0x80):</span>
<span class="gi">+            hbyte &lt;&lt;= 1</span>
<span class="gi">+            bitlen -= 1</span>
<span class="gi">+        return bitlen</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tb_strings():</span>
<span class="gi">+    return &quot;&quot;.join(traceback.format_exception(*sys.exc_info())).split(&quot;\n&quot;)</span>


<span class="w"> </span>def generate_key_bytes(hash_alg, salt, key, nbytes):
<span class="gu">@@ -36,7 +153,21 @@ def generate_key_bytes(hash_alg, salt, key, nbytes):</span>
<span class="w"> </span>    :param int nbytes: number of bytes to generate.
<span class="w"> </span>    :return: Key data, as `bytes`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keydata = bytes()</span>
<span class="gi">+    digest = bytes()</span>
<span class="gi">+    if len(salt) &gt; 8:</span>
<span class="gi">+        salt = salt[:8]</span>
<span class="gi">+    while nbytes &gt; 0:</span>
<span class="gi">+        hash_obj = hash_alg()</span>
<span class="gi">+        if len(digest) &gt; 0:</span>
<span class="gi">+            hash_obj.update(digest)</span>
<span class="gi">+        hash_obj.update(b(key))</span>
<span class="gi">+        hash_obj.update(salt)</span>
<span class="gi">+        digest = hash_obj.digest()</span>
<span class="gi">+        size = min(nbytes, len(digest))</span>
<span class="gi">+        keydata += digest[:size]</span>
<span class="gi">+        nbytes -= size</span>
<span class="gi">+    return keydata</span>


<span class="w"> </span>def load_host_keys(filename):
<span class="gu">@@ -55,7 +186,9 @@ def load_host_keys(filename):</span>
<span class="w"> </span>    :return:
<span class="w"> </span>        nested dict of `.PKey` objects, indexed by hostname and then keytype
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from paramiko.hostkeys import HostKeys</span>
<span class="gi">+</span>
<span class="gi">+    return HostKeys(filename)</span>


<span class="w"> </span>def parse_ssh_config(file_obj):
<span class="gu">@@ -65,14 +198,31 @@ def parse_ssh_config(file_obj):</span>
<span class="w"> </span>    .. deprecated:: 2.7
<span class="w"> </span>        Use `SSHConfig.from_file` instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    config = SSHConfig()</span>
<span class="gi">+    config.parse(file_obj)</span>
<span class="gi">+    return config</span>


<span class="w"> </span>def lookup_ssh_host_config(hostname, config):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provided only as a backward-compatible wrapper around `.SSHConfig`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return config.lookup(hostname)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def mod_inverse(x, m):</span>
<span class="gi">+    # it&#39;s crazy how small Python can make this function.</span>
<span class="gi">+    u1, u2, u3 = 1, 0, m</span>
<span class="gi">+    v1, v2, v3 = 0, 1, x</span>
<span class="gi">+</span>
<span class="gi">+    while v3 &gt; 0:</span>
<span class="gi">+        q = u3 // v3</span>
<span class="gi">+        u1, v1 = v1, u1 - v1 * q</span>
<span class="gi">+        u2, v2 = v2, u2 - v2 * q</span>
<span class="gi">+        u3, v3 = v3, u3 - v3 * q</span>
<span class="gi">+    if u2 &lt; 0:</span>
<span class="gi">+        u2 += m</span>
<span class="gi">+    return u2</span>


<span class="w"> </span>_g_thread_data = threading.local()
<span class="gu">@@ -80,21 +230,59 @@ _g_thread_counter = 0</span>
<span class="w"> </span>_g_thread_lock = threading.Lock()


<span class="gi">+def get_thread_id():</span>
<span class="gi">+    global _g_thread_data, _g_thread_counter, _g_thread_lock</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _g_thread_data.id</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        with _g_thread_lock:</span>
<span class="gi">+            _g_thread_counter += 1</span>
<span class="gi">+            _g_thread_data.id = _g_thread_counter</span>
<span class="gi">+        return _g_thread_data.id</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def log_to_file(filename, level=DEBUG):
<span class="w"> </span>    &quot;&quot;&quot;send paramiko logs to a logfile,
<span class="w"> </span>    if they&#39;re not already going somewhere&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    logger = logging.getLogger(&quot;paramiko&quot;)</span>
<span class="gi">+    if len(logger.handlers) &gt; 0:</span>
<span class="gi">+        return</span>
<span class="gi">+    logger.setLevel(level)</span>
<span class="gi">+    f = open(filename, &quot;a&quot;)</span>
<span class="gi">+    handler = logging.StreamHandler(f)</span>
<span class="gi">+    frm = &quot;%(levelname)-.3s [%(asctime)s.%(msecs)03d] thr=%(_threadid)-3d&quot;</span>
<span class="gi">+    frm += &quot; %(name)s: %(message)s&quot;</span>
<span class="gi">+    handler.setFormatter(logging.Formatter(frm, &quot;%Y%m%d-%H:%M:%S&quot;))</span>
<span class="gi">+    logger.addHandler(handler)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# make only one filter object, so it doesn&#39;t get applied more than once</span>
<span class="w"> </span>class PFilter:
<span class="gd">-    pass</span>
<span class="gi">+    def filter(self, record):</span>
<span class="gi">+        record._threadid = get_thread_id()</span>
<span class="gi">+        return True</span>


<span class="w"> </span>_pfilter = PFilter()


<span class="gd">-class ClosingContextManager:</span>
<span class="gi">+def get_logger(name):</span>
<span class="gi">+    logger = logging.getLogger(name)</span>
<span class="gi">+    logger.addFilter(_pfilter)</span>
<span class="gi">+    return logger</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def constant_time_bytes_eq(a, b):</span>
<span class="gi">+    if len(a) != len(b):</span>
<span class="gi">+        return False</span>
<span class="gi">+    res = 0</span>
<span class="gi">+    # noinspection PyUnresolvedReferences</span>
<span class="gi">+    for i in range(len(a)):  # noqa: F821</span>
<span class="gi">+        res |= byte_ord(a[i]) ^ byte_ord(b[i])</span>
<span class="gi">+    return res == 0</span>
<span class="gi">+</span>

<span class="gi">+class ClosingContextManager:</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self

<span class="gu">@@ -102,18 +290,48 @@ class ClosingContextManager:</span>
<span class="w"> </span>        self.close()


<span class="gi">+def clamp_value(minimum, val, maximum):</span>
<span class="gi">+    return max(minimum, min(val, maximum))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def asbytes(s):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Coerce to bytes if possible or return unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def b(s, encoding=&#39;utf8&#39;):</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Attempt to run through our version of b(), which does the Right Thing</span>
<span class="gi">+        # for unicode strings vs bytestrings, and raises TypeError if it&#39;s not</span>
<span class="gi">+        # one of those types.</span>
<span class="gi">+        return b(s)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # If it wasn&#39;t a string/byte/buffer-ish object, try calling an</span>
<span class="gi">+            # asbytes() method, which many of our internal classes implement.</span>
<span class="gi">+            return s.asbytes()</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # Finally, just do nothing &amp; assume this object is sufficiently</span>
<span class="gi">+            # byte-y or buffer-y that everything will work out (or that callers</span>
<span class="gi">+            # are capable of handling whatever it is.)</span>
<span class="gi">+            return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO: clean this up / force callers to assume bytes OR unicode</span>
<span class="gi">+def b(s, encoding=&quot;utf8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;cast unicode or bytes to bytes&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(s, bytes):</span>
<span class="gi">+        return s</span>
<span class="gi">+    elif isinstance(s, str):</span>
<span class="gi">+        return s.encode(encoding)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&quot;Expected unicode or bytes, got {type(s)}&quot;)</span>


<span class="gd">-def u(s, encoding=&#39;utf8&#39;):</span>
<span class="gi">+# TODO: clean this up / force callers to assume bytes OR unicode</span>
<span class="gi">+def u(s, encoding=&quot;utf8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;cast bytes or unicode to unicode&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(s, bytes):</span>
<span class="gi">+        return s.decode(encoding)</span>
<span class="gi">+    elif isinstance(s, str):</span>
<span class="gi">+        return s</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&quot;Expected unicode or bytes, got {type(s)}&quot;)</span>
<span class="gh">diff --git a/paramiko/win_openssh.py b/paramiko/win_openssh.py</span>
<span class="gh">index ac5aeeee..614b5898 100644</span>
<span class="gd">--- a/paramiko/win_openssh.py</span>
<span class="gi">+++ b/paramiko/win_openssh.py</span>
<span class="gu">@@ -1,17 +1,56 @@</span>
<span class="gi">+# Copyright (C) 2021 Lew Gordon &lt;lew.gordon@genesys.com&gt;</span>
<span class="gi">+# Copyright (C) 2022 Patrick Spendrin &lt;ps_ml@gmx.de&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>import os.path
<span class="w"> </span>import time
<span class="gd">-PIPE_NAME = &#39;\\\\.\\pipe\\openssh-ssh-agent&#39;</span>

<span class="gi">+PIPE_NAME = r&quot;\\.\pipe\openssh-ssh-agent&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def can_talk_to_agent():</span>
<span class="gi">+    # use os.listdir() instead of os.path.exists(), because os.path.exists()</span>
<span class="gi">+    # uses CreateFileW() API and the pipe cannot be reopen unless the server</span>
<span class="gi">+    # calls DisconnectNamedPipe().</span>
<span class="gi">+    dir_, name = os.path.split(PIPE_NAME)</span>
<span class="gi">+    name = name.lower()</span>
<span class="gi">+    return any(name == n.lower() for n in os.listdir(dir_))</span>

<span class="gd">-class OpenSSHAgentConnection:</span>

<span class="gi">+class OpenSSHAgentConnection:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        while True:
<span class="w"> </span>            try:
<span class="w"> </span>                self._pipe = os.open(PIPE_NAME, os.O_RDWR | os.O_BINARY)
<span class="w"> </span>            except OSError as e:
<span class="gi">+                # retry when errno 22 which means that the server has not</span>
<span class="gi">+                # called DisconnectNamedPipe() yet.</span>
<span class="w"> </span>                if e.errno != 22:
<span class="w"> </span>                    raise
<span class="w"> </span>            else:
<span class="w"> </span>                break
<span class="w"> </span>            time.sleep(0.1)
<span class="gi">+</span>
<span class="gi">+    def send(self, data):</span>
<span class="gi">+        return os.write(self._pipe, data)</span>
<span class="gi">+</span>
<span class="gi">+    def recv(self, n):</span>
<span class="gi">+        return os.read(self._pipe, n)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        return os.close(self._pipe)</span>
<span class="gh">diff --git a/paramiko/win_pageant.py b/paramiko/win_pageant.py</span>
<span class="gh">index 2bad5392..c927de65 100644</span>
<span class="gd">--- a/paramiko/win_pageant.py</span>
<span class="gi">+++ b/paramiko/win_pageant.py</span>
<span class="gu">@@ -1,19 +1,49 @@</span>
<span class="gi">+# Copyright (C) 2005 John Arbash-Meinel &lt;john@arbash-meinel.com&gt;</span>
<span class="gi">+# Modified up by: Todd Whiteman &lt;ToddW@ActiveState.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# This file is part of paramiko.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is free software; you can redistribute it and/or modify it under the</span>
<span class="gi">+# terms of the GNU Lesser General Public License as published by the Free</span>
<span class="gi">+# Software Foundation; either version 2.1 of the License, or (at your option)</span>
<span class="gi">+# any later version.</span>
<span class="gi">+#</span>
<span class="gi">+# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="gi">+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR</span>
<span class="gi">+# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more</span>
<span class="gi">+# details.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the GNU Lesser General Public License</span>
<span class="gi">+# along with Paramiko; if not, write to the Free Software Foundation, Inc.,</span>
<span class="gi">+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Functions for communicating with Pageant, the basic windows ssh agent program.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import array
<span class="w"> </span>import ctypes.wintypes
<span class="w"> </span>import platform
<span class="w"> </span>import struct
<span class="w"> </span>from paramiko.common import zero_byte
<span class="w"> </span>from paramiko.util import b
<span class="gi">+</span>
<span class="w"> </span>import _thread as thread
<span class="gi">+</span>
<span class="w"> </span>from . import _winapi
<span class="gd">-_AGENT_COPYDATA_ID = 2152616122</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_AGENT_COPYDATA_ID = 0x804E50BA</span>
<span class="w"> </span>_AGENT_MAX_MSGLEN = 8192
<span class="gi">+# Note: The WM_COPYDATA value is pulled from win32con, as a workaround</span>
<span class="gi">+# so we do not have to import this huge library just for this one variable.</span>
<span class="w"> </span>win32con_WM_COPYDATA = 74


<span class="gi">+def _get_pageant_window_object():</span>
<span class="gi">+    return ctypes.windll.user32.FindWindowA(b&quot;Pageant&quot;, b&quot;Pageant&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def can_talk_to_agent():
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check to see if there is a &quot;Pageant&quot; agent we can talk to.
<span class="gu">@@ -21,10 +51,10 @@ def can_talk_to_agent():</span>
<span class="w"> </span>    This checks both if we have the required libraries (win32all or ctypes)
<span class="w"> </span>    and if there is a Pageant currently running.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bool(_get_pageant_window_object())</span>


<span class="gd">-if platform.architecture()[0] == &#39;64bit&#39;:</span>
<span class="gi">+if platform.architecture()[0] == &quot;64bit&quot;:</span>
<span class="w"> </span>    ULONG_PTR = ctypes.c_uint64
<span class="w"> </span>else:
<span class="w"> </span>    ULONG_PTR = ctypes.c_uint32
<span class="gu">@@ -35,8 +65,12 @@ class COPYDATASTRUCT(ctypes.Structure):</span>
<span class="w"> </span>    ctypes implementation of
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms649010%28v=vs.85%29.aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _fields_ = [(&#39;num_data&#39;, ULONG_PTR), (&#39;data_size&#39;, ctypes.wintypes.</span>
<span class="gd">-        DWORD), (&#39;data_loc&#39;, ctypes.c_void_p)]</span>
<span class="gi">+</span>
<span class="gi">+    _fields_ = [</span>
<span class="gi">+        (&quot;num_data&quot;, ULONG_PTR),</span>
<span class="gi">+        (&quot;data_size&quot;, ctypes.wintypes.DWORD),</span>
<span class="gi">+        (&quot;data_loc&quot;, ctypes.c_void_p),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>def _query_pageant(msg):
<span class="gu">@@ -44,7 +78,37 @@ def _query_pageant(msg):</span>
<span class="w"> </span>    Communication with the Pageant process is done through a shared
<span class="w"> </span>    memory-mapped file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hwnd = _get_pageant_window_object()</span>
<span class="gi">+    if not hwnd:</span>
<span class="gi">+        # Raise a failure to connect exception, pageant isn&#39;t running anymore!</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # create a name for the mmap</span>
<span class="gi">+    map_name = f&quot;PageantRequest{thread.get_ident():08x}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    pymap = _winapi.MemoryMap(</span>
<span class="gi">+        map_name, _AGENT_MAX_MSGLEN, _winapi.get_security_attributes_for_user()</span>
<span class="gi">+    )</span>
<span class="gi">+    with pymap:</span>
<span class="gi">+        pymap.write(msg)</span>
<span class="gi">+        # Create an array buffer containing the mapped filename</span>
<span class="gi">+        char_buffer = array.array(&quot;b&quot;, b(map_name) + zero_byte)  # noqa</span>
<span class="gi">+        char_buffer_address, char_buffer_size = char_buffer.buffer_info()</span>
<span class="gi">+        # Create a string to use for the SendMessage function call</span>
<span class="gi">+        cds = COPYDATASTRUCT(</span>
<span class="gi">+            _AGENT_COPYDATA_ID, char_buffer_size, char_buffer_address</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        response = ctypes.windll.user32.SendMessageA(</span>
<span class="gi">+            hwnd, win32con_WM_COPYDATA, ctypes.sizeof(cds), ctypes.byref(cds)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if response &gt; 0:</span>
<span class="gi">+            pymap.seek(0)</span>
<span class="gi">+            datalen = pymap.read(4)</span>
<span class="gi">+            retlen = struct.unpack(&quot;&gt;I&quot;, datalen)[0]</span>
<span class="gi">+            return datalen + pymap.read(retlen)</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class PageantConnection:
<span class="gu">@@ -57,3 +121,18 @@ class PageantConnection:</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._response = None
<span class="gi">+</span>
<span class="gi">+    def send(self, data):</span>
<span class="gi">+        self._response = _query_pageant(data)</span>
<span class="gi">+</span>
<span class="gi">+    def recv(self, n):</span>
<span class="gi">+        if self._response is None:</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+        ret = self._response[:n]</span>
<span class="gi">+        self._response = self._response[n:]</span>
<span class="gi">+        if self._response == &quot;&quot;:</span>
<span class="gi">+            self._response = None</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        pass</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>